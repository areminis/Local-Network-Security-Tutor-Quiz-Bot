Chapman & Hall/CRC
CRYPTOGRAPHY AND NETWORK SECURITY
INTRODUCTION TO 
 
MODERN 
CRYPTOGRAPHY
Second Edition
Jonathan Katz
Yehuda Lindell
INTRODUCTION TO 
 
MODERN CRYPTOGRAPHY
Second
Edition
Katz
Lindell
K16475
www.crcpress.com
Cryptography is ubiquitous and plays a key role in ensuring data secrecy and 
integrity as well as in securing computer systems more broadly. 
Introduction 
to Modern Cryptography
 provides a rigorous yet accessible treatment of this 
fascinating subject. 
The authors introduce the core principles of modern cryptography, with an 
emphasis on formal definitions, clear assumptions, and rigorous proofs of se
-
curity. The book begins by focusing on private-key cryptography, including an 
extensive treatment of private-key encryption, message authentication codes, 
and hash functions. The authors also present design principles for widely used 
stream ciphers and block ciphers including RC4, DES, and AES, plus they pro
-
vide provable constructions of stream ciphers and block ciphers from lower-
level primitives. The second half of the book covers public-key cryptography, 
beginning with a self-contained introduction to the number theory needed to 
understand the RSA, Diffie–Hellman, and El Gamal cryptosystems (and oth
-
ers), followed by a thorough treatment of several standardized public-key en
-
cryption and digital signature schemes. 
Integrating a more practical perspective without sacrificing rigor, this widely 
anticipated 
Second Edition
 offers improved treatment of
•
 
Stream ciphers and block ciphers, including modes of operation and 
design principles
•
 
Authenticated encryption and secure communication sessions
•
 
Hash functions, including hash-function applications and design 
principles 
•
 
Attacks on poorly implemented cryptography, including attacks on 
chained-CBC encryption, padding-oracle attacks, and timing attacks
•
 
The random-oracle model and its application to several standardized, 
widely used public-key encryption and signature schemes
•
 
Elliptic-curve cryptography and associated standards such as DSA/
ECDSA and DHIES/ECIES
Containing updated exercises and worked examples, 
Introduction to Modern 
Cryptography, Second Edition
 can serve as a textbook for undergraduate- or 
graduate-level courses in cryptography, a valuable reference for researchers 
and practitioners, or a general introduction suitable for self-study. 
Computer Science/Mathematics
K16475_cover.indd   1
10/3/14   9:48 AMINTRODUCTION TO  
MODERN 
CRYPTOGRAPHY
Second Edition
K16475_FM.indd   1 9/24/14   1:27 PMCHAPMAN & HALL/CRC
CRYPTOGRAPHY AND NETWORK SECURITY
Series Editor
Douglas R. Stinson
Published Titles  
 
Lidong Chen and Guang Gong, Communication System Security
Shiu-Kai Chin and Susan Older, Access Control, Security, and Trust:  
A Logical Approach
M. Jason Hinek, Cryptanalysis of RSA and Its VariantsAntoine Joux, Algorithmic CryptanalysisJonathan Katz and Yehuda Lindell, Introduction to Modern 
Cryptography, Second Edition
Sankar K. Pal, Alfredo Petrosino, and Lucia Maddalena, Handbook on 
Soft Computing for Video Surveillance
Burton Rosenberg, Handbook of Financial Cryptography and Security
Forthcoming Titles  
 
Maria Isabel Vasco, Spyros Magliveras, and Rainer Steinwandt,  Group Theoretic Cryptography
K16475_FM.indd   2 9/24/14   1:27 PMChapman & Hall/CRC
CRYPTOGRAPHY AND NETWORK SECURITY
INTRODUCTION TO  
MODERN 
CRYPTOGRAPHY
Second Edition
Jonathan Katz
University of Maryland 
College Park, MD, USA
Yehuda Lindell
Bar-Ilan University
Ramat Gan, Israel
K16475_FM.indd   3 9/24/14   1:27 PMCRC Press
Taylor & Francis Group6000 Broken Sound Parkway NW, Suite 300Boca Raton, FL 33487-2742
© 2015 by Taylor & Francis Group, LLC
CRC Press is an imprint of Taylor & Francis Group, an Informa business
No claim to original U.S. Government works
Version Date: 20140915
International Standard Book Number-13: 978-1-4665-7027-6 (eBook - PDF)This book contains information obtained from authentic and highly regarded sources. Reasonable 
efforts have been made to publish reliable data and information, but the author and publisher cannot assume responsibility for the validity of all materials or the consequences of their use. The authors and publishers have attempted to trace the copyright holders of all material reproduced in this publication and apologize to copyright holders if permission to publish in this form has not been obtained. If any copyright material has not been acknowledged please write and let us know so we may rectify in any future reprint.
Except as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, 
transmitted, or utilized in any form by any electronic, mechanical, or other means, now known or hereafter invented, including photocopying, microfilming, and recording, or in any information stor-age or retrieval system, without written permission from the publishers.
For permission to photocopy or use material electronically from this work, please access www.copy -
right.com (http://www.copyright.com/) or contact the Copyright Clearance Center, Inc. (CCC), 222 
Rosewood Drive, Danvers, MA 01923, 978-750-8400. CCC is a not-for-profit organization that pro -
vides licenses and registration for a variety of users. For organizations that have been granted a photo -
copy license by the CCC, a separate system of payment has been arranged.
Trademark Notice:  Product or corporate names may be trademarks or registered trademarks, and are 
used only for identification and explanation without intent to infringe.
Visit the Taylor & Francis Web site at
http://www.taylorandfrancis.com
and the CRC Press Web site at
http://www.crcpress.comContents
Preface xv
I Introduction and Classical Cryptography
1 Introduction 3
1.1 Cryptography and Modern Cryptography . . . . . . . . . . . 3
1.2 The Setting of Private-Key Encryption . . . . . . . . . . . . 4
1.3 Historical Ciphers and Their Cryptanalysis . . . . . . . . . . 8
1.4 Principles of Modern Cryptography . . . . . . . . . . . . . . 16
1.4.1 Principle 1 – Formal Deﬁnitions . . . . . . . . . . . . 17
1.4.2 Principle 2 – Precise Assumptions . . . . . . . . . . . 20
1.4.3 Principle 3 – Proofs of Security . . . . . . . . . . . . . 22
1.4.4 Provable Security and Real-World Security . . . . . . 22
References and Additional Reading . . . . . . . . . . . . . . . . . 23
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2 Perfectly Secret Encryption 25
2.1 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.2 The One-Time Pad . . . . . . . . . . . . . . . . . . . . . . . 32
2.3 Limitations of Perfect Secrecy . . . . . . . . . . . . . . . . . 35
2.4 *Shannon’s Theorem . . . . . . . . . . . . . . . . . . . . . . 36
References and Additional Reading . . . . . . . . . . . . . . . . . 37
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
II Private-Key (Symmetric) Cryptography
3 Private-Key Encryption 43
3.1 Computational Security . . . . . . . . . . . . . . . . . . . . . 43
3.1.1 The Concrete Approach . . . . . . . . . . . . . . . . . 44
3.1.2 The Asymptotic Approach . . . . . . . . . . . . . . . 45
3.2 Deﬁning Computationally Secure Encryption . . . . . . . . . 52
3.2.1 The Basic Deﬁnition of Security . . . . . . . . . . . . 53
3.2.2 *Semantic Security . . . . . . . . . . . . . . . . . . . . 56
3.3 Constructing Secure Encryption Schemes . . . . . . . . . . . 60
3.3.1 Pseudorandom Generators and Stream Ciphers . . . . 60
3.3.2 Proofs by Reduction . . . . . . . . . . . . . . . . . . . 65
3.3.3 A Secure Fixed-Length Encryption Scheme . . . . . . 66
viiviii
3.4Stronger Security Notions . . . . . . . . . . . . . . . . . . . . 71
3.4.1 Security for Multiple Encryptions . . . . . . . . . . . . 71
3.4.2 Chosen-Plaintext Attacks and CPA-Security. . . . . . 73
3.5 Constructing CPA-Secure Encryption Schemes . . . . . . . . 77
3.5.1 Pseudorandom Functions and Block Ciphers . . . . . 77
3.5.2 CPA-Secure Encryption from Pseudorandom Functions 82
3.6 Modes of Operation . . . . . . . . . . . . . . . . . . . . . . . 86
3.6.1 Stream-Cipher Modes of Operation . . . . . . . . . . . 86
3.6.2 Block-Cipher Modes of Operation . . . . . . . . . . . 88
3.7 Chosen-Ciphertext Attacks . . . . . . . . . . . . . . . . . . . 96
3.7.1 Deﬁning CCA-Security . . . . . . . . . . . . . . . . . . 96
3.7.2 Padding-Oracle Attacks . . . . . . . . . . . . . . . . . 98
References and Additional Reading . . . . . . . . . . . . . . . . . 101
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
4 Message Authentication Codes 107
4.1 Message Integrity . . . . . . . . . . . . . . . . . . . . . . . . 107
4.1.1 Secrecy vs. Integrity . . . . . . . . . . . . . . . . . . . 107
4.1.2 Encryption vs. Message Authentication . . . . . . . . 108
4.2 Message Authentication Codes – Deﬁnitions . . . . . . . . . 110
4.3 Constructing Secure Message Authentication Codes . . . . . 116
4.3.1 A Fixed-Length MAC . . . . . . . . . . . . . . . . . . 116
4.3.2 Domain Extension for MACs . . . . . . . . . . . . . . 118
4.4 CBC-MAC . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
4.4.1 The Basic Construction . . . . . . . . . . . . . . . . . 123
4.4.2 *Proof of Security . . . . . . . . . . . . . . . . . . . . 125
4.5 Authenticated Encryption . . . . . . . . . . . . . . . . . . . 131
4.5.1 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . 131
4.5.2 Generic Constructions . . . . . . . . . . . . . . . . . . 132
4.5.3 Secure Communication Sessions . . . . . . . . . . . . . 140
4.5.4 CCA-Secure Encryption . . . . . . . . . . . . . . . . . 141
4.6 *Information-Theoretic MACs . . . . . . . . . . . . . . . . . 142
4.6.1 Constructing Information-Theoretic MACs . . . . . . 143
4.6.2 Limitations on Information-Theoretic MACs . . . . . 145
References and Additional Reading . . . . . . . . . . . . . . . . . 146
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
5 Hash Functions and Applications 153
5.1 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
5.1.1 Collision Resistance . . . . . . . . . . . . . . . . . . . 154
5.1.2 Weaker Notions of Security . . . . . . . . . . . . . . . 156
5.2 Domain Extension: The Merkle–Damg˚ ard Transform . . . . 156
5.3 Message Authentication Using Hash Functions . . . . . . . . 158
5.3.1 Hash-and-MAC . . . . . . . . . . . . . . . . . . . . . . 159
5.3.2 HMAC . . . . . . . . . . . . . . . . . . . . . . . . . . 161ix
5.4Generic Attacks on Hash Functions . . . . . . . . . . . . . . 164
5.4.1 Birthday Attacks for Finding Collisions . . . . . . . . 164
5.4.2 Small-Space Birthday Attacks . . . . . . . . . . . . . . 166
5.4.3 *Time/Space Tradeoﬀs for Inverting Functions . . . . 168
5.5 The Random-Oracle Model . . . . . . . . . . . . . . . . . . . 174
5.5.1 The Random-Oracle Model in Detail . . . . . . . . . . 175
5.5.2 Is the Random-Oracle Methodology Sound? . . . . . . 179
5.6 Additional Applications of Hash Functions . . . . . . . . . . 182
5.6.1 Fingerprinting and Deduplication . . . . . . . . . . . . 182
5.6.2 Merkle Trees . . . . . . . . . . . . . . . . . . . . . . . 183
5.6.3 Password Hashing . . . . . . . . . . . . . . . . . . . . 184
5.6.4 Key Derivation . . . . . . . . . . . . . . . . . . . . . . 186
5.6.5 Commitment Schemes . . . . . . . . . . . . . . . . . . 187
References and Additional Reading . . . . . . . . . . . . . . . . . 189
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
6 Practical Constructions of Symmetric-Key Primitives 193
6.1 Stream Ciphers . . . . . . . . . . . . . . . . . . . . . . . . . 194
6.1.1 Linear-Feedback Shift Registers . . . . . . . . . . . . . 195
6.1.2 Adding Nonlinearity . . . . . . . . . . . . . . . . . . . 197
6.1.3 Trivium . . . . . . . . . . . . . . . . . . . . . . . . . . 198
6.1.4 RC4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
6.2 Block Ciphers . . . . . . . . . . . . . . . . . . . . . . . . . . 202
6.2.1 Substitution-Permutation Networks . . . . . . . . . . 204
6.2.2 Feistel Networks . . . . . . . . . . . . . . . . . . . . . 211
6.2.3 DES – The Data Encryption Standard . . . . . . . . . 212
6.2.4 3DES: Increasing the Key Length of a Block Cipher . 220
6.2.5 AES – The Advanced Encryption Standard . . . . . . 223
6.2.6 *Diﬀerential and Linear Cryptanalysis . . . . . . . . . 225
6.3 Hash Functions . . . . . . . . . . . . . . . . . . . . . . . . . 231
6.3.1 Hash Functions from Block Ciphers . . . . . . . . . . 232
6.3.2 MD5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
6.3.3 SHA-0, SHA-1, and SHA-2 . . . . . . . . . . . . . . . 234
6.3.4 SHA-3 (Keccak) . . . . . . . . . . . . . . . . . . . . . 235
References and Additional Reading . . . . . . . . . . . . . . . . . 236
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
7 *Theoretical Constructions of Symmetric-Key Primitives 241
7.1 One-Way Functions . . . . . . . . . . . . . . . . . . . . . . . 242
7.1.1 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . 242
7.1.2 Candidate One-Way Functions . . . . . . . . . . . . . 245
7.1.3 Hard-Core Predicates . . . . . . . . . . . . . . . . . . 246
7.2 From One-Way Functions to Pseudorandomness . . . . . . . 248
7.3 Hard-Core Predicates from One-Way Functions . . . . . . . 250
7.3.1 A Simple Case . . . . . . . . . . . . . . . . . . . . . . 250x
7.3.2 A More Involved Case . . . . . . . . . . . . . . . . . . 251
7.3.3 The Full Proof . . . . . . . . . . . . . . . . . . . . . . 254
7.4 Constructing Pseudorandom Generators . . . . . . . . . . . . 257
7.4.1 Pseudorandom Generators with Minimal Expansion . 258
7.4.2 Increasing the Expansion Factor . . . . . . . . . . . . 259
7.5 Constructing Pseudorandom Functions . . . . . . . . . . . . 265
7.6 Constructing (Strong) Pseudorandom Permutations . . . . . 269
7.7 Assumptions for Private-Key Cryptography . . . . . . . . . . 273
7.8 Computational Indistinguishability . . . . . . . . . . . . . . 276
References and Additional Reading . . . . . . . . . . . . . . . . . 278
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
III Public-Key (Asymmetric) Cryptography
8 Number Theory and Cryptographic Hardness Assumptions 285
8.1 Preliminaries and Basic Group Theory . . . . . . . . . . . . 287
8.1.1 Primes and Divisibility . . . . . . . . . . . . . . . . . . 287
8.1.2 Modular Arithmetic . . . . . . . . . . . . . . . . . . . 289
8.1.3 Groups . . . . . . . . . . . . . . . . . . . . . . . . . . 291
8.1.4 The Group Z∗
N. . . . . . . . . . . . . . . . . . . . . . 295
8.1.5 *Isomorphisms and the Chinese Remainder Theorem . 297
8.2 Primes, Factoring, and RSA . . . . . . . . . . . . . . . . . . 302
8.2.1 Generating Random Primes . . . . . . . . . . . . . . . 303
8.2.2 *Primality Testing . . . . . . . . . . . . . . . . . . . . 306
8.2.3 The Factoring Assumption . . . . . . . . . . . . . . . 311
8.2.4 The RSA Assumption . . . . . . . . . . . . . . . . . . 312
8.2.5 *Relating the RSA and Factoring Assumptions . . . . 314
8.3 Cryptographic Assumptions in Cyclic Groups . . . . . . . . . 316
8.3.1 Cyclic Groups and Generators . . . . . . . . . . . . . 316
8.3.2 The Discrete-Logarithm/Diﬃe–Hellman Assumptions 319
8.3.3 Working in (Subgroups of) Z∗
p. . . . . . . . . . . . . 322
8.3.4 Elliptic Curves . . . . . . . . . . . . . . . . . . . . . . 325
8.4 *Cryptographic Applications . . . . . . . . . . . . . . . . . . 332
8.4.1 One-Way Functions and Permutations . . . . . . . . . 332
8.4.2 Constructing Collision-Resistant Hash Functions . . . 335
References and Additional Reading . . . . . . . . . . . . . . . . . 337
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338
9 *Algorithms for Factoring and Computing Discrete Loga-
rithms 341
9.1 Algorithms for Factoring . . . . . . . . . . . . . . . . . . . . 342
9.1.1 Pollard’s p−1 Algorithm . . . . . . . . . . . . . . . . 343
9.1.2 Pollard’s Rho Algorithm . . . . . . . . . . . . . . . . . 344
9.1.3 The Quadratic Sieve Algorithm . . . . . . . . . . . . . 345
9.2 Algorithms for Computing Discrete Logarithms . . . . . . . 348xi
9.2.1 The Pohlig–Hellman Algorithm . . . . . . . . . . . . . 350
9.2.2 The Baby-Step/Giant-Step Algorithm . . . . . . . . . 352
9.2.3 Discrete Logarithms from Collisions . . . . . . . . . . 353
9.2.4 The Index Calculus Algorithm . . . . . . . . . . . . . 354
9.3 Recommended Key Lengths . . . . . . . . . . . . . . . . . . 356
References and Additional Reading . . . . . . . . . . . . . . . . . 357
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 358
10 Key Management and the Public-Key Revolution 359
10.1 Key Distribution and Key Management . . . . . . . . . . . . 359
10.2 A Partial Solution: Key-Distribution Centers . . . . . . . . . 361
10.3 Key Exchange and the Diﬃe–Hellman Protocol . . . . . . . 363
10.4 The Public-Key Revolution . . . . . . . . . . . . . . . . . . . 370
References and Additional Reading . . . . . . . . . . . . . . . . . 372
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373
11 Public-Key Encryption 375
11.1 Public-Key Encryption – An Overview . . . . . . . . . . . . 375
11.2 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 378
11.2.1 Security against Chosen-Plaintext Attacks . . . . . . . 379
11.2.2 Multiple Encryptions . . . . . . . . . . . . . . . . . . . 381
11.2.3 Security against Chosen-Ciphertext Attacks . . . . . . 387
11.3 Hybrid Encryption and the KEM/DEM Paradigm . . . . . . 389
11.3.1 CPA-Security . . . . . . . . . . . . . . . . . . . . . . . 393
11.3.2 CCA-Security . . . . . . . . . . . . . . . . . . . . . . . 398
11.4 CDH/DDH-Based Encryption . . . . . . . . . . . . . . . . . 399
11.4.1 El Gamal Encryption . . . . . . . . . . . . . . . . . . 400
11.4.2 DDH-Based Key Encapsulation . . . . . . . . . . . . . 404
11.4.3 *A CDH-Based KEM in the Random-Oracle Model . 406
11.4.4 Chosen-Ciphertext Security and DHIES/ECIES . . . . 408
11.5 RSA Encryption . . . . . . . . . . . . . . . . . . . . . . . . . 410
11.5.1 Plain RSA . . . . . . . . . . . . . . . . . . . . . . . . 410
11.5.2 Padded RSA and PKCS #1 v1.5 . . . . . . . . . . . . 415
11.5.3 *CPA-Secure Encryption without Random Oracles . . 417
11.5.4 OAEP and RSA PKCS #1 v2.0 . . . . . . . . . . . . 421
11.5.5 *A CCA-Secure KEM in the Random-Oracle Model . 425
11.5.6 RSA Implementation Issues and Pitfalls . . . . . . . . 429
References and Additional Reading . . . . . . . . . . . . . . . . . 432
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
12 Digital Signature Schemes 439
12.1 Digital Signatures – An Overview . . . . . . . . . . . . . . . 439
12.2 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441
12.3 The Hash-and-Sign Paradigm . . . . . . . . . . . . . . . . . . 443
12.4 RSA Signatures . . . . . . . . . . . . . . . . . . . . . . . . . 444xii
12.4.1 Plain RSA . . . . . . . . . . . . . . . . . . . . . . . . 444
12.4.2 RSA-FDH and PKCS #1 v2.1 . . . . . . . . . . . . . 446
12.5 Signatures from the Discrete-Logarithm Problem . . . . . . . 451
12.5.1 The Schnorr Signature Scheme . . . . . . . . . . . . . 451
12.5.2 DSA and ECDSA . . . . . . . . . . . . . . . . . . . . 459
12.6 *Signatures from Hash Functions . . . . . . . . . . . . . . . 461
12.6.1 Lamport’s Signature Scheme . . . . . . . . . . . . . . 461
12.6.2 Chain-Based Signatures . . . . . . . . . . . . . . . . . 465
12.6.3 Tree-Based Signatures . . . . . . . . . . . . . . . . . . 468
12.7 *Certiﬁcates and Public-Key Infrastructures . . . . . . . . . 473
12.8 Putting It All Together – SSL/TLS . . . . . . . . . . . . . . 479
12.9 *Signcryption . . . . . . . . . . . . . . . . . . . . . . . . . . 481
References and Additional Reading . . . . . . . . . . . . . . . . . 483
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 484
13 *Advanced Topics in Public-Key Encryption 487
13.1 Public-Key Encryption from Trapdoor Permutations . . . . . 487
13.1.1 Trapdoor Permutations . . . . . . . . . . . . . . . . . 488
13.1.2 Public-Key Encryption from Trapdoor Permutations . 489
13.2 The Paillier Encryption Scheme . . . . . . . . . . . . . . . . 491
13.2.1 The Structure of Z∗
N2. . . . . . . . . . . . . . . . . . 492
13.2.2 The Paillier Encryption Scheme . . . . . . . . . . . . . 494
13.2.3 Homomorphic Encryption . . . . . . . . . . . . . . . . 499
13.3 Secret Sharing and Threshold Encryption . . . . . . . . . . . 501
13.3.1 Secret Sharing . . . . . . . . . . . . . . . . . . . . . . 501
13.3.2 Veriﬁable Secret Sharing . . . . . . . . . . . . . . . . . 503
13.3.3 Threshold Encryption and Electronic Voting . . . . . 505
13.4 The Goldwasser–Micali Encryption Scheme . . . . . . . . . . 507
13.4.1 Quadratic Residues Modulo a Prime . . . . . . . . . . 507
13.4.2 Quadratic Residues Modulo a Composite . . . . . . . 510
13.4.3 The Quadratic Residuosity Assumption . . . . . . . . 514
13.4.4 The Goldwasser–Micali Encryption Scheme . . . . . . 515
13.5 The Rabin Encryption Scheme . . . . . . . . . . . . . . . . . 518
13.5.1 Computing Modular Square Roots . . . . . . . . . . . 518
13.5.2 A Trapdoor Permutation Based on Factoring . . . . . 523
13.5.3 The Rabin Encryption Scheme . . . . . . . . . . . . . 527
References and Additional Reading . . . . . . . . . . . . . . . . . 528
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529
Index of Common Notation 533xiii
Appendix A Mathematical Background 537
A.1 Identities and Inequalities . . . . . . . . . . . . . . . . . . . . 537
A.2 Asymptotic Notation . . . . . . . . . . . . . . . . . . . . . . 537
A.3 Basic Probability . . . . . . . . . . . . . . . . . . . . . . . . 538
A.4 The “Birthday” Problem . . . . . . . . . . . . . . . . . . . . 542
A.5 *Finite Fields . . . . . . . . . . . . . . . . . . . . . . . . . . 544
Appendix B Basic Algorithmic Number Theory 547
B.1 Integer Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . 549
B.1.1 Basic Operations . . . . . . . . . . . . . . . . . . . . . 549
B.1.2 The Euclidean and Extended Euclidean Algorithms . 550
B.2 Modular Arithmetic . . . . . . . . . . . . . . . . . . . . . . . 552
B.2.1 Basic Operations . . . . . . . . . . . . . . . . . . . . . 552
B.2.2 Computing Modular Inverses . . . . . . . . . . . . . . 552
B.2.3 Modular Exponentiation . . . . . . . . . . . . . . . . . 553
B.2.4 *Montgomery Multiplication . . . . . . . . . . . . . . 556
B.2.5 Choosing a Uniform Group Element . . . . . . . . . . 557
B.3 *Finding a Generator of a Cyclic Group . . . . . . . . . . . . 559
B.3.1 Group-Theoretic Background . . . . . . . . . . . . . . 559
B.3.2 Eﬃcient Algorithms . . . . . . . . . . . . . . . . . . . 561
References and Additional Reading . . . . . . . . . . . . . . . . . 562
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
References 563
Index 577Preface
The goal of our book remains the same as in the ﬁrst edition: to present the
basic paradigms and principles of modern cryptography to a general audience
with a basic mathematics background. We have designed this book to serve as
a textbook for undergraduate- or graduate-level courses in cryptography (in
computer science, electrical engineering, or mathematics departments), as a
general introduction suitable for self-study (especially for beginning graduate
students), and as a reference for students, researchers, and practitioners.
There are numerous other cryptography textbooks available today, and the
reader may rightly ask whether another book on the subject is needed. We
would not have written this book—nor worked on revising it for the second
edition—if the answer to that question were anything other than an unequiv-
ocalyes. What, in our opinion, distinguishes our book from other available
books is that it provides a rigorous treatment of modern cryptography in an
accessible manner appropriate for an introduction to the topic.
Our focus is on modern(post-1980s) cryptography, which is distinguished
from classical cryptography by its emphasis on deﬁnitions, precise assump-
tions, and rigorous proofs of security. We brieﬂy discuss each of these in turn
(these principles are explored in greater detail in Chapter 1):
•The central role of deﬁnitions: A key intellectual contribution of
modern cryptography has been the recognition that formal deﬁnitions
of security are an essential ﬁrst step in the design of any cryptographic
primitive or protocol . The reason, in retrospect, is simple: if you don’t
know what it is you are trying to achieve, how can you hope to know
when you have achieved it? As we will see in this book, cryptographic
deﬁnitions ofsecurity are quite strong and—at ﬁrst glance—mayappear
impossible to achieve. One of the most amazingaspects ofcryptography
is that eﬃcient constructions satisfying such strong deﬁnitions can be
proven to exist (under rather mild assumptions).
•The importance of precise assumptions: As will be explained in
Chapters 2 and 3, many cryptographic constructions cannot currently
be proven secure in an unconditional sense. Security often relies, in-
stead, on some widely believed (though unproven) assumption(s). The
moderncryptographicapproachdictates that any such assumption must
be clearly stated and unambiguously deﬁned . This not only allows for
objective evaluation of the assumption but, more importantly, enables
rigorous proofs of security as described next.
xvxvi
•Thepossibility of proofs of security: The previous two principles
serve as the basis for the idea that cryptographic constructions can be
proven secure with respect to clearly stated deﬁnitions of security and
relative to well-deﬁned cryptographic assumptions. This concept is the
essence of modern cryptography, and is what has transformed the ﬁeld
from an art to a science.
The importance of this idea cannot be overemphasized. Historically,
cryptographic schemes were designed in a largely ad hoc fashion, and
were deemed to be secure if the designers themselves could not ﬁnd
any attacks. In contrast, modern cryptography advocates the design
of schemes with formal, mathematical proofs of security in well-deﬁned
models. Such schemes are guaranteed to be secure unless the underly-
ing assumption is false (or the security deﬁnition did not appropriately
model the real-world security concerns). By relying on long-standing
assumptions (e.g., the assumption that “factoring is hard”), it is thus
possible to obtain schemes that are extremely unlikely to be broken.
A uniﬁed approach. The above principles of modern cryptography are rel-
evant not only to the “theory of cryptography” community. The importance
of precise deﬁnitions is, by now, widely understood and appreciated by de-
velopers and security engineers who use cryptographic tools to build secure
systems, and rigorous proofs of security have become one of the requirements
for cryptographic schemes to be standardized.
Changes in the Second Edition
Inpreparingthesecondedition, wehavemadeaconsciouseﬀorttointegrate
a more practical perspective (without sacriﬁcing a rigorous approach). This
is reﬂected in a number of changes and additions we have made:
•We have increased our coverage of stream ciphers , introducing them
as a variant of pseudorandom generators in Section 3.3.1, discussing
stream-cipher modes of operation in Section 3.6.1, and describing mod-
ern stream-cipher design principles and examples in Section 6.1.
•We have emphasized the importance of authenticated encryption (see
Section 4.5) and haveadded a sectionon secure communicationsessions.
•We have moved our treatment of hash functions into its own chapter
(Chapter 5), have included some standard applications of cryptographic
hash functions (Section 5.6), and have added a section on hash-function
design principles and widely used constructions (Section 6.3). We have
also improved our treatment of birthday attacks (covering small-space
birthdayattacksinSection5.4.2)andhaveaddedadiscussionofrainbow
tables and time/space tradeoﬀs (Section 5.4.3).xvii
•Wehaveincluded severalimportant attackson implementations ofcryp-
tography that arise in practice, including chosen-plaintext attacks on
chained-CBCencryption(Section3.6.2),padding-oracleattacksonCBC-
mode encryption (Section 3.7.2), and timing attacks on MAC veriﬁca-
tion (Section 4.2).
•After much deliberation, we have decided to introduce the random-
oracle model much earlier in the book (Section 5.5). This allows us to
give a proper, integrated treatment of standardized, widely used public-
key encryption and signature schemes in later chapters, instead of rele-
gating them to second-class status in a chapter at the end of the book.
•We have strengthened our coverage of elliptic-curve cryptography (Sec-
tion 8.3.4) and have added a discussion of its impact on recommended
key lengths (Section 9.3).
•In the chapter on public-key encryption, we introduce the KEM/DEM
paradigm as a form of hybrid encryption (see Section 11.3). We also
cover DHIES/ECIES in addition to the RSA PKCS #1 standards.
•In the chapter on digital signatures, we now describe the construction of
signaturesfrom identiﬁcation schemes using the Fiat–Shamir transform,
with the Schnorr signature scheme as a prototypical example. We have
also improved our coverage of DSA/ECDSA. We include brief discus-
sions of SSL/TLS and signcryption, both of which serve as culminations
of everything covered up to that point.
•In the “advanced topics” chapter, we have ampliﬁed our treatment of
homomorphic encryption, and have included sections on secret sharing
and threshold encryption.
Beyond the above, we have also edited the entire book to make extensive
corrections as well as smaller adjustments, including more worked examples,
to improve the exposition. Several additional exercises have also been added.
Guide to Using This Book
This section is intended primarily for instructors seeking to adopt this book
for their course, though the student picking up this book on his or her own
may also ﬁnd it a useful overview.
Required background. Wehavestructuredthebooksothattheonlyformal
prerequisite is a course on discrete mathematics. Even here we rely on very
little material: we assume familiarity with basic (discrete) probability and
modular arithmetic. Students reading this book are also expected to have had
some exposure to algorithms, mainly to be comfortable reading pseudocode
and to be familiar with big- Onotation. Many of these concepts are reviewed
in Appendix A and/or when ﬁrst used in the book.xviii
Notwithstanding the above, the book does use deﬁnitions, proofs, and ab-
stract mathematical concepts, and therefore requires some mathematical ma-
turity. In particular, the reader is assumed to have had some exposure to
proofs at the college level, whether in an upper-level mathematics course or a
course on discrete mathematics, algorithms, or computability theory.
Suggestions for course organization. The core material of this book,
which we recommend should be covered in any introductory course on cryp-
tography, consists of the following (in all cases, starred sections are excluded;
more on this below):
•Introduction and Classical Cryptography: Chapters 1 and 2 discuss clas-
sical cryptography and set the stage for modern cryptography.
•Private-Key (Symmetric) Cryptography: Chapter 3 on private-key en-
cryption, Chapter 4 on message authentication, and Chapter 5 on hash
functions provide a thorough treatment of these topics.
We also highly recommend coveringSection 6.2, which deals with block-
cipher design; in our experience students really enjoy this material, and
it makes the abstract ideas they have learned in previous chapters more
concrete. Although we do consider this core material, it is not used in
the rest of the book and so can be safely skipped if desired.
•Public-Key (Asymmetric) Cryptography: Chapter8givesaself-contained
introduction to all the number theory needed for the remainder of the
book. The material in Chapter 9 is not used subsequently; however,
we do recommend at least covering Section 9.3 on recommended key
lengths. The public-key revolution is described in Chapter 10. Ideally,
all of Chapters 11 and 12 should be covered; those pressed for time can
pick and choose appropriately.
We are typically able to cover most of the above in a one-semester (35-hour)
undergraduate course (omitting some proofs and skipping some topics, as
needed) or, with some changes to add more material on theoretical founda-
tions, intheﬁrstthree-quartersofaone-semestergraduatecourse. Instructors
with more time available can proceed at a more leisurely pace or incorporate
additional topics, as discussed below.
Those wishing to cover additional material, in either a longer course or a
faster-paced graduate course, will ﬁnd that the book is structured to allow
ﬂexible incorporation of other topics as time permits (and depending on the
interests of the instructor). Speciﬁcally, the starred (*) sections and chapters
may be covered in any order, or skipped entirely, without aﬀecting the overall
ﬂow of the book. We have taken care to ensure that none of the core material
depends on any of the starred material and, for the most part, the starred
sections do not depend on each other. (When they do, this dependence is
explicitly noted.)xix
Wesuggest the following from among the starred topics for those wishing
to give their course a particular ﬂavor:
•Theory: A more theoretically inclined course could include material
from Section 3.2.2 (semantic security); Chapter 7 (one-way functions
and hard-core predicates, and constructing pseudorandom generators,
functions, and permutations from one-way permutations); Section 8.4
(one-way functions and collision-resistant hash functions from number-
theoreticassumptions); Section11.5.3(RSA encryptionwithout random
oracles); and Section 12.6 (signatures without random oracles).
•Mathematics: A course directed at students with a strong mathemat-
ics background—or being taught by someone who enjoys this aspect
of cryptography—could incorporate Section 4.6 (information-theoretic
MACs in ﬁnite ﬁelds); some of the more advanced number theory from
Chapter 8 (e.g., the Chinese remainder theorem and the Miller–Rabin
primality test); and all of Chapter 9.
In either case, a selection of advanced topics from Chapter 13 could also be
included.
Feedback and Errata
Our goal in writing this book was to make modern cryptography accessible
to a wide audience beyond the “theoreticalcomputer science”community. We
hope you will let us know if we have succeeded. The many enthusiastic emails
we have received in response to our ﬁrst edition have made the whole process
of writing this book worthwhile.
We are always happy to receive feedback. We hope there are no errors
or typos in the book; if you do ﬁnd any, however, we would greatly appre-
ciate it if you let us know. (A list of known errata will be maintained at
http://www.cs.umd.edu/~jkatz/imc.html .) You can email your comments
and errata to jkatz@cs.umd.edu andlindell@biu.ac.il ; please put “In-
troduction to Modern Cryptography” in the subject line.
Acknowledgments
For the second edition: We are grateful to the many readers of the ﬁrst edi-
tion who have sent us comments, suggestions, and corrections that helped to
greatly improve the book. Discussions with Claude Cr´ epeau, Bill Gasarch,
Gene Itkis, Leonid Reyzin, Tom Shrimpton, and Salil Vadhan regarding the
content and overall “philosophy” of the book were especially fruitful. We also
thank Bar Alon, Gilad Asharov, Giuseppe Ateniese, Amir Azodi, Omer Berk-
man, Sergio de Biasi, Aurora Bristor, Richard Chang, Qingfeng Cheng, Kwan
Tae Cho, Kyliah Clarkson, Ran Cohen, Nikolas Coukouma, Dana Dachman-
Soled, Michael Fang, Michael Farcasin, Pooya Farshim, Marc Fischlin, Lancexx
Fortnow, Michael Fuhr, Bill Gasarch, Virgil Gligor, Carmit Hazay, Andreas
H¨ ubner, Karst Koymans, Eyal Kushilevitz, Steve Lai, Ugo Dal Lago, Ar-
mand Makowski, Tal Malkin, Steve Myers, Naveen Nathan, Ariel Nof, Eran
Omri, Ruy de Queiroz, Eli Quiroz, Tal Rabin, Charlie Rackoﬀ, Yona Raekow,
Tzachy Reinman, Wei Ren, Ben Riva, Volker Roth, Christian Schaﬀner,
Joachim Schipper, Dominique Schr¨ oder, Randy Shull, Nigel Smart, Christoph
Sprenger, Aravind Srinivasan, John Steinberger, Aishwarya Thiruvengadam,
Dave Tuller, Poorvi Vora, Avishai Yanai, Rupeng Yang, Arkady Yerukhi-
movich, Dae Hyun Yum, Hila Zarosim, and Konstantin Ziegler for their help-
ful corrections to the ﬁrst edition and/or early drafts of the second edition.
For the ﬁrst edition: We thank Zoe Bermant for producing the ﬁgures; David
Wagner for answering questions related to block ciphers and their cryptanaly-
sis; and Salil Vadhan and Alon Rosen for experimenting with an early version
of our text in an introductory course at Harvard University and for providing
us with valuable feedback. We would also like to extend ourgratitude to those
who read and commented on earlier drafts of this book and to those who sent
us corrections: Adam Bender, Chiu-Yuen Koo, Yair Dombb, Michael Fuhr,
William Glenn, S. Dov Gordon, Carmit Hazay, Eyal Kushilevitz, Avivit Levy,
Matthew Mah, Ryan Murphy, Steve Myers, Martin Paraskevov, Eli Quiroz,
JasonRogers, Rui Xue, DickyYan, ArkadyYerukhimovich, andHila Zarosim.
We are extremely grateful to all those who encouraged us to write this book
and agreed with us that a book of this sort is badly needed.
Finally, we thank our wives and children for all their support and understand-
ing during the many hours, days, months, and now years we have spent on
this project.Part I
In
troduction and Classical
Cry
ptographyChapter 1
Introduction
1.1 Cryptography and Modern Cryptography
TheConcise Oxford English Dictionary deﬁnes cryptography as “the art of
writing or solving codes.” This is historically accurate, but does not capture
the current breadth of the ﬁeld or its present-day scientiﬁc foundations. The
deﬁnition focuses solely on the codesthat have been used for centuries to en-
able secret communication. But cryptography nowadays encompasses much
more than this: it deals with mechanismsfor ensuring integrity, techniques for
exchanging secret keys, protocols for authenticating users, electronic auctions
and elections, digital cash, and more. Without attempting to provide a com-
plete characterization, we would say that modern cryptography involves the
study of mathematical techniques for securing digital information, systems,
and distributed computations against adversarial attacks .
The dictionary deﬁnition also refers to cryptographyas an art. Until late in
the 20th century cryptographywas, indeed, largelyan art. Constructing good
codes, or breaking existing ones, relied on creativity and a developed sense of
how codes work. There was little theory to rely on and, for a long time, no
working deﬁnition of what constitutes a good code. Beginning in the 1970s
and 1980s, this picture of cryptography radically changed. A rich theory
began to emerge, enabling the rigorous study of cryptography as a science
and a mathematical discipline. This perspective has, in turn, inﬂuenced how
researchers think about the broader ﬁeld of computer security.
Another very important diﬀerence between classical cryptography (say, be-
fore the 1980s) and modern cryptographyrelates to its adoption. Historically,
the major consumers of cryptography were military organizations and gov-
ernments. Today, cryptography is everywhere! If you have ever authenticated
yourself by typing a password, purchased something by credit card over the
Internet, or downloaded a veriﬁed update for your operating system, you have
undoubtedly used cryptography. And, more and more, programmerswith rel-
ativelylittle experiencearebeingaskedto“secure”the applicationstheywrite
by incorporating cryptographic mechanisms.
In short, cryptography has gone from a heuristic set of tools concerned
with ensuring secret communication for the military to a science that helps
secure systems for ordinary people all across the globe. This also means that
cryptography has become a more central topic within computer science.
34 Introduction to Modern Cryptography
Goals of this book. Our goal is to make the basic principles of modern
cryptography accessible to students of computer science, electrical engineer-
ing, or mathematics; to professionals who want to incorporate cryptography
in systems or software they are developing; and to anyone with a basic level
of mathematical maturity who is interested in understanding this fascinating
ﬁeld. After completing this book, the reader should appreciate the secu-
rity guarantees common cryptographic primitives are intended to provide; be
aware of standard (secure) constructions of such primitives; and be able to
perform a basic evaluation of new schemes based on their proofs of security
(or lack thereof) and the mathematical assumptions underlying those proofs.
It is not our intention for readers to become experts—or to be able to de-
sign new cryptosystems—after ﬁnishing this book, but we have attempted to
provide the terminology and foundational material needed for the interested
reader to subsequently study more advanced references in the area.
This chapter. The focus of this book is the formal study of modern cryp-
tography, but we begin in this chapter with a more informal discussion of
“classical” cryptography. Besides allowing us to ease into the material, our
treatment in this chapter will also serve to motivate the more rigorous ap-
proach we will be taking in the rest of the book. Our intention here is not to
be exhaustive and, as such, this chapter should not be taken as a representa-
tive historical account. The reader interested in the history of cryptography
is invited to consult the references at the end of this chapter.
1.2 The Setting of Private-Key Encryption
Classical cryptography was concerned with designing and using codes(also
calledciphers) that enable two parties to communicate secretly in the pres-
ence of an eavesdropper who can monitor all communication between them.
In modern parlance, codes are called encryption schemes and that is the ter-
minology we will use here. Security of all classical encryption schemes relied
on a secret—a key—shared by the communicating parties in advance and un-
known to the eavesdropper. This scenario is known as the private-key (or
shared-/secret-key ) setting, and private-key encryption is just one example of
a cryptographic primitive used in this setting. Before describing some histor-
ical encryption schemes, we discuss private-key encryption more generally.
In the setting ofprivate-keyencryption, two parties sharea key and use this
key when they want to communicate secretly. One party can send a message,
orplaintext, to the other by using the shared key to encrypt(or “scramble”)
the message and thus obtain a ciphertext that is transmitted to the receiver.
The receiver uses the same key to decrypt(or “unscramble”) the ciphertext
and recover the original message. Note the same key is used to convert theIntroduction 5
/MT107 /MT107
/MT63/MT109 /MT109/MT101/MT110/MT99/MT114/MT121/MT112/MT116/MT105/MT111/MT110 /MT100/MT101/MT99/MT114/MT121/MT112/MT116/MT105/MT111/MT110
/MT99/MT105/MT112/MT104/MT101/MT114/MT116/MT101/MT120/MT116
FIGURE 1.1 :One common setting of private-key cryptography (here,
encryption): two parties share a key that they use to communicate securely.
plaintext into a ciphertext and back; that is why this is also known as the
symmetric-key setting, where the symmetry lies in the fact that both parties
hold the same key that is used for encryption and decryption. This is in
contrast to asymmetric , orpublic-key , encryption (introduced in Chapter 10),
where encryption and decryption use diﬀerent keys.
Asalreadynoted, thegoalofencryptionistokeepthe plaintexthiddenfrom
an eavesdropperwho can monitor the communication channel and observethe
ciphertext. We discuss this in more detail later in this chapter, and spend a
great deal of time in Chapters 2 and 3 formally deﬁning this goal.
There are two canonical applications of private-key cryptography. In the
ﬁrst, there are two distinct parties separated in space, e.g., a worker in New
York communicating with her colleague in California; see Figure 1.2. These
two users are assumed to have been able to securely share a key in advance
of their communication. (Note that if one party simply sends the key to the
other over the public communication channel, then the eavesdropper obtains
the key too!) Often this is easy to accomplish by having the parties physically
meet in a secure location to share a key before they separate; in the example
just given, the co-workers might arrange to share a key when they are both in
the New York oﬃce. In other cases, sharing a key securely is more diﬃcult.
For the next several chapters we simply assume that sharing a key is possible;
we will revisit this issue in Chapter 10.
The secondwidespreadapplication ofprivate-keycryptographyinvolvesthe
same party communicating with itself over time. (See Figure 1.2.) Consider,
e.g., disk encryption, where a user encrypts some plaintext and stores the
resulting ciphertext on their hard drive; the same user will return at a later6 Introduction to Modern Cryptography
/MT107
/MT107
/MT63/MT109/MT101/MT110/MT99/MT114/MT121/MT112/MT116/MT105/MT111/MT110
/MT100/MT101/MT99/MT114/MT121/MT112/MT116/MT105/MT111/MT110/MT99/MT105/MT112/MT104/MT101/MT114/MT116/MT101/MT120/MT116
/MT109
FIGURE 1.2 :Another common setting of private-key cryptography
(again, encryption): a single user stores data securely over time.
point in time to decrypt the ciphertext and recover the original data. The
hard drive here serves as the communication channel on which an attacker
might eavesdrop by gaining access to the hard drive and reading its contents.
“Sharing” the key is now trivial, though the user still needs a secure and
reliable way to remember/store the key for use at a later point in time.
The syntax of encryption. Formally, a private-key encryption scheme
is deﬁned by specifying a message spaceMalong with three algorithms: a
procedure for generating keys ( Gen), a procedure for encrypting ( Enc), and
a procedure for decrypting ( Dec). The message space Mdeﬁnes the set of
“legal” messages, i.e., those supported by the scheme. The algorithms have
the following functionality:
1. Thekey-generation algorithm Genis a probabilistic algorithm that out-
puts a key kchosen according to some distribution.
2. Theencryption algorithm Enctakes as input a key kand a message m
and outputs a ciphertext c. We denote by Enck(m) the encryption of
the plaintext musing the key k.
3. Thedecryption algorithm Dectakes as input a key kand a ciphertext c
and outputs a plaintext m. We denote the decryption ofthe ciphertext c
using the key kbyDeck(c).
An encryption scheme must satisfy the following correctness requirement: for
every key koutput by Genand every message m∈M, it holds that
Deck(Enck(m)) =m.Introduction 7
Inwords: encrypting a message and then decrypting the resulting ciphertext
(using the same key) yields the original message.
The set of all possible keys output by the key-generationalgorithm is called
thekey space and is denoted by K. Almost always, Gensimply chooses a
uniform key from the key space; in fact, one can assume without loss of
generality that this is the case (see Exercise 2.1).
Reviewing our earlier discussion, an encryption scheme can be used by two
partieswhowishtocommunicateasfollows. First, Genisruntoobtainakey k
that the parties share. Later, when one party wants to send a plaintext m
to the other, she computes c:=Enck(m) and sends the resulting ciphertext c
over the public channel to the other party.1Upon receiving c, the other party
computes m:=Deck(c) to recover the original plaintext.
Keys and Kerckhoﬀs’ principle. As is clear from the above, if an eaves-
dropping adversary knows the algorithm Decas well as the key kshared by
the two communicating parties, then that adversary will be able to decrypt
any ciphertexts transmitted by those parties. It is for this reason that the
communicating parties must share the key ksecurely and keep kcompletely
secret from everyone else. Perhaps they should keep the decryption algorithm
Decsecret, too? For that matter, might it not be better for them to keep all
the details of the encryption scheme secret?
In the late 19th century, Auguste Kerckhoﬀs argued the opposite in a paper
he wrote elucidating several design principles for military ciphers. One of the
most important of these, now known simply as Kerckhoﬀs’ principle , was:
The cipher method must not be required to be secret, and it must
be able to fall into the hands of the enemy without inconvenience.
That is, an encryption scheme should be designed to be secure even ifan
eavesdropper knows all the details of the scheme, so long as the attacker
doesn’t know the key being used. Stated diﬀerently, security should not rely
on the encryption scheme being secret; instead, Kerckhoﬀs’principle demands
thatsecurity rely solely on secrecy of the key .
There are three primary arguments in favor of Kerckhoﬀs’ principle. The
ﬁrst is that it is signiﬁcantly easier for the parties to maintain secrecy of
a short key than to keep secret the (more complicated) algorithm they are
using. This is especially true if we imagine using encryption to secure the
communication between all pairs of employees in some organization. Unless
each pair of parties uses their own, unique algorithm, some parties will know
the algorithm used by others. Information about the encryption algorithm
might be leaked by one of these employees (say, after being ﬁred), or obtained
by an attacker using reverse engineering. In short, it is simply unrealistic to
assume that the encryption algorithm will remain secret.
1Weuse “:=” to denote deterministic assignment, and assume for now that Encis deter-
ministic. A list of common notation can be found in the back of the book.8 Introduction to Modern Cryptography
Second, in case the honest parties’ shared, secret information isever ex-
posed, it will be much easier for them to change a key than to replace an
encryption scheme. (Consider updating a ﬁle versus installing a new pro-
gram.) Moreover, it is relatively trivial to generate a new random secret,
whereas it would be a huge undertaking to design a new encryption scheme.
Finally, for large-scale deployment it is signiﬁcantly easier for users to all
rely on the same encryption algorithm/software (with diﬀerent keys) than
for everyone to use their own custom algorithm. (This is true even for a
single user who is communicating with several diﬀerent parties.) In fact, it is
desirable for encryption schemes to be standardized so that (1) compatibility
is ensured by default and (2) users will utilize an encryption scheme that has
undergone public scrutiny and in which no weaknesses have been found.
Nowadays Kerckhoﬀs’ principle is understood as advocating that crypto-
graphic designs be made completely public, in stark contrast to the notion
of “security by obscurity” which suggests that keeping algorithms secret im-
proves security. It is very dangerous to use a proprietary, “home-brewed”
algorithm (i.e., a non-standardized algorithm designed in secret by some com-
pany). In contrast, published designs undergo public review and are therefore
likely to be stronger. Many years of experience have demonstrated that it is
very diﬃcult to construct good cryptographic schemes. Therefore, our con-
ﬁdence in the security of a scheme is much higher if it has been extensively
studied (by expertsother than the designersofthe scheme) and no weaknesses
havebeen found. As simple and obviousas it maysound, the principle ofopen
cryptographic design (i.e., Kerckhoﬀs’ principle) has been ignored over and
overagainwith disastrousresults. Fortunately, todaythere areenoughsecure,
standardized, and widely available cryptosystems that there is no reason to
use anything else.
1.3 Historical Ciphers and Their Cryptanalysis
Inour study of “classical” cryptography we will examine some historical
encryption schemes and show that they are insecure. Our main aims in pre-
senting this material are (1) to highlight the weaknesses of an “ad hoc” ap-
proach to cryptography, and thus motivate the modern, rigorous approach
that will be taken in the rest of the book, and (2) to demonstrate that simple
approaches to achieving secure encryption are unlikely to succeed. Along the
way, we will present some central principles of cryptography inspired by the
weaknesses of these historical schemes.
In this section, plaintext characters are written in lower case and cipher-
text characters are written in UPPER CASE for typographical clarity.
Caesar’s cipher. One of the oldest recorded ciphers, known as Caesar’sIntroduction 9
cipher, is described in De Vita Caesarum, Divus Iulius (“The Lives of the
Caesars, the Deiﬁed Julius”), written in approximately 110 CE:
There are also letters of his to Cicero, as well as to his intimates
on private aﬀairs, and in the latter, if he had anything conﬁdential
to say, he wrote it in cipher, that is, by so changing the order of
the letters of the alphabet, that not a word could be made out...
Julius Caesar encrypted by shifting the letters of the alphabet 3 places for-
ward:awas replaced with D,bwithE, and so on. At the very end of the
alphabet, the letters wrap around and so zwas replaced with C,ywithB, and
xwithA. For example, encryption of the message begin the attack now ,
with spaces removed, gives:
EHJLQWKHDWWDFNQRZ .
An immediate problem with this cipher is that the encryption method is ﬁxed;
there is no key. Thus, anyone learning how Caesar encrypted his messages
would be able to decrypt eﬀortlessly.
Interestingly, a variant of this cipher called ROT-13 (where the shift is 13
places instead of 3) is still used nowadays in various online forums. It is
understood that this does not provide any cryptographic security; it is used
merely to ensure that the text (say, a movie spoiler) is unintelligible unless
the reader of a message consciously chooses to decrypt it.
The shift cipher and the suﬃcient key-space principle. Theshift
ciphercan be viewed as a keyed variant of Caesar’s cipher.2Speciﬁcally, in
theshift cipherthekey kisanumberbetween0and25. Toencrypt, lettersare
shifted as in Caesar’scipher, but now by kplaces. Mapping this to the syntax
of encryption described earlier, the message space consists of arbitrary length
stringsofEnglishletterswithpunctuation, spaces,andnumeralsremoved,and
with no distinction between upper and lower case. Algorithm Genoutputs a
uniform key k∈{0,...,25}; algorithm Enctakes a key kand a plaintext and
shifts each letter of the plaintext forward kpositions (wrapping around at the
end of the alphabet); and algorithm Dectakes a key kand a ciphertext and
shifts every letter of the ciphertext backward kpositions.
A more mathematical description is obtained by equating the English al-
phabet with the set {0,...,25}(soa= 0,b= 1, etc.). The message space
Mis then any ﬁnite sequence of integers from this set. Encryption of the
message m=m1···m/lscript(wheremi∈{0,...,25}) using key kis given by
Enck(m1···m/lscript) =c1···c/lscript,whereci= [(mi+k) mod 26] .
(The notation [ amodN] denotes the remainder of aupon division by N,
with 0≤[amodN]< N. We refer to the process mapping ato [amodN]
2Insome books, “Caesar’s cipher” and “shift cipher” are used interchangeably.10 Introduction to Modern Cryptography
asreduction modulo N; we will have more to say about this beginning in
Chapter 8.) Decryption of a ciphertext c=c1···c/lscriptusing key kis given by
Deck(c1···c/lscript) =m1···m/lscript,wheremi= [(ci−k) mod 26] .
Is the shift cipher secure? Before reading on, try to decrypt the following
ciphertext that was generated using the shift cipher and a secret key k:
OVDTHUFWVZZPISLRLFZHYLAOLYL .
Is it possible to recoverthe message without knowing k? Actually, it is trivial!
The reason is that there are only 26 possible keys. So one can try to decrypt
the ciphertext using every possible key and thereby obtain a list of 26 candi-
date plaintexts. The correct plaintext will certainly be on this list; moreover,
if the ciphertext is “long enough” then the correct plaintext will likely be the
only candidate on the list that “makes sense.” (The latter is not necessar-
ily true, but will be true most of the time. Even when it is not, the attack
narrows down the set of potential plaintexts to at most 26 possibilities.) By
scanning the list of candidates it is easy to recover the original plaintext.
An attack that involves trying every possible key is called a brute-force or
exhaustive-search attack. Clearly, for an encryption scheme to be secure it
must not be vulnerable to such an attack.3This observation is known as the
suﬃcient key-space principle :
Any secure encryption scheme must have a key space that is suﬃ-
ciently large to make an exhaustive-search attack infeasible.
One can debate what amount of eﬀort makes a task “infeasible,” and an
exact determination of feasibility depends on both the resources of a potential
attacker and the length of time the sender and receiver want to ensure secrecy
of their communication. Nowadays, attackers can use supercomputers, tens
of thousands of personal computers, or graphics processing units (GPUs) to
speed up brute-force attacks. To protect against such attacks the key space
must therefore be very large—say, of size at least 270, and even larger if one
is concerned about long-term security against a well-funded attacker.
The suﬃcient key-space principle gives a necessary condition for security,
but not a suﬃcient one. The next example demonstrates this.
The mono-alphabetic substitution cipher. In the shift cipher, the key
deﬁnes a map from each letter of the (plaintext) alphabet to some letter of
the (ciphertext) alphabet, where the map is a ﬁxed shift determined by the
key. In the mono-alphabetic substitution cipher , the key also deﬁnes a map
on the alphabet, but the map is now allowed to be arbitrary subject only to
the constraint that it be one-to-one so that decryption is possible. The key
3Technically, this is only true if the message space is larger than the key space; we will
return to this point in Chapter 2. Encryption schemes used in practice have this property.Introduction 11
space thus consists of all bijections , orpermutations , of the alphabet. So, for
example, the key that deﬁnes the following permutation
a b c d e f g h i j k l m n o p q r s t u v w x y z
XEU A D N B K V M R O C Q F S Y H W G L Z I J P T
(in which amaps toX, etc.) would encrypt the message tellhimaboutme to
GDOOKVCXEFLGCD . The name of this cipher comes from the fact that the key
deﬁnes a (ﬁxed) substitution for individual characters of the plaintext.
Assuming the English alphabet is being used, the key space is of size 26! =
26·25·24···2·1, or approximately 288, and a brute-force attack is infeasible.
This, however, does not mean the cipher is secure! In fact, as we will show
next, it is easy to break this scheme even though it has a large key space.
Assume English-language text is being encrypted (i.e., the text is gram-
matically correct English writing, not just text written using characters of
the English alphabet). The mono-alphabetic substitution cipher can then be
attacked by utilizing statistical patterns of the English language. (Of course,
the same attack works for any language.) The attack relies on the facts that:
1. For any key, the mapping of each letter is ﬁxed, and so if eis mapped
toD, then every appearance of ein the plaintext will result in the ap-
pearance of Din the ciphertext.
2. The frequency distribution of individual letters in the English language
is known (see Figure 1.3). Of course, very short texts may deviate from
this distribution, but even texts consisting of only a few sentences tend
to have distributions that are very close to the average.
   
 
   

 

      
	 
    
   

  
	  
 

 
  
	  
	  
     
 
   
      
  

 
	  
   

  

  
 
                   ! " # $ % & ' (
) *
+
,
*
-
. /
0
*1 2 3 3 2 4
FIGURE 1.3 :Average letter frequencies for English-language text.12 Introduction to Modern Cryptography
The attack works by tabulating the frequency distribution of charactersin the
ciphertext, i.e., recording that Aappeared 11 times, Bappeared 4 times, and
so on. These frequencies are then compared to the known letter frequencies
of normal English text. One can then guess parts of the mapping deﬁned by
the key based on the observed frequencies. For example, since eis the most
frequent letter in English, one can guess that the most frequent character in
the ciphertext corresponds to the plaintext character e, and so on. Some of
the guesses may be wrong, but enough of the guesses will be correct to enable
relatively quick decryption (especially utilizing other knowledge of English,
such as the fact that ugenerally follows q, and that his likely to appear be-
tweentande). We conclude that although the mono-alphabetic substitution
cipher has a large key space, it is still insecure.
Itshouldnotbesurprisingthatthemono-alphabeticsubstitutionciphercan
be quickly broken, since puzzles based on this cipher appear in newspapers
(and are solved by some people before their morning coﬀee!). We recommend
that you try to decipher the following ciphertext—this should convince you
how easy the attack is to carry out. (Use Figure 1.3 to help you.)
JGRMQOYGHMVBJWRWQFPWHGFFDQGFPFZRKBEEBJIZQQOCIBZKLFAFGQVFZFWWE
OGWOPFGFHWOLPHLRLOLFDMFGQWBLWBWQOLKFWBYLBLYLFSFLJGRMQBOLWJVFP
FWQVHQWFFPQOQVFPQOCFPOGFWFJIGFQVHLHLROQVFGWJVFPFOLFHGQVQVFILE
OGQILHQFQGIQVVOSFAFGBWQVHQWIJVWJVFPFWHGFIWIHZZRQGBABHZQOCGFHX
An improved attack on the shift cipher. We can use letter-frequency
tables to give an improved attack on the shift cipher. Our previous attack on
the shiftcipherrequireddecryptingthe ciphertextusingeachpossiblekey, and
thencheckingwhichkeyresultsinaplaintextthat“makessense.” Adrawback
ofthis approachis that it is somewhat diﬃcult to automate, since it is diﬃcult
for a computer to check whether a given plaintext “makes sense.” (We do not
claim that it would be impossible, as the attack could be automated using a
dictionary of valid English words. We only claim that it would not be trivial
to automate.) Moreover, there may be cases—we will see one later—where
the plaintext characters are distributed just like English-language text even
though the plaintext itself is not valid English, in which case checking for a
plaintext that “makes sense” will not work.
We now describe an attack that does not suﬀer from these drawbacks. As
before, associate the letters of the English alphabet with 0 ,...,25. Let pi,
with 0≤pi≤1, denote the frequency of the ith letter in normal English text
(ignoring spaces, punctuation, etc.). Calculation using Figure 1.3 gives
25/summationdisplay
i=0p2
i≈0.065. (1.1)
Now, say we are given some ciphertext and let qidenote the frequency of
theith letter of the alphabet in this ciphertext; i.e., qiis simply the numberIntroduction 13
of occurrences of the ith letter of the alphabet in the ciphertext divided by
the length of the ciphertext. If the key is k, thenpishould be roughly equal
toqi+kfor alli, because the ith letter is mapped to the ( i+k)th letter. (We
usei+kinstead ofthe more cumbersome [ i+kmod 26].) Thus, if we compute
Ijdef=25/summationdisplay
i=0pi·qi+j
for each value of j∈{0,...,25}, then we expect to ﬁnd that Ik≈0.065
(wherekis the actual key), whereas Ijforj/negationslash=kwill be diﬀerent from 0.065.
This leads to a key-recovery attack that is easy to automate: compute Ijfor
allj, and then output the value kfor which Ikis closest to 0 .065.
The Vigen` ere (poly-alphabetic shift) cipher. The statistical attack on
the mono-alphabetic substitution cipher can be carried out because the key
deﬁnes a ﬁxed mapping that is applied letter-by-letter to the plaintext. Such
an attack could be thwarted by using a poly-alphabetic substitution cipher
where the key instead deﬁnes a mapping that is applied on blocksof plaintext
characters. Here, for example, a key might map the 2-character block abto
DZwhile mapping actoTY; note that the plaintext character adoes not get
mapped to a ﬁxed ciphertext character. Poly-alphabetic substitution ciphers
“smooth out” the frequency distribution of characters in the ciphertext and
make it harder to perform statistical analysis.
TheVigen` ere cipher , a special case of the above also called the poly-
alphabetic shiftcipher, works by applying several independent instances of
the shift cipher in sequence. The key is now viewed as a stringof letters; en-
cryption is done by shifting each plaintext character by the amount indicated
by the next character of the key, wrapping around in the key when necessary.
(This degenerates to the shift cipher if the key has length 1.) For example,
encryption of the message tellhimaboutme using the key cafewould work
as follows:
Plaintext: tellhimaboutme
Key (repeated): cafecafecafeca
Ciphertext: VEQPJIREDOZXOE
(The keyneednotbe anEnglishword.) Thisis exactlythe sameasencrypting
theﬁrst, ﬁfth, ninth, ... characterswiththeshiftcipherandkey c; thesecond,
sixth, tenth, ... characters with key a; the third, seventh, ... characters
withf; and the fourth, eighth, ... characterswith e. Notice that in the above
example lis mapped once to Qand once to P. Furthermore, the ciphertext
character Eis sometimes obtained from eand sometimes from a. Thus, the
character frequencies of the ciphertext are “smoothed out,” as desired.
Ifthe key is suﬃciently long, crackingthis cipher appearsdaunting. Indeed,
it had been considered by many to be “unbreakable,” and although it was
invented in the 16th century, a systematic attack on the scheme was only
devised hundreds of years later.14 Introduction to Modern Cryptography
Attacking the Vigen` ere cipher. A ﬁrst observation in attacking the Vi-
gen` erecipher is that if the length of the key is known then attackingthe cipher
is relatively easy. Speciﬁcally, say the length of the key, also called the period,
ist. Write the key kask=k1···ktwhere each kiis a letter of the alphabet.
An observed ciphertext c=c1c2···can be divided into tparts where each
part can be viewed as having been encrypted using a shift cipher. Speciﬁcally,
for allj∈{1,...,t}the ciphertext characters
cj,cj+t,cj+2t,...
all resulted by shifting the corresponding characters of the plaintext by kj
positions. We refer to the above sequence of characters as the jthstream.
All that remains is to determine, for each of the tstreams, which of the 26
possible shifts was used. This is not as trivial as in the case of the shift
cipher, because it is no longer possible to simply try diﬀerent shifts in an
attempt to determine when decryption of a stream “makes sense.” (Recall
that a stream does not correspond to consecutive letters of the plaintext.)
Furthermore, trying to guess the entire key kat once would require a brute-
force search through 26tdiﬀerent possibilities, which is infeasible for large t.
Nevertheless, we can still use letter-frequency analysis to analyze each stream
independently. Namely, for each stream we tabulate the frequency of each
ciphertext character and then check which of the 26 possible shifts yields the
“right” probability distribution for that stream. Since this can be carried out
independently for each stream (i.e., for each character of the key), this attack
takes time 26·trather than time 26t.
A more principled, easier-to-automate approach is to use the improved
method for attacking the shift cipher discussed earlier. That attack did not
rely on checking for a plaintext that “made sense,” but only relied on the
underlying frequency distribution of characters in the plaintext.
Eitherofthe aboveapproachesgivesasuccessfulattackwhen thekeylength
is known. What if the key length is unknown?
Note ﬁrst that as long as the maximum length Tof the key is not too
large, we can simply repeat the above attack Ttimes (for each possible value
t∈{1,...,T}). This leads to at most Tdiﬀerent candidate plaintexts, among
which the true plaintext will likely be easy to identify. So an unknown key
length is not a serious obstacle.
There are also more eﬃcient ways to determine the key length from an
observed ciphertext. One is to use Kasiski’s method , published in the mid-
19th century. The ﬁrst step here is to identify repeated patterns of length 2
or3intheciphertext. Thesearelikelytheresultofcertainbigramsortrigrams
that appear frequently in the plaintext. For example, consider the common
word “the.” This word will be mapped to diﬀerent ciphertext characters,
depending on its position in the plaintext. However, if it appears twice in
the same relative position, then it will be mapped to the same ciphertext
characters. For a suﬃciently long plaintext, there is thus a good chance that
“the” will be mapped repeatedly to the same ciphertext characters.Introduction 15
Consider the following concrete example with the key beads(spaces have
been added for clarity):
Plaintext: the man and the woman retrieved the letter from the post office
Key: bea dsb ead sbe adsbe adsbeadsb ead sbeads bead sbe adsb eadsbe
Ciphertext: ULE PSO ENG LII WREBR RHLSMEYWE XHH DFXTHJ GVOP LII PRKU SFIADI
The word theismapped sometimes to ULE, sometimes to LII, and sometimes
toXHH. However, it is mapped twicetoLII, and in a long enough text it is
likely that it would be mapped multiple times to each of these possibilities.
Kasiski’s observation was that the distance between such repeated appear-
ances (assuming they are not coincidental) must be a multiple of the period.
(In the above example, the period is 5 and the distance between the two ap-
pearances of LIIis 30, which is 6 times the period.) Therefore, the greatest
common divisor of the distances between repeated sequences (assuming they
are not coincidental) will yield the key length tor a multiple thereof.
An alternative approach, called the index of coincidence method , is more
methodical and hence easier to automate. Recall that if the key length is t,
then the ciphertext characters
c1,c1+t,c1+2t,...
in the ﬁrst stream all resulted from encryption using the same shift. This
means that the frequencies of the characters in this sequence are expected
to be identical to the character frequencies of standard English text in some
shifted order . In more detail: let qidenote the observed frequency of the ith
English letter in this stream; this is simply the number of occurrences of the
ith letter of the alphabet divided by the total number of letters in the stream.
If the shift used here is j(i.e., if the ﬁrst character k1of the key is equal
toj), then for all iwe expect qi+j≈pi, wherepiis the frequency of the ith
letter of the alphabet in standard English text. (Once again, we use qi+jin
place ofq[i+jmod 26].) But this means that the sequence q0,...,q 25is just the
sequence p0,...,p 25shiftedjplaces. As a consequence (cf. Equation (1.1)):
25/summationdisplay
i=0q2
i≈25/summationdisplay
i=0p2
i≈0.065.
This leads to a nice way to determine the key length t. Forτ= 1,2,...,
look at the sequence of ciphertext characters c1,c1+τ,c1+2τ,...and tabulate
q0,...,q 25for this sequence. Then compute
Sτdef=25/summationdisplay
i=0q2
i.
Whenτ=twe expect Sτ≈0.065, asdiscussed above. On the other hand, if τ
isnotamultipleof tweexpectthatallcharacterswilloccurwithroughlyequal16 Introduction to Modern Cryptography
probability in the sequence c1,c1+τ,c1+2τ,..., and so we expect qi≈1/26 for
alli. In this case we will obtain
Sτ≈25/summationdisplay
i=0/parenleftbigg1
26/parenrightbigg2
≈0.038.
The smallest value of τfor which Sτ≈0.065 is thus likely the key length.
One can further validate a guess τby carrying out a similar calculation using
the second stream c2,c2+τ,c2+2τ,..., etc.
Ciphertext length and cryptanalytic attacks. The above attacks on
the Vigen` ere cipher require a longer ciphertext than the attacks on previous
schemes. For example, the index of coincidence method requires c1,c1+t,c1+2t
(wheretis the actual key length) to be suﬃciently long in orderto ensure that
the observed frequencies match what is expected; the ciphertext itself must
then be roughly ttimes larger. Similarly, the attack we showed on the mono-
alphabetic substitution cipher requires a longer ciphertext than the attack on
the shift cipher (which can work for encryptions of even a single word). This
illustrates that a longer key can, in general, require the cryptanalyst to obtain
more ciphertext in order to carry out an attack. (Indeed, the Vigen` ere cipher
can be shown to be secure if the key is as long as what is being encrypted.
We will see a similar phenomenon in the next chapter.)
Conclusions. We have presented only a few historical ciphers. Beyond their
historicalinterest,ouraiminpresentingthemwastoillustratesomeimportant
lessons. Perhaps the most important is that designing secure ciphers is hard .
The Vigen` ere cipher remained unbroken for a long time. Far more complex
schemes have also been used. But a complex scheme is not necessarily secure,
and all historical schemes have been broken.
1.4 Principles of Modern Cryptography
Asshould be clear from the previous section, cryptography was historically
more of an art than a science. Schemes were designed in an ad hoc manner
and evaluated based on their perceived complexity or cleverness. A scheme
would be analyzedto seeifany attackscould be found; ifso, the schemewould
be “patched” to thwart that attack, and the process repeated. Although there
may have been agreement that some schemes were notsecure (as evidenced
by an especially damaging attack), there was no agreed-upon notion of what
requirements a “secure” scheme should satisfy, and no way to give evidence
that any speciﬁc scheme was secure.
Over the past several decades, cryptography has developed into more of
a science. Schemes are now developed and analyzed in a more systematicIntroduction 17
manner, with the ultimate goal being to give a rigorous proofthat a given
construction is secure. In order to articulate such proofs, we ﬁrst need formal
deﬁnitions that pin down exactly what “secure” means; such deﬁnitions are
useful and interesting in their own right. As it turns out, most cryptographic
proofs rely on currently unproven assumptions about the algorithmic hard-
ness of certain mathematical problems; any such assumptions must be made
explicit and be stated precisely. An emphasis on deﬁnitions, assumptions,
and proofs distinguishes moderncryptography from classical cryptography;
we discuss these three principles in greater detail in the following sections.
1.4.1 Principle 1 – Formal Deﬁnitions
One of the key contributions of modern cryptography has been the recog-
nition that formal deﬁnitions of security are essential for the proper design,
study, evaluation, and usage of cryptographic primitives. Put bluntly:
If you don’t understand what you want to achieve, how can you
possibly know when (or if) you have achieved it?
Formal deﬁnitions provide such understanding by giving a clear description of
what threats are in scope and what security guarantees are desired. As such,
deﬁnitions can help guide the design of cryptographic schemes. Indeed, it is
much better to formalize what is required beforethe design process begins,
ratherthantocomeupwithadeﬁnition post facto oncethedesigniscomplete.
The latter approach risks having the design phase end when the designers’
patience is exhausted (rather than when the goalhas been met), or may result
in a construction achieving morethan is needed at the expense of eﬃciency.
Deﬁnitions also oﬀer a way to evaluate and analyze what is constructed.
Withadeﬁnitioninplace, onecanstudyaproposedschemetoseeifitachieves
the desired guarantees; in some cases, one can even provea given construction
secure (see Section 1.4.3) by showing that it meets the deﬁnition. On the ﬂip
side, deﬁnitions can be used to conclusively show that a given scheme is not
secure, insofar as the scheme does not satisfy the deﬁnition. In particular,
notethattheattacksintheprevioussectiondonotautomaticallydemonstrate
that any of the schemes shown there is “insecure.” For example, the attack
on the Vigen` ere cipher assumed that suﬃciently long English text was being
encrypted, but could the Vigen` ere cipher be “secure” if short English text,
or compressed text (which will have roughly uniform letter frequencies), is
encrypted? It is hard to say without a formal deﬁnition in place.
Deﬁnitions enable a meaningful comparison of schemes. As we will see,
there can be multiple (valid) ways to deﬁne security; the “right” one depends
on the context in which a scheme is used. A scheme satisfying a weaker
deﬁnition may be more eﬃcient than another scheme satisfying a stronger
deﬁnition; with precise deﬁnitions we can properly evaluate the trade-oﬀs
between the two schemes. Along the same lines, deﬁnitions enable secure
usage of schemes. Consider the question of deciding which encryption scheme18 Introduction to Modern Cryptography
to use for some largerapplication. A sound way to approach the problem is to
ﬁrst understand what notion of security is required for that application, and
then ﬁnd an encryption scheme satisfying that notion. A side beneﬁt of this
approachis modularity : adesignercan “swapout”one encryptionscheme and
replace it with another (that also satisﬁes the necessary deﬁnition of security)
without having to worry about aﬀecting security of the overall application.
Writing a formal deﬁnition forces one to think about what is essential to
the problem at hand and what properties are extraneous. Going through the
process often reveals subtleties of the problem that were not obvious at ﬁrst
glance. We illustrate this next for the case of encryption.
An example: secure encryption. A common mistake is to think that
formal deﬁnitions are not needed, or are trivial to come up with, because
“everyone has an intuitive idea of what security means.” This is not the case.
As an example, we consider the case of encryption. (The reader may want to
pauseheretothinkabouthowtheywouldformallydeﬁnewhatitmeansforan
encryption scheme to be secure.) Although we postpone a formal deﬁnition of
secure encryption to the next two chapters, we describe here informally what
such a deﬁnition should capture.
In general, a security deﬁnition has two components: a security guarantee
(or, from the attacker’s point of view, what constitutes a successful attack
on the scheme) and a threat model. The security guarantee deﬁnes what the
scheme is intended to prevent the attacker from doing, while the threat model
describesthe powerofthe adversary,i.e., what actionsthe attackerisassumed
able to carry out.
Let’s start with the ﬁrst of these. What should a secure encryption scheme
guarantee? Here are some thoughts:
•It should be impossible for an attacker to recover the key . We have
previously observed that if an attacker can determine the key shared
by two parties using some scheme, then that scheme cannot be secure.
However, it is easy to come up with schemes for which key recovery
is impossible, yet the scheme is blatantly insecure. Consider, e.g., the
scheme where Enck(m) =m. The ciphertext leaks no information about
the key (and so the key cannot be recovered if it is long enough) yet the
messageis sent in the clear! We thus see that inability to recoverthe key
is not suﬃcient for security. This makes sense: the aim of encryption is
to protect the message; the key is a means for achieving this but is, in
itself, unimportant.
•It should be impossible for an attacker to recover the entire plaintext from
the ciphertext . This deﬁnition is better, but is still far from satisfactory.
In particular, this deﬁnition would consideran encryptionscheme secure
if its ciphertexts revealed 90% of the plaintext, as long as 10% of the
plaintext remained hard to ﬁgure out. This is clearly unacceptable in
most common applications of encryption; for example, when encryptingIntroduction 19
asalary database, we would be justiﬁably upset if 90% of employees’
salaries were revealed!
•It should be impossible for an attacker to recover any character of the
plaintext from the ciphertext . This looks like a good deﬁnition, yet is
still not suﬃcient. Going back to the example of encrypting a salary
database, we would not consider an encryption scheme secure if it re-
veals whether an employee’s salary is more than or less than $100,000,
even if it does not reveal any particular digit of that employee’s salary.
Similarly, we would not want an encryption scheme to reveal whether
employee Amakes more than employee B.
Another issue is how to formalize what it means for an adversary to
“recover a character of the plaintext.” What if an attacker correctly
guesses, through sheer luck or external information, that the least sig-
niﬁcant digit of someone’s salaryis 0? Clearly that should not render an
encryption scheme insecure, and so any viable deﬁnition must somehow
rule out such behavior as being a successful attack.
•The “right” answer: regardless of any information an attacker already
has, a ciphertext should leak no additional information about the un-
derlying plaintext. This informal deﬁnition captures all the concerns
outlined above. Note in particular that it does not try to deﬁne what
information about the plaintext is “meaningful”; it simply requires that
noinformation be leaked. This is important, as it means that a secure
encryption scheme is suitable for all potential applications in which se-
crecy is required.
What is missing here is a precise, mathematical formulation of the def-
inition. How should we capture an attacker’s prior knowledge about
the plaintext? And what does it mean to (not) leak information? We
will return to these questions in the next two chapters; see especially
Deﬁnitions 2.3 and 3.12.
Now that we have ﬁxed a security goal, it remains to specify a threat model .
This speciﬁes what “power” the attacker is assumed to have, but does not
place any restrictions on the adversary’s strategy. This is an important dis-
tinction: we specify what we assume about the adversary’s abilities, but we
donotassume anything about how it uses those abilities. It is impossible to
foresee what strategies might be used in an attack, and history has proven
that attempts to do so are doomed to failure.
There are several plausible options for the threat model in the context of
encryption; standard ones, in order of increasing power of the attacker, are:
•Ciphertext-only attack: This is the most basic attack, and refers to
a scenario where the adversary just observes a ciphertext (or multiple
ciphertexts) and attempts to determine information about the under-
lying plaintext (or plaintexts). This is the threat model we have been20 Introduction to Modern Cryptography
implicitly assuming when discussing classical encryption schemes in the
previous section.
•Known-plaintext attack: Here, the adversary is able to learn one
or more plaintext/ciphertext pairs generated using some key. The aim
of the adversary is then to deduce information about the underlying
plaintext of some otherciphertext produced using the same key.
All the classical encryption schemes we have seen are trivial to break
using a known-plaintextattack; we leavea demonstrationas an exercise.
•Chosen-plaintext attack: In this attack, the adversary can obtain
plaintext/ciphertext pairs (as above) for plaintexts of its choice .
•Chosen-ciphertext attack: The ﬁnal type of attack is one where
the adversary is additionally able to obtain (some information about)
thedecryption of ciphertexts of its choice, e.g., whether the decryption
of some ciphertext chosen by the attacker yields a valid English mes-
sage. The adversary’s aim, once again, is to learn information about
the underlying plaintext of some otherciphertext (whose decryption
the adversary is unable to obtain directly).
None of these threat models is inherently better than any other; the right one
to use depends onthe environmentin which an encryptionschemeis deployed.
The ﬁrst two types of attack are the easiest to carry out. In a ciphertext-
only attack, the only thing the adversary needs to do is eavesdrop on the
public communication channel over which encrypted messages are sent. In
a known-plaintext attack it is assumed that the adversary somehow also ob-
tains ciphertexts corresponding to known plaintexts. This is often easy to
accomplish because not all encrypted messages are conﬁdential, at least not
indeﬁnitely. As a trivial example, two parties may always encrypt a “hello”
message whenever they begin communicating. As a more complex example,
encryption may be used to keep quarterly-earnings reports secret until their
release date; in this case, anyone eavesdropping on the ciphertext will later
obtain the corresponding plaintext.
In the latter two attacks the adversary is assumed to be able to obtain
encryptions and/or decryptions of plaintexts/ciphertexts of its choice. This
may at ﬁrst seem strange, and we defer a more detailed discussion of these
attacks, and their practicality, to Section 3.4.2 (for chosen-plaintext attacks)
and Section 3.7 (for chosen-ciphertext attacks).
1.4.2 Principle 2 – Precise Assumptions
Most modern cryptographic constructions cannot be proven secure uncon-
ditionally; such proofs would require resolving questions in the theory of com-
putational complexity that seem far from being answered today. The result ofIntroduction 21
this unfortunate state of aﬀairs is that proofs of security typically rely on as-
sumptions . Modern cryptography requires any such assumptions to be made
explicit and mathematically precise. At the most basic level, this is simply
because mathematical proofs of security require this. But there are other
reasons as well:
1.Validation of assumptions: By their very nature, assumptions are state-
ments that are not proven but are instead conjectured to be true. In
order to strengthen our belief in some assumption, it is necessary for
the assumption to be studied. The more the assumption is examined
and tested without being refuted, the more conﬁdent we are that the
assumption is true. Furthermore, study of an assumption can provide
evidence of its validity by showing that it is implied by some other as-
sumption that is also widely believed.
If the assumption being relied upon is not precisely stated, it cannot be
studied and (potentially) refuted. Thus, a pre-condition to increasing
our conﬁdence in an assumption is having a precise statement of what
exactly is being assumed.
2.Comparison of schemes: Often in cryptography we are presented with
two schemes that can both be proven to satisfy some deﬁnition, each
based on a diﬀerent assumption. Assuming all else is equal, which
schemeshould be preferred? Ifthe assumptionon whichthe ﬁrstscheme
is based is weakerthan the assumption on which the second scheme
is based (i.e., the second assumption implies the ﬁrst), then the ﬁrst
scheme is preferable since it may turn out that the second assumption
is false while the ﬁrst assumption is true. If the assumptions used by the
two schemes are not comparable, then the general rule is to prefer the
scheme that is based on the better-studied assumption in which there is
greater conﬁdence.
3.Understanding the necessary assumptions: An encryption scheme may
be based on some underlying building block. If some weaknesses are
later found in the building block, how can we tell whether the encryp-
tion scheme is still secure? If the underlying assumptions regarding the
building block are made clear as part of proving security of the scheme,
then we need only check whether the required assumptions are aﬀected
by the new weaknesses that were found.
A question that sometimes arises is: rather than prove a scheme secure
basedonsomeotherassumption, whynotsimplyassumethattheconstruction
itselfis secure? In some cases—e.g., when a scheme has successfully resisted
attack for many years—thismay be a reasonableapproach. But this approach
is never preferred, and is downright dangerous when a new scheme is being
introduced. The reasons above help explain why. First, an assumption that
has been tested for several years is preferable to a new, ad hoc assumption22 Introduction to Modern Cryptography
that is introduced along with a new construction. Second, there is a general
preference for assumptions that are simpler to state, since such assumptions
are easierto study and to (potentially) refute. So, for example, an assumption
that some mathematical problem is hard to solve is simpler to study and
evaluate than the assumption that an encryption scheme satisﬁes a complex
securitydeﬁnition. Anotheradvantageofrelyingon“lower-level”assumptions
(rather than just assuming a construction is secure) is that these low-level
assumptions can typically be used in other constructions. Finally, low-level
assumptions can provide modularity . Consider an encryption scheme whose
security relies on some assumed property of one of its building blocks. If the
underlying building block turns out notto satisfy the stated assumption, the
encryption scheme can still be instantiated using a diﬀerent component that
is believed to satisfy the necessary requirements.
1.4.3 Principle 3 – Proofs of Security
The two principles described above allowus to achieve our goalof providing
a rigorous proofthat a construction satisﬁes a given deﬁnition under certain
speciﬁed assumptions. Such proofs are especially important in the context
of cryptography where there is an attacker who is actively trying to “break”
some scheme. Proofs of security give an iron-clad guarantee—relative to the
deﬁnition and assumptions—that no attacker will succeed; this is much better
than taking an unprincipled or heuristic approach to the problem. Without a
proof that no adversary with the speciﬁed resources can break some scheme,
we are left only with our intuition that this is the case. Experience has shown
that intuition in cryptography and computer security is disastrous. There
are countless examples of unproven schemes that were broken, sometimes
immediately and sometimes years after being developed.
Summary: Rigorous vs. Ad Hoc Approaches to Security
Reliance on deﬁnitions, assumptions, and proofs constitutes a rigorous ap-
proach to cryptography that is distinct from the informal approach of clas-
sical cryptography. Unfortunately, unprincipled, “oﬀ-the-cuﬀ” solutions are
still designed and deployed by those wishing to obtain a quick solution to a
problem, or by those who are simply unknowledgable. We hope this book
will contribute to an awareness of the rigorous approach and its importance
in developing provably secure schemes.
1.4.4 Provable Security and Real-World Security
Much of modern cryptography now rests on sound mathematical founda-
tions. But this does not mean that the ﬁeld is no longer partly an artas
well. The rigorous approach leaves room for creativity in developing deﬁni-
tionssuitedtocontemporaryapplicationsandenvironments, inproposingnewIntroduction 23
mathematical assumptions or designing new primitives, and in constructing
novel schemes and proving them secure. There will also, of course, always be
the art of attacking deployed cryptosystems, even if they are proven secure.
We expand on this point next.
The approach taken by modern cryptography has revolutionized the ﬁeld,
andhelpsprovideconﬁdenceinthesecurityofcryptographicschemesdeployed
in the real world. But it is important not to overstate what a proof of security
implies. Aproofofsecurityisalwaysrelativetothe deﬁnition beingconsidered
and theassumption(s) being used. If the security guarantee does not match
what is needed, or the threat model does not capture the adversary’s true
abilities, then the proof may be irrelevant. Similarly, if the assumption that
is relied upon turns out to be false, then the proof of security is meaningless.
The take-away point is that provable security of a scheme does not nec-
essarily imply security of that scheme in the real world.4While some have
viewed this as a drawback of provable security, we view this optimistically as
illustrating the strength of the approach. To attack a provably secure scheme
in the real world, it suﬃces to focus attention on the deﬁnition (i.e., to explore
how the idealized deﬁnition diﬀers from the real-world environment in which
the scheme is deployed) or the underlying assumptions (i.e., to see whether
they hold). In turn, it is the job of cryptographers to continually reﬁne their
deﬁnitions to more closely match the real world, and to investigate their as-
sumptions to test their validity. Provable security does not end the age-old
battle between attacker and defender, but it does provide a framework that
helps shift the odds in the defender’s favor.
References and Additional Reading
Inthis chapter, we have studied just a few of the known historical ciphers.
There are many others of both historical and mathematical interest, and we
refer the reader to textbooks by Stinson [168] or Trappe and Washington [169]
for further details. The important role cryptography has played throughout
history is a fascinating subject covered in books by Kahn [97] and Singh [163].
Kerckhoﬀs’ principles were elucidated in [103, 104]. Shannon [154] was the
ﬁrst to pursue a rigorous approach to cryptography based on precise deﬁni-
tions and mathematical proofs; we explore his work in the next chapter.
4Here we are not even considering the possibility of an incorrect implementation of the
scheme. Poorly implemented cryptography is a serious problem in the real world, but this
problem is somewhat outside the scope of cryptography per se.24 Introduction to Modern Cryptography
Exercises
1.1Decrypt the ciphertext provided at the end of the section on mono-
alphabetic substitution ciphers.
1.2 Provide a formal deﬁnition of the Gen,Enc, andDecalgorithms for the
mono-alphabetic substitution cipher.
1.3 Provide a formal deﬁnition of the Gen,Enc, andDecalgorithms for
the Vigen` ere cipher. (Note: there are several plausible choices for Gen;
choose one.)
1.4 Implement the attacks described in this chapter for the shift cipher and
the Vigen` ere cipher.
1.5 Show that the shift, substitution, and Vigen` ere ciphers are all trivial to
break using a chosen-plaintext attack. How much chosen plaintext is
needed to recover the key for each of the ciphers?
1.6 Assume an attackerknowsthat a user’s passwordis either abcdorbedg.
Say the user encrypts his password using the shift cipher, and the at-
tacker sees the resulting ciphertext. Show how the attacker can deter-
mine the user’s password, or explain why this is not possible.
1.7 Repeat the previous exercise for the Vigen` ere cipher using period 2,
using period 3, and using period 4.
1.8 The shift, substitution, and Vigen` ere ciphers can also be deﬁned over
the 128-characterASCII alphabet (rather than the 26-characterEnglish
alphabet).
(a) Provide a formal deﬁnition of each of these schemes in this case.
(b) Discuss how the attacks we have shown in this chapter can be
modiﬁed to break each of these modiﬁed schemes.Chapter 2
Perfectly Secret Encryption
Inthepreviouschapterwepresentedhistoricalencryptionschemesandshowed
how they can be broken with little computational eﬀort. In this chapter, we
look at the other extreme and study encryption schemes that are provably se-
cure even against an adversary with unbounded computational power. Such
schemes are called perfectly secret . Besides rigorously deﬁning the notion, we
will explore conditions under which perfect secrecy can be achieved. (Begin-
ning in this chapter, we assume familiarity with basic probability theory. The
relevant notions are reviewed in Appendix A.3.)
The material in this chapter belongs, in some sense, more to the world of
“classical” cryptography than to the world of “modern” cryptography. Be-
sides the fact that all the material introduced here was developed before the
revolution in cryptography that took place in the mid-1970s and 1980s, the
constructions we study in this chapter rely only on the ﬁrst and third prin-
ciples outlined in Section 1.4. That is, precise mathematical deﬁnitions are
used and rigorous proofs are given, but it will not be necessary to rely on
any unproven computational assumptions. It is clearly advantageous to avoid
such assumptions; we will see, however, that doing so has inherent limitations.
Thus, in addition to serving as a good basis for understanding the principles
underlying modern cryptography, the results of this chapter also justify our
later adoption of all three of the aforementioned principles.
Beginningwith this chapter, we will deﬁne securityand analyze schemesus-
ingprobabilisticexperimentsinvolvingalgorithmsmakingrandomizedchoices;
a basic example is given by communicating parties’ choosing a random key.
Thus, beforereturningtothesubjectofcryptography per se, webrieﬂydiscuss
the issue of generating randomness suitable for cryptographic applications.
Generating randomness. Throughout the book, we will simply assume
that parties have access to an unlimited supply of independent, unbiased
randombits. Inpractice,wheredotheserandombits comefrom? Inprinciple,
one could generate a small number of random bits by hand, e.g., by ﬂipping
a fair coin. But such an approach is not very convenient, nor does it scale.
Modernrandom-number generation proceeds in two steps. First, a “pool”
of high-entropy data is collected. (For our purposes a formal deﬁnition of
entropy is not needed, and it suﬃces to think of entropy as a measure of
unpredictability.) Next, thishigh-entropydataisprocessedtoyieldasequence
of nearly independent and unbiased bits. This second step is necessary since
high-entropy data is not necessarily uniform.
2526 Introduction to Modern Cryptography
For the ﬁrst step, some source of unpredictable data is needed. There are
several ways such data can be acquired. One technique is to rely on external
inputs, for example, delays between network events, hard-disk access times,
keystrokes or mouse movements made by the user, and so on. Such data is
likely to be far from uniform, but if enough measurements are taken the re-
sulting pool of data is expected to have suﬃcient entropy. More sophisticated
approaches—which, by design, incorporate random-number generation more
tightly into the system at the hardwarelevel—havealsobeen used. These rely
on physical phenomena such as thermal/shot noise or radioactive decay. In-
tel has recently developed a processor that includes a digital random-number
generator on the processor chip and provides a dedicated instruction for ac-
cessing the resulting random bits (after they have been suitably processed to
yield independent, unbiased bits, as discussed next).
Theprocessingneededto“smooth”thehigh-entropydatatoobtain(nearly)
uniformbitsisanon-trivialone, andisdiscussedbrieﬂyinSection5.6.4. Here,
wejust giveasimple exampletogiveanideaofwhatisdone. Imaginethat our
high-entropy pool results from a sequence of biasedcoin ﬂips, where “heads”
occurs with probability pand “tails” with probability 1 −p. (We do assume,
however, that the result of any coin ﬂip is independent of all other coin ﬂips.
In practice this assumption is typically not valid.) The result of 1,000 such
coin ﬂips certainly has high entropy, but is not close to uniform. We can
obtain a uniform distribution by considering the coin ﬂips in pairs: if we see
a head followed by a tail then we output “0,” and if we see a tail followed by
a head then we output “1.” (If we see two heads or two tails in a row, we
output nothing, and simply move on to the next pair.) The probability that
any pair results in a “0” is p·(1−p), which is exactly equal to the probability
that any pair results in a “1,” and we thus obtain a uniformly distributed
output from our initial high-entropy pool.
Care must be taken in how random bits are produced, and using poor
random-number generators can often leave a good cryptosystem vulnerable
to attack. One should use a random-number generator that is designed for
cryptographic use , ratherthana“general-purpose”random-numbergenerator,
which is not suitable for cryptographicapplications. In particular, the rand()
function in the C stdlib.h library is notcryptographically secure, and using
it in cryptographic settings can have disastrous consequences.
2.1 Deﬁnitions
Webegin by recalling and expanding upon the syntax that was introduced
in the previous chapter. An encryption scheme is deﬁned by three algorithms
Gen,Enc, andDec, as well as a speciﬁcation of a (ﬁnite) message spaceMPerfectly Secret Encryption 27
with|M|>1.1The key-generationalgorithm Genis a probabilistic algorithm
that outputs a key kchosen according to some distribution. We denote by
Kthe (ﬁnite) key space , i.e., the set of all possible keys that can be output
byGen. The encryption algorithm Enctakes as input a key k∈Kand a
message m∈M, and outputs a ciphertext c. We now allow the encryption
algorithm to be probabilistic (so Enck(m) might output a diﬀerent ciphertext
when run multiple times), and we write c←Enck(m) to denote the possibly
probabilistic process by which message mis encrypted using key kto give
ciphertext c. (In case Encis deterministic, we may emphasize this by writing
c:=Enck(m). Looking ahead, we also sometimes use the notation x←S
to denote uniform selection of xfrom a set S.) We letCdenote the set
of all possible ciphertexts that can be output by Enck(m), for all possible
choices of k∈Kandm∈M(and for all random choices of Encin case it
is randomized). The decryption algorithm Dectakes as input a key k∈K
and a ciphertext c∈Cand outputs a message m∈M. We assume perfect
correctness , meaning that for all k∈K,m∈M, and any ciphertext coutput
byEnck(m), it holds that Deck(c) =mwith probability 1. Perfect correctness
implies that we may assume Decis deterministic without loss of generality,
sinceDeck(c) must give the same output every time it is run. We will thus
writem:=Deck(c) to denote the process of decrypting ciphertext cusing
keykto yield the message m.
In the deﬁnitions and theorems below, we refer to probability distributions
overK,M, andC. The distribution over Kis the one deﬁned by running Gen
and taking the output. (It is almost always the case that Genchooses a key
uniformly fromKand, in fact, we may assume this without loss of generality;
see Exercise2.1.) We let Kbe a randomvariabledenoting the value ofthe key
output by Gen; thus, for any k∈K, Pr[K=k] denotes the probability that
the key output by Genis equal to k. Similarly, we let Mbe a random variable
denoting the message being encrypted, so Pr[ M=m] denotes the probability
that the message takes on the value m∈M. The probability distribution of
the message is not determined by the encryption scheme itself, but instead
reﬂects the likelihood of diﬀerent messages being sent by the parties using the
scheme, as well as an adversary’s uncertainty about what will be sent. As
an example, an adversary may know that the message will either be attack
todayordon’t attack . The adversary may even know (by other means)
that with probability 0.7 the message will be a command to attack and with
probability 0.3 the message will be a command not to attack. In this case, we
have Pr[M=attack today ] = 0.7 and Pr[ M=don’t attack ] = 0.3.
KandMare assumed to be independent, i.e., what is being communicated
by the parties is independent of the key they happen to share. This makes
sense, among other reasons, because the distribution over Kis determined by
1If|M|= 1 there is only one message and no point in communicating, let alone encrypting.28 Introduction to Modern Cryptography
the encryption scheme itself (since it is deﬁned by Gen), while the distribution
overMdepends on the context in which the encryption scheme is being used.
Fixing an encryption scheme and a distribution over Mdetermines a dis-
tribution over the space of ciphertexts Cgiven by choosing a key k∈K(ac-
cording to Gen) and a message m∈M(according to the given distribution),
and then computing the ciphertext c←Enck(m). We let Cbe the random
variable denoting the resulting ciphertext and so, for c∈C, write Pr[ C=c]
to denote the probability that the ciphertext is equal to the ﬁxed value c.
Example 2.1
We work through a simple example for the shift cipher (cf. Section 1.3). Here,
by deﬁnition, we have K={0,...,25}with Pr[K=k] = 1/26 for each k∈K.
Say we are given the following distribution over M:
Pr[M=a] = 0.7 and Pr[ M=z] = 0.3.
What is the probability that the ciphertext is B? There are only two ways this
can occur: either M=aandK= 1, orM=zandK= 2. By independence
ofMandK, we have
Pr[M=a∧K= 1] = Pr[ M=a]·Pr[K= 1]
= 0.7·/parenleftbigg1
26/parenrightbigg
.
Similarly, Pr[ M=z∧K= 2] = 0.3·/parenleftbig1
26/parenrightbig
.Therefore,
Pr[C=B] = Pr[M=a∧K= 1]+Pr[ M=z∧K= 2]
= 0.7·/parenleftbigg1
26/parenrightbigg
+0.3·/parenleftbigg1
26/parenrightbigg
=1/26.
We can calculate conditional probabilities as well. For example, what is
the probability that the message awas encrypted, given that we observe
ciphertext B? Using Bayes’ Theorem (Theorem A.8) we have
Pr[M=a|C=B] =Pr[C=B|M=a]·Pr[M=a]
Pr[C=B]
=0.7·Pr[C=B|M=a]
1/26.
Note that Pr[ C=B|M=a] = 1/26, since if M=athen the only way C=B
can occur is if K= 1 (which occurs with probability 1/26). We conclude that
Pr[M=a|C=B] = 0.7. ♦
Example 2.2
Consider the shift cipher again, but with the following distribution over M:
Pr[M=kim] = 0.5,Pr[M=ann] = 0.2,Pr[M=boo] = 0.3.Perfectly Secret Encryption 29
What is the probability that C=DQQ? The only way this ciphertext can
occur is if M=annandK= 3, orM=booandK= 2, which happens with
probability 0 .2·1/26+0.3·1/26 = 1/52.
So what is the probability that annwas encrypted, conditioned on observ-
ing the ciphertext DQQ? A calculation as above using Bayes’ Theorem gives
Pr[M=ann|C=DQQ] = 0.4. ♦
Perfect secrecy. We are now ready to deﬁne the notion of perfect secrecy .
We imagine an adversary who knows the probability distribution over M;
that is, the adversary knows the likelihood that diﬀerent messages will be
sent. This adversary also knows the encryption scheme being used; the only
thing unknown to the adversary is the key shared by the parties. A message
is chosen by one of the honest parties and encrypted, and the resulting ci-
phertext transmitted to the other party. The adversary can eavesdrop on the
parties’ communication, and thus observe this ciphertext. (That is, this is a
ciphertext-only attack, where the attacker gets only a single ciphertext.) For
a scheme to be perfectly secret, observingthis ciphertext should have no eﬀect
on the adversary’s knowledge regarding the actual message that was sent; in
other words, the a posteriori probability that some message m∈Mwas sent,
conditioned on the ciphertext that was observed, should be no diﬀerent from
thea priori probability that mwould be sent. This means that the cipher-
text reveals nothing about the underlying plaintext, and the adversary learns
absolutely nothing about the plaintext that was encrypted. Formally:
DEFINITION 2.3 An encryption scheme (Gen,Enc,Dec)with message
spaceMisperfectly secret if for every probability distribution over M, every
message m∈M, and every ciphertext c∈Cfor which Pr[C=c]>0:
Pr[M=m|C=c] = Pr[M=m].
(The requirement that Pr[ C=c]>0 is a technical one needed to prevent
conditioning on a zero-probability event.)
We now give an equivalent formulation of perfect secrecy. Informally, this
formulation requires that the probability distribution of the ciphertext does
not depend on the plaintext, i.e., for any two messages m,m/prime∈Mthe distri-
bution of the ciphertext when mis encrypted should be identical to the distri-
butionoftheciphertextwhen m/primeisencrypted. Formally,forevery m,m/prime∈M,
and every c∈C,
Pr[EncK(m) =c] = Pr[EncK(m/prime) =c] (2.1)
(where the probabilities are over choice of Kand any randomness of Enc).
This implies that the ciphertext contains no information about the plaintext,
and that it is impossible to distinguish an encryption of mfrom an encryption
ofm/prime, since the distributions over the ciphertext are the same in each case.30 Introduction to Modern Cryptography
LEMMA 2.4 An encryption scheme (Gen,Enc,Dec)with message space
Mis perfectly secret if and only if Equation (2.1) holds for every m,m/prime∈M
and every c∈C.
PROOF We show that if the stated condition holds, then the scheme
is perfectly secret; the converse implication is left to Exercise 2.4. Fix a
distribution overM, amessage m, and aciphertext cforwhichPr[ C=c]>0.
If Pr[M=m] = 0 then we trivially have
Pr[M=m|C=c] = 0 = Pr[ M=m].
So, assume Pr[ M=m]>0. Notice ﬁrst that
Pr[C=c|M=m] = Pr[EncK(M) =c|M=m] = Pr[EncK(m) =c],
where the ﬁrst equality is by deﬁnition of the random variable C, and the
second is because we condition on the event that Mis equal to m. Setδcdef=
Pr[EncK(m) =c] = Pr[C=c|M=m]. If the condition of the lemma holds,
thenforeverym/prime∈MwehavePr[ EncK(m/prime) =c] = Pr[C=c|M=m/prime] =δc.
Using Bayes’ Theorem (see Appendix A.3), we thus have
Pr[M=m|C=c] =Pr[C=c|M=m]·Pr[M=m]
Pr[C=c]
=Pr[C=c|M=m]·Pr[M=m]/summationtext
m/prime∈MPr[C=c|M=m/prime]·Pr[M=m/prime]
=δc·Pr[M=m]/summationtext
m/prime∈Mδc·Pr[M=m/prime]
=Pr[M=m]/summationtext
m/prime∈MPr[M=m/prime]= Pr[M=m],
where the summation is over m/prime∈Mwith Pr[M=m/prime]/negationslash= 0. We conclude
that for every m∈Mandc∈Cfor which Pr[ C=c]>0, it holds that
Pr[M=m|C=c] = Pr[M=m], and so the scheme is perfectly secret.
Perfect (adversarial) indistinguishability. Weconclude this section by
presenting another equivalent deﬁnition of perfect secrecy. This deﬁnition is
based on an experiment involving an adversary passively observing a cipher-
text and then trying to guess which of two possible messages was encrypted.
We introduce this notion since it will serve as our starting point for deﬁning
computational security in the next chapter. Indeed, throughout the rest of
the book we will often use experiments of this sort to deﬁne security.
In the present context, we consider the following experiment: an adver-
saryAﬁrst speciﬁes two arbitrary messages m0,m1∈M. One of these twoPerfectly Secret Encryption 31
messages is chosen uniformly at random and encrypted using a random key;
the resulting ciphertext is given to A. Finally,Aoutputs a “guess” as to
which of the two messages was encrypted; Asucceeds if it guesses correctly.
An encryption scheme is perfectly indistinguishable ifnoadversaryAcan suc-
ceed with probability better than 1 /2. (Note that, for any encryption scheme,
Acan succeed with probability 1 /2 by outputting a uniform guess; the re-
quirement is simply that no attacker can do any better than this.) We stress
that no limitations are placed on the computational power of A.
Formally, let Π = ( Gen,Enc,Dec) be an encryption scheme with message
spaceM. LetAbe an adversary,which is formallyjust a (stateful) algorithm.
We deﬁne an experiment PrivKeav
A,Πas follows:
The adversarial indistinguishability experiment PrivKeav
A,Π:
1. The adversary Aoutputs a pair of messages m0,m1∈M.
2. A key kis generated using Gen, and a uniform bit b∈{0,1}
is chosen. Ciphertext c←Enck(mb)is computed and given
toA. We refer to cas thechallenge ciphertext .
3.Aoutputs a bit b/prime.
4. The output of the experiment is deﬁned to be 1ifb/prime=b,
and0otherwise. We write PrivKeav
A,Π= 1if the output of the
experiment is 1and in this case we say that Asucceeds.
As noted earlier, it is trivial for Ato succeed with probability 1 /2 by out-
putting a random guess. Perfect indistinguishability requires that it is impos-
sible for anyAto do better.
DEFINITION 2.5 Encryption scheme Π = (Gen,Enc,Dec)with message
spaceMisperfectly indistinguishable if for everyAit holds that
Pr/bracketleftbig
PrivKeav
A,Π= 1/bracketrightbig
=1
2.
The following lemma states that Deﬁnition 2.5 is equivalent to Deﬁni-
tion 2.3. We leave the proof of the lemma as Exercise 2.5.
LEMMA 2.6 Encryption scheme Πis perfectly secret if and only if it is
perfectly indistinguishable.
Example 2.7
We show that the Vigen` ere cipher is notperfectly indistinguishable, at least
for certain parameters. Concretely, let Π denote the Vigen` ere cipher for the
message space of two-character strings, and where the period is chosen uni-
formly in{1,2}. To show that Π is not perfectly indistinguishable, we exhibit
an adversaryAfor which Pr/bracketleftbig
PrivKeav
A,Π= 1/bracketrightbig
>1
2.32 Introduction to Modern Cryptography
AdversaryAdoes:
1. Output m0=aaandm1=ab.
2. Upon receiving the challenge ciphertext c=c1c2, do the following: if
c1=c2output 0; else output 1.
Computation of Pr/bracketleftbig
PrivKeav
A,Π= 1/bracketrightbig
is tedious but straightforward.
Pr/bracketleftbig
PrivKeav
A,Π= 1/bracketrightbig
=1
2·Pr/bracketleftbig
PrivKeav
A,Π= 1|b= 0/bracketrightbig
+1
2·Pr/bracketleftbig
PrivKeav
A,Π= 1|b= 1/bracketrightbig
=1
2·Pr[Aoutputs 0|b= 0]+1
2·Pr[Aoutputs 1|b= 1],(2.2)
wherebis the uniform bit determining which message gets encrypted. A
outputs 0 if and only if the two characters of the ciphertext c=c1c2are
equal. When b= 0 (som0=aais encrypted) then c1=c2if either (1) a key
of period 1 is chosen, or (2) a key of period 2 is chosen, and both characters
of the key are equal. The former occurs with probability1
2,and the latter
occurs with probability1
2·1
26.So
Pr[Aoutputs 0|b= 0] =1
2+1
2·1
26≈0.52.
Whenb= 1 then c1=c2only if a key of period 2 is chosen and the ﬁrst
character of the key is one more than the second character of the key, which
happens with probability1
2·1
26.So
Pr[Aoutputs 1|b= 1] = 1−Pr[Aoutputs 0|b= 1] = 1−1
2·1
26≈0.98.
Plugging into Equation (2.2) then gives
Pr/bracketleftbig
PrivKeav
A,Π= 1/bracketrightbig
=1
2·/parenleftbigg1
2+1
2·1
26+1−1
2·1
26/parenrightbigg
=0.75>1
2,
and the scheme is not perfectly indistinguishable. ♦
2.2 The One-Time Pad
In1917, Vernam patented a perfectly secret encryption scheme now called
theone-time pad . At the time Vernam proposed the scheme, there was no
proof that it was perfectly secret; in fact, there was not yet a notion of what
perfect secrecy was. Approximately 25 years later, however, Shannon intro-
duced the deﬁnition of perfect secrecy and demonstrated that the one-time
pad achieves that level of security.Perfectly Secret Encryption 33
CONSTRUCTION 2.8
Fix an integer /lscript >0. The message space M, key spaceK, and ciphertext
spaceCare all equal to{0,1}/lscript(the set of all binary strings of length /lscript).
•Gen: the key-generation algorithm chooses a key from K={0,1}/lscript
according to the uniform distribution (i.e., each of the 2/lscriptstrings
in the space is chosen as the key with probability exactly 2−/lscript).
•Enc: given a key k∈ {0,1}/lscriptand a message m∈ {0,1}/lscript, the
encryption algorithm outputs the ciphertext c:=k⊕m.
•Dec: given a key k∈{0,1}/lscriptand a ciphertext c∈{0,1}/lscript, the
decryption algorithm outputs the message m:=k⊕c.
The one-time pad encryption scheme.
Indescribing the scheme we let a⊕bdenote the bitwise exclusive-or (XOR)
of two binary strings aandb(i.e., ifa=a1···a/lscriptandb=b1···b/lscriptare/lscript-bit
strings, then a⊕bis the/lscript-bit string given by a1⊕b1···a/lscript⊕b/lscript). In the one-
time pad encryption scheme the key is a uniform string of the same length as
the message; the ciphertext is computed by simply XORing the key and the
message. A formal deﬁnition is given as Construction 2.8. Before discussing
security, we ﬁrst verify correctness: for every key kand every message m
it holds that Deck(Enck(m)) =k⊕k⊕m=m, and so the one-time pad
constitutes a valid encryption scheme.
One can easily prove perfect secrecy of the one-time pad using Lemma 2.4
and the fact that the ciphertext is uniformly distributed regardless of what
messageisencrypted. Wegiveaproofbaseddirectlyontheoriginaldeﬁnition.
THEOREM 2.9 The one-time pad encryption scheme is perfectly secret.
PROOF We ﬁrst compute Pr[ C=c|M=m/prime] for arbitrary c∈Cand
m/prime∈M. For the one-time pad,
Pr[C=c|M=m/prime] = Pr[EncK(m/prime) =c] = Pr[m/prime⊕K=c]
= Pr[K=m/prime⊕c]
= 2−/lscript,
where the ﬁnal equality holds because the key Kis a uniform /lscript-bit string. Fix
any distribution over M. For any c∈C, we have
Pr[C=c] =/summationdisplay
m/prime∈MPr[C=c|M=m/prime]·Pr[M=m/prime]
= 2−/lscript·/summationdisplay
m/prime∈MPr[M=m/prime]
= 2−/lscript,34 Introduction to Modern Cryptography
where the sum is over m/prime∈Mwith Pr[M=m/prime]/negationslash= 0. Bayes’ Theorem gives:
Pr[M=m|C=c] =Pr[C=c|M=m]·Pr[M=m]
Pr[C=c]
=2−/lscript·Pr[M=m]
2−/lscript
=Pr[M=m].
We conclude that the one-time pad is perfectly secret.
The one-time pad was used by several national-intelligence agencies in the
mid-20thcentury toencrypt sensitivetraﬃc. Perhapsmostfamously, the “red
phone” linking the White House and the Kremlin during the Cold War was
protected using one-time pad encryption, where the governments of the US
and USSR wouldexchangeextremelylongkeysusingtrusted courierscarrying
briefcases of paper on which random characters were written.
Notwithstanding the above, one-time pad encryption is rarely used any
more due to a number of drawbacks it has. Most prominent is that the key is
as long as the message .2This limits the usefulness of the scheme for sending
very long messages (as it may be diﬃcult to securely share and store a very
long key), and is problematic when the parties cannot predict in advance (an
upper bound on) how long the message will be.
Moreover, the one-time pad—as the name indicates— is only secure if used
once(with the same key). Although we did not yet deﬁne a notion of secrecy
when multiple messages are encrypted, it is easy to see that encrypting more
than one message with the same key leaks a lot of information. In particular,
say two messages m,m/primeare encrypted using the same key k. An adversary
who obtains c=m⊕kandc/prime=m/prime⊕kcan compute
c⊕c/prime= (m⊕k)⊕(m/prime⊕k) =m⊕m/prime
and thus learn the exclusive-or of the two messages or, equivalently, exactly
where the two messages diﬀer. While this may not seem very signiﬁcant, it is
enough to rule out any claims of perfect secrecy for encrypting two messages
using the same key. Moreover, if the messagescorrespond to natural-language
text, then given the exclusive-or of two suﬃciently long messages it is possible
to perform frequency analysis (as in the previous chapter, though more com-
plex) and recover the messages themselves. An interesting historical example
of this is given by the VENONA project , as part of which the US and UK
were able to decrypt ciphertexts sent by the Soviet Union that were mistak-
enly encrypted with repeated portions of a one-time pad over several decades.
2This does not make the one-time pad useless, since it may be easier for two parties to
share a key at some point in time before the message to be communicated is known.Perfectly Secret Encryption 35
2.3 Limitations of Perfect Secrecy
Weended the previous section by noting some drawbacks of the one-time
pad encryption scheme. Here, we show that these drawbacks are not speciﬁc
to that scheme, but are instead inherent limitations of perfect secrecy. Specif-
ically, we prove that anyperfectly secret encryption scheme must have a key
space that is at least as large as the message space. If all keys are the same
length, and the message space consists of all strings of some ﬁxed length, this
implies that the key is at least as long as the message. In particular, the key
length of the one-time pad is optimal. (The other limitation—namely, that
the key can be used only once—is also inherent if perfect secrecy is required;
see Exercise 2.13.)
THEOREM2.10 If(Gen,Enc,Dec)is a perfectly secret encryption scheme
with message space Mand key spaceK, then|K|≥|M| .
PROOF We show that if|K|<|M|then the scheme cannot be perfectly
secret. Assume|K|<|M|. Consider the uniform distribution over Mand let
c∈Cbe a ciphertext that occurs with non-zero probability. Let M(c) be the
set of all possible messages that are possible decryptions of c; that is
M(c)def={m|m=Deck(c) for some k∈K}.
Clearly|M(c)|≤|K|. (Recall that we may assume Decis deterministic.) If
|K|<|M|, there is some m/prime∈Msuch that m/prime/negationslash∈M(c). But then
Pr[M=m/prime|C=c] = 0/negationslash= Pr[M=m/prime],
and so the scheme is not perfectly secret.
Perfect secrecy with shorter keys? The abovetheorem showsan inherent
limitation of schemes that achieve perfect secrecy. Even so, individuals oc-
casionally claim they have developed a radically new encryption scheme that
is “unbreakable” and achieves the security of the one-time pad without using
keys as long as what is being encrypted. The above proof demonstrates that
such claims cannotbe true; anyone making such claims either knows very
little about cryptography or is blatantly lying.36 Introduction to Modern Cryptography
2.4 *Shannon’s Theorem
Inhis work on perfect secrecy, Shannon also provided a characterization of
perfectly secret encryption schemes. This characterization says that, under
certain conditions, the key-generation algorithm Genmust choose the key
uniformly from the set of all possible keys (as in the one-time pad); moreover,
for every message mand ciphertext cthere is a uniquekey mapping mtoc
(again, as in the one-time pad). Beyond being interesting in its own right,
this theorem is a useful tool for proving (or disproving) perfect secrecy of
suggested schemes. We discuss this further after the proof.
The theorem as stated here assumes |M|=|K|=|C|, meaning that the sets
of plaintexts, keys, and ciphertexts all have the same size. We have already
seen that for perfect secrecy we must have |K|≥|M| . It is easy to see that
correct decryption requires |C|≥|M| . Therefore, in some sense, encryption
schemes with|M|=|K|=|C|are “optimal.”
THEOREM 2.11 (Shannon’s theorem) Let(Gen,Enc,Dec)be an en-
cryption scheme with message space M, for which|M|=|K|=|C|. The
scheme is perfectly secret if and only if:
1. Every key k∈Kis chosen with(equal) probability 1/|K|by algorithm Gen.
2. For every m∈Mand every c∈C, there exists a unique key k∈Ksuch
thatEnck(m)outputsc.
PROOF The intuition behind the proof is as follows. To see that the
stated conditions imply perfect secrecy, note that condition 2 means that
any ciphertext ccould be the result of encrypting any possible plaintext m,
because there is some key kmapping mtoc. Since there is a uniquesuch key,
and each key is chosen with equal probability, perfect secrecy follows as for
the one-time pad. For the other direction, perfect secrecyimmediately implies
that for every mandcthere is at least one key mapping mtoc. The fact that
|M|=|K|=|C|means, moreover, that for every mandcthere is exactly one
such key. Given this, each key must be chosen with equal probability or else
perfect secrecy would fail to hold. A formal proof follows.
We assume for simplicity that Encis deterministic. (One can show that
this is without loss of generality here.) We ﬁrst prove that if the encryption
scheme satisﬁes conditions 1 and 2, then it is perfectly secret. The proof is
essentially the same as the proof of perfect secrecy for the one-time pad, so
we will be relatively brief. Fix arbitrary c∈Candm∈M. Letkbe the
unique key, guaranteed by condition 2, for which Enck(m) =c. Then,
Pr[C=c|M=m] = Pr[K=k] = 1/|K|,Perfectly Secret Encryption 37
where the ﬁnal equality holds by condition 1. So
Pr[C=c] =/summationdisplay
m∈MPr[EncK(m) =c]·Pr[M=m] = 1/|K|.
This holds for any distribution over M. Thus, for any distribution over M,
anym∈Mwith Pr[M=m]/negationslash= 0, and any c∈C, we have:
Pr[M=m|C=c] =Pr[C=c|M=m]·Pr[M=m]
Pr[C=c]
=Pr[EncK(m) =c]·Pr[M=m]
Pr[C=c]
=|K|−1·Pr[M=m]
|K|−1=Pr[M=m],
and the scheme is perfectly secret.
For the second direction, assume the encryption scheme is perfectly secret;
we show that conditions 1 and 2 hold. Fix arbitrary c∈C. There must
be some message m∗for which Pr[ EncK(m∗) =c]/negationslash= 0. Lemma 2.4 then
implies that Pr[ EncK(m) =c]/negationslash= 0 for every m∈M. In other words, if we
letM={m1,m2,...}, then for each mi∈Mwe have a nonempty set of
keysKi⊂Ksuch that Enck(mi) =cif and only if k∈Ki. Moreover, when
i/negationslash=jthenKiandKjmust be disjoint or else correctness fails to hold. Since
|K|=|M|, we see that each Kicontains only a single key ki, as required by
condition 2. Now, Lemma 2.4 shows that for any mi,mj∈Mwe have
Pr[K=ki] = Pr[EncK(mi) =c] = Pr[EncK(mj) =c] = Pr[K=kj].
Since this holds for all 1 ≤i,j≤|M|=|K|, andki/negationslash=kjfori/negationslash=j, this means
each key is chosen with probability 1 /|K|, as required by condition 1.
Shannon’stheoremisuseful fordecidingwhether agivenschemeis perfectly
secret. Condition 1 is easy to check, and condition 2 can be demonstrated
(or contradicted) without having to compute any probabilities (in contrast to
working with Deﬁnition 2.3 directly). As an example, perfect secrecy of the
one-time pad is trivial to prove using Shannon’s theorem. We stress, however,
that the theorem only applies when |M|=|K|=|C|.
References and Additional Reading
The one-time pad is popularly credited to Vernam [172], who ﬁled a patent
on it, but recent historical research [25] shows that it was invented some38 Introduction to Modern Cryptography
35 years earlier. Analysis of the one-time pad had to await the ground-
breaking work of Shannon [154], who introduced the notion of perfect secrecy.
In this chapter we studied perfectly secret encryption . Some other cryp-
tographic problems can also be solved with “perfect” security. A notable
example is the problem of message authentication where the aim is to prevent
an adversaryfrom (undetectably) modifying a message sent from one party to
another. We study this problem in depth in Chapter 4, discussing “perfectly
secure” message authentication in Section 4.6.
Exercises
2.1Prove that, by redeﬁning the key space, we may assume that the key-
generation algorithm Genchooses a key uniformly at random from the
key space, without changing Pr[ C=c|M=m] for any m,c.
Hint:Deﬁne the key space to be the set of all possible random tapes for
the randomized algorithm Gen.
2.2 Prove that, by redeﬁning the key space, we may assume that Encis
deterministic without changing Pr[ C=c|M=m] for any m,c.
2.3 Prove or refute: An encryption scheme with message space Mis per-
fectly secret if and only if for every probability distribution over Mand
everyc0,c1∈Cwe have Pr[ C=c0] = Pr[C=c1].
2.4 Prove the second direction of Lemma 2.4.
2.5 Prove Lemma 2.6.
2.6 For each of the following encryption schemes, state whether the scheme
is perfectly secret. Justify your answer in each case.
(a) The message space is M={0,...,4}. Algorithm Genchooses
a uniform key from the key space {0,...,5}.Enck(m) returns
[k+mmod 5], and Deck(c) returns [ c−kmod 5].
(b) The message space is M={m∈{0,1}/lscript|the last bit of mis 0}.
Genchooses a uniform key from {0,1}/lscript−1.Enck(m) returns cipher-
textm⊕(k/bardbl0), andDeck(c) returns c⊕(k/bardbl0).
2.7 When using the one-time pad with the key k= 0/lscript, we have Enck(m) =
k⊕m=mand the message is sent in the clear! It has therefore been
suggested to modify the one-time pad by only encrypting with k/negationslash= 0/lscript
(i.e., to have Genchoosekuniformly from the set of nonzero keys of
length/lscript). Is this modiﬁed scheme still perfectly secret? Explain.Perfectly Secret Encryption 39
2.8 Let Π denote the Vigen` erecipher where the messagespace consists ofall
3-characterstrings (overthe English alphabet), and the key is generated
by ﬁrst choosing the period tuniformly from{1,2,3}and then letting
the key be a uniform string of length t.
(a) DeﬁneAas follows:Aoutputsm0=aabandm1=abb. When
given a ciphertext c, it outputs 0 if the ﬁrst character of cis the
same as the second character of c, and outputs 1 otherwise. Com-
pute Pr[PrivKeav
A,Π= 1].
(b) Construct andanalyzeanadversary A/primeforwhich Pr[ PrivKeav
A/prime,Π= 1]
is greater than your answer from part (a).
2.9 In this exercise, we look at diﬀerent conditions under which the shift,
mono-alphabetic substitution, and Vigen` ere ciphers are perfectly secret:
(a) Prove that if only a single character is encrypted, then the shift
cipher is perfectly secret.
(b) Whatisthelargestmessagespace Mforwhichthemono-alphabetic
substitution cipher provides perfect secrecy?
(c) Prove that the Vigen` ere cipher using (ﬁxed) period tis perfectly
secret when used to encrypt messages of length t.
Reconcile this with the attacks shown in the previous chapter.
2.10 Prove that a scheme satisfying Deﬁnition 2.5 must have |K| ≥ |M|
without using Lemma 2.4. Speciﬁcally, let Π be an arbitrary encryption
scheme with|K|<|M|. Show anAfor which Pr/bracketleftbig
PrivKeav
A,Π= 1/bracketrightbig
>1
2.
Hint:It may be easier to let Abe randomized.
2.11 Assume we require only that an encryption scheme ( Gen,Enc,Dec) with
message spaceMsatisfy the following: For all m∈ M, we have
Pr[DecK(EncK(m)) =m]≥2−t. (This probability is taken over choice
of the key as well as any randomness used during encryption.) Show
that perfect secrecy can be achieved with |K|<|M|whent≥1. Prove
a lower bound on the size of Kin terms of t.
2.12 Let ε≥0 be a constant. Say an encryption scheme is ε-perfectly secret
if for every adversary Ait holds that
Pr/bracketleftbig
PrivKeav
A,Π= 1/bracketrightbig
≤1
2+ε.
(ComparetoDeﬁnition2.5.) Showthat ε-perfectsecrecycanbeachieved
with|K|<|M|whenε >0. Prove a lower bound on the size of Kin
terms of ε.40 Introduction to Modern Cryptography
2.13 In this problem we consider deﬁnitions of perfect secrecy for the en-
cryption of twomessages (using the same key). Here we consider dis-
tributions over pairsof messages from the message space M; we let
M1,M2be random variables denoting the ﬁrst and second message, re-
spectively. (We stress that these random variables are not assumed to
be independent.) We generate a (single) key k, sample a pair of mes-
sages (m1,m2) according to the given distribution, and then compute
ciphertexts c1←Enck(m1) andc2←Enck(m2); this induces a distri-
bution over pairs of ciphertexts and we let C1,C2be the corresponding
random variables.
(a) Say encryption scheme ( Gen,Enc,Dec) isperfectly secret for two
messages if for all distributions over M×M, allm1,m2∈M,
and all ciphertexts c1,c2∈Cwith Pr[C1=c1∧C2=c2]>0:
Pr[M1=m1∧M2=m2|C1=c1∧C2=c2]
= Pr[M1=m1∧M2=m2].
Prove that noencryption scheme can satisfy this deﬁnition.
Hint:Takec1=c2.
(b) Say encryption scheme ( Gen,Enc,Dec) isperfectly secret for two
distinct messages if for all distributions over M×M where the
ﬁrst and second messages are guaranteed to be diﬀerent (i.e., dis-
tributions over pairs of distinctmessages), all m1,m2∈M, and
allc1,c2∈Cwith Pr[C1=c1∧C2=c2]>0:
Pr[M1=m1∧M2=m2|C1=c1∧C2=c2]
= Pr[M1=m1∧M2=m2].
Show an encryption scheme that provably satisﬁes this deﬁnition.
Hint:The encryption scheme you propose need not be eﬃcient,
although an eﬃcient solution is possible.Part II
Pr
ivate-Key (Symmetric)
Cry
ptographyChapter 3
Private-Key Encryption
Inthe previous chapter we saw some fundamental limitations of perfect se-
crecy. In this chapter we begin our study of modern cryptography by intro-
ducing the weaker (but suﬃcient) notion of computational secrecy. We will
then show how this deﬁnition can be used to bypass the impossibility results
shown previously and, in particular, how a short key (say, 128 bits long) can
be used to encrypt many long messages (say, gigabytes in total).
Along the way we will study the fundamental notion of pseudorandomness ,
which captures the idea that something can “look” completely random even
though it is not. This powerful concept underlies much of modern cryptogra-
phy, and has applications and implications beyond the ﬁeld as well.
3.1 Computational Security
InChapter 2 we introduced the notion of perfect secrecy. While perfect
secrecy is a worthwhile goal, it is also unnecessarily strong. Perfect secrecy
requires that absolutely no information about an encrypted message is leaked,
even to an eavesdropper with unlimited computational power . For all practical
purposes, however, an encryption scheme would still be considered secure if
it leaked only a tinyamount of information to eavesdroppers with bounded
computational power . For example, a scheme that leaks information with
probability at most 2−60to eavesdroppers investing up to 200 years of com-
putational eﬀort on the fastest available supercomputer is adequate for any
real-world application. Security deﬁnitions that take into account computa-
tional limits on the attacker, and allow for a small probability of failure, are
calledcomputational , to distinguish them from notions (like perfect secrecy)
that are information-theoretic in nature. Computational security is now the
de facto way in which security is deﬁned for all cryptographic purposes.
We stress that although we give up on obtaining perfect security, this does
not mean we do away with the rigorous mathematical approach. Deﬁnitions
and proofs are still essential, and the only diﬀerence is that we now consider
weaker (but still meaningful) deﬁnitions of security.
Computationalsecurityincorporatestworelaxationsrelativetoinformation-
4344 Introduction to Modern Cryptography
theoretic notions of security (in the case of encryption, both these relaxations
arenecessaryin orderto gobeyond the limitations ofperfect secrecydiscussed
in the previous chapter):
1.Security is only guaranteed against eﬃcientadversaries that runfor some
feasible amount of time . This means that given enough time (or suﬃ-
cient computational resources) an attacker may be able to violate secu-
rity. If we can make the resources required to break the scheme larger
than those available to any realistic attacker, then for all practical pur-
poses the scheme is unbreakable.
2.Adversaries can potentially succeed (i.e., security can potentially fail)
with some very small probability .If we can make this probability suﬃ-
ciently small, we need not worry about it.
To obtain a meaningful theory, we need to precisely deﬁne the above relax-
ations. There are two general approaches for doing so: the concrete approach
and theasymptotic approach . These are described next.
3.1.1 The Concrete Approach
Theconcreteapproachtocomputationalsecurityquantiﬁesthe securityofa
cryptographic scheme by explicitly bounding the maximum success probabil-
ity of any (randomized) adversary running for some speciﬁed amount of time
or, more precisely, investing some speciﬁc amount of computational eﬀort.
Thus, a concrete deﬁnition of security takes roughly the following form:
A scheme is (t,ε)-secureif any adversary running for time at
mosttsucceeds in breaking the scheme with probability at most ε.
(Of course, the above serves only as a general template, and for the above
statement to make sense we need to deﬁne exactly what it means to “break”
the scheme in question.) As an example, one might have a scheme with the
guarantee that no adversary running for at most 200 years using the fastest
available supercomputer can succeed in breaking the scheme with probability
better than 2−60. Or, it may be more convenient to measure running time in
terms of CPU cycles, and to construct a scheme such that no adversary using
at most 280cycles can break the scheme with probability better than 2−60.
It is instructive to get a feel for the large values of tand the small values
ofεthat are typical of modern cryptographic schemes.
Example 3.1
Modern private-key encryption schemes are generally assumed to give almost
optimal security in the following sense: when the key has length n—and so
the key space has size 2n—an adversary running for time t(measured in, say,
computer cycles) succeeds in breaking the scheme with probability at mostPrivate-Key Encryption 45
ct/2nfor some ﬁxed constant c. (This simply corresponds to a brute-force
search of the key space, and assumes no preprocessing has been done.)
Assuming c= 1 for simplicity, a key of length n= 60 provides adequate
security against an adversary using a desktop computer. Indeed, on a 4 GHz
processor (that executes 4 ×109cycles per second) 260CPU cycles require
260/(4×109)seconds, orabout9years. However,the fastestsupercomputerat
the time of this writing can execute roughly 2 ×1016ﬂoating point operations
per second, and 260such operations require only about 1 minute on such a
machine. Taking n= 80 would be a more prudent choice; even the computer
just mentioned would take about 2 years to carry out 280operations.
(Theabovenumbersareforillustrativepurposesonly; inpractice c >1, and
several other factors—such as the time required for memory access and the
possibility of parallel computation on a network of computers—signiﬁcantly
aﬀect the performance of brute-force attacks.)
Today, however, a recommended key length might be n= 128. The diﬀer-
ence between 280and 2128is amultiplicative factor of 248. To get a feeling
for how big this is, note that according to physicists’ estimates the number of
seconds since the Big Bang is on the order of 258.
If the probability that an attacker can successfully recover an encrypted
message in one year is at most 2−60, then it is much more likely that the
sender and receiver will both be hit by lightning in that same period of time.
An event that occurs once every hundred years can be roughly estimated to
occur with probability 2−30in any given second. Something that occurs with
probability 2−60in any given second is 230timeslesslikely, and might be
expected to occur roughly once every 100 billion years. ♦
The concrete approach is important in practice, since concrete guarantees
are what users of a cryptographic scheme are ultimately interested in. How-
ever, precise concrete guarantees are diﬃcult to provide. Furthermore, one
must be careful in interpreting concrete security claims. For example, a claim
that no adversary running for 5 years can break a given scheme with proba-
bility better than εbegs the questions: what type of computing power (e.g.,
desktop PC, supercomputer, network of hundreds of computers) does this
assume? Does this take into account future advances in computing power
(which, by Moore’s Law, roughly doubles every 18 months)? Does the es-
timate assume the use of “oﬀ-the-shelf” algorithms, or dedicated software
implementations optimized for the attack? Furthermore, such a guarantee
says little about the success probability of an adversary running for 2 years
(other than the fact that it can be at most ε) and says nothing about the
success probability of an adversary running for 10 years.
3.1.2 The Asymptotic Approach
As partly noted above, there are some technical and theoretical diﬃculties
in using the concrete-security approach. These issues must be dealt with in46 Introduction to Modern Cryptography
practice, but when concrete security is not an immediate concern it is conve-
nient instead to use an asymptotic approach to security; this is the approach
taken in this book. This approach, rooted in complexity theory, introduces
an integer-valued security parameter (denoted by n) that parameterizes both
cryptographic schemes as well as all involved parties (namely, the honest par-
ties as well as the attacker). When honest parties initialize a scheme (i.e.,
when they generate keys), they choose some value nfor the security parame-
ter; forthe purposesofthis discussion, onecan think ofthe securityparameter
as corresponding to the length of the key. The security parameter is assumed
to be known to any adversary attacking the scheme, and we now view the
running time of the adversary, as well as its success probability, as functions
of the security parameter rather than as concrete numbers. Then:
1. We equate “eﬃcient adversaries” with randomized (i.e., probabilistic)
algorithms running in time polynomial in n. This means there is some
polynomial psuch that the adversary runs for time at most p(n) when
the security parameter is n. We also require—for real-world eﬃciency—
that honest parties run in polynomial time, although we stress that the
adversary may be much more powerful (and run much longer than) the
honest parties.
2. We equate the notion of “small probabilities of success” with success
probabilities smaller than any inverse polynomial in n(seeDeﬁnition3.4).
Such probabilities are called negligible .
Letpptstand for “probabilistic polynomial-time.” A deﬁnition of asymptotic
security then takes the following general form:
A scheme is secureif anypptadversary succeeds in breaking the
scheme with at most negligible probability.
This notion of security is asymptotic since security depends on the behavior
of the scheme for suﬃciently large values of n. The following example makes
this clear.
Example 3.2
Say we have a scheme that is asymptotically secure. Then it may be the
case that an adversary running for n3minutes can succeed in “breaking the
scheme” with probability 240·2−n(which is a negligible function of n). When
n≤40 this means that an adversary running for 403minutes (about 6 weeks)
can break the scheme with probability 1, so such values of nare not very
useful. Even for n= 50 an adversary running for 503minutes (about 3
months) can break the scheme with probability roughly 1 /1000, which may
not be acceptable. On the other hand, when n= 500 an adversary running
for 200 years breaks the scheme only with probability roughly 2−500.♦Private-Key Encryption 47
Asindicatedbythepreviousexample,wecanviewthesecurityparameteras
a mechanism that allows the honest parties to “tune” the security of a scheme
to some desired level. (Increasing the security parameter also increases the
time required to run the scheme, as well as the length of the key, so the honest
parties will want to set the security parameter as small as possible subject
to defending against the class of attacks they are concerned about.) Viewing
the security parameter as the key length, this corresponds roughly to the fact
that the time required for an exhaustive-search attack grows exponentially
in the length of the key. The ability to “increase security” by increasing
the security parameter has important practical ramiﬁcations, since it enables
honest parties to defend against increases in computing power. The following
example gives a sense of how this might play out in practice.
Example 3.3
Let us see the eﬀect that the availability of faster computers might have on
security in practice. Say we have a cryptographic scheme in which the honest
parties run for 106·n2cycles, and for which an adversary running for 108·n4
cycles can succeed in “breaking” the scheme with probability at most 2−n/2.
(The numbers are intended to make calculations easier, and are not meant to
correspond to any existing cryptographic scheme.)
Sayallpartiesareusing2GHz computersandthe honestpartiesset n= 80.
Then the honest parties run for 106·6400 cycles, or 3.2 seconds, and an
adversary running for 108·(80)4cycles, or roughly 3 weeks, can break the
scheme with probability only 2−40.
Say 8 GHz computers become available, and all parties upgrade. Honest
parties can increase nto 160 (which requires generating a fresh key) and
maintain a running time of 3 .2 seconds (i.e., 106·1602cycles at 8·109cy-
cles/second). In contrast, the adversary now has to run for over 8 million
seconds, or more than 13 weeks, to achieve a success probability of 2−80. The
eﬀect of a faster computer has been to make the adversary’s job harder.♦
Evenwhenusingtheasymptoticapproachitisimportanttorememberthat,
ultimately, when a cryptosystem is deployed in practice a concrete security
guarantee will be needed. (After all, one must decide on some value of n.)
As the above examples indicate, however, it is generally the case that an
asymptotic security claim can be translated into a concrete security bound
for any desired value of n.
The Asymptotic Approach in Detail
We now discuss more formally the notions of “polynomial-time algorithms”
and “negligible success probabilities.”
Eﬃcient algorithms. We have deﬁned an algorithm to be eﬃcient if it runs
in polynomial time. An algorithm Aruns in polynomial time if there exists a48 Introduction to Modern Cryptography
polynomial psuch that, for every input x∈{0,1}∗, the computation of A(x)
terminates within at most p(|x|) steps. (Here,|x|denotes the length of the
stringx.) As mentioned earlier, we are only interested in adversaries whose
running time is polynomial in the security parameter n. Since we measure the
running time of an algorithm in terms of the length of its input, we sometimes
provide algorithms with the security parameter written in unary (i.e., as 1n,
or a string of nones) as input. Parties(or, more precisely, the algorithms they
run) may take other inputs besides the security parameter—for example, a
message to be encrypted—and we allow their running time to be polynomial
in the (total) length of their inputs.
By default, we allow all algorithms to be probabilistic (or randomized).
Any such algorithm may “toss a coin” at each step of its execution; this is a
metaphorical way of sayingthat the algorithm can access an unbiased random
bit at each step. Equivalently, we can view a randomized algorithm as one
that, in addition to its input, is given a uniformly distributed random tape of
suﬃcient length1whose bits it can use, as needed, throughout its execution.
We consider randomized algorithms by default for two reasons. First, ran-
domness is essential to cryptography (e.g., in order to choose random keys
and so on) and so honest parties must be probabilistic; given this, it is nat-
ural to allow adversaries to be probabilistic as well. Second, randomization
is practical and—as far as we know—gives attackers additional power. Since
our goal is to model allrealistic attacks, we prefer a more liberal deﬁnition of
eﬃcient computation.
Negligible success probability. A negligible function is one that is asymp-
totically smaller than any inverse polynomial function. Formally:
DEFINITION 3.4 A function ffrom the natural numbers to the non-
negative real numbers is negligible if for every positive polynomial pthere is
anNsuch that for all integers n > Nit holds that f(n)<1
p(n).
For shorthand, the above is also stated as follows: for every polynomial p
andall suﬃciently large values of nit holds that f(n)<1
p(n).An equivalent
formulation of the above is to require that for all constants cthere exists an
Nsuch that for all n > Nit holds that f(n)< n−c. We typically denote an
arbitrary negligible function by negl.
Example 3.5
The functions 2−n,2−√n,andn−lognare all negligible. However, they ap-
proach zero at very diﬀerent rates. For example, we can look at the minimum
value ofnfor which each function is smaller than 1 /n5:
1Ifthe algorithm in question runs for p(n) steps on inputs of length n, then a random tape
of length p(n) is suﬃcient since the attacker can read at most one random bit per time step.Private-Key Encryption 49
1. Solving 2−n< n−5we getn >5logn. The smallest integer value of n
for which this holds is n= 23.
2. Solving 2−√n<n−5we getn >25log2n. The smallest integer value of
nfor which this holds is n≈3500.
3. Solving n−logn< n−5we get log n >5. The smallest integer value of n
for which this holds is n= 33.
From the above you may have the impression that n−lognapproaches zero
more quickly than 2−√n.However, this is incorrect; for all n >65536 it holds
that 2−√n<n−logn. Nevertheless, this does show that for values of nin
the hundreds or thousands, an adversarial success probability of n−lognis
preferable to an adversarial success probability of 2−√n. ♦
Atechnical advantage of working with negligible success probabilities is
that they obey certain closure properties. The following is an easy exercise.
PROPOSITION 3.6 Letnegl1andnegl2be negligible functions. Then,
1. The function negl3deﬁned by negl3(n) =negl1(n)+negl2(n)is negligible.
2. For any positive polynomial p, the function negl4deﬁned by negl4(n) =
p(n)·negl1(n)is negligible.
The second part of the above proposition implies that if a certain event oc-
curs with only negligible probability in a certain experiment, then the event
occurs with negligible probability even if the experiment is repeated polyno-
mially many times. (This relies on the union bound; see Proposition A.7.)
For example, the probability that nfair coin ﬂips all come up “heads” is neg-
ligible. This means that even if we repeat the experiment of ﬂipping ncoins
polynomiallymanytimes, the probabilitythat anyofthoseexperimentsresult
innheads is still negligible.
A corollary of the second part of the above proposition is that if a function
gisnotnegligible, then neither is the function f(n)def=g(n)/p(n) for any
positive polynomial p.
Asymptotic Security: A Summary
Any security deﬁnition consists of two parts: a deﬁnition of what is consid-
ereda“break”ofthescheme, andaspeciﬁcationofthe poweroftheadversary.
The power of the adversary can relate to many issues (e.g., in the case of en-
cryption, whether we assume a ciphertext-only attack or a chosen-plaintext
attack). However, when it comes to the computational powerofthe adversary,
we will from now on model the adversary as eﬃcient and thus only consider
adversarial strategies that can be implemented in probabilistic polynomial50 Introduction to Modern Cryptography
time. Deﬁnitions will also always be formulated so that a break that occurs
with negligible probability is not considered signiﬁcant. Thus, the general
framework of any security deﬁnition will be as follows:
A scheme is secureif for every probabilistic polynomial-time adver-
saryAcarrying out an attack of some formally speciﬁed type, the
probability thatAsucceeds in the attack (where success is also
formally speciﬁed) is negligible .
Such a deﬁnition is asymptotic because it is possible that for small values of n
an adversary can succeed with high probability. In order to see this in more
detail, we expand the term “negligible” in the above statement:
A scheme is secureif for every pptadversaryAcarrying out an
attack of some formally speciﬁed type, and for every positive poly-
nomialp, there exists an integer Nsuch that when n > Nthe
probability thatAsucceeds in the attack is less than1
p(n).
Note that nothing is guaranteed for values n≤N.
On the Choices Made in Deﬁning Asymptotic Security
In deﬁning the general notion of asymptotic security, we have made two
choices: we have identiﬁed eﬃcient adversarial strategies with the class of
probabilistic, polynomial-time algorithms , and have equated small chances
of success with negligible probabilities . Both of these choices are—to some
extent—arbitrary, and one could build a perfectly reasonable theory by deﬁn-
ing, say, eﬃcient strategies as those running in quadratic time, or small suc-
cess probabilities as those bounded by 2−n. Nevertheless, we brieﬂy justify
the choices we have made (which are the standard ones).
Those familiar with complexity theory or algorithms will recognize that the
idea of equating eﬃcient computation with (probabilistic) polynomial-time
algorithms is not unique to cryptography. One advantage of using (proba-
bilistic) polynomial time as our measure of eﬃciency is that this frees us from
having to precisely specify our model of computation, since the extended
Church–Turing thesis states that all “reasonable” models of computation are
polynomially equivalent. Thus, we need not specify whether we use Turing
machines, boolean circuits, or random-access machines; we can present algo-
rithms in high-level pseudocode and be conﬁdent that if our analysis shows
that these algorithms run in polynomial time, then any reasonable implemen-
tation will also.
Another advantage of (probabilistic) polynomial-time algorithms is that
they satisfy desirable closure properties: in particular, an algorithm that
makes polynomially many calls to a polynomial-time subroutine (and does
only polynomial computation in addition) will itself run in polynomial time.Private-Key Encryption 51
The most important feature of negligible probabilities is the closure prop-
erty we have already seen in Proposition 3.6(2): any polynomial times a negli-
gible function is still negligible. This means, in particular, that ifan algorithm
makes polynomially many calls to some subroutine that “fails” with negligible
probability each time it is called, then the probability that any of the calls to
that subroutine fail is still negligible.
Necessity of the Relaxations
Computational secrecy introduces two relaxations of perfect secrecy: ﬁrst,
security is guaranteed only against eﬃcient adversaries; second, a small prob-
ability of success is allowed. Both these relaxations are essential for achieving
practical encryption schemes, and in particular for bypassing the negative re-
sults for perfectly secret encryption. We informally discuss why this is the
case. Assume we have an encryption scheme where the size of the key space K
is much smaller than the size ofthe messagespace M. (As shown in the previ-
ous chapter, this means the scheme cannot be perfectly secret.) Two attacks
apply regardless of how the encryption scheme is constructed:
•Given a ciphertext c, an adversary can decrypt cusing all keys k∈K.
This gives a list of all the messages to which ccan possibly correspond.
Since this list cannot contain all of M(because|K|<|M|), this attack
leakssomeinformation about the message that was encrypted.
Moreover, say the adversary carries out a known-plaintext attack and
learnsthatciphertexts c1,...,c /lscriptcorrespondtothemessages m1,...,m /lscript,
respectively. The adversary can again try decrypting each of these ci-
phertextswithallpossiblekeysuntilitﬁndsakey kforwhich Deck(ci) =
mifor alli. Later, given a ciphertext cthat is the encryption of an un-
known message m, it is almost surely the case that Deck(c) =m.
Exhaustive-search attacks like the above allow an adversary to succeed
with probability essentially 1 in time linear in |K|.
•Consider again the case where the adversary learns that ciphertexts
c1,...,c /lscriptcorrespondtomessages m1,...,m /lscript. Theadversarycan guessa
uniformkey k∈Kandchecktoseewhether Deck(ci) =miforalli. Ifso,
then, as above, the attacker can use kto decrypt anything subsequently
encrypted by the honest parties.
Here the adversary runs in essentially constant time and succeeds with
nonzero (though very small) probability 1 /|K|.
It follows that if we wish to encrypt many messages using a single short key,
security can only be achieved if we limit the running time of the adversary(so
the adversary does not have suﬃcient time to carry out a brute-force search)
and are willing to allow a very small probability of success (so the second
“attack” is ruled out).52 Introduction to Modern Cryptography
3.2 Deﬁning Computationally Secure Encryption
Given the background of the previous section, we are ready to present a
deﬁnition of computational security for private-key encryption. First, we re-
deﬁne the syntaxof private-key encryption; this will be essentially the same
as the syntax introduced in Chapter 2 except that we now explicitly take into
account the security parameter n. We also allow the decryption algorithm
to output an error message in case it is presented with an invalid ciphertext.
Finally, by default, we let the message space be the set {0,1}∗of all (ﬁnite-
length) binary strings.
DEFINITION 3.7 Aprivate-key encryption scheme is a tuple of proba-
bilistic polynomial-time algorithms (Gen,Enc,Dec)such that:
1. Thekey-generation algorithm Gen takes as input 1n(i.e., the security
parameter written in unary) and outputs a key k; we write k←Gen(1n)
(emphasizing that Genis a randomized algorithm ). We assume without
loss of generality that any key koutput by Gen(1n)satisﬁes|k|≥n.
2. Theencryption algorithm Enc takes as input a key kand a plaintext
message m∈{0,1}∗, and outputs a ciphertext c. Since Encmay be
randomized, we write this as c←Enck(m).
3. Thedecryption algorithm Dec takes as input a key kand a ciphertext c,
and outputs a message mor an error. We assume that Decis deter-
ministic, and so write m:=Deck(c)(assuming here that Decdoes not
return an error). We denote a generic error by the symbol ⊥.
It is required that for every n, every key koutput by Gen(1n), and every
m∈{0,1}∗, it holds that Deck(Enck(m)) =m.
If(Gen,Enc,Dec)is such that for koutput by Gen(1n), algorithm Enckis
only deﬁned for messages m∈{0,1}/lscript(n), then we say that (Gen,Enc,Dec)is
aﬁxed-length private-key encryption scheme for messages of length /lscript(n).
Almost always, Gen(1n) simply outputs a uniform n-bit string as the key.
When this is the case, we will omit Genand simply deﬁne a private-key en-
cryption scheme by a pairof algorithms ( Enc,Dec).
The above deﬁnition considers stateless schemes, in which each invocation
ofEnc(andDec) is independent of all prior invocations. Later in the chapter,
we will occasionallydiscuss statefulschemes in which the sender (and possibly
the receiver)is requiredto maintain state acrossinvocations. Unless explicitly
noted otherwise, all our results assume stateless encryption/decryption.Private-Key Encryption 53
3.2.1 The Basic Deﬁnition of Security
We begin by presenting the most basic notion of security for private-key
encryption: security against a ciphertext-only attack where the adversary
observes only a singleciphertext or, equivalently, security when a given key
is used to encrypt just a singlemessage. We consider stronger deﬁnitions of
security later in the chapter.
Motivating the deﬁnition. As we have already discussed, any deﬁnition
of security consists of two distinct components: a threat model (i.e., a speci-
ﬁcation of the assumed power of the adversary) and a security goal (usually
speciﬁed by describing what constitutes a “break” of the scheme). We begin
our deﬁnitional treatment by considering the simplest threat model, where
we have an eavesdropping adversary who observes the encryption of a single
message. This is exactly the threat model that was considered in the previous
chapter with the exception that, as explained in the previous section, we are
now interested only in adversaries that are computationally bounded and so
limited to running in polynomial time.
Although we have made two assumptions about the adversary’s capabili-
ties (namely, that it only eavesdrops, and that it runs in polynomial time), we
make no assumptions whatsoever about the adversary’s strategy in trying to
decipher the ciphertext it observes. This is crucial for obtaining meaningful
notions of security; the deﬁnition ensures protection against anycomputa-
tionally bounded adversary, regardless of the algorithm it uses.
Correctly deﬁning the security goal for encryption is not trivial, but we
have already discussed this issue at length in Section 1.4.1 and in the previ-
ous chapter. We therefore just recall that the idea behind the deﬁnition is
that the adversary should be unable to learn any partial information about
the plaintext from the ciphertext. The deﬁnition of semantic security (cf.
Section 3.2.2) exactly formalizes this notion, and was the ﬁrst deﬁnition of
computationally secure encryption to be proposed. Semantic security is com-
plex and diﬃcult to work with. Fortunately, there is an equivalent deﬁnition
calledindistinguishability that is much simpler.
The deﬁnition of indistinguishability is patterned on the alternative deﬁni-
tion of perfect secrecy given as Deﬁnition 2.5. (This serves as further moti-
vation that the deﬁnition of indistinguishability is a good one.) Recall that
Deﬁnition 2.5 considers an experiment PrivKeav
A,Πin which an adversary Aout-
puts two messages m0andm1, and is then given an encryption of one of those
messages using a uniform key. The deﬁnition states that a scheme Π is secure
if no adversaryAcan determine which of the messages m0,m1was encrypted
with probability any diﬀerent from 1 /2, which is the probability that Ais
correct if it just makes a random guess.
Here, we keep the experiment PrivKeav
A,Πalmost exactly the same (except for
some technical diﬀerences discussed below), but introduce two key modiﬁca-
tions in the deﬁnition itself:54 Introduction to Modern Cryptography
1. We now consider only adversaries running in polynomial time , whereas
Deﬁnition2.5consideredevenadversarieswithunboundedrunningtime.
2. We nowconcede that the adversarymight determine the encrypted mes-
sage with probability negligibly better than 1/2.
As discussed extensively in the previous section, the above relaxations consti-
tute the core elements of computational security.
As for the other diﬀerences, the most prominent is that we now parame-
terize the experiment by a security parameter n. We then measure both the
running time of the adversary Aas well as its success probability as functions
ofn. We write PrivKeav
A,Π(n) to denote the experiment being run with security
parameter n, and write
Pr[PrivKeav
A,Π(n) = 1] (3.1)
to denote the probability that the output of experiment PrivKeav
A,Π(n) is 1.
Note that withA,Π ﬁxed, Equation (3.1) is a function of n.
A second diﬀerence in experiment PrivKeav
A,Πis that we now explicitly re-
quire the adversary to output two messages m0,m1of equal length . (In Def-
inition 2.5 this requirement is implicit if the message space Monly contains
messages of some ﬁxed length, as is the case for the one-time pad encryption
scheme.) This means that, by default, we do not require a secure encryption
scheme to hide the length of the plaintext. We revisit this point at the end of
this section; see also Exercises 3.2 and 3.3.
Indistinguishability in the presence of an eavesdropper. We now give
the formal deﬁnition, beginning with the experiment outlined above. The ex-
perimentisdeﬁnedforanyprivate-keyencryptionschemeΠ = ( Gen,Enc,Dec),
any adversaryA, and any value nfor the security parameter:
The adversarial indistinguishabilityexperiment PrivKeav
A,Π(n):
1. The adversary Ais given input 1n, and outputs a pair of
messages m0,m1with|m0|=|m1|.
2. A key kis generated by running Gen(1n), and a uniform bit
b∈{0,1}is chosen. Ciphertext c←Enck(mb)is computed
and given toA. We refer to cas thechallenge ciphertext .
3.Aoutputs a bit b/prime.
4. The output of the experiment is deﬁned to be 1ifb/prime=b, and
0otherwise. If PrivKeav
A,Π(n) = 1, we say thatAsucceeds.
There is no limitation on the lengths of m0andm1, as long as they are the
same. (Of course, if Aruns in polynomial time, then m0andm1have length
polynomial in n.) If Π is a ﬁxed-length scheme for messages of length /lscript(n),
the above experiment is modiﬁed by requiring m0,m1∈{0,1}/lscript(n).Private-Key Encryption 55
The fact that the adversary can only eavesdrop is implicit in the fact that
its input is limited to a (single) ciphertext, and the adversary does not have
any further interaction with the sender or the receiver. (As we will see later,
allowing additional interaction makes the adversary signiﬁcantly stronger.)
The deﬁnition ofindistinguishability states that an encryption scheme is se-
cure if no pptadversaryAsucceeds in guessing which message was encrypted
in the above experiment with probability signiﬁcantly better than random
guessing (which is correct with probability 1 /2):
DEFINITION 3.8 A private-key encryption scheme Π = (Gen,Enc,Dec)
hasindistinguishable encryptions in the presence of an eavesdropper , or isEAV-
secure, if for all probabilistic polynomial-time adversaries Athere is a negli-
gible function neglsuch that, for all n,
Pr/bracketleftbig
PrivKeav
A,Π(n) = 1/bracketrightbig
≤1
2+negl(n),
where the probability is taken over the randomness used by Aand the ran-
domness used in the experiment (for choosing the key and the bit b, as well as
any randomness used by Enc).
Note: unless otherwise qualiﬁed, when we write “ f(n)≤g(n)” we mean
that inequality holds for all n.
It should be clear that Deﬁnition 3.8 is weakerthan Deﬁnition 2.5, which
is equivalent to perfect secrecy. Thus, any perfectly secret encryption scheme
has indistinguishable encryptions in the presence of an eavesdropper. Our
goal, therefore, will be to show that there exist encryption schemes satisfying
the above in which the key is shorter than the message. That is, we will show
schemes that satisfy Deﬁnition 3.8 but cannot satisfy Deﬁnition 2.5.
An equivalent formulation. Deﬁnition 3.8 requires that no pptadver-
sary can determine which of two messages was encrypted, with probability
signiﬁcantly better than 1 /2. An equivalent formulation is that every pptad-
versarybehaves the same whether it sees an encryption of m0or ofm1. Since
Aoutputs a single bit, “behaving the same” means it outputs 1 with almost
the same probability in each case. To formalize this, deﬁne PrivKeav
A,Π(n,b) as
aboveexcept that the ﬁxed bit bis used (ratherthan being chosenatrandom).
LetoutA(PrivKeav
A,Π(n,b)) denote the output bit b/primeofAin the experiment. The
following essentially states that no Acan determine whether it is running in
experiment PrivKeav
A,Π(n,0) or experiment PrivKeav
A,Π(n,1).
DEFINITION 3.9 A private-key encryption scheme Π = (Gen,Enc,Dec)
hasindistinguishable encryptions in the presence of an eavesdropper if for all
pptadversariesAthere is a negligible function neglsuch that/vextendsingle/vextendsingle/vextendsinglePr[outA(PrivKeav
A,Π(n,0)) = 1]−Pr[outA(PrivKeav
A,Π(n,1)) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl(n).
The fact that this is equivalent to Deﬁnition 3.8 is left as an exercise.56 Introduction to Modern Cryptography
Encryption and Plaintext Length
The default notion of secure encryption does not require the encryption
scheme to hide the plaintext length and, in fact, all commonly used encryp-
tion schemes reveal the plaintext length (or a close approximation thereof).
The main reason for this is that it is impossible to support arbitrary-length
messages while hiding all information about the plaintext length (cf. Exer-
cise 3.2). In many cases this is inconsequential since the plaintext length is
already public or is not sensitive. This is not always the case, however, and
sometimes leaking the plaintext length is problematic. As examples:
•Simple numeric/text data: Saytheencryptionschemebeing usedreveals
the plaintext length exactly. Then encrypted salary information would
reveal whether someone makes a 5-ﬁgure or a 6-ﬁgure salary. Similarly,
encryption of “yes”/“no” responses would leak the answer exactly.
•Auto-suggestions: Websites often include an “auto-complete” or “auto-
suggestion”functionalitybywhichthewebserversuggestsalistofpoten-
tial words or phrases based on partial information the user has already
typed. The sizeof this list can reveal information about the letters the
user has typed so far. (For example, the number of auto-completions
returned for “ th” is far greater than the number for “ zo.”)
•Database searches: Consider a user querying a database for all records
matching some search term. The number of records returned can reveal
a lot of information about what the user was searching for. This can be
particularly damaging if the user is searching for medical information
and the query reveals information about a disease the user has.
•Compressed data: If the plaintext is compressed before being encrypted,
then information about the plaintext might be revealed even if only
ﬁxed-length data is ever encrypted. (Such an encryption scheme would
therefore not satisfy Deﬁnition 3.8.) For example, a short compressed
plaintext would indicate that the original (uncompressed) plaintext has
a lot of redundancy. If an adversary can control a portion of what gets
encrypted, this vulnerability can enable an adversaryto learn additional
information about the plaintext; it has been shown possible to use an
attackofexactly this sort(the CRIME attack ) againstencrypted HTTP
traﬃc to reveal secret session cookies.
When using encryption one should determine whether leaking the plaintext
length is a concernand, if so, takesteps to mitigate or prevent such leakageby
padding all messages to some pre-determined length before encrypting them.
3.2.2 *Semantic Security
We motivated the deﬁnition ofsecureencryption by sayingthat it shouldbe
infeasible foran adversarytolearnanypartialinformationaboutthe plaintextPrivate-Key Encryption 57
from the ciphertext. However, the deﬁnition of indistinguishability looks very
diﬀerent. As we have mentioned, Deﬁnition 3.8 is equivalent to a deﬁnition
calledsemantic security that formalizes the notion that partial information
cannot be learned. We build up to that deﬁnition by discussing two weaker
notions and showing that they are implied by indistinguishability.
We begin by showing that indistinguishability means that ciphertexts leak
noinformationaboutindividualbitsoftheplaintext. Formally,sayencryption
scheme ( Enc,Dec) is EAV-secure (recall then when Genis omitted, the key is
a uniform n-bit string), and m∈{0,1}/lscriptis uniform. Then we show that for
any index i, it is infeasible to guess mifromEnck(m) (where, in this section,
midenotes the ith bit of m) with probability much better than 1 /2.
THEOREM 3.10 LetΠ = (Enc,Dec)be a ﬁxed-length private-key encryp-
tion scheme for messages of length /lscriptthat has indistinguishable encryptions in
the presence of an eavesdropper. Then for all pptadversariesAand any
i∈{1,...,/lscript}, there is a negligible function neglsuch that
Pr/bracketleftbig
A(1n,Enck(m)) =mi/bracketrightbig
≤1
2+negl(n),
where the probability is taken over uniform m∈{0,1}/lscriptandk∈{0,1}n, the
randomness ofA, and the randomness of Enc.
PROOF Theideabehindtheproofofthistheoremisthatifitwerepossible
to guess the ith bit of mfromEnck(m), then it would also be possible to
distinguish between encryptions of messages m0andm1whoseith bits diﬀer.
We formalize this via a proof by reduction , in which we show how to use
any eﬃcient adversary Ato construct an eﬃcient adversary A/primesuch that ifA
violatesthesecuritynotionofthetheoremforΠ,then A/primeviolatesthedeﬁnition
ofindistinguishabilityforΠ. (SeeSection3.3.2.) SinceΠhasindistinguishable
encryptions, it must also be secure in the sense of the theorem.
Fix an arbitrary pptadversaryAandi∈{1,...,/lscript}. LetI0⊂{0,1}/lscriptbe
the set of all strings whose ith bit is 0, and let I1⊂{0,1}/lscriptbe the set of all
strings whose ith bit is 1. We have
Pr/bracketleftbig
A(1n,Enck(m)) =mi/bracketrightbig
=1
2·Pr
m0←I0[A(1n,Enck(m0)) = 0]+1
2·Pr
m1←I1[A(1n,Enck(m1)) = 1].
Construct the following eavesdropping adversary A/prime:
AdversaryA/prime:
1. Choose uniform m0∈I0andm1∈I1. Output m0,m1.
2. Upon observing a ciphertext c, invokeA(1n,c). IfAoutputs
0, output b/prime= 0; otherwise, output b/prime= 1.
A/primeruns in polynomial time since Adoes.58 Introduction to Modern Cryptography
By the deﬁnition of experiment PrivKeav
A/prime,Π(n), we have thatA/primesucceeds if
and only ifAoutputsbupon receiving Enck(mb). So
Pr/bracketleftbig
PrivKeav
A/prime,Π(n) = 1/bracketrightbig
= Pr[A(1n,Enck(mb)) =b]
=1
2·Pr
m0←I0[A(1n,Enck(m0)) = 0]+1
2·Pr
m1←I1[A(1n,Enck(m1)) = 1]
= Pr/bracketleftbig
A(1n,Enck(m)) =mi/bracketrightbig
.
By the assumption that ( Enc,Dec) has indistinguishable encryptions in the
presence of an eavesdropper, there is a negligible function neglsuch that
Pr/bracketleftbig
PrivKeav
A/prime,Π(n) = 1/bracketrightbig
≤1
2+negl(n). We conclude that
Pr/bracketleftbig
A(1n,Enck(m)) =mi/bracketrightbig
≤1
2+negl(n),
completing the proof.
We next claim, roughly, that indistinguishability means that no pptadver-
sary can learn anyfunction of the plaintext given the ciphertext, regardless
of the distribution of the message being sent. This is intended to capture the
idea that no information about a plaintext is leaked by the resulting cipher-
text. This requirement is, however, non-trivial to deﬁne formally. To see why,
note that even for the case considered above, it is easy to compute the ith
bit ofmifmis chosen, say, uniformly from the set of all strings whose ith
bit is 0 (rather than uniformly from {0,1}/lscript). Thus, what we actually want to
say is that if there exists any adversary who correctly computes f(m) with
some probability when given Enck(m), then there exists an adversary that
can correctly compute f(m) with the same probability withoutbeing given
the ciphertext at all (and only knowingthe distribution of m). In what follows
we focus on the case when mis chosen uniformly from some set S⊆{0,1}/lscript.
THEOREM 3.11 Let(Enc,Dec)be a ﬁxed-length private-key encryption
scheme for messages of length /lscriptthat has indistinguishable encryptions in the
presence of an eavesdropper. Then for any pptalgorithmAthere is a pptal-
gorithmA/primesuch that for any S⊆{0,1}/lscriptand any function f:{0,1}/lscript→{0,1},
there is a negligible function neglsuch that:
/vextendsingle/vextendsingle/vextendsinglePr[A(1n,Enck(m)) =f(m)]−Pr[A/prime(1n) =f(m)]/vextendsingle/vextendsingle/vextendsingle≤negl(n),
where the ﬁrst probability is taken over uniform choice of k∈{0,1}nand
m∈S, the randomness of A, and the randomness of Enc, and the second
probability is taken over uniform choice of m∈Sand the randomness of A/prime.Private-Key Encryption 59
PROOF (Sketch) The fact that ( Enc,Dec) is EAV-secure means that, for
anyS⊆{0,1}/lscript, nopptadversary can distinguish between Enck(m) (for uni-
formm∈S) andEnck(1/lscript). Consider now the probability that Asuccessfully
computes f(m) givenEnck(m). We claim that Ashould successfully compute
f(m) givenEnck(1/lscript) with almost the same probability; otherwise, Acould
be used to distinguish between Enck(m) andEnck(1/lscript). The distinguisher is
easily constructed: choose uniform m∈S, and output m0=m,m1= 1/lscript.
When given a ciphertext cthat is an encryption of either m0orm1, invoke
A(1n,c) and output 0 if and only if Aoutputsf(m). IfAoutputsf(m) when
given an encryption of mwith probability that is signiﬁcantly diﬀerent from
the probability that it outputs f(m) when given an encryption of 1/lscript, then the
described distinguisher violates Deﬁnition 3.9.
The above suggests the following algorithm A/primethat does not receive c=
Enck(m), yet computes f(m) almost as well as Adoes:A/prime(1n) chooses a
uniform key k∈{0,1}n, invokesAonc←Enck(1/lscript), and outputs whatever A
does. By the above, we have that Aoutputsf(m) when run as a subroutine
byA/primewith almost the same probability as when it receives Enck(m). Thus,
A/primefulﬁlls the property required by the claim.
Semantic security. The full deﬁnition of semantic security guarantees con-
siderably more than the property considered in Theorem 3.11. The deﬁnition
allows the length of the plaintext to depend on the security parameter, and
allows for essentially arbitrary distributions over plaintexts. (Actually, we
allow only eﬃciently sampleable distributions. This means that there is some
probabilistic polynomial-time algorithm Sampsuch that Samp(1n) outputs
messages according to the distribution.) The deﬁnition also takes into ac-
count arbitrary “external” information h(m) about the plaintext that may be
leaked to the adversary through other means (e.g., because the same message
mis used for some other purpose as well).
DEFINITION 3.12 A private-key encryption scheme (Enc,Dec)isseman-
tically secure in the presence of an eavesdropper if for every pptalgorithmA
there exists a pptalgorithmA/primesuch that for any pptalgorithm Sampand
polynomial-time computable functions fandh, the following is negligible:
/vextendsingle/vextendsingle/vextendsinglePr[A(1n,Enck(m),h(m)) =f(m)]−Pr[A/prime(1n,|m|,h(m)) =f(m)]/vextendsingle/vextendsingle/vextendsingle,
where the ﬁrst probability is taken over uniform k∈{0,1}n,moutput by
Samp(1n), the randomness of A, and the randomness of Enc, and the second
probability is taken over moutput by Samp(1n)and the randomness of A/prime.
The adversaryAis given the ciphertext Enck(m) as well as the external
information h(m), and attempts to guess the value of f(m). AlgorithmA/prime
also attempts to guess the value of f(m), but is given onlyh(m) and the60 Introduction to Modern Cryptography
length of m. The security requirement states that A’s probability of correctly
guessing f(m)isaboutthesameasthatof A/prime. Intuitively, then, theciphertext
Enck(m) does not reveal any additional information about the value of f(m).
Deﬁnition 3.12 constitutes a very strong and convincing formulation of the
security guarantees that should be provided by an encryption scheme. How-
ever, it is easier to work with the deﬁnition of indistinguishability (Deﬁni-
tion 3.8). Fortunately, the deﬁnitions are equivalent :
THEOREM 3.13 A private-key encryption scheme has indistinguishable
encryptions in the presence of an eavesdropper if and only if it is semantically
secure in the presence of an eavesdropper.
Looking ahead, a similar equivalence between semantic security and indis-
tinguishability is known for all the deﬁnitions that we present in this chapter
as well as those in Chapter 11. We can therefore use indistinguishability as
our working deﬁnition, while being assured that the guarantees achieved are
those of semantic security.
3.3 Constructing Secure Encryption Schemes
Having deﬁned what it means for an encryption scheme to be secure, the
reader may expect us to turn immediately to constructions of secure encryp-
tion schemes. Before doing so, however, we need to introduce the notions
ofpseudorandom generators (PRGs) and stream ciphers , important building
blocks for private-key encryption. These, in turn, will lead to a discussion of
pseudorandomness , which playsa fundamental role in cryptographyin general
and private-key encryption in particular.
3.3.1 Pseudorandom Generators and Stream Ciphers
A pseudorandom generator Gis an eﬃcient, deterministic algorithm for
transforming a short, uniform string called the seedinto a longer, “uniform-
looking” (or “pseudorandom”) output string. Stated diﬀerently, a pseudoran-
dom generator uses a small amount of true randomness in order to generate
a large amount of pseudorandomness. This is useful whenever a large num-
ber of random(-looking) bits are needed, since generating true random bits
is diﬃcult and slow. (See the discussion at the beginning of Chapter 2.) In-
deed, pseudorandom generators have been studied since at least the 1940s
when they were proposed for running statistical simulations. In that context,
researchers proposed various statistical tests that a pseudorandom generator
should pass in order to be considered “good.” As a simple example, the ﬁrstPrivate-Key Encryption 61
bit of the output ofa pseudorandomgeneratorshould be equalto 1 with prob-
ability very close to 1 /2 (where the probability is taken over uniform choice of
the seed), since the ﬁrst bit of a uniform string is equal to 1 with probability
exactly 1 /2. In fact, the parity of any ﬁxed subset of the output bits should
also be 1 with probability very close to 1 /2. More complex statistical tests
can also be considered.
This historical approachto determining the quality of some candidate pseu-
dorandom generator is ad hoc, and it is not clear when passing some set of
statistical tests is suﬃcient to guarantee the soundness of using a candidate
pseudorandom generator for some application. (In particular, there may be
another statistical test that doessuccessfully distinguish the output of the
generator from true random bits.) The historical approach is even more prob-
lematic when using pseudorandom generators for cryptographic applications;
in that setting, security may be compromised if an attacker is able to distin-
guish the output of a generator from uniform, and we do not know in advance
what strategy an attacker might use.
The above considerations motivated a cryptographic approach to deﬁning
pseudorandom generators in the 1980s. The basic realization was that a good
pseudorandom generator should pass all(eﬃcient) statistical tests. That is,
foranyeﬃcient statistical test (or distinguisher )D, the probability that D
returns 1 when given the output of the pseudorandom generator should be
close to the probability that Dreturns 1 when given a uniform string of the
samelength. Informally,then, theoutputofapseudorandomgeneratorshould
“look like” a uniform string to anyeﬃcient observer.
(We stress that, formally speaking, it does not make sense to say that any
ﬁxed string is “pseudorandom,” in the same waythat it is meaninglessto refer
to any ﬁxed string as “random.” Rather, pseudorandomness is a property of
adistribution on strings. Nevertheless, we sometimes informally call a string
sampledaccordingtothe uniformdistribution a“uniformstring,”and astring
output by a pseudorandom generator a “pseudorandom string.”)
Another perspective is obtained by deﬁning what it means for a distribu-
tion to be pseudorandom. Let Distbe a distribution on /lscript-bit strings. (This
means that Distassigns some probability to every string in {0,1}/lscript; sampling
fromDistmeans that we choose an /lscript-bit string according to this probability
distribution.) Informally, Distispseudorandom if the experiment in which a
string is sampled from Distis indistinguishable from the experiment in which
a uniform string of length /lscriptis sampled. (Strictly speaking, since we are in an
asymptotic setting we need to speak of the pseudorandomness of a sequence
of distributions Dist={Distn}, where distribution Distnis used for security
parameter n. We ignore this point in our current discussion.) More precisely,
it should be infeasible for any polynomial-time algorithm to tell (better than
guessing) whether it is given a string sampled according to Dist, or whether
it is given a uniform /lscript-bit string. This means that a pseudorandom string
is just as good as a uniform string , as long as we consider only polynomial-
time observers. Just as indistinguishability is a computational relaxation of62 Introduction to Modern Cryptography
perfect secrecy, pseudorandomness is a computational relaxation of true ran-
domness. (We will generalize this perspective when we discuss the notion of
indistinguishability in Chapter 7.)
Now let G:{0,1}n→{0,1}/lscriptbe a function, and deﬁne Distto be the
distribution on /lscript-bit strings obtained by choosing a uniform s∈{0,1}nand
outputting G(s). Then Gis a pseudorandom generator if and only if the
distribution Distis pseudorandom.
The formal deﬁnition. As discussed above, Gis a pseudorandom generator
if no eﬃcient distinguisher can detect whether it is given a string output by G
orastringchosenuniformly atrandom. As inDeﬁnition 3.9, this is formalized
by requiring that every eﬃcient algorithm outputs 1 with almost the same
probability when given G(s) (for uniform seed s) or a uniform string. (For an
equivalent deﬁnition analogous to Deﬁnition 3.8, see Exercise 3.5.) We obtain
a deﬁnition in the asymptotic setting by letting the security parameter n
determine the length of the seed. We then insist that Gbe computable by
an eﬃcient algorithm. As a technicality, we also require that G’s output be
longer than its input; otherwise, Gis not very useful or interesting.
DEFINITION 3.14 Let/lscriptbe a polynomial and let Gbe a deterministic
polynomial-time algorithm such that for any nand any input s∈{0,1}n,
the result G(s)is a string of length /lscript(n). We say that Gis apseudorandom
generator if the following conditions hold:
1.(Expansion:) For every nit holds that /lscript(n)> n.
2.(Pseudorandomness:) For anypptalgorithm D, there is a negligible
function neglsuch that
/vextendsingle/vextendsinglePr[D(G(s)) = 1]−Pr[D(r) = 1]/vextendsingle/vextendsingle≤negl(n),
where the ﬁrst probability is taken over uniform choice of s∈{0,1}nand
the randomness of D, and the second probability is taken over uniform
choice of r∈{0,1}/lscript(n)and the randomness of D.
We call/lscripttheexpansion factor ofG.
We give an example of an insecure pseudorandom generator to gain famil-
iarity with the deﬁnition.
Example 3.15
DeﬁneG(s) to output sfollowed by⊕n
i=1si, so the expansion factor of Gis
/lscript(n) =n+ 1. The output of Gcan easily be distinguished from uniform.
Consider the following eﬃcient distinguisher D: on input a string w, output 1
if and only if the ﬁnal bit of wis equal to the XOR of all the preceding
bits ofw. Since this property holds for all strings output by G, we havePrivate-Key Encryption 63
Pr[D(G(s)) = 1] = 1. On the other hand, if wis uniform, the ﬁnal bit of w
is uniform and so Pr[ D(w) = 1] =1
2.The quantity|1
2−1|isconstant, not
negligible, and so this Gis not a pseudorandom generator. (Note that Dis
not always “correct,” since it sometimes outputs 1 even when given a uniform
string. This does not change the fact that Dis a good distinguisher.) ♦
Discussion. The distribution on the output of a pseudorandom generator G
is far from uniform. To see this, consider the case that /lscript(n) = 2nand soG
doubles the length of its input. Under the uniform distribution on {0,1}2n,
each of the 22npossible strings is chosen with probability exactly 2−2n. In
contrast, consider the distribution of the output of G(whenGis run on a
uniform seed). When Greceives an input of length n, the number of diﬀerent
strings in the range of Gis at most 2n. The fraction of strings of length 2 n
that are in the range of Gis thus at most 2n/22n= 2−n, and we see that the
vast majority of strings of length 2 ndo not occur as outputs of G.
This in particular means that it is trivial to distinguish between a random
string and a pseudorandom string given an unlimited amount of time . Let
Gbe as above and consider the exponential-time distinguisher Dthat works
as follows: D(w) outputs 1 if and only if there exists an s∈{0,1}nsuch
thatG(s) =w. (This computation is carried out in exponential time by
exhaustively computing G(s) for every s∈{0,1}n. Recall that by Kerckhoﬀs’
principle, the speciﬁcation of Gis known to D.) Now, if wwere output by G,
thenDoutputs 1 with probability 1. In contrast, if wis uniformly distributed
in{0,1}2n, then the probability that there exists an swithG(s) =wis at
most 2−n, and so Doutputs 1 in this case with probability at most 2−n. So
/vextendsingle/vextendsinglePr[D(r) = 1]−Pr[D(G(s)) = 1]/vextendsingle/vextendsingle≥1−2−n,
which is large. This is just another example of a brute-force attack , and does
not contradict the pseudorandomness of Gsince the attack is not eﬃcient.
The seed and its length. The seed for a pseudorandom generator is anal-
ogous to the cryptographic key used by an encryption scheme, and the seed
must be chosen uniformly and be kept secret from any adversary. Another
important point, evident from the above discussion of brute-force attacks, is
thatsmust be long enough so that it is not feasible to enumerate all possible
seeds. In an asymptotic sense this is taken care of by setting the length of
the seed equal to the security parameter, so that exhaustive search over all
possible seeds requires exponential time. In practice, the seed must be long
enough so that it is impossible to try all possible seeds within some speciﬁed
time bound.
On the existence of pseudorandom generators. Do pseudorandom gen-
erators exist? They certainly seem diﬃcult to construct, and one may rightly
ask whether any algorithm satisfying Deﬁnition 3.14 exists. Although we do
not know how to unconditionally prove the existence of pseudorandom gen-
erators, we have strong reasons to believe they exist. For one, they can be64 Introduction to Modern Cryptography
constructed under the rather weak assumption that one-way functions exist
(which is true if certain problems like factoring large numbers are hard); this
will be discussed in detail in Chapter 7. We also have several practical con-
structions of candidate pseudorandom generators called stream ciphers for
which no eﬃcient distinguishers are known. (Later, we will introduce even
stronger primitives called block ciphers .) We give a high-level overview of
stream ciphers next, and discuss concrete stream ciphers in Chapter 6.
Stream Ciphers
Our deﬁnition of a pseudorandom generator is limited in two ways: the
expansion factor is ﬁxed, and the generator produces its entire output in “one
shot.”Stream ciphers , used in practice to instantiate pseudorandom genera-
tors, work somewhat diﬀerently. The pseudorandom output bits of a stream
cipher are produced gradually and on demand, so that an application can re-
quest exactly as many pseudorandom bits as needed. This improves eﬃciency
(since an application can request fewer bits, if suﬃcient) and ﬂexibility (since
there is no upper bound on the number of bits that can be requested).
Formally, we view a stream cipher2as a pair of deterministic algorithms
(Init,GetBits) where:
•Inittakes as input a seed sand an optional initialization vector IV, and
outputs an initial state st0.
•GetBitstakes as input state information sti, and outputs a bit yand
updated state sti+1. (In practice, yis ablockof several bits; we treat y
as a single bit here for generality and simplicity.)
Given a stream cipher and any desired expansion factor /lscript, we can deﬁne
an algorithm G/lscriptmapping inputs of length nto outputs of length /lscript(n). The
algorithm simply runs Init, and then repeatedly runs GetBitsa total of /lscripttimes.
ALGORITHM 3.16
Constructing G/lscriptfrom(Init,GetBits)
Input:Seedsand optional initialization vector IV
Output: y1,...,y /lscript
st0:=Init(s,IV)
fori= 1 to/lscript:
(yi,sti) :=GetBits(sti−1)
returny1,...,y /lscript
2The terminology here is not completely standard, and beware that “stream cipher” is used
by diﬀerent people in diﬀerent (but related) ways. For example, some use it to refer to G/lscript
(see below), while some use it to refer to Construction 3.17 when instantiated with G/lscript.Private-Key Encryption 65
Astream cipher is securein the basic sense if it takes no IVand for any
polynomial /lscriptwith/lscript(n)> n, the function G/lscriptconstructed above is a pseudo-
random generator with expansion factor /lscript. We brieﬂy discuss one possible
security notion for stream ciphers that use an IVin Section 3.6.1.
3.3.2 Proofs by Reduction
Ifwewishtoprovethatagivenconstructioniscomputationallysecure,then
we must rely on unproven assumptions3(unless the scheme is information-
theoretically secure). Our strategy will be to assume that some mathematical
problem is hard, or that some low-level cryptographic primitive is secure, and
then toprovethat a given construction based on this problem/primitive is
secure under this assumption. In Section 1.4.2 we have already explained
in great detail why this approach is preferable so we do not repeat those
arguments here.
Theproofthatacryptographicconstructionissecureaslongassomeunder-
lying problem is hard generally proceeds by presenting an explicit reduction
showing how to transform any eﬃcient adversary Athat succeeds in “break-
ing” the construction into an eﬃcient algorithm A/primethat solves the problem
that was assumed to be hard. Since this is so important, we walk through
a high-level outline of the steps of such a proof in detail. (We will see nu-
merous concrete examples through the book, beginning with the proof of
Theorem 3.18.) We begin with an assumption that some problem Xcannot
be solved (in some precisely deﬁned sense) by any polynomial-time algorithm,
except with negligible probability. We want to prove that some cryptographic
construction Π is secure (again, in some sense that is precisely deﬁned). A
proof proceeds via the following steps (see also Figure 3.1):
1. Fix some eﬃcient (i.e., probabilistic polynomial-time) adversary Aat-
tacking Π. Denote this adversary’s success probability by ε(n).
2. Construct an eﬃcient algorithm A/prime, called the “reduction,” that at-
tempts to solve problem Xusing adversaryAas a subroutine. An im-
portant point here is that A/primeknows nothing about how Aworks; the
only thingA/primeknows is thatAis expecting to attack Π. So, given some
input instance xof problem X, our algorithmA/primewillsimulate forAan
instance of Π such that:
(a) As far asAcan tell, it is interacting with Π. That is, the view of A
when run as a subroutine by A/primeshould be distributed identically to
(or at least close to) the view of Awhen it interacts with Π itself.
(b) IfAsucceeds in “breaking” the instance of Π that is being sim-
ulated byA/prime, this should allow A/primeto solve the instance xit was
given, at least with inverse polynomial probability 1 /p(n).
3Inparticular, most of cryptography requires the unproven assumption that P /negationslash=NP.66 Introduction to Modern Cryptography
/MT32/MT73/MT110/MT115/MT116/MT97/MT110/MT99/MT101/MT32/MT111/MT102
/MT115/MT99/MT104/MT101/MT109/MT101/MT32/MT82/MT101/MT100/MT117/MT99/MT116/MT105/MT111/MT110
/MT147/MT66/MT114/MT101/MT97/MT107/MT148/MT65/MT73/MT110/MT115/MT116/MT97/MT110/MT99/MT101/MT32/MT32/MT32/MT32/MT111/MT102/MT32
/MT32/MT32/MT112/MT114/MT111/MT98/MT108/MT101/MT109/MT32
/MT83/MT111/MT108/MT117/MT116/MT105/MT111/MT110/MT32/MT116/MT111
/MT32/MT32/MT32/MT88/MT65/MT48
/MT120
/MT120
FIGURE 3.1 :Ahigh-level overview of a security proof by reduction.
3. Taken together, 2(a) and 2(b) imply that A/primesolvesXwith probability
ε(n)/p(n). Ifε(n) is not negligible, then neither is ε(n)/p(n). Moreover,
ifAis eﬃcient then we obtain an eﬃcient algorithm A/primesolvingXwith
non-negligible probability, contradicting the initial assumption.
4. Given our assumption regarding X, we conclude that noeﬃcient ad-
versaryAcan succeed in breaking Π with non-negligible probability.
Stated diﬀerently, Π is computationally secure.
In the following section we will illustrate exactly the above idea: we will
show how to use any pseudorandom generator Gto construct an encryption
scheme; we prove the encryption scheme secure by showing that any attacker
who can “break” the encryption scheme can be used to distinguish the output
ofGfrom a uniform string. Under the assumption that Gis a pseudorandom
generator, then, the encryption scheme is secure.
3.3.3 A Secure Fixed-Length Encryption Scheme
A pseudorandom generator provides a natural way to construct a secure,
ﬁxed-length encryption scheme with a key shorter than the message. Recall
that in the one-time pad (see Section 2.2), encryption is done by XORing a
random pad with the message. The insight is that we can use a pseudorandom
pad instead. Rather than sharing this long, pseudorandom pad, however, the
sender and receiver can instead share a seedwhich is used to generate that
pad when needed (see Figure 3.2); this seed will be shorter than the pad
and hence shorter than the message. As for security, the intuition is that
a pseudorandom string “looks random” to any polynomial-time adversary
and so a computationally bounded eavesdropper cannot distinguish between
a message encrypted using the one-time pad or a message encrypted using
this “pseudo-”one-time pad encryption scheme.Private-Key Encryption 67
/MT67/MT105/MT112/MT104/MT101/MT114/MT116/MT101/MT120/MT116/MT112/MT97/MT100
/MT88/MT79/MT82 /MT80/MT108/MT97/MT105/MT110/MT116/MT101/MT120/MT116/MT80/MT115/MT101/MT117/MT100/MT111/MT114/MT97/MT110/MT100/MT111/MT109
/MT103/MT101/MT110/MT101/MT114/MT97/MT116/MT111/MT114
FIGURE 3.2 :Encryption with a pseudorandom generator.
The encryption scheme. Fix some message length /lscriptand letGbe a pseu-
dorandom generator with expansion factor /lscript(that is,|G(s)|=/lscript(|s|)). Recall
that an encryption scheme is deﬁned by three algorithms: a key-generation
algorithm Gen, an encryption algorithm Enc, and a decryption algorithm Dec.
The key-generation algorithm is the trivial one: Gen(1n) simply outputs a
uniform key kof length n. Encryption works by applying Gto the key (which
serves as a seed) in order to obtain a pad that is then XORed with the plain-
text. Decryption applies Gto the key and XORs the resulting pad with the
ciphertext to recover the message. The scheme is described formally in Con-
struction 3.17. In Section 3.6.1, we describe how stream ciphers are used to
implement a variant of this scheme in practice.
CONSTRUCTION 3.17
LetGbe a pseudorandom generator with expansion factor /lscript. Deﬁne a
private-key encryption scheme for messages of length /lscriptas follows:
•Gen: on input 1n, choose uniform k∈{0,1}nand output it as
the key.
•Enc: on input a key k∈{0,1}nand a message m∈{0,1}/lscript(n),
output the ciphertext
c:=G(k)⊕m.
•Dec: on input a key k∈{0,1}nand a ciphertext c∈{0,1}/lscript(n),
output the messagem:=G(k)⊕c.
A private-key encryption scheme based on any pseudorandom generator.68 Introduction to Modern Cryptography
THEOREM 3.18 IfGis a pseudorandom generator, then Construc-
tion 3.17 is a ﬁxed-length private-key encryption scheme that has indistin-
guishable encryptions in the presence of an eavesdropper.
PROOF Let Π denote Construction 3.17. We show that Π satisﬁes Def-
inition 3.8. Namely, we show that for any probabilistic polynomial-time ad-
versaryAthere is a negligible function neglsuch that
Pr/bracketleftbig
PrivKeav
A,Π(n) = 1/bracketrightbig
≤1
2+negl(n). (3.2)
The intuition is that if Π used a uniform pad in place of the pseudorandom
padG(k), then the resulting scheme would be identical to the one-time pad
encryption scheme and Awould be unable to correctly guess which message
was encrypted with probability any better than 1 /2. Thus, if Equation (3.2)
doesnothold thenAmust implicitly be distinguishing the output of Gfrom
a random string. We make this explicit by showing a reduction ; namely,
by showing how to use Ato construct an eﬃcient distinguisher D, with the
property that D’s ability to distinguish the output of Gfrom a uniform string
is directly related to A’s ability to determine which message was encrypted
by Π. Security of Gthen implies security of Π.
LetAbe an arbitrary pptadversary. We construct a distinguisher Dthat
takes a string was input, and whose goal is to determine whether wwas
chosen uniformly (i.e., wis a “random string”) or whether wwas generated
bychoosingauniform kandcomputing w:=G(k) (i.e.,wisa“pseudorandom
string”). We construct Dso that it emulates the eavesdropping experiment
forA, as described below, and observes whether Asucceeds or not. If A
succeeds then Dguesses that wmust be a pseudorandom string, while if A
does not succeed then Dguesses that wis a random string. In detail:
Distinguisher D:
Dis given as input a string w∈{0,1}/lscript(n). (We assume that ncan
be determined from /lscript(n).)
1. RunA(1n) to obtain a pair of messages m0,m1∈{0,1}/lscript(n).
2. Choose a uniform bit b∈{0,1}. Setc:=w⊕mb.
3. GivectoAand obtain output b/prime. Output 1 if b/prime=b, and
output 0 otherwise.
Dclearly runs in polynomial time (assuming Adoes).
Beforeanalyzing the behaviorof D, we deﬁne a modiﬁed encryption scheme
/tildewideΠ = (/tildewidestGen,/tildewidestEnc,/tildewidestDec) that is exactly the one-time pad encryption scheme, ex-
cept that we now incorporate a security parameter that determines the length
of the message to be encrypted. That is, /tildewidestGen(1n) outputs a uniform key kof
length/lscript(n), and the encryption of message m∈2/lscript(n)using key k∈{0,1}/lscript(n)Private-Key Encryption 69
isthe ciphertext c:=k⊕m. (Decryption can be performed as usual, but is
inessential to what follows.) Perfect secrecy of the one-time pad implies
Pr/bracketleftBig
PrivKeav
A,/tildewideΠ(n) = 1/bracketrightBig
=1
2. (3.3)
To analyze the behavior of D, the main observations are:
1. Ifwischosenuniformlyfrom {0,1}/lscript(n), thentheviewof Awhenrunasa
subroutineby Dis distributed identically to the view of Ain experiment
PrivKeav
A,/tildewideΠ(n). This is because when Ais run as a subroutine by D(w) in
this case,Ais given a ciphertext c=w⊕mbwherew∈{0,1}/lscript(n)is uni-
form. Since Doutputs 1 exactly when Asucceeds in its eavesdropping
experiment, we therefore have (cf. Equation (3.3))
Prw←{0,1}/lscript(n)[D(w) = 1] = Pr/bracketleftBig
PrivKeav
A,/tildewideΠ(n) = 1/bracketrightBig
=1
2.(3.4)
(The subscript on the ﬁrst probability just makes explicit that wis
chosen uniformly from {0,1}/lscript(n)there.)
2. Ifwis instead generated by choosing uniform k∈ {0,1}nand then
settingw:=G(k), the view ofAwhen run as a subroutine by Dis
distributed identically to the view of Ain experiment PrivKeav
A,Π(n). This
is becauseA, when run as a subroutine by D, is now given a ciphertext
c=w⊕mbwherew=G(k) for a uniform k∈{0,1}n. Thus,
Prk←{0,1}n[D(G(k)) = 1] = Pr/bracketleftbig
PrivKeav
A,Π(n) = 1/bracketrightbig
.(3.5)
SinceGis a pseudorandom generator (and since Druns in polynomial time),
we know there is a negligible function neglsuch that
/vextendsingle/vextendsingle/vextendsinglePrw←{0,1}/lscript(n)[D(w) = 1]−Prk←{0,1}n[D(G(k)) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl(n).
Using Equations (3.4) and (3.5), we thus see that
/vextendsingle/vextendsingle/vextendsingle/vextendsingle1
2−Pr/bracketleftbig
PrivKeav
A,Π(n) = 1/bracketrightbig/vextendsingle/vextendsingle/vextendsingle/vextendsingle≤negl(n),
which implies Pr/bracketleftbig
PrivKeav
A,Π(n) = 1/bracketrightbig
≤1
2+negl(n). SinceAwas an arbitrary
pptadversary, this completes the proof that Π has indistinguishable encryp-
tions in the presence of an eavesdropper.
It is easyto get lost in the details of the proofand wonderwhether anything
has been gained as compared to the one-time pad; after all, the one-time pad
also encrypts an /lscript-bit message by XORing it with an /lscript-bit string! The point
of the construction, of course, is that the /lscript-bit string G(k) can be much70 Introduction to Modern Cryptography
longerthan the shared key k. In particular, using the above scheme it is
possible to securely encrypt a 1 Mb ﬁle using only a 128-bit key. By relying
on computational secrecy we have thus circumvented the impossibility result
of Theorem 2.10, which states that any perfectly secret encryption scheme
must use a key at least as long as the message.
Reductions—a discussion. We donotprove unconditionally that Con-
struction 3.17 is secure. Rather, we prove that it is secure under the assump-
tionthatGis a pseudorandom generator. This approach of reducing the
security of a higher-level construction to a lower-level primitive has a number
of advantages (as discussed in Section 1.4.2). One of these advantages is that,
in general, it is easier to design a lower-level primitive than a higher-level one;
it is also easier, in general, to directly analyze an algorithm Gwith respect
to a lower-level deﬁnition than to analyze a more complex scheme Π with
respect to a higher-level deﬁnition. This does not mean that constructing a
pseudorandom generator is “easy,” only that it is easier than constructing an
encryption scheme from scratch. (In the present case the encryption scheme
does nothing except XOR the output of a pseudorandom generator with the
message and so this isn’t really true. However, we will see more complex con-
structions and in those cases the ability to reduce the task to a simpler one is
of great importance.) Another advantage is that once an appropriate Ghas
been constructed, it can be used as a component of various other schemes.
Concrete security. Although Theorem 3.18 and its proof are in an asymp-
totic setting, we can readily adapt the proof to bound the concrete security
of the encryption scheme in terms of the concrete security of G. Fix some
value of nfor the remainder of this discussion, and let Π now denote Con-
struction 3.17 using this value of n. Assume Gis (t,ε)-pseudorandom (for the
given value of n), in the sense that for all distinguishers Drunning in time at
mosttwe have
/vextendsingle/vextendsinglePr[D(r) = 1]−Pr[D(G(s)) = 1]/vextendsingle/vextendsingle≤ε. (3.6)
(Think of t≈280andε≈2−60, though precise values are irrelevant for our
discussion.) We claim that Π is ( t−c, ε)-secure for some (small) constant c,
in the sense that for all Arunning in time at most t−cwe have
Pr/bracketleftbig
PrivKeav
A,Π= 1/bracketrightbig
≤1
2+ε. (3.7)
(Note that the above are now ﬁxed numbers, not functions of n, since we
are not in an asymptotic setting here.) To see this, let Abe an arbitrary
adversary running in time at most t−c. Distinguisher D, as constructed in
the proof of Theorem 3.18, has very little overhead besides running A; setting
cappropriately ensures that Druns in time at most t. Our assumption on
the concrete security of Gthen implies Equation (3.6); proceeding exactly as
in the proof of Theorem 3.18, we obtain Equation (3.7).Private-Key Encryption 71
3.4 Stronger Security Notions
Until now we have considered a relatively weak deﬁnition of security in
which the adversary only passively eavesdrops on a single ciphertext sent
between the honest parties. In this section, we consider two stronger security
notions. Recallthatasecuritydeﬁnitionspeciﬁesasecuritygoalandanattack
model. In deﬁning the ﬁrst new security notion, we modify the security goal;
for the second we strengthen the attack model.
3.4.1 Security for Multiple Encryptions
Deﬁnition3.8dealswith the casewherethecommunicatingpartiestransmit
a single ciphertext that is observed by an eavesdropper. It would be conve-
nient, however, if the communicating parties could send multiple ciphertexts
to each other—all generated using the same key—even if an eavesdropper
mightobserveallofthem. Forsuchapplicationsweneedanencryptionscheme
secure for the encryption of multiple messages.
We begin with an appropriate deﬁnition of security for this setting. As
in the case of Deﬁnition 3.8, we ﬁrst introduce an appropriate experiment
deﬁned for any encryption scheme Π, adversary A, and security parameter n:
The multiple-messageeavesdropping experiment PrivKmult
A,Π(n):
1. The adversary Ais given input 1n, and outputs a pair of
equal-length listsof messages /vectorM0= (m0,1,...,m 0,t)and/vectorM1=
(m1,1,...,m 1,t), with|m0,i|=|m1,i|for alli.
2. A key kis generated by running Gen(1n), and a uniform bit
b∈{0,1}is chosen. For all i, the ciphertext ci←Enck(mb,i)
is computed and the list /vectorC= (c1,...,c t)is given toA.
3.Aoutputs a bit b/prime.
4. The output of the experiment is deﬁned to be 1ifb/prime=b, and
0otherwise.
The deﬁnition of security is the same as before, except that it now refers to
the above experiment.
DEFINITION 3.19 A private-key encryption scheme Π = (Gen,Enc,Dec)
hasindistinguishable multiple encryptions in the presence of an eavesdropper if
for all probabilistic polynomial-time adversaries Athere is a negligible function
neglsuch that
Pr/bracketleftBig
PrivKmult
A,Π(n) = 1/bracketrightBig
≤1
2+negl(n),
where the probability is taken over the randomness used by Aand the random-
ness used in the experiment.72 Introduction to Modern Cryptography
Any scheme that has indistinguishable multiple encryptions in the pres-
ence of an eavesdropper clearly also satisﬁes Deﬁnition 3.8, since experiment
PrivKeavcorresponds to the special case of PrivKmultwhere the adversary out-
putstwolistscontainingonlyasinglemessageeach. Infact, ournewdeﬁnition
is strictly stronger than Deﬁnition 3.8, as the following shows.
PROPOSITION 3.20 There is a private-key encryption scheme that has
indistinguishable encryptions in the presence of an eavesdropper, but not in-
distinguishable multipleencryptions in the presence of an eavesdropper.
PROOF We do not have to look far to ﬁnd an example of an encryption
schemesatisfyingthe proposition. Theone-timepad isperfectly secret, and so
also has indistinguishable encryptions in the presence of an eavesdropper. We
show that it is not secure in the sense of Deﬁnition 3.19. (We have discussed
this attack in Chapter 2 already; here, we merely analyze the attack with
respect to Deﬁnition 3.19.)
Concretely, consider the following adversary Aattacking the scheme (in
the sense deﬁned by experiment PrivKmult):Aoutputs /vectorM0= (0/lscript,0/lscript) and
/vectorM1= (0/lscript,1/lscript). (The ﬁrst contains the same plaintext twice, while the second
contains two diﬀerent messages.) Let /vectorC= (c1,c2) be the list of ciphertexts
thatAreceives. If c1=c2, thenAoutputsb/prime= 0; otherwise,Aoutputsb/prime= 1.
We now analyze the probability that b/prime=b. The crucial point is that the
one-time pad is deterministic , so encrypting the same message twice (using
the same key) yields the same ciphertext. Thus, if b= 0 then we must have
c1=c2andAoutputs 0 in this case. On the other hand, if b= 1 then a
diﬀerent message is encrypted each time; hence c1/negationslash=c2andAoutputs 1.
We conclude that Acorrectly outputs b/prime=bwith probability 1, and so the
encryption scheme is not secure with respect to Deﬁnition 3.19.
Necessity of probabilistic encryption. The above might appear to show
that Deﬁnition 3.19 is impossible to achieve using anyencryption scheme.
But in fact this is true only if the encryption scheme is deterministic and
so encrypting the same message multiple times (using the same key) always
yields the same result. This is important enough to state as a theorem.
THEOREM 3.21 IfΠis a (stateless4) encryption scheme in which Enc
is a deterministic function of the key and the message, then Πcannot have
indistinguishable multiple encryptions in the presence of an eavesdropper.
This should not be takento mean that Deﬁnition 3.19is too strong. Indeed,
4Wewill see in Section 3.6.1 that if the encryption scheme is stateful, then it is possible to
securely encrypt multiple messages even if encryption is deterministic.Private-Key Encryption 73
leaking to an eavesdropperthe fact that two encrypted messages are the same
can be a signiﬁcant security breach. (Consider, e.g., a scenario in which a
student encrypts a series of true/false answers!)
To construct a scheme secure for encrypting multiple messages, we must
design a scheme in which encryption is randomized so that when the same
message is encrypted multiple times, diﬀerent ciphertexts can be produced.
This may seem impossible since decryption must always be able to recover
the message. However, we will soon see how to achieve it.
3.4.2 Chosen-Plaintext Attacks and CPA-Security
Chosen-plaintext attacks capture the ability of an adversary to exercise
(partial) control over what the honest parties encrypt. We imagine a scenario
in which two honest parties share a key k, and the attacker can inﬂuence
these parties to encrypt messages m1,m2,...(usingk) and send the resulting
ciphertexts over a channel that the attacker can observe. At some later point
in time, the attacker observes a ciphertext corresponding to some unknown
message mencrypted using the same key k; let us even assume that the
attacker knows that mis one of two possibilities m0,m1. Security against
chosen-plaintext attacks means that even in this case the attacker cannot
tell which of these two messages was encrypted with probability signiﬁcantly
better than random guessing. (For now we revert back to the case where
the eavesdropper is given only a single encryption of an unknown message.
Shortly, we will return to consideration of the multiple-message case.)
Chosen-plaintext attacks in the real world. Are chosen-plaintext at-
tacks a realistic concern? For starters, note that chosen-plaintext attacks also
encompass known-plaintext attacks —in which the attacker knows what mes-
sages are being encrypted, even if it does not get to choose them—as a special
case. Moreover, there are several real-world scenarios in which an adversary
might have signiﬁcant inﬂuence over what messages get encrypted. A simple
example is given by an attacker typing on a terminal, which in turn encrypts
and sends everything the adversary types using a key shared with a remote
server(and unknownto the attacker). Herethe attackerexactlycontrolswhat
gets encrypted, but the encryption scheme should remain secure when it is
used—with the same key— to encrypt data for another user.
Interestingly, chosen-plaintext attacks have also been used successfully as
part of historical eﬀorts to break military encryption schemes. For example,
during World War II the British placed mines at certain locations, knowing
that the Germans—when ﬁnding those mines—would encrypt the locations
and send them back to headquarters. These encrypted messages were used
by cryptanalysts at Bletchley Park to break the German encryption scheme.
Another example is given by the famous story involving the Battle of Mid-
way. In May 1942, US Navy cryptanalysts intercepted an encrypted message
from the Japanese which they were able to partially decode. The result in-74 Introduction to Modern Cryptography
dicated that the Japanese were planning an attack on AF, whereAFwas a
ciphertext fragment that the US was unable to decode. For other reasons,
the US believed that Midway Island was the target. Unfortunately, their at-
tempts to convince Washington planners that this was the case were futile;
the general belief was that Midway could not possibly be the target. The
Navy cryptanalysts devised the following plan: They instructed US forces at
Midway to send a fake message that their freshwater supplies were low. The
Japanese intercepted this message and immediately reported to their superi-
ors that “ AFis low on water.” The Navy cryptanalysts now had their proof
thatAFcorrespondedto Midway, and the US dispatchedthree aircraftcarriers
to that location. The result was that Midway was saved, and the Japanese
incurred signiﬁcant losses. This battle was a turning point in the war between
the US and Japan in the Paciﬁc.
The Navy cryptanalysts here carried out a chosen-plaintext attack, as they
were able to inﬂuence the Japanese (albeit in a roundabout way) to encrypt
the word “Midway.” If the Japanese encryption scheme had been secure
against chosen-plaintext attacks, this strategy by the US cryptanalysts would
not have worked (and history may have turned out very diﬀerently)!
CPA-security. In the formal deﬁnition we model chosen-plaintext attacks
by giving the adversary Aaccess to an encryption oracle , viewed as a “black
box” that encrypts messages of A’s choice using a key kthat is unknown
toA. That is, we imagine Ahas access to an “oracle” Enck(·); whenA
queriesthis oracle by providing it with a message mas input, the oracle
returns a ciphertext c←Enck(m) as the reply. (When Encis randomized, the
oracle uses fresh randomness each time it answers a query.) The adversary is
allowed to interact with the encryption oracle adaptively, as many times as it
likes.
Consider the following experiment deﬁned for any encryption scheme Π =
(Gen,Enc,Dec), adversaryA, and value nfor the security parameter:
The CPA indistinguishability experiment PrivKcpa
A,Π(n):
1. A key kis generated by running Gen(1n).
2. The adversary Ais given input 1nand oracle access to Enck(·),
and outputs a pair of messages m0,m1of the same length.
3. A uniform bit b∈ {0,1}is chosen, and then a ciphertext
c←Enck(mb)is computed and given to A.
4. The adversary Acontinues to have oracle access to Enck(·),
and outputs a bit b/prime.
5. The output of the experiment is deﬁned to be 1ifb/prime=b, and
0otherwise. In the former case, we say that Asucceeds.Private-Key Encryption 75
DEFINITION 3.22 A private-key encryption scheme Π = (Gen,Enc,Dec)
hasindistinguishable encryptions under a chosen-plaintext attack , or isCPA-
secure, if for all probabilistic polynomial-time adversaries Athere is a negli-
gible function neglsuch that
Pr/bracketleftBig
PrivKcpa
A,Π(n) = 1/bracketrightBig
≤1
2+negl(n),
where the probability is taken over the randomness used by A, as well as the
randomness used in the experiment.
CPA-Security for Multiple Encryptions
Deﬁnition 3.22 can be extended to the case of multiple encryptions in the
same way that Deﬁnition 3.8 is extended to give Deﬁnition 3.19, i.e., by using
lists of plaintexts. Here, we take a diﬀerent approach that is somewhat sim-
pler and has the advantage of modeling attackers that can adaptively choose
plaintexts to be encrypted, even after observing previous ciphertexts. In the
present deﬁnition, we give the attacker access to a “left-or-right” oracle LRk,b
that, on input a pair of equal-length messages m0,m1, computes the cipher-
textc←Enck(mb) and returns c. That is, if b= 0 then the adversaryreceives
an encryption of the “left” plaintext, and if b= 1 then it receives an encryp-
tion of the “right” plaintext. Here, bis a random bit chosen at the beginning
of the experiment, and as in previous deﬁnitions the goal of the attacker is
to guess b. This generalizes the previous deﬁnition of multiple-message secu-
rity (Deﬁnition 3.19) because instead of outputting the lists ( m0,1,...,m 0,t)
and (m1,1,...,m 1,t), one of whose messages will be encrypted, the attacker
can now sequentially query LRk,b(m0,1,m1,1), ...,LRk,b(m0,t,m1,t). This also
encompasses the attacker’s access to an encryption oracle, since the attacker
can simply query LRk,b(m,m) to obtain Enck(m).
We now formally deﬁne this experiment, called the LR-oracle experiment.
Let Π be an encryptionscheme, Aan adversary,and nthe securityparameter:
The LR-oracle experiment PrivKLR-cpa
A,Π(n):
1. A key kis generated by running Gen(1n).
2. A uniform bit b∈{0,1}is chosen.
3. The adversary Ais given input 1nand oracle access to LRk,b(·,·),
as deﬁned above.
4. The adversary Aoutputs a bit b/prime.
5. The output of the experiment is deﬁned to be 1ifb/prime=b, and
0otherwise. In the former case, we say that Asucceeds.76 Introduction to Modern Cryptography
DEFINITION 3.23 Private-key encryption scheme Πhasindistinguish-
able multiple encryptions under a chosen-plaintext attack , or isCPA-secure for
multipleencryptions , if for all probabilistic polynomial-time adversaries Athere
is a negligible function neglsuch that
Pr/bracketleftBig
PrivKLR-cpa
A,Π(n) = 1/bracketrightBig
≤1
2+negl(n),
where the probability is taken over the randomness used by Aand the random-
ness used in the experiment.
OurearlierdiscussionshowsthatCPA-securityformultipleencryptionsisat
leastasstrongasall ourpreviousdeﬁnitions. In particular, ifaprivate-keyen-
cryptionscheme isCPA-secureformultiple encryptionsthen it is clearlyCPA-
secure as well. Importantly, the converse also holds; that is, CPA-security
implies CPA-security for multiple encryptions. (This stands in contrast to
the case of eavesdropping adversaries; see Proposition 3.20.) We state the fol-
lowing theorem here without proof; a similar result in the public-key setting
is proved in Section 11.2.2.
THEOREM 3.24 Any private-key encryption scheme that is CPA-secure
is also CPA-secure for multipleencryptions.
ThisisasigniﬁcanttechnicaladvantageofCPA-security: Itsuﬃcesto prove
that a scheme is CPA-secure(for a single encryption), and we then obtain “for
free” that it is CPA-secure for multiple encryptions as well.
Security againstchosen-plaintextattacks is nowadaysthe minimal notion of
securityan encryptionschemeshould satisfy, thoughit is becoming morecom-
mon to require even the stronger security properties discussed in Section 4.5.
Fixed-length vs. arbitrary-length messages. Another advantage of
working with the deﬁnition of CPA-security is that it allows us to treat ﬁxed-
length encryption schemes without loss of generality. In particular, given any
CPA-secure ﬁxed-length encryption scheme Π = ( Gen,Enc,Dec), it is possi-
ble to construct a CPA-secure encryption scheme Π/prime= (Gen/prime,Enc/prime,Dec/prime) for
arbitrary-length messages quite easily. For simplicity, say Π encrypts mes-
sages that are 1-bit long (though everything we say extends in the natural
way regardless of the message length supported by Π). Leave Gen/primethe same
asGen. Deﬁne Enc/prime
kfor any message m(having some arbitrary length /lscript) as
Enc/prime
k(m) =Enck(m1),...,Enck(m/lscript), where midenotes the ith bit of m. De-
cryption is done in the natural way. Π/primeis CPA-secure if Π is; a proof follows
from Theorem 3.24.
There are more eﬃcient ways to encrypt messages of arbitrary length than
by adapting a ﬁxed-length encryption scheme in the above manner. We ex-
plore this further in Section 3.6.Private-Key Encryption 77
3.5 Constructing CPA-Secure Encryption Schemes
Before constructing encryption schemes secure against chosen-plaintext at-
tacks, we ﬁrst introduce the important notion of pseudorandom functions .
3.5.1 Pseudorandom Functions and Block Ciphers
Pseudorandom functions (PRFs) generalize the notion of pseudorandom
generators. Now, instead of considering “random-looking” stringswe con-
sider “random-looking” functions . As in our earlier discussion of pseudo-
randomness, it does not make much sense to say that any ﬁxedfunction
f:{0,1}∗→{0,1}∗is pseudorandom (in the same way that it makes little
sense to say that any ﬁxed function is random). Thus, we must instead refer
to the pseudorandomness of a distribution on functions. Such a distribution
is induced naturally by considering keyed functions , deﬁned next.
A keyed function F:{0,1}∗×{0,1}∗→{0,1}∗is a two-input function,
where the ﬁrst input is called the keyand denoted k. We say Fiseﬃ-
cientif there is a polynomial-time algorithm that computes F(k,x) given
kandx. (We will only be interested in eﬃcient keyed functions.) In typ-
ical usage a key kis chosen and ﬁxed, and we are then interested in the
single-input function Fk:{0,1}∗→{0,1}∗deﬁned by Fk(x) =F(k,x). The
security parameter ndictates the key length, input length, and output length.
That is, we associate with Fthree functions /lscriptkey,/lscriptin, and/lscriptout; for any key
k∈{0,1}/lscriptkey(n), the function Fkis only deﬁned for inputs x∈{0,1}/lscriptin(n), in
which case Fk(x)∈{0,1}/lscriptout(n). Unless stated otherwise, we assume for sim-
plicity that Fislength-preserving , meaning /lscriptkey(n) =/lscriptin(n) =/lscriptout(n) =n.
That is, by ﬁxing a key k∈{0,1}nwe obtain a function Fkmapping n-bit
input strings to n-bit output strings.
A keyed function Finduces a natural distribution on functions given by
choosing a uniform key k∈{0,1}nand then considering the resulting single-
input function Fk. We call Fpseudorandom if the function Fk(for a uniform
keyk) is indistinguishable from a function chosen uniformly at random from
thesetofallfunctionshavingthesamedomainandrange; thatis, ifnoeﬃcient
adversarycandistinguish—inasensewemorecarefullydeﬁnebelow—whether
it is interacting with Fk(for uniform k) orf(wherefis chosen uniformly
from the set of all functions mapping n-bit inputs to n-bit outputs).
Since choosing a function at random is less intuitive than choosing a string
at random, it is worth spending a bit more time on this idea. Consider the
setFuncnof all functions mapping n-bit strings to n-bit strings. This set is
ﬁnite, and selecting a uniform function mapping n-bit strings to n-bit strings
means choosing an element uniformly from this set. How large is Funcn? A
function fis speciﬁed by giving its value on each point in its domain. We can
view any function (over a ﬁnite domain) as a large look-up table that stores78 Introduction to Modern Cryptography
f(x) in the row of the table labeled by x. Forf∈Funcn, the look-up table
forfhas 2nrows (one for each point of the domain {0,1}n), with each row
containing an n-bit string (since the range of fis{0,1}n). Concatenating all
the entries of the table, we see that any function in Funcncan be represented
by a string of length 2n·n. Moreover, this correspondence is one-to-one, as
each string of length 2n·n(i.e., each table containing 2nentries of length n)
deﬁnes a unique function in Funcn. Thus, the size of Funcnis exactly the
number of strings of length n·2n, or|Funcn|= 2n·2n.
Viewing a function as a look-up table provides another useful way to think
about selecting a uniform function f∈Funcn: It is exactly equivalent to
choosing each row in the look-up table of funiformly. This means, in par-
ticular, that the values f(x) andf(y) (for any two inputs x/negationslash=y) are uniform
and independent. We can view this look-up table being populated by random
entries in advance, before fis evaluated on any input, or we can view entries
of the table being chosen uniformly “on-the-ﬂy,” as needed, whenever fis
evaluated on a new input on which fhas not been evaluated before.
Coming back to our discussion of pseudorandom functions, recall that a
pseudorandom function is a keyed function Fsuch that Fk(fork∈{0,1}n
chosenuniformlyatrandom)isindistinguishablefrom f(forf∈Funcnchosen
uniformlyat random). The formerischosenfromadistribution over(at most)
2ndistinct functions, whereas the latter is chosen from all 2n·2nfunctions in
Funcn. Despite this, the “behavior” of these functions must look the same to
any polynomial-time distinguisher.
A ﬁrst attempt at formalizingthe notion of a pseudorandomfunction would
be to proceed in the same way as in Deﬁnition 3.14. That is, we could require
that every polynomial-time distinguisher Dthat receives a description of the
pseudorandom function Fkoutputs 1 with “almost” the same probability as
when it receivesa descriptionofa randomfunction f. However,this deﬁnition
is inappropriate since the description of a random function has exponential
length(given by its look-up table of length n·2n), while Dis limited to
running in polynomial time. So, Dwould not even have suﬃcient time to
examine its entire input.
The deﬁnition therefore gives Daccess to an oracleOwhich is either equal
toFk(foruniform k) orf(forauniformfunction f). Thedistinguisher Dmay
query its oracle at any point x, in response to which the oracle returns O(x).
We treat the oracle as a black box in the same way as when we provided the
adversary with oracle access to the encryption algorithm in the deﬁnition of a
chosen-plaintext attack. Here, however, the oracle computes a deterministic
function and so returns the same result if queried twice on the same input.
(For this reason, we may assume without loss of generality that Dnever
queries the oracle twice on the same input.) Dmay interact freely with its
oracle, choosing its queries adaptively based on all previous outputs. Since D
runs in polynomial time, however, it can ask only polynomially many queries.
We now present the formal deﬁnition. (The deﬁnition assumes Fis length-
preserving for simplicity only.)Private-Key Encryption 79
DEFINITION 3.25 LetF:{0,1}∗×{0,1}∗→{0,1}∗be an eﬃcient,
length-preserving, keyed function. Fis apseudorandom function if for all
probabilistic polynomial-time distinguishers D, there is a negligible function
neglsuch that:
/vextendsingle/vextendsingle/vextendsinglePr[DFk(·)(1n) = 1]−Pr[Df(·)(1n) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl(n),
where the ﬁrst probability is taken over uniform choice of k∈{0,1}nand the
randomness of D, and the second probability is taken over uniform choice of
f∈Funcnand the randomness of D.
An important point is that Disnotgiven the key k. It is meaningless to
require that Fkbe pseudorandom if kis known, since given kit is trivial to
distinguish an oracle for Fkfrom an oracle for f. (All the distinguisher has
to do is query the oracle at any point xto obtain the answer y, and compare
this to the result y/prime:=Fk(x) that it computes itself using the known value k.
An oracle for Fkwill return y=y/prime, while an oracle for a random function will
havey=y/primewith probability only 2−n.) This means that if kis revealed, any
claims about the pseudorandomness of Fkno longer hold. To take a concrete
example, if Fis a pseudorandom function, then given oracle access to Fk(for
uniform k) it must be hard to ﬁnd an input xfor which Fk(x) = 0n(since it
would be hard to ﬁnd such an input for a truly random function f). But if k
is known, ﬁnding such an input may be easy.
Example 3.26
As usual, we can gain familiarity with the deﬁnition by looking at an insecure
example. Deﬁne the keyed, length-preserving function FbyF(k,x) =k⊕x.
For any input x, the value of Fk(x) is uniformly distributed (when kis uni-
form). Nevertheless, Fis not pseudorandomsince its values on any twopoints
are correlated. Concretely, consider the distinguisher Dthat queries its or-
acleOon arbitrary, distinct points x1,x2to obtain values y1=O(x1) and
y2=O(x2), and outputs 1 if and only if y1⊕y2=x1⊕x2. IfO=Fk, for
anyk, thenDoutputs 1. On the other hand, if O=fforfchosen uniformly
fromFuncn, then the probability that f(x1)⊕f(x2) =x1⊕x2is exactly the
probability that f(x2) =x1⊕x2⊕f(x1), or 2−n, andDoutputs 1 with this
probability. The diﬀerence is |1−2−n|, which is not negligible. ♦
Pseudorandom Permutations/Block Ciphers
LetPermnbe the set of all permutations (i.e., bijections) on {0,1}n. View-
ing any f∈Permnas a look-up table as before, we now have the added
constraint that the entries in any two distinct rows must be diﬀerent. We
have 2ndiﬀerent choices for the entry in the ﬁrst row of the table; once we
ﬁx this entry, we are left with only 2n−1 choices for the second row, and so
on. We thus see that the size of Permnis (2n)!.80 Introduction to Modern Cryptography
LetFbe a keyed function. We call Fakeyed permutation if/lscriptin=/lscriptout, and
furthermore for all k∈/lscriptkey(n) the function Fk:{0,1}/lscriptin(n)→{0,1}/lscriptin(n)is
one-to-one (i.e., Fkis a permutation). We call /lscriptintheblock length ofF.
As before, unless stated otherwise we assume Fislength-preserving and
so/lscriptkey(n) =/lscriptin(n) =n. A keyed permutation is eﬃcient if there is a
polynomial-time algorithm for computing Fk(x) givenkandx, as well as
a polynomial-time algorithm for computing F−1
k(y) givenkandy. That is,
Fkshould be both eﬃciently computable and eﬃciently invertible givenk.
The deﬁnition of what it means for an eﬃcient, keyed permutation Fto be
apseudorandom permutation is exactly analogous to Deﬁnition 3.25, with the
only diﬀerence being that now we require Fkto be indistinguishable from a
uniformpermutation rather than a uniform function. That is, we require that
no eﬃcient algorithm can distinguish between accessto Fk(for uniform key k)
and access to f(for uniform f∈Permn). It turns out that this is merely an
aesthetic choice since, whenever the block length is suﬃciently long, a random
permutation is itself indistinguishable from a random function. Intuitively
this is due to the fact that a uniform function flooks identical to a uniform
permutation unless distinct values xandyare found for which f(x) =f(y),
since in such a case the function cannot be a permutation. However, the
probability of ﬁnding such values x,yusing a polynomial number of queries
is negligible. (This follows from the results of Appendix A.4.)
PROPOSITION 3.27 IfFis a pseudorandom permutation and addition-
ally/lscriptin(n)≥n, thenFis also a pseudorandom function.
IfFis a keyed permutation then cryptographic schemes based on Fmight
require the honest parties to compute the inverse F−1
kin addition to com-
putingFkitself. This potentially introduces new security concerns. In par-
ticular, it may now be necessary to impose the stronger requirement that Fk
be indistinguishable from a uniform permutation even if the distinguisher is
additionally given oracle access to the inverse of the permutation . IfFhas
this property, we call it a strongpseudorandom permutation.
DEFINITION 3.28 LetF:{0,1}∗×{0,1}∗→{0,1}∗be an eﬃcient,
length-preserving, keyed permutation. Fis astrong pseudorandom permuta-
tionif for all probabilistic polynomial-time distinguishers D, there exists a
negligible function neglsuch that:
/vextendsingle/vextendsingle/vextendsinglePr[DFk(·),F−1
k(·)(1n) = 1]−Pr[Df(·),f−1(·)(1n) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl(n),
where the ﬁrst probability is taken over uniform choice of k∈{0,1}nand the
randomness of D, and the second probability is taken over uniform choice of
f∈Permnand the randomness of D.
Of course, any strong pseudorandom permutation is also a pseudorandom
permutation.Private-Key Encryption 81
Block ciphers. In practice, block ciphers are designed to be secure instan-
tiations of (strong) pseudorandom permutations with some ﬁxedkey length
and block length. We discuss approaches for building block ciphers, and some
popularcandidate blockciphers, in Chapter 6. Forthe purposesofthe present
chapter the details of these constructions are unimportant, and for now we
simply assume that (strong) pseudorandom permutations exist.
Pseudorandom functions and pseudorandom generators. As one
might expect, there is a close relationship between pseudorandom functions
and pseudorandom generators. It is fairly easy to construct a pseudorandom
generator Gfrom a pseudorandom function Fby simply evaluating Fon a
series of diﬀerent inputs; e.g., we can deﬁne G(s)def=Fs(1)/bardblFs(2)/bardbl···/bardblFs(/lscript)
for any desired /lscript. IfFswere replaced by a uniform function f, the output of G
would be uniform; thus, when using Finstead, the output is pseudorandom.
You are asked to prove this formally in Exercise 3.14.
More generally, we can use the above idea to construct a stream cipher
(Init,GetBits) that accepts an initialization vector IV. (See Section 3.3.1.)
The onlydiﬀerence isthat insteadofevaluating Fsonthe ﬁxed input sequence
1,2,3,..., we evaluate Fon the inputs IV+1,IV+2, ....
CONSTRUCTION 3.29
LetFbe a pseudorandom function. Deﬁne a stream cipher ( Init,
GetBits), where each call to GetBitsoutputs nbits, as follows:
•Init: on input s∈{0,1}nandIV∈{0,1}n, setst0:= (s,IV).
•GetBits: on input sti= (s,IV), compute IV/prime:=IV+1 and set
y:=Fs(IV/prime) andsti+1:= (s,IV/prime). Output ( y,sti+1).
A stream cipher from any pseudorandom function/block cipher.
Although stream ciphers can be constructed from block ciphers, dedicated
streamciphersusedinpracticetypicallyhavebetterperformance,especiallyin
resource-constrainedenvironments. Onthe otherhand, streamciphersappear
to be less well understood (in practice) than block ciphers, and conﬁdence
in their security is lower. It is therefore recommended to use block ciphers
(possibly by converting them to stream ciphers ﬁrst) whenever possible.
Considering the other direction, a pseudorandom generator Gimmedi-
ately gives a pseudorandom function Fwith small block length . Speciﬁ-
cally, say Ghas expansion factor n·2t(n). We can deﬁne the keyed function
F:{0,1}n×{0,1}t(n)→{0,1}nas follows: to compute Fk(i), ﬁrst com-
puteG(k) and interpret the result as a look-up table with 2t(n)rows each
containing nbits; output the ith row. This runs in polynomial time only if
t(n) =O(logn). It is possible, though more diﬃcult, to construct pseudoran-
dom functions with large block length from pseudorandom generators; this is82 Introduction to Modern Cryptography
shown in Section 7.5. Pseudorandom generators, in turn, can be constructed
based on certain mathematical problems conjectured to be hard. The exis-
tence of pseudorandom functions based on these hard mathematical problems
represents one of the amazing contributions of modern cryptography.
3.5.2 CPA-Secure Encryption from Pseudorandom Functions
WefocushereonconstructingaCPA-secure,ﬁxed-lengthencryptionscheme.
By what we have said at the end of Section 3.4.2, this implies the existence of
a CPA-secure encryption scheme for arbitrary-lengthmessages. In Section 3.6
we will discuss more eﬃcient ways of encrypting messages of arbitrary length.
A naive attempt at constructing a secure encryption scheme from a pseu-
dorandom permutation is to deﬁne Enck(m) =Fk(m). Although we expect
that this “reveals no information about m” (since, if fis a uniform function,
thenf(m) is simply a uniform n-bit string), this method of encryption is de-
terministic and so cannot possibly be CPA-secure. In particular, encrypting
the same plaintext twice will yield the same ciphertext.
Our secure construction is randomized . Speciﬁcally, we encrypt by applying
thepseudorandomfunction toa random value r(ratherthanthemessage)and
XORing the result with the plaintext. (See Figure 3.3 and Construction 3.30.)
This can again be viewed as an instance of XORing a pseudorandom pad with
the plaintext, with the major diﬀerence being the fact that a freshpseudoran-
dom pad is used each time. (In fact, the pseudorandom pad is only “fresh” if
the pseudorandom function is applied to a “fresh” value on which it has never
been applied before. While it is possible that a random rwill be equalto some
r-value chosen previously, this happens with only negligible probability.)
/MT67/MT105/MT112/MT104/MT101/MT114/MT116/MT101/MT120/MT116/MT112/MT97/MT100
/MT88/MT79/MT82 /MT80/MT108/MT97/MT105/MT110/MT116/MT101/MT120/MT116/MT82/MT97/MT110/MT100/MT111/MT109/MT32/MT115/MT116/MT114/MT105/MT110/MT103/MT32/MT114
/MT80/MT115/MT101/MT117/MT100/MT111/MT114/MT97/MT110/MT100/MT111/MT109
/MT102/MT117/MT110/MT99/MT116/MT105/MT111/MT110
FIGURE 3.3 :Encryption with a pseudorandom function.Private-Key Encryption 83
Proofs of security based on pseudorandom functions. Before turning
totheproofthattheaboveconstructionisCPA-secure,wehighlightacommon
template that is used by most proofs of security (even outside the context of
encryption) for constructions based on pseudorandom functions. The ﬁrst
step of such proofs is to consider a hypothetical version of the construction
in which the pseudorandom function is replaced with a random function. It
is then argued—using a proof by reduction—that this modiﬁcation does not
signiﬁcantly aﬀect the attacker’s success probability. We are then left with
analyzing a scheme that uses a completely random function. At this point the
rest of the proof typically relies on probabilistic analysis and does not rely on
any computational assumptions. We will utilize this proof template several
times in this and the next chapter.
CONSTRUCTION 3.30
LetFbe a pseudorandom function. Deﬁne a private-key encryption
scheme for messages of length nas follows:
•Gen: on input 1n, choose uniform k∈{0,1}nand output it.
•Enc: on input a key k∈{0,1}nand a message m∈{0,1}n, choose
uniform r∈{0,1}nand output the ciphertext
c:=/angbracketleftr, Fk(r)⊕m/angbracketright.
•Dec: on input a key k∈{0,1}nand a ciphertext c=/angbracketleftr,s/angbracketright, output
the plaintext message
m:=Fk(r)⊕s.
A CPA-secure encryption scheme from any pseudorandom function.
THEOREM3.31 IfFis apseudorandom function, then Construction 3.30
is a CPA-secure private-key encryption scheme for messages of length n.
PROOF Let/tildewideΠ = (/tildewidestGen,/tildewidestEnc,/tildewidestDec) be an encryption scheme that is exactly
the same as Π = ( Gen,Enc,Dec) from Construction 3.30, except that a truly
random function fis used in place of Fk. That is,/tildewidestGen(1n) chooses a uniform
function f∈Funcn, and/tildewidestEncencrypts just like Encexcept that fis used
instead of Fk. (This modiﬁed encryption scheme is not eﬃcient. But we can
still deﬁne it as a hypothetical encryption scheme for the sake of the proof.)
Fix an arbitrary pptadversaryA, and let q(n) be an upper bound on the
number of queries that A(1n) makes to its encryption oracle. (Note that q
must be upper-bounded by some polynomial.) As the ﬁrst step of the proof,
we show that there is a negligible function neglsuch that
/vextendsingle/vextendsingle/vextendsinglePr/bracketleftBig
PrivKcpa
A,Π(n) = 1/bracketrightBig
−Pr/bracketleftBig
PrivKcpa
A,/tildewideΠ(n) = 1/bracketrightBig/vextendsingle/vextendsingle/vextendsingle≤negl(n).(3.8)84 Introduction to Modern Cryptography
We prove this by reduction. We use Ato construct a distinguisher Dfor
the pseudorandom function F. The distinguisher Dis given oracle access
to some function O, and its goal is to determine whether this function is
“pseudorandom” (i.e., equal to Fkfor uniform k∈{0,1}n) or “random” (i.e.,
equaltofforuniform f∈Funcn). Todothis, Demulatesexperiment PrivKcpa
forAin the manner described below, and observeswhether Asucceeds or not.
IfAsucceedsthen Dguessesthat itsoraclemust beapseudorandomfunction,
whereasifAdoes notsucceedthen Dguessesthat its oraclemust be arandom
function. In detail:
Distinguisher D:
Dis given input 1nand access to an oracle O:{0,1}n→{0,1}n.
1. RunA(1n). WheneverAqueries its encryption oracle on a
message m∈{0,1}n, answer this query in the following way:
(a) Choose uniform r∈{0,1}n.
(b) QueryO(r) and obtain response y.
(c) Return the ciphertext /angbracketleftr,y⊕m/angbracketrighttoA.
2. WhenAoutputs messages m0,m1∈{0,1}n, choose a uni-
form bit b∈{0,1}and then:
(a) Choose uniform r∈{0,1}n.
(b) QueryO(r) and obtain response y.
(c) Return the challenge ciphertext /angbracketleftr,y⊕mb/angbracketrighttoA.
3. Continue answering encryption-oracle queries of Aas before
untilAoutputs a bit b/prime. Output 1 if b/prime=b, and 0 otherwise.
Druns in polynomial time since Adoes. The key points are as follows:
1. IfD’s oracle is a pseudorandom function, then the view of Awhen
run as a subroutine by Dis distributed identically to the view of A
in experiment PrivKcpa
A,Π(n). This is because, in this case, a key kis
chosen uniformly at random and then every encryption is carried out by
choosing a uniform r, computing y:=Fk(r), and setting the ciphertext
equal to/angbracketleftr,y⊕m/angbracketright, exactly as in Construction 3.30. Thus,
Prk←{0,1}n/bracketleftBig
DFk(·)(1n) = 1/bracketrightBig
= Pr/bracketleftBig
PrivKcpa
A,Π(n) = 1/bracketrightBig
,(3.9)
where we emphasize that kis chosen uniformly on the left-hand side.
2. IfD’s oracle is a random function, then the view of Awhen run as a
subroutineby Dis distributed identically to the view of Ain experiment
PrivKcpa
A,/tildewideΠ(n). This can be seen exactly as above, with the only diﬀerence
being that a uniform function f∈Funcnis used instead of Fk. Thus,
Prf←Funcn/bracketleftBig
Df(·)(1n) = 1/bracketrightBig
= Pr/bracketleftBig
PrivKcpa
A,/tildewideΠ(n) = 1/bracketrightBig
,(3.10)
wherefis chosen uniformly from Funcnon the left-hand side.Private-Key Encryption 85
By the assumption that Fis a pseudorandom function (and since Dis eﬃ-
cient), there exists a negligible function neglfor which
/vextendsingle/vextendsingle/vextendsinglePr/bracketleftBig
DFk(·)(1n) = 1/bracketrightBig
−Pr/bracketleftBig
Df(·)(1n) = 1/bracketrightBig/vextendsingle/vextendsingle/vextendsingle≤negl(n).
Combining the above with Equations (3.9) and (3.10) gives Equation (3.8).
For the second part of the proof, we show that
Pr/bracketleftBig
PrivKcpa
A,/tildewideΠ(n) = 1/bracketrightBig
≤1
2+q(n)
2n. (3.11)
(Recall that q(n) is a bound on the number of encryption queries made by A.
The above holds even if we place no computational restrictions on A.) To see
that Equation (3.11) holds, observe that every time a message mis encrypted
inPrivKcpa
A,/tildewideΠ(n) (either by the encryption oracle or when the challenge cipher-
text is computed), a uniform r∈{0,1}nis chosen and the ciphertext is set
equal to/angbracketleftr, f(r)⊕m/angbracketright. Letr∗denote the randomstring used when generating
the challenge ciphertext /angbracketleftr∗,f(r∗)⊕mb/angbracketright. There are two possibilities:
1.The value r∗is never used when answering any of A’s encryption-oracle
queries: In this case,Alearns nothing about f(r∗) from its interaction
with the encryption oracle (since fis a truly random function). This
means that, as far as Ais concerned, the value f(r∗) that is XORed
withmbis uniformly distributed and independent of the rest of the
experiment, and so the probability that Aoutputsb/prime=bin this case is
exactly 1 /2 (as in the case of the one-time pad).
2.The value r∗is used when answering at least one of A’s encryption-
oracle queries: In this case,Amay easily determine whether m0orm1
was encrypted. This is so because if the encryption oracle ever returns
a ciphertext/angbracketleftr∗,s/angbracketrightin response to a request to encrypt the message m,
the adversary learns that f(r∗) =s⊕m.
However, sinceAmakes at most q(n) queries to its encryption ora-
cle (and thus at most q(n) values of rare used when answering A’s
encryption-oraclequeries),andsince r∗ischosenuniformlyfrom {0,1}n,
the probability of this event is at most q(n)/2n.
LetRepeatdenote the event that r∗is used by the encryption oracle when
answering at least one of A’s queries. As just discussed, the probability of
Repeatis at most q(n)/2n, and the probability that Asucceeds in PrivKcpa
A,/tildewideΠ
ifRepeatdoes not occur is exactly 1 /2. Therefore:
Pr[PrivKcpa
A,/tildewideΠ(n) = 1]
= Pr[PrivKcpa
A,/tildewideΠ(n) = 1∧Repeat]+Pr[PrivKcpa
A,/tildewideΠ(n) = 1∧Repeat]
≤Pr[Repeat]+Pr[PrivKcpa
A,/tildewideΠ(n) = 1|Repeat]≤q(n)
2n+1
2.86 Introduction to Modern Cryptography
Combining the above with Equation (3.8), we see that there is a negligible
function neglsuch that Pr[ PrivKcpa
A,Π(n) = 1]≤1
2+q(n)
2n+negl(n). Since
qis polynomial,q(n)
2nisnegligible. In addition, the sum of two negligible
functions is negligible, and thus there exists a negligible function negl/primesuch
that Pr[PrivKcpa
A,Π(n) = 1]≤1
2+negl/prime(n), completing the proof.
Concrete security. The above proof shows that
Pr[PrivKcpa
A,Π(n) = 1]≤1
2+q(n)
2n+negl(n)
for some negligible function negl. The ﬁnal term depends on the security of F
as a pseudorandom function; it is a bound on the distinguishing probability of
algorithm D(which has roughly the same running time as the adversary A).
The termq(n)
2nrepresents a bound on the probability that the value r∗used
to encrypt the challenge ciphertext was used to encrypt some other message.
3.6 Modes of Operation
Modes of operation provide a way to securely (and eﬃciently) encrypt long
messages using stream or block ciphers.
3.6.1 Stream-Cipher Modes of Operation
Construction 3.17 provides a way to construct an encryption scheme using
a pseudorandom generator. That scheme has two main drawbacks. First, as
presented, the length ofthe message to be encrypted must be ﬁxed and known
in advance. Second, the scheme is only EAV-secure, not CPA-secure.
Stream ciphers, which can be viewed as ﬂexible pseudorandom generators,
can be used to address these drawbacks. In practice, stream ciphers are used
for encryption in two ways: synchronized mode andunsynchronized mode .
Synchronized mode. In this stateful encryption scheme, the sender and re-
ceiver must be synchronized in the sense that they know how much plaintext
has been encrypted (resp., decrypted) so far. Synchronized mode is typically
used in a single communication session between parties (see Section 4.5.3),
where statefulness is acceptable and messages are received in order without
being lost. The intuition here is that a long pseudorandom stream is gener-
ated, and a diﬀerent part of it is used to encrypt each message. Synchroniza-
tion is needed to ensure correct decryption (i.e., so the receiver knows which
part of the stream was used to encrypt the next message), and to ensure that
no portion of the stream is re-used. We describe this mode in detail next.Private-Key Encryption 87
/MT109/MT50 /MT99/MT50/MT80/MT97/MT114/MT116/MT32/MT49 /MT80/MT97/MT114/MT116/MT32/MT50 /MT80/MT97/MT114/MT116/MT32/MT51/MT83/MT121/MT110/MT99/MT104/MT114/MT111/MT110/MT105/MT122/MT101/MT100
/MT77/MT111/MT100/MT101/MT107 /MT71
/MT109/MT49 /MT99/MT49 /MT109/MT50 /MT99/MT50 /MT109/MT51 /MT99/MT51
/MT80/MT97/MT114/MT116/MT32/MT49 /MT80/MT97/MT114/MT116/MT32/MT50 /MT80/MT97/MT114/MT116/MT32/MT51/MT85/MT110/MT115/MT121/MT110/MT99/MT104/MT114/MT111/MT110/MT105/MT122/MT101/MT100
/MT77/MT111/MT100/MT101
/MT73/MT86/MT49/MT107
/MT71
/MT109/MT49 /MT99/MT49 /MT109/MT51 /MT99/MT51/MT71
/MT73/MT86/MT50 /MT73/MT86/MT51/MT71
FIGURE 3.4 :Synchronized mode and unsynchronized mode.
We have seen in Algorithm 3.16 that a stream cipher can be used to con-
struct a pseudorandom generator G/lscriptwith any desired expansion factor /lscript. We
can easily modify that algorithm to obtain a pseudorandom generator G∞
withvariable output length. G∞takes two inputs: a seed sand a desired
output length 1/lscript(we specify this in unary since G∞will run in time polyno-
mial in/lscript). As in Algorithm 3.16, G∞(s,1/lscript) runsInit(s) and then repeatedly
runsGetBitsa total of /lscripttimes.
We can use G∞in Construction 3.17 to handle encryption of arbitrary-
length messages: encryption of a message musing the key kis done by com-
puting the ciphertext c:=G∞(k,1|m|)⊕m; decryption of a ciphertext cusing
the keykis carried out by computing the message m:=G∞(k,1|c|)⊕c. A
minor modiﬁcation of the proof of Theorem 3.18 shows that if the stream ci-
pher is secure then this encryption scheme has indistinguishable encryptions
in the presence of an eavesdropper.
A little thought shows that if the communicating parties are willing to
maintain state, then they can use the same key to encrypt multiple messages.
(See Figure 3.4.) The conceptual insight is that the parties can treat multiple
messages m1,m2,...asasingle, longmessage; furthermore, Construction3.17
(as well as the modiﬁed version in the previous paragraph) has the property
that initial portions of a message can be encrypted and transmitted even if
the rest of the message is not yet known. Concretely, the parties share a key k
and both begin by computing st0:=Init(k). To encrypt the ﬁrst message m1
of length /lscript1, the sender repeatedly runs GetBitsa total of /lscript1times, beginning
atst0, to obtain a stream of bits pad1def=y1,...,y /lscript1along with updated
statest/lscript1; it then sends c1:=pad1⊕m1. Upon receiving c1, the other party
repeatedly runs GetBitsa total of /lscript1times to obtain the same values pad1
andst/lscript1; it uses pad1to recover m1:=pad1⊕c1. Later, to encrypt a second
message m2of length /lscript2, the sender will repeatedly run GetBitsa total of /lscript2
times, beginning at st/lscript1, to obtain pad2def=y/lscript1+1,...,y /lscript1+/lscript2and updated state
st/lscript1+/lscript2, and then compute the ciphertext c2:=pad2⊕m2, and so on. This
can continue indeﬁnitely, allowing the parties to send an unlimited number of
messages of arbitrary length. We remark that in this mode, the stream cipher
does not need to use an IV.88 Introduction to Modern Cryptography
This method of encrypting multiple messages requires the communicating
parties to maintain synchronized state, explaining the terminology “synchro-
nized mode.” For that reason, the method is appropriatewhen twoparties are
communicating within a single “session,” but it does not work well for spo-
radic communication or when a party might, over time, communicate from
diﬀerent devices. (It is relatively easy to keep copies of a ﬁxed key in diﬀerent
locations; it is harder to maintain synchronized state across multiple loca-
tions.) Furthermore, if the parties ever get out of sync (e.g., because one of
the transmissions between the parties is dropped), decryption will return an
incorrect result. Resynchronization is possible, but adds additional overhead.
Unsynchronized mode. For stream ciphers whose Initfunction accepts an
initialization vector as input, we can achieve stateless CPA-secure encryption
for messages of arbitrary length. Here we modify G∞to accept three inputs:
a seeds, an initialization vector IV, and a desired output length 1/lscript. Now this
algorithm ﬁrst computes st0:=Init(s,IV) before repeatedly running GetBits
a total of /lscripttimes. Encryption can then be carried out using a variant of
Construction 3.30: the encryption of a message musing the key kis done
by choosing a uniform initialization vector IV∈{0,1}nand computing the
ciphertext/angbracketleftIV,G∞(s,IV,1|m|)⊕m/angbracketright; decryption is performed in the natural
way. (See Figure 3.4.) This scheme is CPA-secure if the stream cipher now
has the stronger property that, for any polynomial /lscript, the function Fdeﬁned
byFk(IV)def=G∞(k,IV,1/lscript) is a pseudorandom function. (In fact, Fneed
only be pseudorandom when evaluated on uniform inputs. Keyed functions
with this weaker property are called weakpseudorandom functions.)
3.6.2 Block-Cipher Modes of Operation
We have already seen a construction of a CPA-secure encryption scheme
based on pseudorandom functions/block ciphers. But Construction 3.30 (and
its extension to arbitrary-length messages as discussed at the end of Sec-
tion 3.4.2) have the drawback that the length of the ciphertext is doublethe
length of the plaintext. Block-cipher modes of operation provide a way of
encrypting arbitrary-length messages using shorter ciphertexts.
In this section, let Fbe a block cipher with block length n. We assume
here that all messages mbeing encrypted have length a multiple of n, and
writem=m1,m2,...,m /lscriptwhere each mi∈{0,1}nrepresents a block of the
plaintext. Messages that are not a multiple of ncan alwaysbe unambiguously
padded to havelength a multiple of nby appending a1 followedby suﬃciently
many 0s, and so this assumption is without much loss of generality.
Several block-cipher modes of operation are known; we present four of the
most common ones and discuss their security.
Electronic Code Book (ECB) mode. This is a naive mode of operation
in which the ciphertext is obtained by direct application of the block cipher
to each plaintext block. That is, c:=/angbracketleftFk(m1),Fk(m2),...,F k(m/lscript)/angbracketright; seePrivate-Key Encryption 89
/MT70/MT107 /MT70/MT107 /MT70/MT107/MT109/MT49
/MT99/MT51 /MT99/MT49/MT109/MT50
/MT99/MT50/MT109/MT51
FIGURE 3.5 :Electronic Code Book (ECB) mode.
Figure 3.5. Decryption is done in the obvious way, using the fact that F−1
kis
eﬃciently computable.
ECB mode is deterministic and therefore cannot be CPA-secure. Worse,
ECB-mode encryption does not even have indistinguishable encryptions in
the presence of an eavesdropper. This is because if a block is repeated in the
plaintext, it will result in a repeating block in the ciphertext. Thus, it is easy
to distinguish an encryption of a plaintext that consists oftwo identical blocks
from an encryption of a plaintext that consists of two diﬀerent blocks. This is
not just a theoretical problem. Consider encrypting an image in which small
groups of pixels correspond to a plaintext block. Encrypting using ECB mode
may reveal a signiﬁcant amount of information about patterns in the image,
something that should not happen when using a secure encryption scheme.
Figure 3.6 demonstrates this.
For these reasons, ECB mode should never be used. (We include it only
because of its historical signiﬁcance.)
FIGURE 3.6 :An illustration of the dangers of using ECB mode. The
middle ﬁgure is an encryption of the image on the left using ECB mode; the
ﬁgure on the right is an encryption of the same image using a secure mode.
(Taken from http://en.wikipedia.org and derived from images created
by Larry Ewing ( lewing@isc.tamu.edu ) using The GIMP.)90 Introduction to Modern Cryptography
/MT73/MT86
/MT73/MT86/MT70/MT107/MT109 /MT49
/MT70/MT107 /MT70/MT107/MT109 /MT50 /MT109 /MT51
/MT99/MT49 /MT99/MT50 /MT99/MT51
FIGURE 3.7 : Cipher Block Chaining (CBC) mode.
Cipher Block Chaining (CBC) mode. To encrypt using this mode, a
uniform initialization vector ( IV) of length nis ﬁrst chosen. Then, ciphertext
blocks are generated by applying the block cipher to the XOR of the current
plaintext block and the previous ciphertext block. That is, set c0:=IV
and then, for i= 1 to/lscript, setci:=Fk(ci−1⊕mi). The ﬁnal ciphertext is
/angbracketleftc0,c1,...,c /lscript/angbracketright. (See Figure 3.7.) Decryption of a ciphertext c0,...,c /lscriptis done
by computing mi:=F−1
k(ci)⊕ci−1fori= 1,...,/lscript. We stress that the IVis
included in the ciphertext; this is crucial so decryption can be carried out.
Importantly, encryption in CBC mode is probabilistic and it has been
proven that if Fis a pseudorandom permutation then CBC-mode encryp-
tion is CPA-secure. The main drawback of this mode is that encryption must
be carried out sequentially because the ciphertext block ci−1is needed in or-
der to encrypt the plaintext block mi. Thus, if parallel processing is available,
CBC-mode encryption may not be the most eﬃcient choice.
One may be tempted to think that it suﬃces to use a distinctIV(rather
than a random IV) for every encryption, e.g., to ﬁrst use IV= 1 and then
increment the IVby one each time a message is encrypted. In Exercise 3.20,
we ask you to show that this variant of CBC-mode encryption is not secure.
One might also consider a stateful variant of CBC-mode encryption—called
chained CBC mode —in which the last block of the previous ciphertext is used
as theIVwhen encrypting the next message. This reduces the bandwidth, as
theIVneed not be sent each time. See Figure 3.8, where an initial message
m1,m2,m3is encrypted using a random IV, and then subsequently a second
message m4,m5is encrypted using c3as theIV. (In contrast, encryption
using stateless CBC mode would generate a fresh IVwhen encrypting the
second message.) Chained CBC mode is used in SSL 3.0 and TLS 1.0.
It may appear that chained CBC mode is as secure as CBC mode, since
the chained-CBC encryption of m1,m2,m3followed by encryption of m4,m5
yieldsthesameciphertextblocksasCBC-modeencryptionofthe(single)mes-
sagem1,m2,m3,m4,m5. Nevertheless, chained CBC mode is vulnerable to a
chosen-plaintextattack. The basisofthe attackis that theadversaryknowsinPrivate-Key Encryption 91
/MT73/MT86
/MT73/MT86/MT70/MT107/MT109 /MT49
/MT70/MT107 /MT70/MT107/MT109 /MT50 /MT109 /MT51
/MT99/MT49 /MT99/MT50 /MT99/MT51/MT70/MT107/MT109 /MT52
/MT70/MT107/MT109 /MT53
/MT99/MT52 /MT99/MT53/MT99/MT51
FIGURE 3.8 :Chained CBC.
advance the “initialization vector” that will be used for the second encrypted
message. We describe the attack informally, based on Figure 3.8. Assume
the attacker knows that m1∈{m0
1,m1
1}, and observes the ﬁrst ciphertext
IV,c1,c2,c3. The attacker then requests an encryption of a second message
m4,m5withm4=IV⊕m0
1⊕c3, and observes a second ciphertext c4,c5. One
can verify that m1=m0
1if and only if c4=c1. This example should serve as
a strong warning against making any modiﬁcations to cryptographic schemes,
even if those modiﬁcations seem benign.
Output Feedback (OFB) mode. Thethird modewepresentcanbeviewed
as an unsynchronized stream-cipher mode, where the stream cipher is con-
structed in a speciﬁc way from the underlying block cipher. We describe the
mode directly. First, a uniform IV∈{0,1}nis chosen. Then, a pseudoran-
dom stream is generated from IVin the following way: Deﬁne y0:=IV,
and set the ith block yiof the stream to be yi:=Fk(yi−1). Each block of
the plaintext is encrypted by XORing it with the appropriate block of the
stream; that is, ci:=yi⊕mi. (See Figure 3.9.) As in CBC mode, the IVis
included as part of the ciphertext to enable decryption. However, in contrast
to CBC mode, here it is not required that Fbe invertible. (In fact, it need
/MT109/MT49/MT70/MT107
/MT73/MT86 /MT99/MT49/MT109/MT50
/MT99/MT50/MT109/MT51
/MT99/MT51/MT70/MT107 /MT70/MT107/MT73/MT86
FIGURE 3.9 :Output Feedback (OFB) mode.92 Introduction to Modern Cryptography
not even be a permutation.) Furthermore, as in stream-cipher modes of oper-
ation, here it is not necessary for the plaintext length to be a multiple of the
block length. Instead, the generated stream can be truncated to exactly the
plaintext length. Another advantage of OFB mode is that its stateful variant
(in which the ﬁnal value y/lscriptused to encrypt some message is used as the IVfor
encrypting the next message) issecure. This stateful variant is equivalent to
asynchronized stream-cipher mode, with the stream cipher constructed from
the block cipher in the speciﬁc manner just described.
OFBmodecanbeshowntobeCPA-secureif Fisapseudorandomfunction.
Although both encryption and decryption must be carried out sequentially,
this mode has the advantage relative to CBC mode that the bulk of the
computation (namely, computation of the pseudorandomstream) can be done
independently of the actual message to be encrypted. So, it is possible to
generate a pseudorandom stream ahead of time using preprocessing, after
which point encryption of the plaintext (once it is known) is incredibly fast.
/MT70/MT107 /MT70/MT107 /MT70/MT107
/MT109/MT49
/MT99/MT51/MT99/MT116/MT114/MT43/MT49 /MT99/MT116/MT114/MT43/MT50
/MT99/MT49/MT109/MT50
/MT99/MT50/MT109/MT51/MT99/MT116/MT114 /MT99/MT116/MT114/MT43/MT51
/MT99/MT116/MT114
FIGURE 3.10 :Counter (CTR) mode.
Counter (CTR) mode. Counter mode can also be viewed as an unsynchro-
nized stream-cipher mode, where the stream cipher is constructed from the
blockcipherasinConstruction3.29. Wegiveaself-containeddescriptionhere.
To encrypt using CTR mode, a uniform value ctr∈{0,1}nis ﬁrst chosen.
Then, a pseudorandom stream is generated by computing yi:=Fk(ctr+i),
wherectrandiare viewed as integers and addition is done modulo 2n. The
ith ciphertext block is ci:=yi⊕mi, and the IVis again sent as part of the
ciphertext; see Figure 3.10. Note again that decryption does not require Fto
be invertible, or even a permutation. As with OFB mode, another “stream-
cipher” mode, the generated stream can be truncated to exactly the plaintext
length, preprocessingcanbeusedtogeneratethepseudorandomstreambefore
the message is known, and the stateful variant of CTR mode is secure.
In contrast to all the secure modes discussed previously, CTR mode has
the advantage that encryption and decryption can be fully parallelized , since
all the blocks of the pseudorandom stream can be computed independently of
each other. In contrast to OFB, it is also possible to decrypt the ith block ofPrivate-Key Encryption 93
the ciphertext using only a single evaluation of F. These features make CTR
mode an attractive choice.
CTR mode is also fairly simple to analyze:
THEOREM 3.32 IfFis a pseudorandom function, then CTR mode is
CPA-secure.
PROOF We follow the same template as in the proof of Theorem 3.31: we
ﬁrst replace Fwith a random function and then analyze the resulting scheme.
Let Π = ( Gen,Enc,Dec) be the (stateless) CTR-mode encryption scheme,
and let/tildewideΠ = (/tildewidestGen,/tildewidestEnc,/tildewidestDec) be the encryption scheme that is identical to Π
except that a truly random function is used in place of Fk. That is,/tildewidestGen(1n)
chooses a uniform function f∈Funcn, and/tildewidestEncencrypts just like Encexcept
thatfis used instead of Fk. (Once again, neither /tildewidestGennor/tildewidestEncis eﬃcient but
this does not matter for the purposes of deﬁning an experiment involving /tildewideΠ.)
Fix an arbitrary pptadversaryA, and let q(n) be a polynomial upper-
bound on the number of encryption-oracle queries made by A(1n) as well as
the maximum number of blocks in any such query and the maximum number
of blocks in m0andm1. As the ﬁrst step of the proof, we claim that there is
a negligible function neglsuch that
/vextendsingle/vextendsingle/vextendsinglePr/bracketleftBig
PrivKcpa
A,Π(n) = 1/bracketrightBig
−Pr/bracketleftBig
PrivKcpa
A,/tildewideΠ(n) = 1/bracketrightBig/vextendsingle/vextendsingle/vextendsingle≤negl(n).(3.12)
This is proved by reduction in a way similar to the analogousstep in the proof
of Theorem 3.31, and is left as an exercise for the reader.
We next claim that
Pr/bracketleftBig
PrivKcpa
A,/tildewideΠ(n) = 1/bracketrightBig
<1
2+2q(n)2
2n. (3.13)
Combined with Equation (3.12) this means that
Pr/bracketleftBig
PrivKcpa
A,Π(n) = 1/bracketrightBig
<1
2+2q(n)2
2n+negl(n).
Sinceqis polynomial,2q(n)2
2nisnegligible and this completes the proof.
WenowproveEquation(3.13). Fixsomevalue nforthesecurityparameter.
Let/lscript∗≤q(n) denote the length (in blocks) of the messages m0,m1output by
Ain experiment PrivKcpa
A,/tildewideΠ(n), and let ctr∗denote the initial value used when
generating the challenge ciphertext. Similarly, let /lscripti≤q(n) be the length (in
blocks) of the ith encryption-oracle query made by A, and let ctridenote the
initial value used when answering this query. When the ith encryption-oracle
query is answered, fis applied to the values ctri+1,...,ctri+/lscripti. When the
challenge ciphertext is encrypted, fis applied to ctr∗+1,...,ctr∗+/lscript∗, and the
ith ciphertext block is computed by XORing f(ctr∗+i) with the ith message
block. There are two cases:94 Introduction to Modern Cryptography
1.There do not exist any i,j,j∗≥1(withj≤/lscriptiandj∗≤/lscript∗) for which
ctri+j=ctr∗+j∗:In this case, the values f(ctr∗+1),...,f(ctr∗+/lscript∗)
used when encrypting the challengeciphertext are uniformly distributed
and independent of the rest of the experiment since fwas not applied to
any ofthese inputs when encrypting the adversary’soraclequeries. This
means that the challenge ciphertext is computed by XORing a stream
of uniform bits with the message mb, and so the probability that A
outputsb/prime=bis exactly 1 /2 (as in the case of the one-time pad).
2.There exist i,j,j∗≥1(withj≤/lscriptiandj∗≤/lscript∗) for which ctri+j=
ctr∗+j∗:We denote this event by Overlap. In this caseAmay poten-
tially determine which of its messages was encrypted to give the chal-
lengeciphertext, since Acandeducethevalueof f(ctri+j) =f(ctr∗+j∗)
from the answer to its ith oracle query.
Let us analyze the probability that Overlapoccurs. The probability is maxi-
mized if /lscript∗and each /lscriptiare as large as possible, so assume /lscript∗=/lscripti=q(n) for
alli. LetOverlapidenote the event that the sequence ctri+1,...,ctri+q(n)
overlaps the sequence ctr∗+1,...,ctr∗+q(n); thenOverlapis the event that
Overlapioccursfor some i. Since there are at most q(n) oraclequeries, a union
bound (cf. Proposition A.7) gives
Pr[Overlap]≤q(n)/summationdisplay
i=1Pr[Overlapi]. (3.14)
Fixingctr∗, eventOverlapioccurs exactly when ctrisatisﬁes
ctr∗−q(n)+1≤ctri≤ctr∗+q(n)−1.
Since there are 2 q(n)−1 values of ctrifor which Overlapioccurs, and ctriis
chosen uniformly from {0,1}n, we see that
Pr[Overlapi] =2q(n)−1
2n<2q(n)
2n.
Combined with Equation (3.14), this gives Pr[ Overlap]<2q(n)2/2n.
Given the above, we can easily bound the success probability of A:
Pr[PrivKcpa
A,/tildewideΠ(n) = 1] = Pr[ PrivKcpa
A,/tildewideΠ(n) = 1∧Overlap]
+Pr[PrivKcpa
A,/tildewideΠ(n) = 1∧Overlap]
≤Pr[PrivKcpa
A,/tildewideΠ(n) = 1|Overlap]+Pr[Overlap]
<1
2+2q(n)2
2n.
This proves Equation (3.13) and completes the proof.Private-Key Encryption 95
Modes of operation and message tampering. In many texts, modes of
operation are also compared based on how well they protect against adver-
sarial modiﬁcation of the ciphertext. We do notinclude such a comparison
here because the issue of message integrity ormessage authentication should
be dealt with separately from encryption, and we do so in the next chapter.
None of the above modes achievesmessage integrity in the sense we will deﬁne
there. We defer further discussion to the next chapter.
With regard to the behavior of diﬀerent modes in the presence of “benign”
(i.e., non-adversarial) transmission errors, see Exercises 3.21 and 3.22. We
remark, however, that in general such errors can be addressed using standard
techniques (e.g., error correction or re-transmission).
Block length and concrete security. CBC, OFB, and CTR modes all
use a random IV. This has the eﬀect of randomizing the encryption process,
and ensures that (with high probability) the underlying block cipher is always
evaluated on fresh(i.e., new) inputs. This is important because, as we have
seen in the proofs of Theorem 3.31 and Theorem 3.32, if an input to the block
cipher is used more than once then security can be violated.
The block length of a block cipher thus has a signiﬁcant impact on the
concrete security of encryption schemes based on that cipher. Consider, e.g.,
CTR mode using a block cipher Fwith block length /lscript. TheIVis then a
uniform /lscript-bit string, and we expect an IVto repeat after encrypting about
2/lscript/2messages(seeAppendixA.4). If /lscriptistooshort,then—evenif Fissecureas
a pseudorandom permutation—the resulting concrete-security bound will be
tooweakforpracticalapplications. Concretely, if /lscript= 64asisthe caseforDES
(a block cipher we will study in Chapter 6), then after 232≈4,300,000,000
encryptions—or roughly 34 gigabytes of plaintext—a repeated IVis expected
to occur. Although this may seem like a lot of data, it is smaller than the
capacity of modern hard drives.
IV misuse. In our description and discussion of the various (secure) modes,
we have assumed a random IVis chosen each time a message encrypted.
What if this assumption goes wrong due, e.g., to poor randomness generation
or a mistaken implementation? Certainly we can no longer guarantee security
in the sense of Deﬁnition 3.22. From a practical point of view, though, the
“stream-cipher modes” (OFB and CTR) are much worse than CBC mode. If
anIVrepeats when using the former, an attacker can XOR the two resulting
ciphertexts and learn a lot of information about the entirecontents of both
encrypted messages (as we have seen previously in the context of the one-time
pad if the key is re-used). With CBC mode, however, it is likely that after
onlya few blocksthe inputs tothe block cipherwill “diverge”and the attacker
will be unable to learn any information beyond the ﬁrst few message blocks.
One way to address potential IVmisuse is to use stateful encryption, as
discussed in the context of OFB and CTR modes. If stateful encryption is not
possible, and there is concern about potential IVmisuse, then CBC mode is
recommended for the reasons described above.96 Introduction to Modern Cryptography
3.7 Chosen-Ciphertext Attacks
3.7.1 Deﬁning CCA-Security
Until now we have deﬁned security against two types of attacks: passive
eavesdropping and chosen-plaintext attacks. A chosen-ciphertext attack is
even more powerful. In a chosen-ciphertext attack, the adversary has the
ability not only to obtain encryptions of messagesof its choice (as in a chosen-
plaintext attack), but also to obtain the decryption of ciphertexts of its choice
(with one exception discussed later). Formally, we give the adversary access
to adecryption oracle in addition to an encryption oracle. We present the
formal deﬁnition and defer further discussion.
Consider the following experiment for any private-key encryption scheme
Π = (Gen,Enc,Dec), adversaryA, and value nfor the security parameter.
The CCA indistinguishability experiment PrivKcca
A,Π(n):
1. A key kis generated by running Gen(1n).
2. AdversaryAis given input 1nand oracle access to Enck(·)
andDeck(·). It outputs a pair of messages m0,m1of the
same length.
3. A uniform bit b∈ {0,1}is chosen, and then a ciphertext
c←Enck(mb)is computed and given to A. We call cthe
challenge ciphertext .
4. The adversary Acontinues to have oracle access to Enck(·)
andDeck(·), but is not allowed to query the latter on the
challenge ciphertext itself. Eventually, Aoutputs a bit b/prime.
5. The output of the experiment is deﬁned to be 1ifb/prime=b, and
0otherwise. If the output of the experiment is 1, we say that
Asucceeds.
DEFINITION 3.33 A private-key encryption scheme Πhasindistinguish-
able encryptions under a chosen-ciphertext attack , or isCCA-secure , if for all
probabilistic polynomial-time adversaries Athere is a negligible function negl
such that:
Pr[PrivKcca
A,Π(n) = 1]≤1
2+negl(n),
where the probability is taken over all randomness used in the experiment.
For completeness, we remark that the natural analogue of Theorem 3.24
holds for CCA-security as well. (Namely, if a scheme has indistinguishable
encryptions under a chosen-ciphertext attack then it has indistinguishable
multiple encryptionsunder a chosen-ciphertextattack, deﬁned appropriately.)Private-Key Encryption 97
Inthe experiment above, the adversary’s access to the decryption oracle
is unlimited exceptfor the restriction that the adversary may not request
decryption of the challenge ciphertext itself. This restriction is necessary or
elsethereis clearlynohopeforanyencryptionschemeto satisfythedeﬁnition.
Atthispointyoumaybewonderingifchosen-ciphertextattacksrealistically
model any real-worldattack. As in the case of chosen-plaintext attacks, we do
not expect honest parties to decrypt arbitrary ciphertexts of an adversary’s
choice. Nevertheless,theremaybescenarioswhereanadversarymightbeable
toinﬂuence what gets decrypted and learn some partial information about
the result. For example:
1. In the Midway example from Section 3.4.2, it is conceivable that the US
cryptanalysts might also have tried to send encrypted messages to the
Japanese and then monitor their behavior. Such behavior (e.g., move-
ment of forces and the like) could have provided important information
about the underlying plaintext.
2. Imagine a user sending encrypted messages to their bank. An adver-
sary may be able to send ciphertexts on behalf of that user; the bank
will decrypt those ciphertexts and the adversary may learn something
about the result. For example, if a ciphertext corresponds to an ill-
formedplaintext (e.g., an unintelligible message, or simply one that is
not formatted correctly), the adversarymay be able to deduce this from
the bank’s reaction (i.e., the pattern of subsequent communication). A
practical attack of this type is presented in Section 3.7.2 below.
3. Encryption is often used in higher-level protocols; e.g., an encryption
scheme might be used as part of an authentication protocol where one
party sends a ciphertext to the other, who decrypts it and returns the
result. In this case, one of the honest parties behaves exactly like a
decryption oracle.
Insecurity of the schemes we have studied. None of the encryption
schemes we have seen thus far is CCA-secure. We demonstrate this for Con-
struction 3.30, where encryption is computed as Enck(m) =/angbracketleftr,Fk(r)⊕m/angbracketright.
Consider an adversary Arunning in the CCA indistinguishability experiment
who chooses m0= 0nandm1= 1n. Then, upon receiving a ciphertext
c=/angbracketleftr,s/angbracketright, the adversary can ﬂip the ﬁrst bit of sand ask for a decryption of
the resulting ciphertext c/prime. Sincec/prime/negationslash=c, this query is allowed and the decryp-
tion oracle answers with either 10n−1(in which case it is clear that b= 0) or
01n−1(in which case b= 1). This example demonstrates that CCA-security
is quite stringent. Any encryption scheme that allows ciphertexts to be “ma-
nipulated” in any controlled way cannot be CCA-secure. Thus, CCA-security
implies a very important property called non-malleability . Loosely speaking,
a non-malleableencryption schemehas the propertythat ifthe adversarytries
to modify a given ciphertext, the result is either an invalid ciphertext or one98 Introduction to Modern Cryptography
that decrypts to a plaintext having no relation to the original one. This is a
very useful property for schemes used in complex cryptographic protocols.
Constructing a CCA-secure encryption scheme. We show how to con-
struct a CCA-secure encryption scheme in Section 4.5.4. The construction is
presented there because it uses tools that we develop in Chapter 4.
3.7.2 Padding-Oracle Attacks
Thechosen-ciphertextattackonConstruction3.30describedintheprevious
sectionisabit contrived,sinceitassumestheattackercanobtainthecomplete
decryption of a modiﬁed ciphertext. While this sort of attack is allowed
under Deﬁnition 3.33, it is not clear that it represents a serious concern in
practice. Here we show a chosen-ciphertext attack on a natural and widely
used encryption scheme; moreover, the attack only requires the ability of an
attackerto determine whether or not a modiﬁed ciphertext decrypts correctly.
Such information is frequently very easy to obtain since, for example, a server
might request a retransmission or terminate a session if it ever receives a
ciphertext that does not decrypt correctly, and either of these events would
generate a noticeable change in the observed traﬃc. The attack has been
shown to work in practice on various deployed protocols; we give one concrete
example at the end of this section.
As mentioned previously, when using CBC mode the length of the plaintext
must be a multiple of the block length; if a plaintext does not satisfy this
property, it must be padded before being encrypted. We refer to the original
plaintext as the message, and the result after padding as encoded data . The
padding scheme we use must allow the receiver to unambiguously determine
fromtheencodeddatawherethemessageends. Onepopularandstandardized
approach is to use PKCS #5 padding. Assume the original message has an
integral number of bytes, and let Ldenote the block length (in bytes) of the
block cipher being used. Let bdenote the number of bytes that need to be
appended to the message in order to make the total length of the resulting
encoded data a multiple of the block length. Here, bis an integer between 1
andL, inclusive. (We cannot have b= 0 since this would lead to ambiguous
padding. Thus, if the message length is already a multiple of the block length,
Lbytes of padding are appended.) Then we append to the message the
string containing the integer b(represented in 1 byte, or 2 hexadecimal digits)
repeated btimes. That is, if 1 byte of padding is needed then the string 0x01
(written in hexadecimal) is appended; if 4 bytes of padding are needed then
the hexadecimal string 0x04040404 is appended; etc. The encoded data is
then encrypted using regular CBC-mode encryption.
When decrypting, the receiver ﬁrst applies CBC-mode decryption as usual
to recover the encoded data, and then checks that the encoded data is cor-
rectly padded. (This is easily done: simply read the value bof the ﬁnal byte
and then verify that the ﬁnal bbytes of the result all have value b.) If so,Private-Key Encryption 99
then the padding is stripped oﬀ and the original message returned. Other-
wise, the standard procedure is to return a “bad padding” error (e.g., in Java
the standard exception is called javax.crypto.BadPaddingException ). The
presenceofsuch anerrormessageprovidesan adversarywith a partialdecryp-
tion oracle. That is, an adversary can send any ciphertext to the server and
learn (based on whether a “bad padding” error is returned or not) whether
the underlying encoded data is padded in the correct format. Although this
may seem like meaningless information, we show that it enables an adversary
to completely recover the original message for any ciphertext of its choice.
We describe the attack on a 3-block ciphertext for simplicity. Let IV,c1,c2
be a ciphertext observed by the attacker, and let m1,m2be the underlying
encoded data (unknown to the attacker) which corresponds to the padded
message, as discussed above. (Each block is Lbytes long.) Note that
m2=F−1
k(c2)⊕c1, (3.15)
wherekis the key (which is, of course, not known to the attacker) being used
by the honest parties. The second block m2ends in 0x b···0xb/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright
btimes, where we let
0xbdenotethe 1-byterepresentationofthe integer b. Thekeypropertyusedin
the attack is that certain changes to the ciphertext yield predictable changes
in the underlying encoded data after CBC-mode decryption. Speciﬁcally, let
c/prime
1be identical to c1except for a modiﬁcation in the ﬁnal byte. Consider
decryption of the modiﬁed ciphertext IV,c/prime
1,c2. This will result in encoded
datam/prime
1,m/prime
2wherem/prime
2=F−1
k(c2)⊕c/prime
1. Comparing to Equation (3.15) we
see that m/prime
2will be identical to m2except for a modiﬁcation in the ﬁnal
byte. (The value of m/prime
1is unpredictable, but this will not adversely aﬀect the
attack.) Similarly, if c/prime
1is the same as c1except for a change in its ith byte,
then decryption of IV,c/prime
1,c2will result in m/prime
1,m/prime
2wherem/prime
2is the same as
m2except for a change in its ith byte. More generally, if c/prime
1=c1⊕∆ for
any string ∆, then decryption of IV,c/prime
1,c2yieldsm/prime
1,m/prime
2wherem/prime
2=m2⊕∆.
The upshot is that the attacker can exercise signiﬁcant control over the ﬁnal
block of the encoded data.
As a warmup, let us see how the adversary can exploit this to learn b, the
amount of padding. (This reveals the length of the original message.) Recall
that upon decryption, the receiver looks at the value bof the ﬁnal byte of the
second block of the encoded data, and then veriﬁes that the ﬁnal bbytes all
have the same value. The attackerbegins by modifying the ﬁrst byte of c1and
sending the resulting ciphertext IV,c/prime
1,c2to the receiver. If decryption fails
(i.e., the receiver returns an error) then it must be the case that the receiver
is checking all Lbytes of m/prime
2, and therefore b=L! Otherwise, the attacker
learnsthat b < L, anditcanthen repeattheprocesswith the secondbyte, and
so on. The left-most modiﬁed byte for which decryption fails reveals exactly
the left-most byte being checked by the receiver, and so reveals exactly b.
Withbknown, the attacker can proceed to learn the bytes of the message
one-by-one. We illustrate the idea for the ﬁnal byte of the message, which we100 Introduction to Modern Cryptography
denote by B. The attacker knows that m2ends in 0x B0xb···0xb(with 0xb
repeated btimes) and wishes to learn B. Deﬁne
∆idef= 0x00···0x00 0xibtimes/bracehtipdownleft/bracehtipupright/bracehtipupleft/bracehtipdownright
0x(b+1)···0x(b+1)
⊕0x00···0x00 0x00btimes/bracehtipdownleft/bracehtipupright/bracehtipupleft/bracehtipdownright
0xb···0xb
for 0≤i <28; i.e., the ﬁnal b+ 1 byes of ∆ icontain the integer i(rep-
resented in hexadecimal) followed by the value ( b+ 1)⊕b(in hexadecimal)
repeated btimes. If the attacker submits the ciphertext IV,c1⊕∆i,c2to the
receiver then, after CBC-mode decryption, the resulting encoded data will
equal 0x( B⊕i)0x(b+1)···0x(b+1) (with 0x( b+1) repeated btimes). De-
cryption will fail unless 0x( B⊕i) = 0x(b+1). The attacker simply needs to
try at most 28values ∆ 0,...,∆28−1until decryption succeeds for some ∆ i, at
which point it can deduce that B= 0x(b+1)⊕i. We leave a full description
of how to extend this attack so as to learn the entire plaintext—and not just
the ﬁnal block—as an exercise.
A padding-oracle attack on CAPTCHAs. A CAPTCHA is a distorted
image of, say, an English word that is easy for humans to read, but hard for
a computer to process. CAPTCHAs are used in order to ensure that a hu-
man user—and not some automated software—is interacting with a webpage.
CAPTCHAs are used, e.g., by online email services to ensure that humans
open accounts; this is important to prevent spammers from automatically
opening thousands of accounts and using them to send spam.
One way that CAPTCHAs can be conﬁgured is as a separate service run on
an independent server. In order to see how this works, we denote a webserver
bySW, the CAPTCHA server by SC, and the user by U. When the user
Uloads a webpage served by SW, the following events occur: SWencrypts
a random English word wusing a key kthat was initially shared between
SWandSC, and sends the resulting ciphertext to the user (along with the
webpage).Uforwards the ciphertext to SC, who decrypts it, obtains w, and
renders a distorted image of wtoU. Finally,Usends the word wback to
SWfor veriﬁcation. The interesting observation here is that SCdecrypts any
ciphertext it receives from Uand will issue a “bad padding” error message if
decryption fails as described earlier. This presents Uwith an opportunity to
carry out a padding-oracle attack as described above, and thus to solve the
CAPTCHA (i.e., to determine w) automatically without any human involve-
ment, rendering the CAPTCHA ineﬀective. While ad hoc measures can be
used (e.g., having SCreturn a random image instead of a decryption error),
what is really needed is to use an encryption scheme that is CCA-secure.Private-Key Encryption 101
References and Additional Reading
The modern computational approach to cryptography was initiated in a
groundbreaking paper by Goldwasser and Micali [80]. That paper introduced
the notion of semantic security, and showed how this goal could be achieved in
the settingofpublic-keyencryption(see Chapters10and11). Thatpaperalso
proposed the notion of indistinguishability (i.e., Deﬁnition 3.8), and showed
that it implies semanticsecurity. The conversewasshownin [125]. The reader
is referred to [76] for further discussion of semantic security.
Blum and Micali [37] introduced the notion of pseudorandom generators
and proved their existence based on a speciﬁc number-theoretic assumption.
In the same work, Blum and Micali also pointed out the connection between
pseudorandom generatorsand private-key encryption as in Construction 3.17.
The deﬁnition of pseudorandom generators given by Blum and Micali is dif-
ferent from the deﬁnition we use in this book (Deﬁnition 3.14); the latter
deﬁnition originates in the work of Yao [179], who showed equivalence of the
two formulations. Yao also showed constructions of pseudorandom generators
based on general assumptions; we will explore this result in Chapter 7.
Formaldeﬁnitionsofsecurityagainstchosen-plaintextattacksweregivenby
Luby [115] and Bellare et al. [15]. Chosen-ciphertextattacks (in the context of
public-key encryption) were ﬁrst formally deﬁned by Naor and Yung [129] and
Rackoﬀ and Simon [147], and were considered also in [61] and [15]. See [101]
for other notions of security for private-key encryption.
Pseudorandom functions were deﬁned and constructed by Goldreich et
al. [78], and their application to encryption was demonstrated in subsequent
work by the same authors [77]. Pseudorandom permutations and strong pseu-
dorandom permutations were studied by Luby and Rackoﬀ [116]. A proof of
Proposition 3.27 (the “switching lemma”) can be found in [24]. Block ciphers
had been used for many years before they began to be studied in the theo-
retical sense initiated by the above works. Practical stream ciphers and block
ciphers are studied in detail in Chapter 6.
The ECB, CBC, and OFB modes of operation (as well as CFB, a mode
of operation not covered here) were standardized along with the DES block
cipher [130]. CTR mode was standardized by NIST in 2001. CBC and CTR
mode were proven CPA-secure in [15]. For more recent modes of operation,
seehttp://csrc.nist.gov/groups/ST/toolkit/BCM/index.html .
The attack on chained CBC was ﬁrst described by Rogaway (unpublished),
and was used to attack SSL/TLS in the so-called “BEAST attack” by Rizzo
and Duong. The padding-oracle attack we describe here originated in the
work of Vaudenay [171].102 Introduction to Modern Cryptography
Exercises
3.1Prove Proposition 3.6.
3.2 Prove that Deﬁnition 3.8 cannot be satisﬁed if Π can encrypt arbitrary-
length messages and the adversary is notrestricted to output equal-
length messages in experiment PrivKeav
A,Π.
Hint:Letq(n) be a polynomial upper-bound on the length of the cipher-
text when Π is used to encrypt a single bit. Then consider an adversary
who outputs m0∈ {0,1}and a uniform m1∈ {0,1}q(n)+2.
3.3 Say Π = ( Gen,Enc,Dec) is such that for k∈{0,1}n, algorithm Enckis
onlydeﬁned for messagesoflength atmost /lscript(n) (forsome polynomial /lscript).
Construct a scheme satisfying Deﬁnition 3.8 even when the adversary is
notrestricted to outputting equal-length messages in PrivKeav
A,Π.
3.4 Prove the equivalence of Deﬁnition 3.8 and Deﬁnition 3.9.
3.5 Let|G(s)|=/lscript(|s|) for some /lscript. Consider the following experiment:
The PRG indistinguishability experiment PRGA,G(n):
(a) A uniform bit b∈{0,1}is chosen. If b= 0then choose
a uniform r∈{0,1}/lscript(n); ifb= 1then choose a uniform
s∈{0,1}nand setr:=G(s).
(b) The adversary Ais givenr, and outputs a bit b/prime.
(c) The output of the experiment is deﬁned to be 1ifb/prime=b,
and0otherwise.
Provide a deﬁnition of a pseudorandom generator based on this exper-
iment, and prove that your deﬁnition is equivalent to Deﬁnition 3.14.
(That is, show that Gsatisﬁes your deﬁnition if and only if it satisﬁes
Deﬁnition 3.14.)
3.6 LetGbe apseudorandomgeneratorwith expansionfactor /lscript(n)>2n. In
eachofthefollowingcases,saywhether G/primeisnecessarilyapseudorandom
generator. If yes, give a proof; if not, show a counterexample.
(a) Deﬁne G/prime(s)def=G(s1···s⌊n/2⌋), where s=s1···sn.
(b) Deﬁne G/prime(s)def=G/parenleftbig
0|s|/bardbls/parenrightbig
.
(c) Deﬁne G/prime(s)def=G(s)/bardblG(s+1).
3.7 Prove the converse of Theorem 3.18. Namely, show that if Gis not a
pseudorandom generator then Construction 3.17 does not have indistin-
guishable encryptions in the presence of an eavesdropper.Private-Key Encryption 103
3.8 (a) Deﬁneanotionofindistinguishabilityfortheencryptionofmultiple
distinctmessages, in which a scheme need not hide whether the
same message is encrypted twice.
(b) Show that Construction 3.17 does not satisfy your deﬁnition.
(c) Giveaconstructionofa deterministic (stateless)encryptionscheme
that satisﬁes your deﬁnition.
3.9 Prove unconditionally the existence of a pseudorandom function F:
{0,1}∗×{0,1}∗→{0,1}∗with/lscriptkey(n) =nand/lscriptin(n) =O(logn).
Hint:Implement a uniform function with logarithmic input length.
3.10 Let Fbe a length-preserving pseudorandom function. For the following
constructions of a keyed function F/prime:{0,1}n×{0,1}n−1→{0,1}2n,
state whether F/primeis a pseudorandom function. If yes, prove it; if not,
show an attack.
(a)F/prime
k(x)def=Fk(0/bardblx)/bardblFk(1/bardblx).
(b)F/prime
k(x)def=Fk(0/bardblx)/bardblFk(x/bardbl1).
3.11 Assuming the existence of pseudorandom functions, prove that there is
an encryption scheme that has indistinguishable multiple encryptions in
the presence of an eavesdropper (i.e., satisﬁes Deﬁnition 3.19), but is
not CPA-secure (i.e., does not satisfy Deﬁnition 3.22).
Hint:The scheme need not be “natural.” You will need to use the fact
that in a chosen-plaintext attack the adversary can choose its queries to
the encryption oracle adaptively .
3.12 Let Fbe a keyed function and consider the following experiment:
The PRF indistinguishability experiment PRFA,F(n):
(a) A uniform bit b∈{0,1}is chosen. If b= 1then choose
uniform k∈{0,1}n.
(b)Ais given1nfor input. If b= 0thenAis given access to
a uniform function f∈Funcn. Ifb= 1thenAis instead
given access to Fk(·).
(c)Aoutputs a bit b/prime.
(d) The output of the experiment is deﬁned to be 1ifb/prime=b,
and0otherwise.
Deﬁne pseudorandom functions using this experiment, and prove that
your deﬁnition is equivalent to Deﬁnition 3.25.
3.13 Consider the following keyed function F: For security parameter n, the
key is an n×nboolean matrix Aand ann-bit boolean vector b. Deﬁne
FA,b:{0,1}n→{0,1}nbyFA,b(x)def=Ax+b, where all operations are
done modulo 2. Show that Fis not a pseudorandom function.104 Introduction to Modern Cryptography
3.14 Prove that if Fis a length-preserving pseudorandom function, then
G(s)def=Fs(1)/bardblFs(2)/bardbl···/bardblFs(/lscript) is a pseudorandom generator with ex-
pansion factor /lscript·n.
3.15 Deﬁne a notion of perfect secrecy under a chosen-plaintext attack by
adapting Deﬁnition 3.22. Show that the deﬁnition cannot be achieved.
3.16 Prove Proposition 3.27.
Hint:Use the results of Appendix A.4.
3.17 Assume pseudorandom permutations exist. Show that there exists a
function F/primethat is a pseudorandom permutation but is nota strong
pseudorandom permutation.
Hint:Construct F/primesuch that F/prime
k(k) = 0|k|.
3.18 Let Fbe a pseudorandom permutation, and deﬁne a ﬁxed-length en-
cryption scheme ( Enc,Dec) as follows: On input m∈{0,1}n/2and key
k∈{0,1}n, algorithm Encchooses a uniform string r∈{0,1}n/2of
lengthn/2 and computes c:=Fk(r/bardblm).
Show howto decrypt, and provethat this schemeis CPA-secureformes-
sages of length n/2. (If you are looking for a real challenge, prove that
this scheme is CCA-secure if Fis astrongpseudorandom permutation.)
3.19 Let Fbe a pseudorandom function and Gbe a pseudorandom generator
with expansion factor /lscript(n) =n+1. For each of the following encryption
schemes, state whether the scheme has indistinguishable encryptions in
the presence of an eavesdropper and whether it is CPA-secure. (In each
case, the shared key is a uniform k∈{0,1}n.) Explain your answer.
(a) To encrypt m∈{0,1}n+1, choose uniform r∈{0,1}nand output
the ciphertext/angbracketleftr,G(r)⊕m/angbracketright.
(b) To encrypt m∈{0,1}n, output the ciphertext m⊕Fk(0n).
(c) Toencrypt m∈{0,1}2n, parsemasm1/bardblm2with|m1|=|m2|, then
chooseuniform r∈{0,1}nandsend/angbracketleftr,m1⊕Fk(r),m2⊕Fk(r+1)/angbracketright.
3.20 Consider a stateful variant of CBC-mode encryption where the sender
simply increments the IVby 1 each time a message is encrypted (rather
thanchoosing IVatrandomeachtime). Showthat theresultingscheme
isnotCPA-secure.
3.21 What is the eﬀect of a single-bit error in the ciphertext when using the
CBC, OFB, and CTR modes of operation?
3.22 What is the eﬀect of a dropped ciphertext block (e.g., if the trabsmitted
ciphertext c1,c2,c3,...is received as c1,c3,...) when using the CBC,
OFB, and CTR modes of operation?Private-Key Encryption 105
3.23 Say CBC-mode encryption is used with a block cipher having a 256-bit
key and 128-bit block length to encrypt a 1024-bit message. What is
the length of the resulting ciphertext?
3.24 Give the details of the proof by reduction for Equation (3.12).
3.25 Let Fbe apseudorandomfunction suchthat for k∈{0,1}nthe function
Fkmaps/lscriptin(n)-bit inputs to /lscriptout(n)-bit outputs.
(a) Consider implementing CTR-mode encryption using F. For which
functions /lscriptin,/lscriptoutis the resulting encryption scheme CPA-secure?
(b) Consider implementing CTR-mode encryption using F, but only
forﬁxed-length messages of length /lscript(n) (which is an integer mul-
tiple of/lscriptout(n)). For which /lscriptin,/lscriptout,/lscriptdoes the scheme have indis-
tinguishable encryptions in the presence of an eavesdropper?
3.26 For any function g:{0,1}n→{0,1}n, deﬁneg$(·) to be a probabilis-
ticoracle that, on input 1n, chooses uniform r∈{0,1}nand returns
/angbracketleftr,g(r)/angbracketright. A keyed function Fis aweak pseudorandom function if for all
pptalgorithms D, there exists a negligible function neglsuch that:
/vextendsingle/vextendsingle/vextendsinglePr[DF$
k(·)(1n) = 1]−Pr[Df$(·)(1n) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl(n),
wherek∈{0,1}nandf∈Funcnare chosen uniformly.
(a) Prove that if Fis pseudorandom then it is weakly pseudorandom.
(b) LetF/primebe a pseudorandom function, and deﬁne
Fk(x)def=/braceleftbigg
F/prime
k(x) ifxis even
F/prime
k(x+1) ifxis odd.
Prove that Fis weakly pseudorandom, but notpseudorandom.
(c) Is CTR-modeencryptionusingaweakpseudorandomfunction nec-
essarily CPA-secure? Does it necessarily have indistinguishable en-
cryptions in the presence of an eavesdropper? Prove your answers.
(d) Prove that Construction 3.30 is CPA-secure if Fis a weak pseudo-
random function.
3.27 Let Fbe a pseudorandompermutation. Considerthe mode of operation
in which a uniform value ctr∈{0,1}nis chosen, and the ith ciphertext
blockciis computed as ci:=Fk(ctr+i+mi). Show that this scheme
does not have indistinguishable encryptions in the presence of an eaves-
dropper.
3.28 Show that the CBC, OFB, and CTR modes of operation do not yield
CCA-secure encryption schemes (regardless of F).106 Introduction to Modern Cryptography
3.29 LetΠ 1= (Enc1,Dec1)andΠ 2= (Enc2,Dec2)betwoencryptionschemes
for which it is known that at least one is CPA-secure (but you don’t
know which one). Show how to construct an encryption scheme Π that
is guaranteed to be CPA-secure as long as at least one of Π 1or Π2is
CPA-secure. Provide a full proof of your solution.
Hint:Generate two plaintext messages from the original plaintext so
that knowledge of either one reveals nothing about the original plaintext,
but knowledge of both enables the original plaintext to be computed.
3.30 Write pseudocode for obtaining the entire plaintext via a padding-oracle
attack on CBC-mode encryption using PKCS #5 padding, as described
in the text.
3.31 Describe a padding-oracle attack on CTR-mode encryption (assuming
PKCS #5 padding is used to pad messages to a multiple of the block
length before encrypting).Chapter 4
Message Authentication Codes
4.1 Message Integrity
4.1.1 Secrecy vs. Integrity
One of the most basic goals of cryptography is to enable parties to commu-
nicate over an open communication channel in a secure way. But what does
“secure communication” entail? In Chapter 3 we showed that it is possible to
obtainsecretcommunication over an open channel. That is, we showed how
encryption can be used to prevent an eavesdropper (or possibly a more active
adversary) from learning anything about the content of messages sent over
an unprotected communication channel. However, not all security concerns
are related to secrecy. In many cases, it is of equal or greater importance
to guarantee message integrity (ormessage authentication ) in the sense that
each party should be able to identify when a message it receives was sent by
the party claiming to send it, and was not modiﬁed in transit. We look at
two canonical examples.
ConsiderthecaseofausercommunicatingwiththeirbankovertheInternet.
When the bank receives a request to transfer $1,000 from the user’s account
to the account of some other user X, the bank has to consider the following:
1. Is the request authentic? That is, did the user in question really issue
thisrequest, orwastherequestissuedbyanadversary(perhaps Xitself)
who is impersonating the legitimate user?
2. Assuming a transfer request was issued by the legitimate user, are the
detailsoftherequestasreceivedexactlythoseintendedbythelegitimate
user? Or was, e.g., the transfer amount modiﬁed?
Note that standard error-correction techniques do not suﬃce for the second
concern. Error-correcting codes are only intended to detect and recover from
“random” errors that aﬀect only a small portion of the transmission, but they
do nothing to protect against a malicious adversary who can choose exactly
where to introduce an arbitrary number of errors.
A second scenario where the need for message integrity arises in practice is
with regard to web cookies. The HTTP protocol used for web traﬃc is state-
less, and so when a client and server communicate in some session (e.g., when
107108 Introduction to Modern Cryptography
a user [client] shops at a merchant’s [server’s] website), any state generated
as part of that session (e.g., the contents of the user’s shopping cart) is often
placed in a “cookie” that is stored by the client and sent from the client to
the server as part of each message the client sends. Assume that the cookie
stored by some user includes the items in the user’s shopping cart along with
a price for each item, as might be done if the merchant oﬀers diﬀerent prices
to diﬀerent users (reﬂecting, e.g., discounts and promotions, or user-speciﬁc
pricing). It should be infeasible here for the user to modify the cookie that
it stores so as to alter the prices of the items in its cart. The merchant thus
needs a technique to ensure the integrity of the cookie that it stores at the
user. Note that the contents of the cookie (namely, the items and their prices)
are not secret and, in fact, must be known by the user. The problem here is
thus purely one of integrity.
In general, one cannot assume the integrity of communication without tak-
ing speciﬁc measures to ensure it. Indeed, any unprotected online purchase
order, online banking operation, email, or SMS message cannot, in general,
be trusted to have originated from the claimed source and to have been un-
modiﬁed in transit. Unfortunately, people are in general trusting and thus in-
formation like the caller-ID or an email return address are taken to be “proofs
of origin” in many cases, even though they are relatively easy to forge. This
leaves the door open to potentially damaging attacks.
In this chapter we will show how to achieve message integrity by using
cryptographic techniques to prevent the undetected tampering of messages
sent over an open communication channel. Note that we cannot hope to
prevent adversarial tampering of messages altogether, as that can only be
defended against at the physical level. Instead, what we will guarantee is that
any such tampering will be detected by the honest parties.
4.1.2 Encryption vs. Message Authentication
Just as the goals of secrecy and message integrity are diﬀerent, so are the
techniques and tools for achieving them. Unfortunately, secrecy and integrity
are often confused and unnecessarily intertwined, so let us be clear up front:
encryption does not(in general) provide any integrity, and encryption should
never be used with the intent of achieving message authentication unless it is
speciﬁcally designed with that purpose in mind (something we will return to
in Section 4.5).
One might mistakenly think that encryption solves the problem of message
authentication. (In fact, this is a common error.) This is due to the fuzzy,
and incorrect, reasoning that since a ciphertext completely hides the contents
of the message, an adversary cannot possibly modify an encrypted message in
any meaningful way. Despite its intuitive appeal, this reasoning is completely
false. We illustrate this point by showing that all the encryption schemes we
have seen thus far do not provide message integrity.Message Authentication Codes 109
Encryption using stream ciphers. Considerthe simple encryptionscheme
in which Enck(m) computes the ciphertext c:=G(k)⊕m, where Gis a
pseudorandomgenerator. Ciphertextsinthiscaseareveryeasytomanipulate:
ﬂipping any bit in the ciphertext cresults in the same bit being ﬂipped in the
message that is recovered upon decryption. Thus, given a ciphertext cthat
encryptsa(possiblyunknown)message m, it ispossibletogenerateamodiﬁed
ciphertext c/primesuchthat m/prime:=Deck(c/prime) is the same as mbut with one (ormore)
of the bits ﬂipped. This simple attack can have severe consequences. As an
example, consider the case of a user encrypting some dollar amount he wants
to transfer from his bank account, where the amount is represented in binary.
Flipping the least signiﬁcant bit has the eﬀect of changing this amount by
only $1, but ﬂipping the 11th least signiﬁcant bit changesthe amount by more
than $1,000! (Interestingly, the adversaryin this example does not necessarily
learn whether it is increasing or decreasing the initial amount, i.e., whether
it is ﬂipping a 0 to a 1 or vice versa. But if the adversary has some partial
knowledge about the amount—say, that it is less than $1,000 to begin with—
then the modiﬁcations it introduces can have a predictable eﬀect.) We stress
that this attack does not contradict the secrecyof the encryption scheme (in
the sense of Deﬁnition 3.8). In fact, the exact same attack applies to the
one-time pad encryption scheme, showing that even perfect secrecy is not
suﬃcient to ensure the most basic level of message integrity.
Encryption using block ciphers. The attack described above utilizes the
fact that ﬂipping a single bit in a ciphertext keeps the underlying plaintext
unchanged except for the corresponding bit (which is also ﬂipped). The same
attack applies to the OFB- and CTR-mode encryption schemes, which also
encrypt messages by XORing them with a pseudorandom stream (albeit one
that changes each time a message is encrypted). We thus see that even using
CPA-secure encryption is not enough to prevent message tampering.
One may hope that attacking ECB- or CBC-mode encryption would be
more diﬃcult since decryption in these cases involves inverting a (strong)
pseudorandom permutation F, and we expect that F−1
k(x) andF−1
k(x/prime) will
be completely uncorrelated even if xandx/primediﬀer in only a single bit. (Of
course, ECB mode does not even guarantee the most basic notion of secrecy,
but that does not matter for the present discussion.) Nevertheless, single-
bit modiﬁcations of a ciphertext still cause partially predictable changes in
the plaintext. For example, when using ECB mode, ﬂipping a bit in the
ith block of the ciphertext aﬀects onlytheith block of the plaintext—all
other blocks remain unchanged. Although the eﬀect on the ith block of the
plaintext maybe impossible to predict, changing that one block (while leaving
everything else unchanged) may represent a harmful attack. Moreover, the
order of plaintext blocks can be changed (without garbling any block) by
simply changing the order of the corresponding ciphertext blocks, and the
message can be truncated by just dropping ciphertext blocks.
Similarly,whenusingCBCmode, ﬂippingthe jthbitofthe IVchangesonly110 Introduction to Modern Cryptography
thejthbitoftheﬁrstmessageblock m1(sincem1:=F−1
k(c1)⊕IV/prime, whereIV/prime
is the modiﬁed IV); all plaintext blocksother than the ﬁrst remain unchanged
(since the ith block of the plaintext is computed as mi:=F−1
k(ci)⊕ci−1, and
blocksciandci−1have not been modiﬁed). Therefore, the ﬁrst block of a
CBC-encrypted message can be changed arbitrarily. This a serious concern
in practice since the ﬁrst block often contains important header information.
Finally, note that all encryption schemes we have seen thus far have the
property that everyciphertext (perhaps satisfying some length constraint)
corresponds to somevalid message. So it is trivial for an adversaryto “spoof”
a message on behalf of one of the communicating parties—by sending some
arbitrary ciphertext—even if the adversary has no idea what the underlying
message will be. As we will see when we formally deﬁne authenticated en-
cryption in Section 4.5, even an attack of this sort should be ruled out.
4.2 Message Authentication Codes – Deﬁnitions
Wehave seen that, in general, encryption does not solve the problem of
message integrity. Rather, an additional mechanism is needed that will enable
the communicating parties to know whether or not a message was tampered
with. The right tool for this task is a message authentication code (MAC).
The aim of a message authentication code is to prevent an adversary from
modifying a message sent by one party to another, or from injecting a new
message, without the receiver detecting that the message did not originate
from the intended party. As in the case of encryption, this is only possible
if the communicating parties share some secret that the adversary does not
know (otherwise nothing can prevent an adversary from impersonating the
party sending the message). Here, we will continue to consider the private-
key setting where the parties share the same secret key.1
The Syntax of a Message Authentication Code
Before formally deﬁning security of a message authentication code, we ﬁrst
deﬁne what a MAC isand howit is used. Twouserswho wish tocommunicate
in an authenticated manner begin by generating and sharing a secret key kin
advance of their communication. When one party wants to send a message m
to the other, she computes a MAC tag (or simply a tag)tbased on the message
and the shared key, and sends the message mand the tag tto the other party.
The tag is computed using a tag-generation algorithm denoted by Mac; thus,
rephrasing what we have already said, the sender of a message mcomputes
t←Mack(m) and transmits ( m,t) to the receiver. Upon receiving ( m,t), the
1Inthe web-cookie example discussed earlier, the merchant is (in eﬀect) communicating
“with itself” with the user acting as a communication channel. In that setting, the server
alone needs to know the key since it is acting as both sender and receiver.Message Authentication Codes 111
second party veriﬁeswhether tis a valid tag on the message m(with respect
to the shared key) or not. This is done by running a veriﬁcation algorithm
Vrfythat takes as input the shared key as well as a message mand a tag t,
and indicates whether the given tag is valid. Formally:
DEFINITION 4.1 Amessage authentication code (orMAC)consists of
three probabilistic polynomial-time algorithms (Gen,Mac,Vrfy)such that:
1. Thekey-generation algorithm Gen takes as input the security parameter
1nand outputs a key kwith|k|≥n.
2. Thetag-generation algorithm Mac takes as input a key kand a message
m∈{0,1}∗, and outputs a tag t. Since this algorithm may be random-
ized, we write this as t←Mack(m).
3. The deterministic veriﬁcation algorithm Vrfy takes as input a key k, a
message m, and a tag t. It outputs a bit b, withb= 1meaning validand
b= 0meaning invalid. We write this as b:=Vrfyk(m,t).
It is required that for every n, every key koutput by Gen(1n), and every
m∈{0,1}∗, it holds that Vrfyk(m,Mack(m)) = 1.
If there is a function /lscriptsuch that for every koutput by Gen(1n), algorithm
Mackis only deﬁned for messages m∈{0,1}/lscript(n), then we call the scheme a
ﬁxed-length MAC for messages of length /lscript(n).
As with private-key encryption, Gen(1n) almost always simply chooses a
uniform key k∈{0,1}n, and we omit Genin that case.
Canonical veriﬁcation. For deterministic message authentication codes
(thatis, where Macisadeterministicalgorithm),thecanonicalwaytoperform
veriﬁcation is to simply re-compute the tag and check for equality. In other
words,Vrfyk(m,t) ﬁrst computes ˜t:=Mack(m) and then outputs 1 if and
only if˜t=t. Even for deterministic MACs, however, it is useful to deﬁne
a separate Vrfyalgorithm in order to explicitly distinguish the semantics of
authenticating a message vs. verifying its authenticity.
Security of Message Authentication Codes
We now deﬁne the default notion of security for message authentication
codes. The intuitive idea behind the deﬁnition is that no eﬃcient adversary
should be able to generate a valid tag on any “new” message that was not
previously sent (and authenticated) by one of the communicating parties.
As with any security deﬁnition, to formalize this notion we have to deﬁne
both the adversary’s power as well as what should be considered a “break.”
As usual, we consider only probabilistic polynomial-time adversaries2and
2See Section 4.6 for a discussion of information-theoretic message authentication, where no
computational restrictions are placed on the adversary.112 Introduction to Modern Cryptography
so the real question is how we model the adversary’s interaction with the
communicatingparties. Inthesettingofmessageauthentication,anadversary
observingthecommunicationbetweenthehonestpartiesmaybeabletoseeall
the messages sent by these parties along with their corresponding MAC tags.
The adversary may also be able to inﬂuence the contentof these messages,
whether directly or indirectly (if, e.g., external actions of the adversary aﬀect
the messages sent by the parties). This is true, for example, in the web cookie
example from earlier, where the user’s own actions inﬂuence the contents of
the cookie being stored on his computer.
To formally model the above we allow the adversary to request MAC tags
foranymessages of its choice. Formally, we give the adversary access to a
MAC oracle Mack(·); the adversary can repeatedly submit any message mof
its choice to this oracle, and is given in return a tag t←Mack(m). (For a
ﬁxed-length MAC, only messages of the correct length can be submitted.)
We will consider it a “break” of the scheme if the adversary is able to
output any message malong with a tag tsuch that: (1) tis a valid tag
on the message m(i.e.,Vrfyk(m,t) = 1), and (2) the adversary had not
previously requested a MAC tag on the message m(i.e., from its oracle). The
ﬁrst condition means that if the adversary were to send ( m,t) to one of the
honest parties, then this party would be mistakenly fooled into thinking that
moriginated from the legitimate party since Vrfyk(m,t) = 1. The second
condition is required because it is always possible for the adversary to just
copyamessageandMACtagthatwerepreviouslysentbyoneofthelegitimate
parties(and, ofcourse, these wouldbe accepted asvalid). Such a replay attack
is not considered a “break” of the message authentication code. This does not
mean that replayattacksarenot asecurityconcern; they are, and wewill have
more to say about them below.
A MAC satisfying the level of security speciﬁed above is said to be exis-
tentially unforgeable under an adaptive chosen-message attack . “Existential
unforgeability” refers to the fact that the adversary must not be able to forge
a valid tag on anymessage, and “adaptive chosen-message attack” refers to
the fact that the adversary is able to obtain MAC tags on arbitrary messages
chosen adaptively during its attack.
Toward the formal deﬁnition, consider the following experiment for a mes-
sage authentication code Π = ( Gen,Mac,Vrfy), an adversaryA, and value n
for the security parameter:
The message authentication experiment Mac-forgeA,Π(n):
1. A key kis generated by running Gen(1n).
2. The adversary Ais given input 1nand oracle access to Mack(·).
The adversary eventually outputs (m,t). LetQdenote the set
of all queries that Aasked its oracle.
3.Asucceeds if and only if (1) Vrfyk(m,t) = 1and (2)m/negationslash∈Q.
In that case the output of the experiment is deﬁned to be 1.Message Authentication Codes 113
A MAC is secure if no eﬃcient adversary can succeed in the above experi-
ment with non-negligible probability:
DEFINITION 4.2 A message authentication code Π = (Gen,Mac,Vrfy)
isexistentially unforgeable under an adaptive chosen-message attack , or just se-
cure, if for all probabilistic polynomial-time adversaries A, there is a negligible
function neglsuch that:
Pr[Mac-forgeA,Π(n) = 1]≤negl(n).
Is the deﬁnition toostrong? The above deﬁnition is rather strong in two
respects. First, theadversaryisallowedtorequestMACtagsfor anymessages
of its choice. Second, the adversaryis considered to have “broken”the scheme
if it can output a valid tag on anypreviously unauthenticated message. One
might object that both these components of the deﬁnition are unrealistic and
overly strong: in “real-world” usage of a MAC, the honest parties would only
authenticate “meaningful” messages (over which the adversary might have
only limited control), and similarly it should only be considered a breach of
security if the adversary can forge a valid tag on a “meaningful” message.
Why not tailor the deﬁnition to capture this?
The crucial point is that what constitutes a meaningful message is en-
tirelyapplication dependent . While some applications of a MAC may only
ever authenticate English-text messages, other applications may authenticate
spreadsheet ﬁles, others database entries, and others raw data. Protocols
may also be designed where anything will be authenticated—in fact, certain
protocols for entity authentication do exactly this. By making the deﬁnition
of security for MACs as strong as possible, we ensure that secure MACs are
broadly applicable for a wide range of purposes, without having to worry
about compatibility of the MAC with the semantics of the application.
Replay attacks. We emphasize that the above deﬁnition, and message au-
thentication codes on their own, oﬀer no protection against replay attacks
whereby a previously sent message (and its MAC tag) are replayed to an hon-
est party. Nevertheless, replay attacks are a serious concern! Consider again
the scenario where a user (say, Alice) sends a request to her bank to transfer
$1,000 from her account to some other user (say, Bob). In doing so, Alice
can compute a MAC tag and append it to the request so the bank knows the
request is authentic. If the MAC is secure, Bob will be unable to intercept the
request and change the amount to $10,000 because this would involve forg-
ing a valid tag on a previously unauthenticated message. However, nothing
prevents Bob from intercepting Alice’s message and replaying it ten times to
the bank. If the bank accepts each of these messages, the net eﬀect is that
$10,000 will be transferred to Bob’s account rather than the desired $1,000.
Despite the real threat that replay attacks represent, a MAC by itself can-
notprotect against such attacks since the deﬁnition of a MAC (Deﬁnition 4.1)114 Introduction to Modern Cryptography
does not incorporate any notion of stateinto the veriﬁcation algorithm (and
so every time a valid pair ( m,t) is presented to the veriﬁcation algorithm,
it will always output 1). Rather, protection against replay attacks—if such
protection is necessary at all—must be handled by some higher-level applica-
tion. The reasonthe deﬁnition of a MAC is structured this way is, once again,
because we are unwilling to assume any semantics regarding applications that
use MACs; in particular, the decision as to whether or not a replayed message
should be treated as “valid” may be application dependent.
Two common techniques for preventing replay attacks are to use sequence
numbers (also known as counters) ortime-stamps . The ﬁrst approach, de-
scribed (in a more general context) in Section 4.5.3, requires the communicat-
ing userstomaintain (synchronized)state, andcan be problematicwhen users
communicate over a lossy channel where messages are occasionally dropped
(though this problem can be mitigated). In the second approach, using time-
stamps, the sender prepends the current time T(say, to the nearest mil-
lisecond) to the message before authenticating, and sends Talong with the
message and the resulting tag t. When the receiver obtains T,m,t, it veriﬁes
thattis a valid tag on T/bardblmand that Tis within some acceptable clock skew
from the current time T/primeat the receiver. This method has certain drawbacks
as well, including the need for the sender and receiver to maintain closely syn-
chronized clocks, and the possibility that a replay attack can still take place
if it is done quickly enough (speciﬁcally, within the acceptable time window).
Strong MACs. As deﬁned, a secure MAC ensures that an adversary cannot
generateavalidtagonanewmessagethatwasneverpreviouslyauthenticated.
But it does not rule out the possibility that an attacker might be able to
generate a new tagon a previously authenticated message. That is, a MAC
guarantees that if an attacker learns tags t1,...on messages m1,..., then it
will not be able to forge a valid tag ton any message m/negationslash∈{m1,...}. However,
it may be possible for an adversary to ”forge” a diﬀerent valid tag t/prime
1/negationslash=t1on
the message m1. In general, this type of adversarialbehavior is not a concern.
Nevertheless, in some settings it is useful to consider a stronger deﬁnition of
security for MACs where such behavior is ruled out.
Formally, we consider a modiﬁed experiment Mac-sforge that is deﬁned in
exactlythe samewayas Mac-forge , except thatnowthe set Qcontains pairsof
oraclequeriesand their associatedresponses. (That is, ( m,t)∈QifAqueried
Mack(m) and received in response the tag t.) The adversary Asucceeds (and
experiment Mac-sforge evaluates to 1) if and only if Aoutputs ( m,t) such
thatVrfyk(m,t) = 1 and ( m,t)/∈Q.
DEFINITION 4.3 A message authentication code Π = (Gen,Mac,Vrfy)
isstrongly secure , or astrong MAC , if for all probabilistic polynomial-time
adversariesA, there is a negligible function neglsuch that:
Pr[Mac-sforgeA,Π(n) = 1]≤negl(n).Message Authentication Codes 115
It is not hard to see that if a secure MAC uses canonical veriﬁcation then
it is also strongly secure. This is important since all real-world MACs use
canonical veriﬁcation. We leave the proof of the following as an exercise.
PROPOSITION 4.4 LetΠ = (Gen,Mac,Vrfy)be a secure MAC that uses
canonical veriﬁcation. Then Πis a strong MAC.
Veriﬁcation Queries
Deﬁnitions 4.2 and 4.3 give the adversary access to a MAC oracle, which
corresponds to a real-world adversary who can inﬂuence an honest sender to
generate a tag for some message m. One could also consider an adversary
who interacts with an honest receiver, sending m/prime,t/primeto the receiver to learn
whether Vrfyk(m/prime,t/prime) = 1. Such an adversary could be captured formally in
the natural way by giving the adversary in the above deﬁnitions access to a
veriﬁcation oracle as well.
A deﬁnition that incorporates a veriﬁcation oracle in this way is, perhaps,
the “right” way to deﬁne security for message authentication codes. It turns
out, however, that for MACs that use canonical veriﬁcationit makesno diﬀer-
ence: any such MAC that satisﬁes Deﬁnition 4.2 also satisﬁes the deﬁnitional
variant in which veriﬁcation queries are allowed. Similarly, any strong MAC
automatically also remains secure even in a setting where veriﬁcation queries
are possible. (This, in fact, serves as one motivation for the deﬁnition of
strong security for MACs.) For MACs that do not use canonical veriﬁcation,
however, allowing veriﬁcation queries can make a diﬀerence; see Exercises 4.2
and 4.3. Since most MACs covered in this book (as well as MACs used in
practice) use canonical veriﬁcation, we use the traditional deﬁnitions that
omit access to a veriﬁcation oracle.
A potential timing attack. One issue not addressed by the above is the
possibility of carrying out a timing attack on MAC veriﬁcation. Here, we
consider an adversary who can send message/tag pairs to the receiver—thus
using the receiver as a veriﬁcation oracle—and learn not only whether the
receiver accepts or rejects, but also the timeit takes for the receiver to make
this decision. We show that if such an attack is possible then a natural im-
plementation of MAC veriﬁcation leads to an easily exploitable vulnerability.
(Note that in our usual cryptographic deﬁnitions of security, the attacker
learns only the output of the oracles it has access to, but nothing else. The
attack we describe here, which is an example of a side-channel attack , shows
that certain real-world attacks are not captured by the usual deﬁnitions.)
Concretely, assume a MAC using canonical veriﬁcation. To verify a tag t
on a message m, the receiver computes t/prime:=Mack(m) and then compares t/prime
tot, outputting 1 if and only if t/primeandtare equal. Assume this comparison
is implemented using a standard routine (like strcmpin C) that compares
tandt/primeone byte at a time, and rejects as soon as the ﬁrst unequal byte is116 Introduction to Modern Cryptography
encountered. The observationis that, when implemented in this way, the time
to reject diﬀers depending on the position of the ﬁrst unequal byte.
Itispossibletousethisseeminglyinconsequentialinformationtoforgeatag
on any desired message m. The basic idea is this: say the attacker knows the
ﬁrstibytes of the correct tag for m. (At the outset, i= 0.) The attacker will
learn the next byte of the correct tag by sending ( m,t0), ..., (m,t255) to the
receiver, where tjis the string with the ﬁrst ibytes set correctly, the ( i+1)st
byte equal to j(in hexadecimal), and the remaining bytes set to 0x00. All of
these tags will likely be rejected (if not, then the attacker succeeds anyway);
however, for exactly one of these tags the ﬁrst ( i+ 1) bytes will match the
correct tag and rejection will take slightly longer than the rest. If tjis the tag
that caused rejection to take the longest, the attacker learns that the ( i+1)st
byte of the correct tag is j. In this way, the attacker learns each byte of the
correct tag using at most 256 queries to the veriﬁcation oracle. For a 16-byte
tag, this attack requires only 4096 queries in the worst case.
One might wonder whether this attack is realistic, as it requires access to a
veriﬁcation oracleas well as the ability to measure the diﬀerence in time taken
to compare ivs.i+1 bytes. In fact, exactly such attacks have been carried
out against real systems! As just one example, MACs were used to verify code
updates in the Xbox 360, and the implementation of MAC veriﬁcation used
there had a diﬀerence of 2.2 milliseconds between rejection times. Attackers
were able to exploit this and load pirated games onto the hardware.
Based on the above, we conclude that MAC veriﬁcation should use time-
independent string comparison that always compares allbytes.
4.3 Constructing Secure Message Authentication Codes
4.3.1 A Fixed-Length MAC
Pseudorandom functions are a natural tool for constructing secure message
authentication codes. Intuitively, if the MAC tag tis obtained by applying a
pseudorandom function to the message m, then forging a tag on a previously
unauthenticated message requires the adversary to correctly guess the value
of the pseudorandom function at a “new” input point. The probability of
guessing the value of a randomfunction on a new point is 2−n(if the output
length of the function is n). The probability of guessing such a value for a
pseudorandom function can be only negligibly greater.
The above idea, shown in Construction 4.5, works for constructing a secure
ﬁxed-length MAC for messages of length n(since our pseudorandom functions
by default have n-bit block length). This is useful, but falls short of our goal.
In Section 4.3.2, we show how to extend this to handle messages of arbitrary
length. We explore more eﬃcient constructions of MACs for arbitrary-length
messages in Sections 4.4 and 5.3.2.Message Authentication Codes 117
CONSTRUCTION 4.5
LetFbe a pseudorandom function. Deﬁne a ﬁxed-length MAC for
messages of length nas follows:
•Mac: on input a key k∈{0,1}nand a message m∈{0,1}n,
output the tag t:=Fk(m). (If|m|/negationslash=|k|then output nothing.)
•Vrfy: on input a key k∈{0,1}n, a message m∈{0,1}n, and a
tagt∈{0,1}n, output 1 if and only if t?=Fk(m). (If|m|/negationslash=|k|,
then output 0.)
A ﬁxed-length MAC from any pseudorandom function.
THEOREM 4.6 IfFis a pseudorandom function, then Construction 4.5
is a secure ﬁxed-length MAC for messages of length n.
PROOF As in previous uses of pseudorandom functions, this proof follows
the paradigm of ﬁrst analyzing the security of the scheme using a truly ran-
dom function, and then considering the result of replacing the truly random
function with a pseudorandom one.
LetAbe a probabilistic polynomial-time adversary. Consider the message
authenticationcode /tildewideΠ = (/tildewidestGen,/tildewidestMac,/tildewidestVrfy)whichisthesameasΠ = ( Mac,Vrfy)
in Construction 4.5 except that a truly random function fis used instead of
the pseudorandomfunction Fk. That is,/tildewidestGen(1n) worksby choosinga uniform
function f∈Funcn, and/tildewidestMaccomputes a tag just as Macdoes except that f
is used instead of Fk. It is immediate that
Pr[Mac-forgeA,/tildewideΠ(n) = 1]≤2−n(4.1)
because for any message m /∈Q, the value t=f(m) is uniformly distributed
in{0,1}nfrom the point of view of the adversary A.
We next show that there is a negligible function neglsuch that
/vextendsingle/vextendsingle/vextendsinglePr[Mac-forgeA,Π(n) = 1]−Pr[Mac-forgeA,/tildewideΠ(n) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl(n); (4.2)
combined with Equation (4.1), this shows that
Pr[Mac-forgeA,Π(n) = 1]≤2−n+negl(n),
proving the theorem.
To prove Equation (4.2), we construct a polynomial-time distinguisher D
that is given oracle access to some function, and whose goal is to determine
whether this function is pseudorandom (i.e., equal to Fkfor uniform k∈
{0,1}n) or random (i.e., equal to ffor uniform f∈Funcn). To do this, D
emulates the message authentication experiment for Aand observes whether
Asucceedsin outputting a validtagon a“new”message. Ifso, Dguessesthat
its oracle is a pseudorandom function; otherwise, Dguesses that its oracle is
a random function. In detail:118 Introduction to Modern Cryptography
Distinguisher D:
Dis given input 1nand access to an oracle O:{0,1}n→{0,1}n,
and works as follows:
1. RunA(1n). WheneverAqueriesitsMACoracleonamessage
m(i.e., wheneverArequests a tag on a message m), answer
this query in the following way:
QueryOwithmand obtain response t; returnttoA.
2. WhenAoutputs ( m,t) at the end of its execution, do:
(a) QueryOwithmand obtain response ˆt.
(b) If (1) ˆt=tand (2)Anever queried its MAC oracle on
m, then output 1; otherwise, output 0.
It is clear that Druns in polynomial time.
Notice that if D’s oracle is a pseudorandom function, then the view of
Awhen run as a sub-routine by Dis distributed identically to the view of
Ain experiment Mac-forgeA,Π(n). Furthermore, Doutputs 1 exactly when
Mac-forgeA,Π(n) = 1. Therefore
Pr/bracketleftBig
DFk(·)(1n) = 1/bracketrightBig
= Pr/bracketleftbig
Mac-forgeA,Π(n) = 1/bracketrightbig
,
wherek∈{0,1}nis chosen uniformly in the above. If D’s oracle is a random
function, then the view of Awhen run as a sub-routine by Dis distributed
identically to the view of Ain experiment Mac-forgeA,/tildewideΠ(n), and again D
outputs 1 exactly when Mac-forgeA,/tildewideΠ(n) = 1. Thus,
Pr/bracketleftBig
Df(·)(1n) = 1/bracketrightBig
= Pr/bracketleftBig
Mac-forgeA,/tildewideΠ(n) = 1/bracketrightBig
,
wheref∈Funcnis chosen uniformly.
SinceFis a pseudorandom function and Druns in polynomial time, there
exists a negligible function neglsuch that
/vextendsingle/vextendsingle/vextendsinglePr/bracketleftBig
DFk(·)(1n) = 1/bracketrightBig
−Pr/bracketleftBig
Df(·)(1n) = 1/bracketrightBig/vextendsingle/vextendsingle/vextendsingle≤negl(n).
This implies Equation (4.2), completing the proof of the theorem.
4.3.2 Domain Extension for MACs
Construction 4.5 is important in that it shows a general paradigm for con-
structing secure message authentication codes from pseudorandom functions.
Unfortunately, the construction is only capable of handling ﬁxed-length mes-
sages that are furthermore rather short.3These limitations are unacceptable
3Given a pseudorandom function taking arbitrary-length inputs, Construction 4.5 would
yield a secure MAC for messages of arbitrary length. Likewise, a pseudorandom functionMessage Authentication Codes 119
in most applications. We show here how a general MAC, handling arbitrary-
length messages, can be constructed from any ﬁxed-length MAC for messages
of length n. The construction we show is not very eﬃcient and is unlikely to
be used in practice. Indeed, far more eﬃcient constructions of secure MACs
are known, as we discuss in Sections 4.4 and 5.3.2. We include the present
construction for its simplicity and generality.
LetΠ/prime= (Mac/prime,Vrfy/prime)beasecureﬁxed-lengthMACformessagesoflength n.
Before presenting the construction of a MAC for arbitrary-length messages
based on Π/prime, we rule out some simple ideas and describe some canonical
attacks that must be prevented. Below, we parse the message mto be au-
thenticated as a sequence of blocks m1,...,m d; note that, since our aim is to
handle messages of arbitrary length, dcan vary from message to message.
1. A natural ﬁrst idea is to simply authenticate each block separately, i.e.,
compute ti:=Mac/prime
k(mi) for all i, and output/angbracketleftt1,...,td/angbracketrightas the tag.
Thispreventsanadversaryfromsendinganypreviouslyunauthenticated
block without being detected. However, it does not prevent a block re-
ordering attack in which the attacker shuﬄes the order of blocks in an
authenticated message. Speciﬁcally, if /angbracketleftt1,t2/angbracketrightis a valid tag on the mes-
sagem1,m2(withm1/negationslash=m2), then/angbracketleftt2,t1/angbracketrightisavalidtagonthe(diﬀerent)
message m2,m1(something that is not allowed by Deﬁnition 4.2).
2. We can prevent the previous attack by authenticating a block index
along with each block. That is, we now compute ti=Mac/prime
k(i/bardblmi) for
alli, and output/angbracketleftt1,...,td/angbracketrightas the tag. (Note that the block length |mi|
will have to change.) This does not prevent a truncation attack whereby
an attacker simply drops blocks from the end of the message (and drops
the corresponding blocks of the tag as well).
3. The truncation attack can be thwarted by additionally authenticating
the message length along with each block. (Authenticating the message
length as a separate block does not work. Do you see why?) That
is, compute ti=Mac/prime
k(/lscript/bardbli/bardblmi) for all i, where /lscriptdenotes the length
of the message in bits. (Once again, the block length |mi|will need to
decrease.) Thisschemeisvulnerabletoa “mix-and-match” attack where
the adversary combines blocks from diﬀerent messages. For example,
if the adversary obtains tags /angbracketleftt1,...,td/angbracketrightand/angbracketleftt/prime
1,...,t/prime
d/angbracketrighton messages
m=m1,...,m dandm/prime=m/prime
1,...,m/prime
d, respectively, it can output the
valid tag/angbracketleftt1,t/prime
2,t3,t/prime
4,.../angbracketrighton the message m1,m/prime
2,m3,m/prime
4,....
We can prevent this last attack by also including a random “message identi-
ﬁer” along with each block that prevents blocks from diﬀerent messages from
being combined. This leads us to Construction 4.7.
with a larger domain would yield a secure MAC for longer messages. However, existing
practicalpseudorandom functions (i.e., block ciphers) take short, ﬁxed-length inputs.120 Introduction to Modern Cryptography
CONSTRUCTION 4.7
LetΠ/prime= (Mac/prime,Vrfy/prime) be a ﬁxed-length MAC for messages of length n.
Deﬁne a MAC as follows:
•Mac: on input a key k∈{0,1}nand a message m∈{0,1}∗of
(nonzero) length /lscript <2n/4, parsemintodblocksm1,...,m d, each
of length n/4. (The ﬁnal block is padded with 0s if necessary.)
Choose a uniform identiﬁer r∈{0,1}n/4.
Fori= 1,...,d, compute ti←Mac/prime
k(r/bardbl/lscript/bardbli/bardblmi), where i,/lscriptare en-
coded as strings of length n/4.†Output the tag t:=/angbracketleftr,t1,...,t d/angbracketright.
•Vrfy: on input a key k∈ {0,1}n, a message m∈ {0,1}∗of
length/lscript <2n/4, and a tag t=/angbracketleftr,t1,...,t d/prime/angbracketright, parse minto
dblocksm1,...,m d, each of length n/4. (The ﬁnal block is
padded with 0s if necessary.) Output 1 if and only if d/prime=d
andVrfy/prime
k(r/bardbl/lscript/bardbli/bardblmi, ti) = 1 for 1≤i≤d.
†Note thatiand/lscriptcan be encoded using n/4 bits because i,/lscript <2n/4.
A MAC for arbitrary-length messages from any ﬁxed-length MAC.
(Technically, the scheme only handles messages of length less than 2n/4.
Asymptotically, since this is an exponential bound, honest parties will not
authenticate messagesthat long and any polynomial-time adversarycould not
submit messages that long to its MAC oracle. In practice, when a concrete
value ofnis ﬁxed, one must ensure that this bound is acceptable.)
THEOREM4.8 IfΠ/primeis a secure ﬁxed-lengthMACfor messages of length n,
then Construction 4.7 is a secure MAC (for arbitrary-length messages).
PROOF The intuition is that as long as Π/primeis secure, an adversary cannot
introduceanewblockwith avalidtag. Furthermore,the extrainformationin-
cludedin eachblockpreventsthevariousattacks(droppingblocks,re-ordering
blocks, etc.) sketched earlier. We will prove security by essentially showing
that these attacks are the only ones possible.
Let Π be the MAC given by Construction 4.7, and let Abe a probabilistic
polynomial-time adversary. We show that Pr[ Mac-forgeA,Π(n) = 1] is negli-
gible. We ﬁrst introduce some notation that will be used in the proof. Let
Repeatdenote the event that the same random identiﬁer appears in two of
the tags returned by the MAC oracle in experiment Mac-forgeA,Π(n). Let-
ting (m,t=/angbracketleftr,t1,.../angbracketright) denote the ﬁnal output of A, wherem=m1,...has
length/lscript, we letNewBlock be the event that at least one of the blocks r/bardbl/lscript/bardbli/bardblmi
was never previously authenticated by Mac/primein the course of answering A’s
Macqueries. (Note that, by construction of Π, it is easy to tell exactly which
blocks are authenticated by Mac/prime
kwhen computing Mack(m).) Informally,
NewBlock is the event that Atries to output a valid tag on a block that wasMessage Authentication Codes 121
never authenticated by the underlying ﬁxed-length MAC Π/prime.
We have
Pr[Mac-forgeA,Π(n) = 1] = Pr[ Mac-forgeA,Π(n) = 1∧Repeat]
+Pr[Mac-forgeA,Π(n) = 1∧Repeat∧NewBlock]
+Pr[Mac-forgeA,Π(n) = 1∧Repeat∧NewBlock ]
≤Pr[Repeat] (4.3)
+Pr[Mac-forgeA,Π(n) = 1∧NewBlock ]
+Pr[Mac-forgeA,Π(n) = 1∧Repeat∧NewBlock ].
We show that the ﬁrst two terms of Equation (4.3) are negligible, and the
ﬁnal term is 0. This implies Pr[ Mac-forgeA,Π(n) = 1] is negligible, as desired.
CLAIM 4.9 Pr[Repeat]is negligible.
PROOF Letq(n) be the number of MAC oracle queries made by A. To
answer the ith oracle query of A, the oracle chooses riuniformly from a set
of size 2n/4. The probability of event Repeatis exactly the probability that
ri=rjfor some i/negationslash=j. Applying the “birthday bound” (Lemma A.15), we
have that Pr[ Repeat]≤q(n)2
2n/4.SinceAmakes only polynomially many queries,
this value is negligible.
We next consider the ﬁnal term on the right-hand side of Equation (4.3).
Weargue that if Mac-forgeA,Π(n) = 1, but Repeatdid not occur, then it must
be the case that NewBlock occurred. That is, Mac-forgeA,Π(n) = 1∧Repeat
impliesNewBlock , and so
Pr[Mac-forgeA,Π(n) = 1∧Repeat∧NewBlock ]= 0.
This is, in some sense, the heart of the proof.
Again let q=q(n) denote the number of MAC oracle queries made by A,
and letridenote the random identiﬁer used to answer the ith oracle query
ofA. IfRepeatdoes not occur then the values r1,...,r qare distinct. Let
(m,t=/angbracketleftr,t1,.../angbracketright) be the output of A, withm=m1,.... Ifr/negationslash∈{r1,...,r q},
thenNewBlock clearly occurs. If not, then r=rjfor some unique j, and the
blocksr/bardbl/lscript/bardbl1/bardblm1,...could then not possibly have been authenticated during
the course of answering any Macqueries other than the jth such query. Let
m(j)be the message that was used by Afor itsjth oracle query, and let /lscriptj
be its length. There are two cases to consider:
Case 1: /lscript/negationslash=/lscriptj.The blocksauthenticated whenansweringthe jthMacquery
all have/lscriptj/negationslash=/lscriptin the second position. So r/bardbl/lscript/bardbl1/bardblm1, in particular, was
never authenticated in the course of answering the jthMacquery, and
NewBlock occurs.122 Introduction to Modern Cryptography
Case 2: /lscript=/lscriptj.IfMac-forgeA,Π(n) = 1, then we must have m/negationslash=m(j). Let
m(j)=m(j)
1,.... Sincemandm(j)have equal length, there must be at
least one index ifor which mi/negationslash=m(j)
i. The block r/bardbl/lscript/bardbli/bardblmiwas then
never authenticated in the course of answering the jthMacquery. (Be-
causeiis included in the third position of the block, the block r/bardbl/lscript/bardbli/bardblmi
could only possiblyhave been authenticated if r/bardbl/lscript/bardbli/bardblmi=rj/bardbl/lscriptj/bardbli/bardblm(j)
i,
but this is not true since mi/negationslash=m(j)
i.)
To complete the proof of the theorem, we bound the second term on the
right-hand side of Equation (4.3):
CLAIM 4.10 Pr[Mac-forgeA,Π(n) = 1∧NewBlock ]is negligible.
The claim relies on security of Π/prime. We construct a pptadversaryA/primewho
attacks the ﬁxed-length MAC Π/primeand succeeds in outputting a valid forgery
on a previously unauthenticated message with probability
Pr[Mac-forgeA/prime,Π/prime(n) = 1]≥Pr[Mac-forgeA,Π(n) = 1∧NewBlock ].(4.4)
Security of Π/primemeans that the left-hand side is negligible, proving the claim.
The construction of A/primeis the obvious one and so we describe it brieﬂy.
A/primerunsAas a sub-routine, and answers the request by Afor a tag on m
by choosing r←{0,1}n/4itself, parsing mappropriately, and making the
necessary queries to its own MAC oracle Mac/prime
k(·). WhenAoutputs ( m,t=
/angbracketleftr,t1,.../angbracketright), thenA/primechecks whether NewBlock occurs (this is easy to do since
A/primecan keep track of all the queries it makes to its own oracle). If so, then
A/primeﬁnds the ﬁrst block r/bardbl/lscript/bardbli/bardblmithat was never previously authenticated by
Mac/primeand outputs ( r/bardbl/lscript/bardbli/bardblmi, ti). (If not,A/primeoutputs nothing.)
The view ofAwhen run as a sub-routine by A/primeis distributed identically
to the view ofAin experiment Mac-forgeA,Π(n), and so the probabilities of
eventsMac-forgeA,Π(n) = 1 and NewBlock do not change. If NewBlock occurs
thenA/primeoutputs a block r/bardbl/lscript/bardbli/bardblmithat was never previously authenticated
by its own MAC oracle; if Mac-forgeA,Π(n) = 1 then the tag on every block
is valid (with respect to Π/prime), and so in particular this is true for the block
output byA/prime. This means that whenever Mac-forgeA,Π(n) = 1 and NewBlock
occur we have Mac-forgeA/prime,Π/prime(n) = 1, proving Equation (4.4).
4.4 CBC-MAC
Theorems 4.6 and 4.8 show that it is possible to construct a secure mes-
sage authentication code for arbitrary-length messages from a pseudorandomMessage Authentication Codes 123
function taking inputs of ﬁxed length n. This demonstrates, in principle, that
secure MACs can be constructed from block ciphers. Unfortunately, the re-
sulting construction is extremely ineﬃcient: to compute a tag on a message of
lengthdn, the blockcipheris evaluated4 dtimes; the tagismorethan 4 dnbits
long. Fortunately, far more eﬃcient constructions are available. We explore
one such construction here that relies solely on block ciphers, and another in
Section 5.3.2 that uses an additional cryptographic primitive.
4.4.1 The Basic Construction
CBC-MAC is a standardized message authentication code used widely in
practice. A basic version of CBC-MAC, secure when authenticating messages
of anyﬁxedlength, is given as Construction 4.11. (See also Figure 4.1.) We
caution that this basic scheme is notsecure in the general case when messages
of diﬀerent lengths may be authenticated; see further discussion below.
CONSTRUCTION 4.11
LetFbe a pseudorandom function, and ﬁx a length function /lscript >0. The
basic CBC-MAC construction is as follows:
•Mac: on input a key k∈{0,1}nand a message mof length /lscript(n)·n,
do the following (we set /lscript=/lscript(n) in what follows):
1. Parse masm=m1,...,m /lscriptwhere each miis of length n.
2. Sett0:= 0n. Then, for i= 1 to/lscript:
Setti:=Fk(ti−1⊕mi).
Outputt/lscriptas the tag.
•Vrfy: on input a key k∈{0,1}n, a message m, and a tag t, do: If
mis not of length /lscript(n)·nthen output 0. Otherwise, output 1 if
and only if t?=Mack(m).
Basic CBC-MAC (for ﬁxed-length messages).
THEOREM 4.12 Let/lscriptbe a polynomial. If Fis a pseudorandom function,
then Construction 4.11 is a secure MAC for messages of length /lscript(n)·n.
The proof of Theorem 4.12 is somewhat involved. In the following section
we will prove a more general result from which the above theorem follows.
Although Construction 4.11 can be extended in the obvious way to han-
dle messages whose length is an arbitrary multiple of n, the construction
is only secure when the length of the messages being authenticated is ﬁxed
and agreed upon in advance by the sender and receiver. (See Exercise 4.13.)124 Introduction to Modern Cryptography
The advantage of this construction over Construction 4.5, which also gives a
ﬁxed-length MAC, is that the present construction can authenticate longer
messages. Compared to Construction 4.7, CBC-MAC is much more eﬃcient,
requiring only dblock-cipher evaluations for a message of length dn, and with
a tag of length nonly.
CBC-MAC vs. CBC-mode encryption. CBC-MACissimilartotheCBC
mode of operation. There are, however, some important diﬀerences:
1. CBC-mode encryption uses a randomIVand this is crucial for security.
In contrast, CBC-MAC uses no IV(alternately, it can be viewed as
using the ﬁxed value IV= 0n) and this is also crucial for security.
Speciﬁcally, CBC-MAC using a random IVis not secure.
2. In CBC-mode encryption all intermediate values ti(calledciin the
case of CBC-mode encryption) are output by the encryption algorithm
as part of the ciphertext, whereas in CBC-MAC only the ﬁnal block
is output as the tag. If CBC-MAC is modiﬁed to output all the {ti}
obtainedduringthecourseofthecomputationthenitisnolongersecure.
In Exercise 4.14 you are asked to verify that the modiﬁcations of CBC-MAC
discussedaboveareinsecure. Theseexamplesillustratethefactthatharmless-
looking modiﬁcations to cryptographic constructions can render them inse-
cure. One should always implement a cryptographic construction exactly as
speciﬁed and not introduce any variations (unless the variations themselves
can be proven secure). Furthermore, it is essential to understand the con-
struction being used. In many cases a cryptographic library provides a pro-
grammer with a “CBC function,” but does not distinguish between the use of
this function for encryption or message authentication.
Secure CBC-MAC for arbitrary-length messages. We brieﬂy describe
two ways Construction 4.11 can be modiﬁed, in a provably secure fashion,
to handle arbitrary-length messages. (Here for simplicity we assume that all
messagesbeingauthenticatedhavelengthamultiple of n, andthat Vrfyrejects
/MT70/MT107/MT109 /MT50
/MT70/MT107/MT109 /MT51
/MT70/MT107
/MT116/MT109 /MT49
FIGURE 4.1 :Basic CBC-MAC (for ﬁxed-length messages).Message Authentication Codes 125
any message whose length is not a multiple of n. In the following section we
treat the more general case where messages can have arbitrary length.)
1.Prepend the message mwith its length|m|(encoded as an n-bit string),
and then compute basic CBC-MAC on the result; see Figure 4.2. Secu-
rity of this variant follows from the results proved in the next section.
Note that appending |m|to theendof the message and then computing
the basic CBC-MAC is notsecure.
2. Change the scheme so that key generation chooses two independent,
uniform keys k1∈{0,1}nandk2∈{0,1}n. Then to authenticate a
message m, ﬁrst compute the basic CBC-MAC of musingk1and lett
be the result; output the tag ˆt:=Fk2(t).
The second option has the advantage of not needing to know the message
length in advance (i.e., when beginning to compute the tag). However, it
has the drawback of using two keys for F. Note that, at the expense of two
additional applications of the pseudorandom function, it is possible to store a
singlekey kand thenderivekeys k1:=Fk(1) andk2:=Fk(2) atthe beginning
of the computation. Despite this, in practice, the operation of initializing a
key for a block cipher is considered relatively expensive. Therefore, requiring
two diﬀerent keys—even if they are derived on the ﬂy—is less desirable.
4.4.2 *Proof of Security
In this section we prove security of diﬀerent variants of CBC-MAC. We
begin by summarizing the results, and then give the details of the proof.
Before beginning, we remark that the proof in this section is quite involved,
and is intended for advanced readers.
Throughout this section, ﬁx a keyed function Fthat, for security parame-
tern, mapsn-bit keys and n-bit inputs to n-bit outputs. We deﬁne a keyed
/MT70/MT107/MT109/MT49
/MT70/MT107 /MT70/MT107/MT109/MT50 /MT109/MT51
/MT70/MT107/MT109
/MT116
FIGURE 4.2 :Avariant of CBC-MAC secure for authenticating
arbitrary-length messages.126 Introduction to Modern Cryptography
function CBCthat, for security parameter n, mapsn-bit keys and inputs in
({0,1}n)∗(i.e., strings whose length is a multiple of n) ton-bit outputs. This
function is deﬁned as
CBCk(x1,...,x /lscript)def=Fk(Fk(···Fk(Fk(x1)⊕x2)⊕···)⊕x/lscript),
where|x1|=···=|x/lscript|=|k|=n. (We leave CBCkundeﬁned on the empty
string.) Note that CBCis exactly basic CBC-MAC, although here we consider
inputs of diﬀerent lengths.
A set of strings P⊂({0,1}n)∗ispreﬁx-free if it does not contain the empty
string, and no string X∈Pis a preﬁx of any other string X/prime∈P. We show:
THEOREM 4.13 IfFis a pseudorandom function, then CBCis a pseu-
dorandom function as long as the set of inputs on which it is queried is
preﬁx-free. Formally, for all probabilistic polynomial-time distinguishers D
that query their oracle on a preﬁx-free set of inputs, there is a negligible func-
tionneglsuch that
/vextendsingle/vextendsingle/vextendsinglePr[DCBCk(·)(1n) = 1]−Pr[Df(·)(1n) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl(n),
wherekis chosen uniformly from {0,1}nandfis chosen uniformly from the
set of functions mapping ({0,1}n)∗to{0,1}n(i.e., the value of fat each
input is uniform and independent of the values of fat all other inputs).
Thus, we can convert a pseudorandom function Ffor ﬁxed-length inputs
into a pseudorandom function CBCfor arbitrary-length inputs (subject to a
constraint on which inputs can be queried)! To use this for message authen-
tication, we adapt the idea of Construction 4.5 as follows: to authenticate a
message m, ﬁrst apply some encoding function encodeto obtain a (nonempty)
stringencode(m)∈({0,1}n)∗; then output the tag CBCk(encode(m)). For
this to be secure (cf. the proof of Theorem 4.6), the encoding needs to be
preﬁx-free , namely, to have the property that for any distinct (legal) messages
m1,m2, the string encode(m1) is not a preﬁx of encode(m2). This implies
that for any set of (legal) messages {m1,...}, the set of encoded messages
{encode(m1),...}is preﬁx-free.
We now examine two concrete applications of this idea:
•Fix/lscript, and let the set of legal messages be {0,1}/lscript(n)·n. Then we can
take the trivial encoding encode(m) =m, which is preﬁx-free since one
string cannot be a preﬁx of a diﬀerent string of the same length. This is
exactlybasicCBC-MAC,andwhatwehavesaidaboveimpliesthatbasic
CBC-MAC is securefor messagesofany ﬁxed length (cf. Theorem 4.12).
•One wayofhandling arbitrary-length(nonempty) messages(technically,
messages of length less than 2n) is to encode a string m∈ {0,1}∗
by prepending its length |m|(encoded as an n-bit string), and then
appending as many 0s as needed to make the length of the resultingMessage Authentication Codes 127
string a multiple of n. (This is essentially what is shown in Figure 4.2.)
This encoding is preﬁx-free, and we therefore obtain a secure MAC for
arbitrary-length messages.
The rest of this section is devoted to a proof of Theorem 4.13. In proving
the theorem, we analyze CBCwhen it is “keyed” with a random function g
rather than a random key kfor some underlying pseudorandom function F.
That is, we consider the keyed function CBCgdeﬁned as
CBCg(x1,...,x /lscript)def=g(g(···g(g(x1)⊕x2)⊕···)⊕x/lscript)
where, for security parameter n, the function gmapsn-bit inputs to n-bit
outputs, and|x1|=···=|x/lscript|=n. Note that CBCgas deﬁned here is
not eﬃcient (since the representation of grequires space exponential in n);
nevertheless, it is still a well-deﬁned, keyed function.
We show that if gis chosen uniformly from Funcn, thenCBCgis indistin-
guishable from a random function mapping ( {0,1}n)∗ton-bit strings, as long
as a preﬁx-free set of inputs is queried. More precisely:
CLAIM 4.14 Fix any n≥1. For all distinguishers Dthat query their
oracle on a preﬁx-free set of qinputs, where the longest such input contains /lscript
blocks, it holds that:
/vextendsingle/vextendsingle/vextendsinglePr[DCBCg(·)(1n) = 1]−Pr[Df(·)(1n) = 1]/vextendsingle/vextendsingle/vextendsingle≤q2/lscript2
2n,
wheregis chosen uniformly from Funcn, andfis chosen uniformly from the
set of functions mapping ({0,1}n)∗to{0,1}n.
(The claim is unconditional, and does not impose any constraints on the
running time of D. Thus we may take Dto be deterministic.) The above
implies Theorem 4.13 using standard techniques that we have already seen.
In particular, for any Drunning in polynomial time we must have q(n),/lscript(n) =
poly(n) and so q(n)2/lscript(n)2·2−nis negligible.
PROOF (of Claim 4.14) Fix some n≥1. The proof proceeds in two
steps: We ﬁrst deﬁne a notion of smoothness and prove that CBCis smooth;
we then show that smoothness implies the claim.
LetP={X1,...,X q}be a preﬁx-free set of qinputs, where each Xiis
in ({0,1}n)∗and the longest string in Pcontains /lscriptblocks (i.e., each Xi∈P
contains at most /lscriptblocks of length n). Note that for any t1,...,tq∈{0,1}n
it holds that Pr[ ∀i:f(Xi) =ti] = 2−nq, where the probability is over uni-
form choice of the function ffrom the set of functions mapping ( {0,1}n)∗
to{0,1}n. We say that CBCis (q,/lscript,δ)-smoothif for every preﬁx-free set P=
{X1,...,X q}as above and every t1,...,tq∈{0,1}n, it holds that
Pr[∀i:CBCg(Xi) =ti]≥(1−δ)·2−nq,
where the probability is over uniform choice of g∈Funcn.128 Introduction to Modern Cryptography
Inwords, CBCissmoothifforeveryﬁxedsetofinput/outputpairs {(Xi,ti)},
where the{Xi}form a preﬁx-free set, the probability that CBCg(Xi) =tifor
alliisδ-close to the probability that f(Xi) =tifor alli(wheregis a random
function from{0,1}nto{0,1}n, andfis a random function from ( {0,1}n)∗
to{0,1}n).
CLAIM 4.15 CBCgis(q,/lscript,δ)-smooth, for δ=q2/lscript2·2−n.
PROOF For any X∈({0,1}n)∗, withX=x1,...andxi∈{0,1}n, let
Cg(X)denote the set ofinputs onwhich gisevaluated duringthe computation
ofCBCg(X); i.e., if X∈({0,1}n)mthen
Cg(X)def= (x1,CBCg(x1)⊕x2, ...,CBCg(x1,...,x m−1)⊕xm).
ForX∈({0,1}n)mandX/prime∈({0,1}n)m/prime
, withCg(X) = (I1,...,I m) and
Cg(X/prime) = (I/prime
1,...,I/prime
m/prime), say there is a non-trivial collision in XifIi=Ijfor
somei/negationslash=j, and say that there is a non-trivial collision between XandX/primeif
Ii=I/prime
jbut (x1,...,x i)/negationslash= (x/prime
1,...,x/prime
j) (in this latter case imay equal j). We
say that there is a non-trivial collision in Pif there is a non-trivial collision
in some X∈Por between some pair of strings X,X/prime∈P. LetCollbe the
event that there is a non-trivial collision in P.
We prove the claim in two steps. First, we show that conditioned on there
not being a non-trivial collision in P, the probability that CBCg(Xi) =ti
for alliis exactly 2−nq. Next, we show that the probability that there is a
non-trivial collision in Pis less than δ=q2/lscript2·2−n.
Consider choosing a uniform gby choosing, one-by-one, uniform values for
theoutputsof gondiﬀerentinputs. Determiningwhetherthereisanon-trivial
collision between two strings X,X/prime∈Pcan be done by ﬁrst choosing the
values of g(I1) andg(I/prime
1) (ifI/prime
1=I1, these values are the same), then choosing
values for g(I2) andg(I/prime
2) (note that I2=g(I1)⊕x2andI/prime
2=g(I/prime
1)⊕x/prime
2
are deﬁned once g(I1),g(I/prime
1) have been ﬁxed), and continuing in this way
until we choose values for g(Im−1) andg(I/prime
m/prime−1). In particular, the values
ofg(Im),g(I/prime
m/prime) need not be chosen in order to determine whether there is a
non-trivial collision between XandX/prime. Continuing this line of reasoning, it
is possible to determine whether Colloccurs by choosing the values of gon all
but the ﬁnal entries of each of Cg(X1),...,Cg(Xq).
AssumeCollhas not occurred after ﬁxing the values of gon various inputs
as described above. Consider the ﬁnal entries in each of Cg(X1),...,Cg(Xq).
These entries are all distinct (this is immediate from the fact that Collhas
not occurred), and we claim that the value of gon each of those points has
not yet been ﬁxed. Indeed, the only way the value of gcould already be ﬁxed
on any of those points is if the ﬁnal entry Imof someCg(X) is equal to a
non-ﬁnal entry Ijof someCg(X/prime). But since Collhas not occurred, this canMessage Authentication Codes 129
only happen if X/negationslash=X/primeand (x/prime
1,...,x/prime
j) = (x1,...,x m). But then Xwould
be a preﬁx of X/prime, violating the assumption that Pis preﬁx-free.
Sincegisarandomfunction, theabovemeansthat CBCg(X1),...,CBCg(Xq)
areuniform andindependent of each other as well as all the other values of g
that have already been ﬁxed. (This is because CBCg(Xi) is the value of g
when evaluated at the ﬁnal entry of Cg(Xi), an input value which is diﬀerent
from all the other inputs at which ghas already been ﬁxed.) Thus, for any
t1,...,tq∈{0,1}nwe have:
Pr/bracketleftbig
∀i:CBCg(Xi) =ti|Coll/bracketrightbig
=2−nq. (4.5)
We next show that Colloccurs with high probability by upper-bounding
Pr[Coll]. For distinct Xi,Xj∈P, letColli,jdenote the event that there is a
non-trivial collision in XorX/prime, or a non-trivial collision between XandX/prime.
We have Coll=/logicalortext
i,jColli,jand so a union bound gives
Pr[Coll]≤/summationdisplay
i,j:i<jPr[Colli,j] =/parenleftbiggq
2/parenrightbigg
·Pr[Colli,j]≤q2
2·Pr[Colli,j].(4.6)
Fixing distinct X=XiandX/prime=XjinP, we now bound Colli,j. As will
be clear from the analysis, the probability is maximized when XandX/primeare
both as long as possible, and thus we assume they are each /lscriptblocks long. Let
X= (x1,...,x /lscript) andX/prime= (x/prime
1,...,x/prime
/lscript), and let tbe the largest integer such
that (x1,...,x t) = (x/prime
1,...,x/prime
t). (Note that t < /lscriptor elseX=X/prime.) We assume
t >0, but the analysis below can be easily modiﬁed, giving the same result,
ift= 0. We continue to let I1,I2,...(resp.,I/prime
1,I/prime
2,...) denote the inputs
togduring the course of computing CBCg(X) (resp., CBCg(X/prime)); note that
(I/prime
1,...,I/prime
t) = (I1,...,I t). Consider choosing gby choosing uniform values for
the outputs of g, one-by-one. We do this in 2 /lscript−2 steps as follows:
Steps 1 through t−1(ift >1):In each step i, choose a uniform value for
g(Ii), thus deﬁning Ii+1andI/prime
i+1(which are equal).
Stept:Choose a uniform value for g(It), thus deﬁning It+1andI/prime
t+1.
Stepst+1to/lscript−1(ift < /lscript−1):Choose, in turn, uniform values for each
ofg(It+1),g(It+2), ...,g(I/lscript−1), thus deﬁning It+2,It+3, ...,I/lscript.
Steps/lscriptto2/lscript−2(ift < /lscript−1):Choose, in turn, uniform values for each of
g(I/prime
t+1),g(I/prime
t+2), ...,g(I/prime
/lscript−1), thus deﬁning I/prime
t+2,I/prime
t+3, ...,I/prime
/lscript.
LetColl(k) be the event that a non-trivial collision occurs by step k. Then
Pr[Colli,j]=Pr[/logicalortext
kColl(k)]≤Pr[Coll(1)]+2/lscript−2/summationdisplay
k=2Pr[Coll(k)|Coll(k−1)],(4.7)
using Proposition A.9. For k < t, we claim Pr[ Coll(k)|Coll(k−1)] =k/2n:
indeed, if no non-trivial collision has occurred by step k−1, the value of130 Introduction to Modern Cryptography
g(Ik) is chosen uniformly in step k; a non-trivial collision occurs only if it
happens that Ik+1=g(Ik)⊕xk+1is equal to one of {I1,...,I k}(which are
all distinct, since Coll(k−1) has not occurred). By similar reasoning, we
have Pr[Coll(t)|Coll(t−1)]≤2t/2n(here there are two values It+1,I/prime
t+1to
consider; note that they cannot be equal to each other). Finally, arguing
as before, for k > twe have Pr[ Coll(k)|Coll(k−1)] = (k+1)/2n. Using
Equation (4.7), we thus have
Pr[Colli,j]≤2−n·/parenleftBiggt−1/summationdisplay
k=1k+2t+2/lscript−2/summationdisplay
k=t+1(k+1)/parenrightBigg
= 2−n·2/lscript−1/summationdisplay
k=2k= 2−n·(2/lscript+1)·(/lscript−1)<2/lscript2·2−n.
From Equation (4.6) we get Pr[ Coll]< q2/lscript2·2−n=δ. Finally, using Equa-
tion (4.5) we see that
Pr[∀i:CBCg(Xi) =ti]≥Pr/bracketleftbig
∀i:CBCg(Xi) =ti|Coll/bracketrightbig
·Pr[Coll]
=2−nq·Pr[Coll]≥(1−δ)·2−nq,
as claimed.
We now show that smoothness implies the theorem. Assume without loss of
generality that Dalways makes q(distinct) queries, each containing at most /lscript
blocks.Dmay choose its queries adaptively (i.e., depending on the answers
to previous queries), but the set of D’s queries must be preﬁx-free.
For distinct X1,...,X q∈({0,1}n)∗and arbitrary t1,...,tq∈{0,1}n, de-
ﬁneα(X1,...,X q;t1,...,tq) to be 1 if and only if Doutputs 1 when mak-
ing queries X1,...,X qand getting responses t1,...,tq. (If, say, Ddoes
not make query X1as its ﬁrst query, then α(X1,...;...) = 0.) Letting
/vectorX= (X1,...,X q) and/vectort= (t1,...,tq), we then have
Pr[DCBCg(·)(1n) = 1] =/summationdisplay
/vectorXpreﬁx-free; /vectortα(/vectorX,/vectort)·Pr[∀i:CBCg(Xi) =ti]
≥/summationdisplay
/vectorXpreﬁx-free; /vectortα(/vectorX,/vectort)·(1−δ)·Pr[∀i:f(Xi) =ti]
= (1−δ)·Pr[Df(·)(1n) = 1],
where, above, gis chosen uniformly from Funcn, andfis chosen uniformly
from the set of functions mapping ( {0,1}n)∗to{0,1}n. This implies
Pr[Df(·)(1n) = 1]−Pr[DCBCg(·)(1n) = 1]≤δ·Pr[Df(·)(1n) = 1]≤δ.
A symmetric argument for when Doutputs 0 completes the proof.Message Authentication Codes 131
4.5 Authenticated Encryption
InChapter 3, we studied how it is possible to obtain secrecyin the private-
key setting using encryption. In this chapter, we have shown how to ensure
integrity using message authentication codes. One might naturally want to
achieve both goals simultaneously, and this is the problem we turn to now.
It is best practice to always ensure secrecy and integrity by default in the
private-key setting. Indeed, in many applications where secrecy is required
it turns out that integrity is essential also. Moreover, a lack of integrity can
sometimes lead to a breach of secrecy.
4.5.1 Deﬁnitions
We begin, as usual, by deﬁning precisely what we wish to achieve. At
an abstract level, our goal is to realize an “ideally secure” communication
channel that provides both secrecy and integrity. Pursuing a deﬁnition of
this sort is beyond the scope of this book. Instead, we provide a simpler set
of deﬁnitions that treat secrecy and integrity separately. These deﬁnitions
and our subsequent analysis suﬃce for understanding the key issues at hand.
(We cautionthe reader, however,that—in contrastto encryptionand message
authentication codes—the ﬁeld has not yet settled on standard terminology
and deﬁnitions for authenticated encryption.)
Let Π = ( Gen,Enc,Dec) be a private-key encryption scheme. As mentioned
already, we deﬁne security by separately deﬁning secrecy and integrity. The
notion of secrecy we consider is one we have seen before: we require that
Π be secure against chosen-ciphertext attacks, i.e., that it be CCA-secure.
(Refer to Section 3.7 for a discussion and deﬁnition of CCA-security.) We
are concerned about chosen-ciphertext attacks here because we are explicitly
consideringan activeadversarywho can modify the data sent from one honest
partytotheother. Ournotionofintegritywillbe essentiallythat ofexistential
unforgeability under an adaptive chosen-message attack. Since Π does not
satisfy the syntax of a message authentication code, however, we introduce a
deﬁnition speciﬁc to this case. Consider the following experiment deﬁned for
a private-key encryption scheme Π = ( Gen,Enc,Dec), adversaryA, and value
nfor the security parameter:
The unforgeable encryption experiment Enc-ForgeA,Π(n):
1. RunGen(1n)to obtain a key k.
2. The adversary Ais given input 1nand access to an encryp-
tion oracle Enck(·). The adversary outputs a ciphertext c.
3. Letm:=Deck(c), and letQdenote the set of all queries that
Aasked its encryption oracle. The output of the experiment
is1if and only if (1) m/negationslash=⊥and (2)m/negationslash∈Q.132 Introduction to Modern Cryptography
DEFINITION 4.16 A private-key encryption scheme Πisunforgeable if
for all probabilistic polynomial-time adversaries A, there is a negligible func-
tionneglsuch that:
Pr[Enc-ForgeA,Π(n) = 1]≤negl(n).
ParallelingourdiscussionaboutveriﬁcationqueriesfollowingDeﬁnition 4.2,
here one could also consider a stronger deﬁnition in which Ais additionally
given access to a decryption oracle. One can verify that the secure construc-
tion we present below also satisﬁes that stronger deﬁnition.
We now deﬁne a (secure) authenticated encryption scheme.
DEFINITION 4.17 A private-key encryption scheme is an authenticated
encryption scheme if it is CCA-secure and unforgeable.
4.5.2 Generic Constructions
It may be tempting to think that any reasonable combination of a secure
encryption scheme and a secure message authentication code should result
in an authenticated encryption scheme. In this section we show that this is
not the case. This demonstrates that even secure cryptographic tools can be
combined in such a way that the result is insecure, and highlights once again
the importance of deﬁnitions and proofs of security. On the positive side, we
show how encryption and message authentication can be combined properly
to achieve joint secrecy and integrity.
Throughout, let Π E= (Enc,Dec) be a CPA-secure encryption scheme and
let ΠM= (Mac,Vrfy) denote a message authentication code, where key gener-
ation in both schemes simply involves choosinga uniform n-bit key. There are
threenaturalapproachestocombiningencryptionandmessageauthentication
using independent keys4kEandkMfor ΠEand Π M, respectively:
1.Encrypt-and-authenticate: In this method, encryption and message au-
thentication are computed independently in parallel. That is, given a
plaintext message m, the sender transmits the ciphertext /angbracketleftc,t/angbracketrightwhere:
c←EnckE(m) andt←MackM(m).
The receiver decrypts cto recover m; assuming no error occurred, it
then veriﬁes the tag t. IfVrfykM(m,t) = 1, the receiver outputs m;
otherwise, it outputs an error.
4Independent cryptographic keys should always be used when diﬀerent schemes are com-
bined. We return to this point at the end of this section.Message Authentication Codes 133
2.Authenticate-then-encrypt: Here a MAC tag tis ﬁrst computed, and
then the message and tag are encrypted together. That is, given a
message m, the sender transmits the ciphertext ccomputed as:
t←MackM(m) andc←EnckE(m/bardblt).
The receiver decrypts cto obtain m/bardblt; assuming no error occurs, it then
veriﬁes the tag t. As before, if VrfykM(m,t) = 1 the receiver outputs m;
otherwise, it outputs an error.
3.Encrypt-then-authenticate: Inthis case, the message mis ﬁrstencrypted
and then a MAC tag is computed overthe result. That is, the ciphertext
is the pair/angbracketleftc,t/angbracketrightwhere:
c←EnckE(m) andt←MackM(c).
(See also Construction 4.18.) If VrfykM(c,t) = 1, then the receiver
decrypts cand outputs the result; otherwise, it outputs an error.
We analyze each of the above approaches when they are instantiated with
“generic”securecomponents, i.e., an arbitrary CPA-secureencryptionscheme
and anarbitrary (strongly) secure MAC. We want an approach that provides
joint secrecy and integrity when using any(secure) components, and we will
therefore reject as “unsafe” any approach for which there exists even a single
counterexample of a secure encryption scheme/MAC for which the combi-
nation is insecure. This “all-or-nothing” approach reduces the likelihood of
implementation ﬂaws. Speciﬁcally, an authenticated encryption scheme might
be implemented by making calls to an “encryption subroutine” and a “mes-
sage authentication subroutine,” and the implementation of those subroutines
may be changed at some later point in time. (This commonly occurs when
cryptographic libraries are updated, or when standards are modiﬁed.) Im-
plementing an approach whose security depends on how its components are
implemented(ratherthanonthesecuritytheyprovide)isthereforedangerous.
We stress that if an approach is rejected this does not mean that it is
insecure for all possible instantiations of the components; it does, however,
mean that any instantiation of the approach must be analyzed and proven
secure before it is used.
Encrypt-and-authenticate. Recall that in this approach encryption and
message authentication are carried out independently. Given a message m,
the transmitted value is /angbracketleftc,t/angbracketrightwhere
c←EnckE(m) andt←MackM(m).
This approach may not achieve even the most basic level of secrecy. To see
this, note that a secure MAC does not guarantee anysecrecy and so it is pos-
sible for the tag MackM(m) to leak information about mto an eavesdropper.134 Introduction to Modern Cryptography
(As a trivial example, consider a secure MAC where the ﬁrst bit of the tag is
always equal to the ﬁrst bit of the message.) So the encrypt-and-authenticate
approach may yield a scheme that does not even have indistinguishable en-
cryptions in the presence of an eavesdropper.
Infact, theencrypt-and-authenticateapproachislikelytobeinsecureagainst
chosen-plaintext attacks even when instantiated with standard components
(unlike the contrived counterexample in the previous paragraph). In partic-
ular, if a deterministic MAC like CBC-MAC is used, then the tag computed
on a message (for some ﬁxed key kM) is the same every time. This allows
an eavesdropper to identify when the same message is sent twice, and so the
scheme is not CPA-secure. Most MACs used in practice are deterministic, so
this represents a real concern.
Authenticate-then-encrypt. Here, a MAC tag t←MackM(m) is ﬁrst com-
puted; then m/bardbltis encrypted and the resulting value EnckE(m/bardblt) is trans-
mitted. We show that this combination also does not necessarily yield an
authenticated encryption scheme.
Actually, we have already encountered a CPA-secure encryption scheme
for which this approach is insecure: the CBC-mode-with-padding scheme dis-
cussed in Section 3.7.2. (We assume in what follows that the readeris familiar
with that section.) Recall that this scheme works by ﬁrst padding the plain-
text (which in our case will be m/bardblt) in a speciﬁc way so the result is a multiple
of the block length, and then encrypting the result using CBC mode. During
decryption, if an error in the padding is detected after performing the CBC-
mode decryption, then a “bad padding” error is returned. With regard to
authenticate-then-encrypt, this means there are now twosources of potential
decryption failure: the padding may be incorrect, or the MAC tag may not
verify. Schematically, the decryption algorithm Dec/primein the combined scheme
works as follows:
Dec/prime
kE,kM(c):
1. Compute ˜ m:=DeckE(c). If an error in the padding is de-
tected, return “bad padding” and stop.
2. Parse ˜ masm/bardblt. IfVrfykM(m,t) = 1 return m; else, output
“authentication failure.”
Assuming the attackercan distinguish between the twoerrormessages, the at-
tacker can apply the same chosen-ciphertext attack described in Section 3.7.2
to the above scheme to recover the entire original plaintext from a given ci-
phertext. (This is due to the fact that the padding-oracle attack shown in
Section 3.7.2 relies only on the ability to learn whether or not there was a
padding error, something that is revealed by this scheme.) This type of at-
tack has been carried out successfully in the real world in various settings,
e.g., in conﬁgurations of IPsec that use authenticate-then-encrypt.Message Authentication Codes 135
One way to ﬁx the above scheme would be to ensure that only a singleerror
message is returned, regardless of the source of decryption failure. This is an
unsatisfying solution for several reasons: (1) there may be legitimate reasons
(e.g., usability, debugging) to have multiple error messages; (2) forcing the
error messages to be the same means that the combination is no longer truly
generic, i.e., it requires the implementer of the authenticate-then-encrypt ap-
proach to be aware of what error messages are returned by the underlying
CPA-secure encryption scheme; (3) most of all, it is extraordinarily hard to
ensure that the diﬀerent errors cannot be distinguished since, e.g., even a dif-
ference in the time to return each of these errors may be used by an adversary
to distinguish between them (cf. our earlier discussion of timing attacks at
the end of Section 4.2). Some versions of SSL tried using only a single er-
ror message in conjunction with an authenticate-then-encrypt approach, but
a padding-oracle attack was still successfully carried out using timing infor-
mation of this sort. We conclude that authenticate-then-encrypt does not
provide authenticated encryption in general, and should not be used.
Encrypt-then-authenticate. In this approach, the message is ﬁrst en-
crypted and then a MAC is computed over the result. That is, the message
is the pair/angbracketleftc,t/angbracketrightwhere
c←EnckE(m) andt←MackM(c).
Decryption of/angbracketleftc,t/angbracketrightis done by outputting ⊥ifVrfykM(c,t)/negationslash= 1, and otherwise
outputting DeckE(c). See Construction 4.18 for a formal description.
CONSTRUCTION 4.18
LetΠE= (Enc,Dec) be a private-key encryption scheme and let Π M=
(Mac,Vrfy) be a message authentication code, where in each case key
generation is done by simply choosing a uniform n-bit key. Deﬁne a
private-key encryption scheme ( Gen/prime,Enc/prime,Dec/prime) as follows:
•Gen/prime: on input 1n, choose independent, uniform kE,kM∈{0,1}n
and output the key ( kE,kM).
•Enc/prime: on inputa key( kE,kM)and a plaintextmessage m, compute
c←EnckE(m) andt←MackM(c). Output the ciphertext /angbracketleftc,t/angbracketright.
•Dec/prime: on input a key ( kE,kM) and a ciphertext /angbracketleftc,t/angbracketright, ﬁrst check
whether VrfykM(c,t)?= 1. If yes, then output DeckE(c); if no, then
output⊥.
A generic construction of an authenticated encryption scheme.
This approach issound, as long as the MAC is strongly secure , as in Deﬁni-
tion 4.3. As intuition for the securityofthis approach,saya ciphertext /angbracketleftc,t/angbracketrightis
validiftis a valid MAC tag on c. Strong security of the MAC ensures that an136 Introduction to Modern Cryptography
adversarywillbeunabletogenerate anyvalidciphertextthatitdidnotreceive
from its encryption oracle. This immediately implies that Construction 4.18
is unforgeable. As for CCA-security, the MAC computed over the ciphertext
has the eﬀect of rendering the decryption oracle useless since for every cipher-
text/angbracketleftc,t/angbracketrightthe adversary submits to its decryption oracle, the adversary either
already knows the decryption (if it received /angbracketleftc,t/angbracketrightfrom its own encryption or-
acle) or else can expect the result to be an error (since the adversary cannot
generate any new, valid ciphertexts). This means that CCA-security of the
combined scheme reduces to the CPA-security of Π E. Observe also that the
MAC is veriﬁed before decryption takes place; thus, MAC veriﬁcation cannot
leak anything about the plaintext (in contrast to the padding-oracle attack
we saw for the authenticate-then-encrypt approach). We now formalize the
above arguments.
THEOREM4.19 LetΠEbe a CPA-secureprivate-key encryption scheme,
and letΠMbe a strongly secure message authentication code. Then Construc-
tion 4.18 is an authenticated encryption scheme.
PROOF Let Π/primedenote the scheme resulting from Construction 4.18. We
need to show that Π/primeis unforgeable, and that it is CCA-secure. Following
the intuition given above, say a ciphertext /angbracketleftc,t/angbracketrightisvalid(with respect to
some ﬁxed secret key ( kE,kM)) ifVrfykM(c,t) = 1. We show that strong
security of Π Mimplies that (except with negligible probability) any “new”
ciphertexts the adversary submits to the decryption oracle will be invalid.
As discussed already, this immediately implies unforgeability. (In fact, it is
stronger than unforgeability.) This fact also renders the decryption oracle
useless, and means that CCA-security of Π/prime= (Gen/prime,Enc/prime,Dec/prime) reduces to
the CPA-security of Π E.
In moredetail, let Abe a probabilisticpolynomial-time adversaryattacking
Construction 4.18 in a chosen-ciphertext attack (cf. Deﬁnition 3.33). Say a
ciphertext/angbracketleftc,t/angbracketrightisnewifAdid not receive/angbracketleftc,t/angbracketrightfrom its encryption oracle
or as the challenge ciphertext. Let ValidQuery be the event that Asubmits
a new ciphertext /angbracketleftc,t/angbracketrightto its decryption oracle which is valid, i.e., for which
VrfykM(c,t) = 1. We prove:
CLAIM 4.20 Pr[ValidQuery ]is negligible.
PROOF Intuitively, this is due to the fact that if ValidQuery occurs then
the adversary has forged a new, valid pair ( c,t) in the Mac-sforge experi-
ment. Formally, let q(·) be a polynomial upper bound on the number of
decryption-oracle queries made by A, and consider the following adversary
AMattacking the message authentication code Π M(i.e., running in experi-
mentMac-sforgeAM,ΠM(n)):Message Authentication Codes 137
AdversaryAM:
AMis given input 1nand has access to a MAC oracle MackM(·).
1. Choose uniform kE∈{0,1}nandi∈{1,...,q(n)}.
2. RunAon input 1n. WhenAmakes an encryption-oracle
query for the message m, answer it as follows:
(i) Compute c←EnckE(m).
(ii) Query cto the MAC oracle and receive tin response.
Return/angbracketleftc,t/angbracketrighttoA.
The challenge ciphertext is prepared in the exact same way
(with a uniform bit b∈{0,1}chosen to select the message
mbthat gets encrypted).
WhenAmakes a decryption-oracle query for the ciphertext
/angbracketleftc,t/angbracketright, answer it as follows: If this is the ith decryption-oracle
query, output ( c,t). Otherwise:
(i) If/angbracketleftc,t/angbracketrightwas a response to a previous encryption-oracle
query for a message m, returnm.
(ii) Otherwise, return ⊥.
In essence,AMis “guessing”that the ith decryption-oracle query of Awill be
the ﬁrst new, valid query Amakes. In that case, AMoutputs a valid forgery
on a message cthat it had never previously submitted to its own MAC oracle.
ClearlyAMruns in probabilistic polynomial time. We now analyze the
probability thatAMproduces a good forgery. The key point is that the view
ofAwhen run as a subroutine by AMis distributed identically to the view
ofAin experiment PrivKcca
A,Π/prime(n)until event ValidQuery occurs. To see this,
note that the encryption-oracle queries of A(as well as computation of the
challenge ciphertext) are simulated perfectly by AM. As for the decryption-
oraclequeriesofA, untilValidQuery occurstheseareallsimulatedproperly. In
case (i) this is obvious. As for case (ii), if the ciphertext /angbracketleftc,t/angbracketrightsubmitted to the
decryption oracle is new, then as long as ValidQuery has not yet occurred the
correct answer to the decryption-oracle query is indeed ⊥. (Note that case (i)
is exactly the case that /angbracketleftc,t/angbracketrightis not new, and case (ii) is exactly the case
that/angbracketleftc,t/angbracketrightis new.) Recall that Ais disallowed from submitting the challenge
ciphertext to the decryption oracle.
Because the view of Awhen run as a subroutine by AMis distributed
identically to the view of Ain experiment PrivKcca
A,Π/prime(n) until event ValidQuery
occurs, the probability of event ValidQuery in experiment Mac-forgeAM,ΠM(n)
is the same as the probability of that event in experiment PrivKcca
A,Π/prime(n).
IfAMcorrectly guesses the ﬁrst index iwhenValidQuery occurs, thenAM
outputs ( c,t) for which VrfykM(c,t) = 1 (since/angbracketleftc,t/angbracketrightis valid) and for which
it was never given tag tin response to the query MackM(c) (since/angbracketleftc,t/angbracketrightis
new). In this case, then, AMsucceeds in experiment Mac-sforgeAM,ΠM(n).138 Introduction to Modern Cryptography
The probability that AMguessesicorrectly is 1 /q(n). Therefore
Pr[Mac-sforgeAM,ΠM(n) = 1]≥Pr[ValidQuery ]/q(n).
Since Π Mis a strongly secure MAC and qis polynomial, we conclude that
Pr[ValidQuery ] is negligible.
We use Claim 4.20 to prove security of Π/prime.The easier case is to prove
that Π/primeis unforgeable. This follows immediately from the claim, and so we
just provide informal reasoning rather than a formal proof. Observe ﬁrst that
the adversaryA/primein the unforgeable encryption experiment is a restricted
version of the adversary in the chosen-ciphertext experiment (in the former,
the adversary only has access to an encryption oracle). When A/primeoutputs a
ciphertext/angbracketleftc,t/angbracketrightat the end of its experiment, it “succeeds” only if /angbracketleftc,t/angbracketrightis valid
and new. But the previous claim shows precisely that the probability of such
an event is negligible.
It is slightly more involved to prove that Π/primeis CCA-secure. Let Aagain be
a probabilistic polynomial-time adversary attacking Π/primein a chosen-ciphertext
attack. We have
Pr[PrivKcca
A,Π/prime(n) = 1]
≤Pr[ValidQuery ]+Pr[PrivKcca
A,Π/prime(n) = 1∧ValidQuery ].(4.8)
We have already shown that Pr[ ValidQuery ] is negligible. The following
claim thus completes the proof of the theorem.
CLAIM 4.21 There exists a negligible function neglsuch that
Pr[PrivKcca
A,Π/prime(n) = 1∧ValidQuery ]≤1
2+negl(n).
To prove this claim, we rely on CPA-security of Π E. Consider the following
adversaryAEattacking Π Ein a chosen-plaintext attack:
AdversaryAE:
AEis given input 1nand has access to EnckE(·).
1. Choose uniform kM∈{0,1}n.
2. RunAon input 1n. WhenAmakes an encryption-oracle
query for the message m, answer it as follows:
(i) Query mtoEnckE(·) and receive cin response.
(ii) Compute t←MackM(c) and return/angbracketleftc,t/angbracketrighttoA.
WhenAmakes a decryption-oracle query for the ciphertext
/angbracketleftc,t/angbracketright, answer it as follows:Message Authentication Codes 139
•If/angbracketleftc,t/angbracketrightwas a response to a previous encryption-oracle
query for a message m, returnm. Otherwise, return ⊥.
3. WhenAoutputs messages ( m0,m1), output these same mes-
sages and receive a challenge ciphertext cin response. Com-
putet←MackM(c), and return/angbracketleftc,t/angbracketrightas the challenge cipher-
text forA. Continue answering A’s oracle queries as above.
4. Output the same bit b/primethat is output by A.
Notice thatAEdoes not need a decryption oracle because it simply as-
sumes that any decryption query by Athat was not the result of a previous
encryption-oracle query is invalid.
Clearly,AEruns in probabilistic polynomial time. Furthermore, the view
ofAwhen run as a subroutine by AEis distributed identically to the view
ofAin experiment PrivKcca
A,Π/prime(n)as long as event ValidQuery never occurs .
Therefore, the probability that AEsucceeds when ValidQuery does not occur
is the same as the probability that Asucceeds when ValidQuery does not
occur; i.e.,
Pr[PrivKcpa
AE,ΠE(n) = 1∧ValidQuery ]=Pr[PrivKcca
A,Π/prime(n) = 1∧ValidQuery ],
implying that
Pr[PrivKcpa
AE,ΠE(n) = 1]≥Pr[PrivKcpa
AE,ΠE(n) = 1∧ValidQuery ]
=Pr[PrivKcca
A,Π/prime(n) = 1∧ValidQuery ].
Since Π Eis CPA-secure, there exists a negligible function neglsuch that
Pr[PrivKcpa
AE,ΠE(n) = 1]≤1
2+negl(n). This proves the claim.
The need for independent keys. Weconclude this section by stressing a
basicprincipleofcryptography: diﬀerent instances of cryptographic primitives
should always use independent keys . To illustrate this here, consider what can
happen to the encrypt-then-authenticate methodologywhen the same key kis
usedforbothencryptionandauthentication. Let Fbeastrongpseudorandom
permutation. It follows that F−1is a strong pseudorandom permutation also.
DeﬁneEnck(m) =Fk(m/bardblr) form∈{0,1}n/2and a uniform r∈{0,1}n/2,
and deﬁne Mack(c) =F−1
k(c). It can be shown that this encryption scheme is
CPA-secure (in fact, it is even CCA-secure; see Exercise 4.25), and we know
that the given message authentication code is a secure MAC. However, the
encrypt-then-authenticate combination using the same key kas applied to the
message myields:
Enck(m),Mack(Enck(m)) =Fk(m/bardblr),F−1
k(Fk(m/bardblr)) =Fk(m/bardblr),m/bardblr,
andthemessage misrevealedintheclear! Thisdoesnotinanywaycontradict
Theorem 4.19, since Construction 4.18 expressly requires that kM,kEare
chosen (uniformly and) independently. We encourage the reader to examine
where this independence is used in the proof of Theorem 4.19.140 Introduction to Modern Cryptography
4.5.3 Secure Communication Sessions
We brieﬂy describe the application of authenticated encryption to the set-
ting of two parties who wish to communicate “securely”—namely, with joint
secrecy and integrity—over the course of a communication session. (For the
purposes of this section, a communication session is simply a period of time
during which the communicating parties maintain state.) In our treatment
herewearedeliberatelyinformal; aformaldeﬁnitionisquiteinvolved,andthis
topic arguably lies more in the area of network security than cryptography.
Let Π = ( Enc,Dec) be an authenticated encryption scheme. Consider two
partiesAandBwho share a key kand wish to use this key to secure their
communication over the course of a session. The obvious thing to do here is
to use Π: Whenever, say, Awants to transmit a message mtoB, it computes
c←Enck(m) and sends ctoB; in turn, Bdecrypts cto recover the result
(ignoring the result if decryption returns ⊥). Likewise, the same procedure
is followed when Bwants to send a message to A. This simple approach,
however, does not suﬃce, as there are various potential attacks:
Re-ordering attack An attacker can swap the order of messages. For ex-
ample, if Atransmits c1(an encryption of m1) and subsequently trans-
mitsc2(an encryption of m2), an attacker who has some control over
the network can deliver c2beforec1and thus cause Bto output the
messages in the wrong order. This causes a mismatch between the two
parties’ views of their communication session.
Replay attack An attacker can replaya (valid) ciphertext csent previously
by one of the parties. Again, this causes a mismatch between what is
sent by one party and received by the other.
Reﬂection attack An attacker can take a ciphertext csent from AtoB
and send it back to A. This again can cause a mismatch between the
two parties’ transcripts of their communication session: Amay output
a message m, even though Bnever sent such a message.
Fortunately, the aboveattacksareeasyto preventusing counters to address
the ﬁrst two and a directionality bit to prevent the third.5We describe these
in tandem. Each party maintains two counters ctrA,BandctrB,Akeeping
track of the number of messages sent from AtoB(resp.,BtoA) during the
session. These counters are initialized to 0 and incremented each time a party
sends or receives a (valid) message. The parties also agree on a bit bA,B, and
deﬁnebB,Ato be its complement. (One way to do this is to set bA,B= 0 iﬀ
the identity of Ais lexicographically smaller than the identity of B.)
5Inpractice, the issue of directionality is often solved by simply having separate keys for
each direction (i.e., the parties use a key kAfor messages sent from AtoB, and a diﬀerent
keykBfor messages sent from BtoA).Message Authentication Codes 141
WhenAwants to transmit a message mtoB, she computes the ciphertext
c←Enck(bA,B/bardblctrA,B/bardblm) and sends c; she then increments ctrA,B. Upon
receiving c, partyBdecrypts; if the result is ⊥, he immediately rejects.
Otherwise, he parses the decrypted message as b/bardblctr/bardblm. Ifb=bA,Band
ctr=ctrA,B, thenBoutputsmand increments ctrA,B; otherwise, Brejects.
The abovesteps, mutatis mutandis , are applied when Bsends a messageto A.
We remark that since the parties are anyway maintaining state (namely,
the counters ctrA,BandctrB,A), the parties could easily use a statefulau-
thenticated encryption scheme Π.
4.5.4 CCA-Secure Encryption
It follows directly from the deﬁnition that any authenticated encryption
scheme is also secure against chosen-ciphertext attacks. Can there be CCA-
secureprivate-keyencryptionschemesthatare notunforgeable? Indeed, there
are; see Exercise 4.25.
One can imagine applications where CCA-security is needed but authenti-
cated encryption is not. One example might be when private-key encryption
is used for key transport . As a concrete example, say a server gives a tamper-
proof hardware token to a user, where embedded in the token is a long-term
keyk. The servercan upload a fresh, short-term key k/primeto this token by giving
the user Enck(k/prime); the user is supposed to give this ciphertext to the token,
which will decrypt it and use k/primefor the next time period. A chosen-ciphertext
attack in this setting could allow the user to learn k/prime, something the user is
not supposed to be able to do. (Note that here a padding-oracleattack, which
only relies on the user’s ability to determine whether a decryption failure oc-
curs, could potentially be carried out rather easily.) On the other hand, not
much harm is done if the user can generate a “valid” ciphertext that causes
the token to use an arbitrary (unrelated) key k/prime/primefor the next time period. (Of
course, this depends on what the token does with this short-term key.)
Notwithstanding the above, for private-key encryption most “natural” con-
structions of CCA-secure schemes that we know anyway satisfy the stronger
deﬁnition of authenticated encryption. Put diﬀerently, there is no real rea-
son to ever use a CCA-secure scheme that is notan authenticated encryption
scheme, simply because we don’t really have any constructions satisfying the
former that are more eﬃcient than constructions achieving the latter.
Fromaconceptual pointofview,however,itisimportanttokeepthenotions
of CCA-security and authenticated encryption distinct. With regard to CCA-
security we are not interested in message integrity per se; rather, we wish to
ensure privacy even against an active adversary who can interfere with the
communication as it goes from sender to receiver. In contrast, with regard
to authenticated encryption we are interested in the twin goals of secrecy
and integrity. We stress this here because in the public-key setting that we
study later in the book, the diﬀerence between authenticated encryption and
CCA-security is more pronounced.142 Introduction to Modern Cryptography
4.6 *Information-Theoretic MACs
Inprevious sections we have explored message authentication codes with
computational security, i.e., where bounds on the attacker’s running time are
assumed. Recalling the results of Chapter 2, it is natural to ask whether
message authentication in the presence of an unbounded adversaryis possible.
In this section, we show under which conditions information-theoretic (as
opposed to computational) security is attainable.
A ﬁrst observation is that it is impossible to achieve “perfect” security
in this context: namely, we cannot hope to have a message authentication
code for which the probability that an adversary outputs a valid tag on a
previously unauthenticated message is 0. The reason is that an adversary can
simply guess a valid tag ton any message and the guess will be correct with
probability (at least) 1 /2|t|, where|t|denotes the tag length of the scheme.
The above example tells us what we canhope to achieve: a MAC with
tags of length|t|where the probability of forgery is at most 1 /2|t|, even for
unbounded adversaries. We will see that this is achievable, but only under
restrictions on how many messages are authenticated by the honest parties.
We ﬁrst deﬁne information-theoretic security for message authentication
codes. A starting point is to take experiment Mac-forgeA,Π(n) that is used
to deﬁne security for computationally secure MACs (cf. Deﬁnition 4.2), but
to drop the security parameter nand require that Pr[ Mac-forgeA,Π= 1]
should be “small” for alladversariesA(and not just adversaries running
in polynomial time). As mentioned above (and as will be proved formally in
Section 4.6.2), however, such a deﬁnition is impossible to achieve. Rather,
information-theoretic security can be achieved only if we place some bound
on the number of messages authenticated by the honest parties. We look
here at the most basic setting, where the parties authenticate just a single
message. We refer to this as one-time message authentication . The following
experiment modiﬁes Mac-forgeA,Π(n) following the above discussion:
The one-timemessageauthentication experiment Mac-forge1-time
A,Π:
1. A key kis generated by running Gen.
2. The adversary Aoutputs a message m/prime, and is given in return
a tagt/prime←Mack(m/prime).
3.Aoutputs(m,t).
4. The output of the experiment is deﬁned to be 1if and only if
(1)Vrfyk(m,t) = 1and (2)m/negationslash=m/prime.
DEFINITION 4.22 A message authentication code Π = (Gen,Mac,Vrfy)
isone-time ε-secure, or justε-secure, if for all (even unbounded) adversaries A:
Pr[Mac-forge1-time
A,Π= 1]≤ε.Message Authentication Codes 143
4.6.1 Constructing Information-Theoretic MACs
In this section we showhowto build an ε-secureMAC basedon any strongly
universal function .6We then show a simple construction of the latter.
Leth:K×M→T be a keyed function whose ﬁrst input is a key k∈Kand
whose second input is taken from some domain M. As usual, we write hk(m)
instead of h(k,m). Then hisstrongly universal (orpairwise-independent ) if
for any two distinct inputs m,m/primethe values hk(m) andhk(m/prime) are uniformly
andindependently distributedin Twhenkisauniformkey. Thisisequivalent
tosayingthattheprobabilitythat hk(m),hk(m/prime)takeonanyparticularvalues
t,t/primeis exactly 1 /|T|2. That is:
DEFINITION 4.23 A function h:K×M→T isstrongly universal if for
all distinct m,m/prime∈Mand allt,t/prime∈Tit holds that
Pr[hk(m) =t∧hk(m/prime) =t/prime] =1
|T|2,
where the probability is taken over uniform choice of k∈K.
The above should motivate the construction of a one-time message authen-
tication code from any strongly universal function h. The tag ton a message
mis obtained by computing hk(m), where the key kis uniform; see Construc-
tion 4.24. Intuitively, even after an adversary observes the tag t/prime:=hk(m/prime)
for any message m/prime, the correct tag hk(m) for any othermessage mis still
uniformly distributed in Tfrom the adversary’s point of view. Thus, the ad-
versary can do nothing more than blindly guess the tag, and this guess will
be correct only with probability 1 /|T|.
CONSTRUCTION 4.24
Leth:K×M→T be a strongly universal function. Deﬁne a MAC for
messages inMas follows:
•Gen: choose uniform k∈Kand output it as the key.
•Mac: on input a key k∈Kand a message m∈M, output the tag
t:=hk(m).
•Vrfy: on input a key k∈K, a message m∈M, and a tag t∈T,
output 1 if and only if t?=hk(m). (Ifm/negationslash∈M, then output 0.)
A MAC from any strongly universal function.
6These are often called strongly universal hashfunctions, but in cryptographic contexts the
term “hash” has another meaning that we will see later in the book.144 Introduction to Modern Cryptography
The above construction can be viewed as analogous to Construction 4.5.
This is because a strongly universal function his identical to a random func-
tion, as long as it is only evaluated twice.
THEOREM 4.25 Leth:K×M→T be a strongly universal function.
Then Construction 4.24 is a 1/|T|-secure MAC for messages in M.
PROOF LetAbe an adversary. As usual in the information-theoretic
setting, we may assume Ais deterministic without loss of generality. So the
message m/primethatAoutputs at the outset of the experiment is ﬁxed. Fur-
thermore, the pair ( m,t) thatAoutputs at the end of the experiment is a
deterministic function of the tag t/primeonm/primethatAreceives. We thus have
Pr[Mac-forge1-time
A,Π= 1] =/summationdisplay
t/prime∈TPr[Mac-forge1-time
A,Π= 1∧hk(m/prime) =t/prime]
=/summationdisplay
t/prime∈T
(m,t) :=A(t/prime)Pr[hk(m) =t∧hk(m/prime) =t/prime]
=/summationdisplay
t/prime∈T
(m,t) :=A(t/prime)1
|T|2=1
|T|.
This proves the theorem.
We now turn to a classical construction of a strongly universal function.
Weassume some basic knowledge about arithmetic modulo a prime number;
readers may refer to Sections 8.1.1 and 8.1.2 for the necessary background.
Fix some prime p, and let Zpdef={0,...,p−1}. We take as our message space
M=Zp; the space of possible tags will also be T=Zp. A key ( a,b) consists
of a pair of elements from Zp; thus,K=Zp×Zp. Deﬁne has
ha,b(m)def= [a·m+bmodp],
wherethenotation[ Xmodp]referstothereductionoftheinteger Xmodulop
(and so [ Xmodp]∈Zpalways).
THEOREM 4.26 For any prime p, the function his strongly universal.
PROOF Fix any distinct m,m/prime∈Zpand any t,t/prime∈Zp. For which keys
(a,b) does it hold that both ha,b(m) =tandha,b(m/prime) =t/prime? This holds only if
a·m+b=tmodpanda·m/prime+b=t/primemodp.Message Authentication Codes 145
We thus have two linear equations in the two unknowns a,b. These two
equations are both satisﬁed exactly when a= [(t−t/prime)·(m−m/prime)−1modp] and
b= [t−a·mmodp]; note that [( m−m/prime)−1modp] exists because m/negationslash=m/primeand
som−m/prime/negationslash= 0 mod p. Restated, this means that for any m,m/prime,t,t/primeas above
there is a uniquekey (a,b) withha,b(m) =tandha,b(m/prime) =t/prime. Since there
are|T|2keys, we conclude that the probability (over choice of the key) that
ha,b(m) =tandha,b(m/prime) =t/primeis exactly 1 /|K|= 1/|T|2as required.
Parameters of Construction 4.24. Webrieﬂy discuss the parameters
of Construction 4.24 when instantiated with the strongly universal function
described above, ignoring the fact that pis not a power of 2. The construction
is a 1/|T|-secure MAC with tags of length log |T|; the tag length is optimal
for the level of security achieved.
LetMbe some ﬁxed message space for which we want to construct a one-
time secure MAC. The construction above gives a 1 /|M|-secure MAC with
keys that are twice the length of the messages. The reader may notice two
problems here, at opposite ends of the spectrum: First, if |M|is small then a
1/|M|probability of forgery may be unacceptably large. On the ﬂip side, if
|M|is large then a 1 /|M|probability of forgery may be overkill; one might
be willing to accept a (somewhat) larger probability of forgery if that level
of security can be achieved with shorter keys. The ﬁrst problem (when |M|
is small) is easy to deal with by simply embedding Minto a larger message
spaceM/primeby, for example, padding messages with 0s. The second problem
can be addressed as well; see the references at the end of this chapter.
4.6.2 Limitations on Information-Theoretic MACs
In this section we explore limitations on information-theoretic message au-
thentication. We show that any 2−n-secure MAC must have keys of length at
least 2n. An extension of the proof shows that any /lscript-time 2−n-secure MAC
(where security is deﬁned via a natural modiﬁcation of Deﬁnition 4.23) re-
quires keys of length at least ( /lscript+ 1)·n. A corollary is that noMAC with
bounded-length keys can provide information-theoretic security when authen-
ticating an unbounded number of messages.
In the following, we assume the message space contains at least two mes-
sages; if not, there is no point in communicating, let alone authenticating.
THEOREM 4.27 LetΠ = (Gen,Mac,Vrfy)be a2−n-secure MAC where
all keys output by Genare the same length. Then the keys output by Genmust
have length at least 2n.
PROOF Fix two distinct messages m0,m1in the message space. The
intuition for the proof is that there must be at least 2npossibilities for the tag146 Introduction to Modern Cryptography
ofm0(or else the adversary could guess it with probability better than 2−n);
furthermore, even conditioned on the value of the tag for m0, there must be
2npossibilities for the tag of m1(or else the adversarycould forgea tag on m1
with probability better than 2−n). Since each key deﬁnes tags for m0andm1,
this means there must be at least 2n×2nkeys. We make this formal below.
LetKdenote the key space (i.e., the set of all possible keys that can be
output by Gen). For any possible tag t0, letK(t0) denote the set of keys for
whicht0is a valid tag on m0; i.e.,
K(t0)def={k|Vrfyk(m0,t0) = 1}.
For anyt0we must have|K(t0)|≤2−n·|K|. Otherwise the adversary could
simply output ( m0,t0) as its forgery; this would be a valid forgery with prob-
ability at least|K(t0)|/|K|>2−n, contradicting the claimed security.
Consider now the adversary Awho requests a tag on the message m0,
receives in return a tag t0, chooses a uniform key k∈K(t0), and outputs
(m1,Mack(m1)) as its forgery. The probability that Aoutputs a valid forgery
is at least
/summationdisplay
t0Pr[Mack(m0) =t0]·1
|K(m0,t0)|≥/summationdisplay
t0Pr[Mack(m0) =t0]·2n
|K|
=2n
|K|.
Bythe claimed security of the scheme, the probability that the adversary can
output a valid forgery is at most 2−n. Thus, we must have |K|≥22n. Since
all keys have the same length, each key must have length at least 2 n.
References and Additional Reading
The deﬁnition of security for message authentication codes was adapted by
Bellare et al. [18] from the deﬁnition of security for digital signatures given by
Goldwasser et al. [81] (see Chapter 12). For more on the deﬁnitional variant
where veriﬁcation queries are allowed, see [17].
The paradigm of using pseudorandom functions for message authentication
(as in Construction 4.5) was introduced by Goldreich et al. [77]. Construc-
tion 4.7 is due to Goldreich [76].
CBC-MAC was standardized in the early 1980s [94, 178] and is still used
widely today. Basic CBC-MAC was proven secure (for authenticating ﬁxed-
length messages) by Bellare et al. [18]. Bernstein [26, 27] gives a more direct
(though perhaps less intuitive) proof, and also discusses some generalizedMessage Authentication Codes 147
versions of CBC-MAC. As noted in this chapter, basic CBC-MAC is insecure
when used to authenticate messages of diﬀerent lengths. One way to ﬁx this
is to prepend the length to the message. This has the disadvantage of not
being able to cope with streaming data, where the length ofthe messageis not
known in advance. Petrank and Rackoﬀ [137] suggest an alternate, “on-line”
approach addressing this issue. Further improvements were given by Black
and Rogaway [32] and Iwata and Kurosawa [95]; these led to a new proposed
standard called CMAC.
The importance of authenticated encryption was ﬁrst explicitly highlighted
in [100, 19], who propose deﬁnitions similar to what we have given here.
Bellare and Namprempre [19] analyze the three generic approaches discussed
here, althoughthe idea ofusingencrypt-then-authenticateforachievingCCA-
security goes back at least to the work of Dolev et al. [61]. Krawczyk [108]
examinesothermethodsforachievingsecrecyandauthentication, andalsoan-
alyzes the authenticate-then-encrypt approach used by SSL. Degabriele and
Paterson [54] show an attack on IPsec when conﬁgured to authenticate-then-
encrypt (the default for authenticated encryption is actually encrypt-then-
authenticate; however it is possible to achieve authenticate-then-encrypt in
some conﬁgurations). Several nongeneric schemes for authenticated encryp-
tion have also been proposed; see [110] for a detailed comparison.
Information-theoretic MACs were ﬁrst studied by Gilbert et al. [73]. Weg-
man and Carter [177] introduced the notion of strongly universal functions,
and noted their application to one-time message authentication. They also
show how to reduce the key length for this task by using an almoststrongly
universal function. Speciﬁcally, the construction we give here achieves 2−n-
securityformessagesoflength nwithkeysoflength O(n); WegmanandCarter
showhow to constructa 2−n-secureMAC formessagesoflength /lscriptwith keysof
(essentially)length O(n·log/lscript). Thesimpleconstructionofastronglyuniversal
function that we give here is (with minor diﬀerences) due to Carter and Weg-
man [42]. The reader interested in learning more about information-theoretic
MACs is referred to the paper by Stinson [166], the survey by Simmons [162],
or the ﬁrst edition of Stinson’s textbook [167, Chapter 10].
Exercises
4.1Say Π = ( Gen,Mac,Vrfy) is a secure MAC, and for k∈{0,1}nthe tag-
generation algorithm Mackalways outputs tags of length t(n). Prove
thattmust be super-logarithmicor, equivalently, that if t(n) =O(logn)
then Π cannot be a secure MAC.
Hint:Consider the probability of randomly guessing a valid tag.148 Introduction to Modern Cryptography
4.2 Consider an extension of the deﬁnition of secure message authentication
where the adversary is provided with both a Macand aVrfyoracle.
(a) Provide a formal deﬁnition of security for this case.
(b) Assume Π is a deterministic MAC using canonical veriﬁcation that
satisﬁes Deﬁnition 4.2. Prove that Π also satisﬁes your deﬁnition
from part (a).
4.3 Assume secureMACs exist. Give a constructionofa MAC that is secure
with respect to Deﬁnition 4.2 but that is not secure when the adversary
is additionally given access to a Vrfyoracle (cf. the previous exercise).
4.4 Prove Proposition 4.4.
4.5 Assume secure MACs exist. Prove that there exists a MAC that is
secure (by Deﬁnition 4.2) but is notstrongly secure (by Deﬁnition 4.3).
4.6 Consider the following MAC for messages of length /lscript(n) = 2n−2 us-
ing a pseudorandom function F: On input a message m0/bardblm1(with
|m0|=|m1|=n−1) and key k∈ {0,1}n, algorithm Macoutputs
t=Fk(0/bardblm0)/bardblFk(1/bardblm1). Algorithm Vrfyis deﬁned in the natural way.
Is (Gen,Mac,Vrfy) secure? Prove your answer.
4.7 LetFbe a pseudorandom function. Show that each of the following
MACs is insecure, even if used to authenticate ﬁxed-length messages.
(In each case Genoutputs a uniform k∈{0,1}n. Let/angbracketlefti/angbracketrightdenote an
n/2-bit encoding of the integer i.)
(a) To authenticate a message m=m1,...,m /lscript, wheremi∈{0,1}n,
compute t:=Fk(m1)⊕···⊕Fk(m/lscript).
(b) To authenticate a message m=m1,...,m /lscript, wheremi∈{0,1}n/2,
compute t:=Fk(/angbracketleft1/angbracketright/bardblm1)⊕···⊕Fk(/angbracketleft/lscript/angbracketright/bardblm/lscript).
(c) To authenticate a message m=m1,...,m /lscript, wheremi∈{0,1}n/2,
choose uniform r←{0,1}n, compute
t:=Fk(r)⊕Fk(/angbracketleft1/angbracketright/bardblm1)⊕···⊕Fk(/angbracketleft/lscript/angbracketright/bardblm/lscript),
and let the tag be /angbracketleftr,t/angbracketright.
4.8 LetFbe a pseudorandom function. Show that the following MAC for
messages of length 2 nis insecure: Genoutputs a uniform k∈{0,1}n.
To authenticate a message m1/bardblm2with|m1|=|m2|=n, compute the
tagFk(m1)/bardblFk(Fk(m2)).
4.9 Given any deterministic MAC (Mac,Vrfy), we may view Macas a keyed
function. In both Constructions 4.5 and 4.11, Macis a pseudorandom
function. Give a construction of a secure, deterministic MAC in which
Macisnota pseudorandom function.Message Authentication Codes 149
4.10 Is Construction 4.5 necessarily secure when instantiated using a weak
pseudorandom function (cf. Exercise 3.26)? Explain.
4.11 Prove that Construction 4.7 is secure even when the adversary is addi-
tionally given access to a Vrfyoracle (cf. Exercise 4.2).
4.12 Prove that Construction 4.7 is secure if it is changed as follows: Set
ti:=Fk(r/bardblb/bardbli/bardblmi) wherebis a single bit such that b= 0 in all blocks
but the last one, and b= 1 in the last block. (Assume for simplicity
that the length of all messages being authenticated is always an integer
multiple of n/2−1.) What is the advantage of this modiﬁcation?
4.13 We explore what happens when the basic CBC-MAC construction is
used with messages of diﬀerent lengths.
(a) Say the sender and receiver do not agree on the message length
in advance (and so Vrfyk(m,t) = 1 iﬀ t?=Mack(m), regardless of
the length of m), but the sender is careful to only authenticate
messages of length 2 n. Show that an adversary can forge a valid
tag on a message of length 4 n.
(b) Say the receiver only accepts 3-block messages (so Vrfyk(m,t) = 1
only ifmhas length 3 nandt?=Mack(m)), but the sender au-
thenticates messages of any length a multiple of n. Show that an
adversary can forge a valid tag on a new message.
4.14 Prove that the following modiﬁcations of basic CBC-MAC do not yield
a secure MAC (even for ﬁxed-length messages):
(a)Macoutputs all blocks t1,...,t/lscript, rather than just t/lscript. (Veriﬁcation
only checks whether t/lscriptis correct.)
(b) Arandominitialblockisusedeachtimeamessageisauthenticated.
That is, choose uniform t0∈{0,1}n, run basic CBC-MAC over the
“message” t0,m1,...,m /lscript, and output the tag /angbracketleftt0,t/lscript/angbracketright. Veriﬁcation
is done in the natural way.
4.15 Show that appending the message length to the endof the message
before applying basic CBC-MAC does not result in a secure MAC for
arbitrary-length messages.
4.16 Show that the encoding for arbitrary-length messages described in Sec-
tion 4.4.2 is preﬁx-free.
4.17 Consider the following encoding that handles messages whose length is
less than n·2n: We encode a string m∈{0,1}∗by ﬁrst appending
as many 0s as needed to make the length of the resulting string ˆ ma
nonzero multiple of n. Then we prepend the number of blocksin ˆm
(equivalently, prepend the integer |ˆm|/n), encoded as an n-bit string.
Show that this encoding is notpreﬁx-free.150 Introduction to Modern Cryptography
4.18 Prove that the following modiﬁcation of basic CBC-MAC gives a secure
MAC for arbitrary-length messages (for simplicity, assume all messages
have length a multiple of the block length). Mack(m) ﬁrst computes
k/lscript=Fk(/lscript), where /lscriptis the length of m. The tag is then computed using
basic CBC-MAC with key k/lscript. Veriﬁcation is done in the natural way.
4.19 Let Fbe a keyed function that is a secure (deterministic) MAC for
messages of length n. (Note that Fneed not be a pseudorandom per-
mutation.) Show that basic CBC-MAC is not necessarily a secure MAC
(even for ﬁxed-length messages) when instantiated with F.
4.20 Show that Construction 4.7 is strongly secure.
4.21 Show that Construction 4.18 might not be CCA-secure if it is instanti-
ated with a secure MAC that is notstrongly secure.
4.22 Prove that Construction 4.18 is unforgeable when instantiated with any
encryption scheme (even if not CPA-secure) and any secure MAC (even
if the MAC is not strongly secure).
4.23 Considerastrengthenedversionofunforgeability(Deﬁnition4.16)where
Ais additionally given access to a decryption oracle.
(a) Write a formal deﬁnition for this version of unforgeability.
(b) Provethat Construction4.18satisﬁesthis strongerdeﬁnition ifΠ M
is a strongly secure MAC.
(c) Show by counterexample that Construction 4.18 need not satisfy
this stronger deﬁnition if Π Mis a secure MAC that is not strongly
secure. (Compare to the previous exercise.)
4.24 Prove that the authenticate-then-encrypt approach, instantiated with
any CPA-secure encryption scheme and any secure MAC, yields a CPA-
secure encryption scheme that is unforgeable.
4.25 Let Fbe a strong pseudorandom permutation, and deﬁne the following
ﬁxed-length encryption scheme: On input a message m∈{0,1}n/2and
keyk∈{0,1}n, algorithm Encchooses a uniform r∈{0,1}n/2and
computes c:=Fk(m/bardblr). (See Exercise 3.18.) Prove that this scheme is
CCA-secure, but is not an authenticated encryption scheme.
4.26 Show a CPA-secure private-key encryption scheme that is unforgeable
but is not CCA-secure.
4.27 Fix /lscript >0 and a prime p. LetK=Z/lscript+1
p,M=Z/lscript
p, andT=Zp. Deﬁne
h:K×M→T as
hk0,k1,...,k/lscript(m1,...,m /lscript) =/bracketleftbig
k0+/summationtext
ikimimodp/bracketrightbig
.
Prove that his strongly universal.Message Authentication Codes 151
4.28 Fix /lscript,n >0. LetK={0,1}/lscript×n×{0,1}/lscript(interpreted as a boolean
/lscript×nmatrix and an /lscript-dimensional vector), let M={0,1}n, and let
T={0,1}/lscript. Deﬁne h:K×M→T ashK,v(m) =K·m⊕v, where all
operations are performed modulo 2. Prove that his strongly universal.
4.29 AToeplitz matrix Kis a matrix in which Ki,j=Ki−1,j−1wheni,j >1;
i.e., the values along any diagonal are equal. So an /lscript×nToeplitz matrix
(for/lscript > n) has the form

K1,1K1,2K1,3···K1,n
K2,1K1,1K1,2···K1,n−1
...............
K/lscript,1K/lscript−1,1K/lscript−2,1···K/lscript−n+1,1
.
LetK=T/lscript×n×{0,1}/lscript(whereT/lscript×ndenotes the set of /lscript×nToeplitz
matrices), letM={0,1}n, and letT={0,1}/lscript. Deﬁne h:K×M→T
ashK,v(m) =K·m⊕v, where all operations are performed modulo 2.
Prove that his strongly universal. What is the advantage here as com-
pared to the construction in the previous exercise?
4.30 Deﬁne an appropriate notion of a two-time ε-secure MAC, and give a
construction that meets your deﬁnition.
4.31 Let{hn:Kn×{0,1}10·n→{0,1}n}n∈Nbe such that hnis strongly
universal for all n, and let Fbe a pseudorandom function. (When
K∈Knwe write hK(·) instead of hn,K(·).) Consider the following
MAC:Gen(1n) chooses uniform K∈ Knandk∈ {0,1}n, and out-
puts (K,k). To authenticate a message m∈{0,1}10·n, choose uniform
r∈{0,1}nand output/angbracketleftr, hK(m)⊕Fk(r)/angbracketright. Veriﬁcation is done in the
natural way. Prove that this gives a (computationally) secure MAC for
messages of length 10 n.Chapter 5
Hash Functions and Applications
Inthis chapter we introduce cryptographic hash functions and explore a few
of their applications. At the most basic level, a hash function provides a
way to map a long input string to a shorter output string sometimes called
adigest. The primary requirement is to avoid collisions , or two inputs that
map to the same digest. Collision-resistant hash functions have numerous
uses. One example that we will see here is another approach—standardized
as HMAC—for achieving domain extension for message authentication codes.
Beyond that, hash functions have become ubiquitous in cryptography, and
they are often used in scenarios that require properties much stronger than
collision resistance. It has become common to model cryptographic hash
functions as being “completely unpredictable” (a.k.a., random oracles ), and
we discuss this framework—and the controversy that surrounds it—in detail
later in the chapter. We touch on only a few applications of the random-
oracle model here, but will encounter it again when we turn to the setting of
public-key cryptography.
Hash functions are intriguing in that they can be viewed as lying between
the worlds of private- and public-key cryptography. On the one hand, as we
will see in Chapter 6, they are (in practice) constructed using symmetric-key
techniques, and many of the canonical applications of hash functions are in
the symmetric-key setting. From a theoretical point of view, however, the
existence of collision-resistant hash functions appears to represent a qualita-
tively stronger assumption than the existence of pseudorandom functions (yet
a weaker assumption than the existence of public-key encryption).
5.1 Deﬁnitions
Hash functions are simply functions that take inputs of some length and
compress them into short, ﬁxed-length outputs. The classic use of hash func-
tions is in data structures, where they can be used to build hash tables that
enableO(1) lookup time when storing a set of elements. Speciﬁcally, if the
range of the hash function His of size N, then element xis stored in row
H(x) ofa table ofsize N. To retrieve x, it suﬃces to compute H(x) and probe
153154 Introduction to Modern Cryptography
that row of the table for the elements stored there. A “good” hash function
for this purpose is one that yields few collisions , where a collision is a pair of
distinct items xandx/primefor which H(x) =H(x/prime); in this case we also say that
xandx/primecollide. (When a collision occurs, two elements end up being stored
in the same cell, increasing the lookup time.)
Collision-resistant hash functions are similar in spirit. Again, the goal is
to avoid collisions. However, there are fundamental diﬀerences. For one,
the desire to minimize collisions in the setting of data structures becomes a
requirement to avoid collisions in the setting of cryptography. Furthermore, in
the context of data structures we can assume that the set of data elements is
chosen independently of the hash function and without any intention to cause
collisions. In the context of cryptography, in contrast, we are faced with an
adversary who may select elements with the explicit goal of causing collisions.
This means that collision-resistant hash functions are much harder to design.
5.1.1 Collision Resistance
Informally, a function Hiscollision resistant if it is infeasible for any prob-
abilistic polynomial-time algorithm to ﬁnd a collision in H. We will only be
interested in hash functions whose domain is larger than their range. In this
case collisions must exist, but such collisions should be hard to ﬁnd.
Formally, we consider keyedhash functions. That is, His a two-input
function that takes as input a key sand a string x, and outputs a string
Hs(x)def=H(s,x). The requirement is that it must be hard to ﬁnd a collision
inHsfor a randomly generated key s. There are at least two diﬀerences
between keys in this context and keys as we have used them until now. First,
not all strings necessarily correspond to valid keys (i.e., Hsmay not be de-
ﬁned for certain s), and therefore the key swill typically be generated by an
algorithm Genrather than being chosen uniformly. Second, and perhaps more
importantly, this key sis (generally) not kept secret, and collision resistance
is required even when the adversary is given s. In order to emphasize this, we
superscript the key and write Hsrather than Hs.
DEFINITION 5.1 Ahash function (with output length /lscript)is a pair of
probabilistic polynomial-time algorithms (Gen,H)satisfying the following:
•Genis a probabilistic algorithm which takes as input a security parame-
ter1nand outputs a key s. We assume that 1nis implicit in s.
•Htakes as input a key sand a string x∈{0,1}∗and outputs a string
Hs(x)∈{0,1}/lscript(n)(wherenis the value of the security parameter im-
plicit in s).
IfHsis deﬁned only for inputs x∈{0,1}/lscript/prime(n)and/lscript/prime(n)> /lscript(n), then we say
that(Gen,H)is aﬁxed-lengthhash function for inputs of length /lscript/prime. In this case,
we also call Hacompression function .Hash Functions and Applications 155
In the ﬁxed-length case we require that /lscript/primebe greater than /lscript. This ensures
that the function compresses its input. In the general case the function takes
as input strings of arbitrary length. Thus, it also compresses (albeit only
strings of length greater than /lscript(n)). Note that without compression, collision
resistance is trivial (since one can just take the identity function Hs(x) =x).
We now proceed to deﬁne security. As usual, we ﬁrst deﬁne an experiment
forahash function Π = ( Gen,H), anadversaryA, andasecurityparameter n:
The collision-ﬁnding experiment Hash-collA,Π(n):
1. A key sis generated by running Gen(1n).
2. The adversary Ais given sand outputs x,x/prime.(IfΠis a
ﬁxed-length hash function for inputs of length /lscript/prime(n), then we
requirex,x/prime∈{0,1}/lscript/prime(n).)
3. The output of the experiment is deﬁned to be 1if and only if
x/negationslash=x/primeandHs(x) =Hs(x/prime). In such a case we say that A
has found a collision.
The deﬁnition of collision resistance states that no eﬃcient adversary can
ﬁnd a collision in the above experiment except with negligible probability.
DEFINITION 5.2 A hash function Π = (Gen,H)iscollision resistant if
for all probabilistic polynomial-time adversaries Athere is a negligible function
neglsuch that
Pr[Hash-collA,Π(n) = 1]≤negl(n).
For simplicity, we sometimes refer to HorHsas a “collision-resistant hash
function,” even though technically we should only say that ( Gen,H) is. This
should not cause any confusion.
Cryptographic hash functions are designed with the explicit goal of being
collision resistant (among other things). We will discuss some common real-
world hash functions in Chapter 6. In Section 8.4.2 we will see how it is
possible to construct hash functions with proven collision resistance based on
an assumption about the hardness of a certain number-theoretic problem.
Unkeyed hash functions. Cryptographic hash functions used in practice
generally have a ﬁxed output length (just as block ciphers have a ﬁxed key
length) and are usually unkeyed, meaning that the hash function is just a
ﬁxed function H:{0,1}∗→{0,1}/lscript. This is problematic from a theoretical
standpoint since for any such function there is always a constant-time algo-
rithm that outputs a collision in H: the algorithm simply outputs a colliding
pair (x,x/prime) hardcoded into the algorithm itself. Using keyed hash functions
solves this technical issue since it is impossible to hardcode a colliding pair for
every possible key using a reasonable amount of space (and in an asymptotic
setting, it would be impossible to hardcode a colliding pair for every value of
the security parameter).156 Introduction to Modern Cryptography
Notwithstanding the above, the (unkeyed) cryptographic hash functions
used in the realworldare collisionresistantfor allpracticalpurposes since col-
liding pairs are unknown (and computationally diﬃcult to ﬁnd) even though
they must exist. Proofs of security for some construction based on collision
resistance of a hash function are meaningful even when an unkeyed hash
function His used, as long as the proof shows that any eﬃcient adversary
“breaking” the primitive can be used to eﬃciently ﬁnd a collision in H. (All
the proofs in this book satisfy this condition.) In this case, the interpreta-
tion of the proof of security is that if an adversary can break the scheme in
practice, then it can be used to ﬁnd a collision in practice, something that we
believe is hard to do.
5.1.2 Weaker Notions of Security
In some applications it suﬃces to rely on security requirements weaker than
collision resistance. These include:
•Second-preimage or target-collision resistance: Informally, a hash func-
tionissecondpreimageresistantifgiven sandauniform xitisinfeasible
for apptadversary to ﬁnd x/prime/negationslash=xsuch that Hs(x/prime) =Hs(x).
•Preimage resistance: Informally, a hash function is preimage resistant if
givensand auniform yit isinfeasible fora pptadversarytoﬁnd avalue
xsuch that Hs(x) =y. (Looking ahead to Chapter 7, this essentially
means that Hsisone-way.)
Any hash function that is collision resistant is also second preimage resistant.
This holds since if, given a uniform x, an adversary can ﬁnd x/prime/negationslash=xfor
whichHs(x/prime) =Hs(x), then it can clearly ﬁnd a colliding pair xandx/prime.
Likewise, any hash function that is second preimage resistant is also preimage
resistant. This is due to the fact that if it were possible, given y, to ﬁnd an
xsuch that Hs(x) =y, then one could also take a given input x/prime, compute
y:=Hs(x/prime), and then obtain an xwithHs(x) =y. With high probability
x/prime/negationslash=x(relying on the fact that Hcompresses, and so multiple inputs map to
the same output), in which case a second preimage has been found.
Wedonotformallydeﬁnetheabovenotionsorprovetheaboveimplications,
since they are not used in the rest of the book. You are asked to formalize
the above in Exercise 5.1.
5.2 Domain Extension: The Merkle-Damg˚ ard Transform
Hash functions are often constructed by ﬁrst designing a collision-resistant
compression function handling ﬁxed-length inputs, and then using domainHash Functions and Applications 157
extension to handle arbitrary-length inputs. In this section, we show one
solution to the problem of domain extension. We return to the question of
designing collision-resistant compression functions in Section 6.3.
TheMerkle–Damg˚ ard transform is a common approach for extending a
compression function to a full-ﬂedged hash function, while maintaining the
collision-resistance property of the former. It is used extensively in practice
for hash functions including MD5 and the SHA family (see Section 6.3). The
existence of this transform means that when designing collision-resistant hash
functions, we can restrict our attention to the ﬁxed-length case. This, in turn,
makes the job of designing collision-resistant hash functions much easier. The
Merkle–Damg˚ ardtransform is alsointeresting from a theoretical point of view
since it implies that compressing by a single bit is as easy (or as hard) as
compressing by an arbitrary amount.
For concreteness, assume the compression function ( Gen,h) compresses its
input by half; say its input length is 2 nand its output length is n. (The
construction works regardless of the input/output lengths, as long as hcom-
presses.) We construct a collision-resistant hash function ( Gen,H) that maps
inputs of arbitrary length to outputs of length n. (Genremains unchanged.)
The Merkle–Damg˚ ard transform is deﬁned in Construction 5.3 and depicted
in Figure 5.1. The value z0used in step 2 of the construction, called the
initialization vector orIV, is arbitrary and can be replaced by any constant.
CONSTRUCTION 5.3
Let(Gen,h) be a ﬁxed-length hash function for inputs of length 2 nand
with output length n. Construct hash function ( Gen,H) as follows:
•Gen: remains unchanged.
•H: on input a key sand a string x∈{0,1}∗of length L <2n, do
the following:
1. SetB:=/ceilingleftbigL
n/ceilingrightbig
(i.e., the number of blocks in x). Padxwith
zeros so its length is a multiple of n. Parse the padded result
as the sequence of n-bit blocks x1,...,x B. SetxB+1:=L,
whereLis encoded as an n-bit string.
2. Setz0:= 0n. (This is also called the IV.)
3. Fori= 1,...,B+1, compute zi:=hs(zi−1/bardblxi).
4. Output zB+1.
The Merkle–Damg˚ ard transform.
THEOREM 5.4 If(Gen,h)is collision resistant, then so is (Gen,H).
PROOF We show that for any s, a collision in Hsyields a collision in hs.
Letxandx/primebe two diﬀerent strings of length LandL/prime, respectively, such
thatHs(x) =Hs(x/prime). Letx1,...,x Bbe theBblocks of the padded x, and158 Introduction to Modern Cryptography
/MT120/MT49
/MT73/MT86/MT104/MT115/MT120/MT50
/MT46/MT46/MT46/MT120/MT66
/MT72/MT115/MT120/MT40/MT32/MT32/MT32/MT41 /MT104/MT115/MT104/MT115/MT104/MT115 /MT122/MT48/MT61 /MT122/MT49 /MT122/MT66/MT120/MT66/MT43/MT49/MT61/MT76 /MT46/MT46/MT46
FIGURE 5.1 :The Merkle–Damg˚ ard transform.
letx/prime
1,...,x/prime
B/primebe theB/primeblocks of the padded x/prime. Recall that xB+1=Land
x/prime
B/prime+1=L/prime. There are two cases to consider:
1.Case 1: L/negationslash=L/prime.In this case, the last step of the computation of
Hs(x) iszB+1:=hs(zB/bardblL), and the last step of the computation of
Hs(x/prime) isz/prime
B/prime+1:=hs(z/prime
B/prime/bardblL/prime). Since Hs(x) =Hs(x/prime) it follows that
hs(zB/bardblL) =hs(z/prime
B/prime/bardblL/prime). However, L/negationslash=L/primeand sozB/bardblLandz/prime
B/prime/bardblL/primeare
two diﬀerent strings that collide under hs.
2.Case 2:L=L/prime.Thismeansthat B=B/prime. Letz0,...,z B+1bethevalues
deﬁned during the computation of Hs(x), letIidef=zi−1/bardblxidenote the
ith input to hs, and set IB+2def=zB+1. Deﬁne I/prime
1,...,I/prime
B+2analogously
with respect to x/prime. LetNbe thelargestindex for which IN/negationslash=I/prime
N. Since
|x|=|x/prime|butx/negationslash=x/prime, there is an iwithxi/negationslash=x/prime
iand so such an N
certainly exists. Because
IB+2=zB+1=Hs(x) =Hs(x/prime) =z/prime
B+1=I/prime
B+2,
we haveN≤B+1. By maximality of N, we have IN+1=I/prime
N+1and in
particular zN=z/prime
N. But this means that IN,I/prime
Nare a collision in hs.
We leave it as an exercise to turn the above into a formal reduction.
5.3 Message Authentication Using Hash Functions
Inthe previous chapter, we presented two constructions of message authen-
tication codes for arbitrary-length messages. The ﬁrst approach was generic,
but ineﬃcient. The second, CBC-MAC, was based on pseudorandom func-
tions. Here we will see another approach, which we call “hash-and-MAC,”
that relies on collision-resistant hashing along with any message authentica-
tion code. We then discussa standardizedand widely used constructioncalled
HMAC that can be viewed as a speciﬁc instantiation of this approach.Hash Functions and Applications 159
5.3.1 Hash-and-MAC
The idea behind the hash-and-MAC approach is simple. First, an arbitrar-
ily long message mis hashed down to a ﬁxed-length string Hs(m) using a
collision-resistant hash function. Then, a (ﬁxed-length) MAC is applied to
the result. See Construction 5.5 for a formal description.
CONSTRUCTION 5.5
LetΠ = (Mac,Vrfy) be a MAC for messages of length /lscript(n), and let
ΠH= (GenH,H) be a hash function with output length /lscript(n). Construct
a MAC Π/prime= (Gen/prime,Mac/prime,Vrfy/prime) for arbitrary-length messages as follows:
•Gen/prime: on input 1n, choose uniform k∈{0,1}nand run GenH(1n)
to obtain s; the key is k/prime:=/angbracketleftk,s/angbracketright.
•Mac/prime: on input a key /angbracketleftk,s/angbracketrightand a message m∈{0,1}∗, output
t←Mack(Hs(m)).
•Vrfy/prime: on input a key /angbracketleftk,s/angbracketright, a message m∈{0,1}∗, and a MAC
tagt, output 1 if and only if Vrfyk(Hs(m),t)?= 1.
The hash-and-MAC paradigm.
Construction 5.5 is secure if Π is a secure MAC for ﬁxed-length messages
and (Gen,H) is collision resistant. Intuitively, since the hash function is col-
lision resistant, authenticating Hs(m) is as good as authenticating mitself:
if the sender can ensure that the receiver obtains the correct value Hs(m),
collision resistance guarantees that the attacker cannot ﬁnd a diﬀerent mes-
sagem/primethat hashes to the same value. A bit more formally, say a sender uses
Construction 5.5 to authenticate some set of messages Q, and an attacker A
is then able to forge a valid tag on a new message m∗/negationslash∈Q. There are two
possible cases:
Case 1: there is a message m∈Qsuch that Hs(m∗) =Hs(m).ThenAhas
foundacollisionin Hs, contradictingthecollisionresistanceof( Gen,H).
Case 2: for every message m∈ Qit holds that Hs(m∗)/negationslash=Hs(m).Let
Hs(Q)def={Hs(m)|m∈Q}. ThenHs(m∗)/∈Hs(Q). In this case,
Ahas forged a valid tag on the “new message” Hs(m∗) with respect
to theﬁxed-length message authentication code Π. This contradicts the
assumption that Π is a secure MAC.
We now turn the above into a formal proof.
THEOREM 5.6 IfΠis a secure MAC for messages of length /lscriptandΠH
is collision resistant, then Construction 5.5 is a secure MAC (for arbitrary-
length messages).160 Introduction to Modern Cryptography
PROOF Let Π/primedenote Construction 5.5, and let A/primebe apptadversary
attacking Π/prime. In an execution of experiment Mac-forgeA/prime,Π/prime(n), letk/prime=/angbracketleftk,s/angbracketright
denote the MAC key, let Qdenote the set of messages whose tags were re-
quested byA/prime, and let ( m∗,t) be the ﬁnal output of A/prime. We assume without
loss of generality that m∗/negationslash∈Q. Deﬁnecollto be the event that, in experiment
Mac-forgeA/prime,Π/prime(n), there is an m∈Qfor which Hs(m∗) =Hs(m). We have
Pr[Mac-forgeA/prime,Π/prime(n) = 1]
= Pr[Mac-forgeA/prime,Π/prime(n) = 1∧coll]+Pr[Mac-forgeA/prime,Π/prime(n) = 1∧coll]
≤Pr[coll]+Pr[Mac-forgeA/prime,Π/prime(n) = 1∧coll]. (5.1)
We show that both terms in Equation (5.1) are negligible, thus completing
the proof. Intuitively, the ﬁrst term is negligible by collision resistance of Π H,
and the second term is negligible by security of Π.
Consider the following algorithm Cfor ﬁnding a collision in Π H:
AlgorithmC:
The algorithm is given sas input (with nimplicit).
•Choose uniform k∈{0,1}n.
•RunA/prime(1n). WhenA/primerequests a tag on the ith message
mi∈{0,1}∗, compute ti←Mack(Hs(mi)) and give titoA/prime.
•WhenA/primeoutputs ( m∗,t), then if there exists an ifor which
Hs(m∗) =Hs(mi), output ( m∗,mi).
It is clear thatCruns in polynomial time. Let us analyze its behavior. When
the input toCis generated by running GenH(1n) to obtain s, the view ofA/prime
when run as a subroutine by Cis distributed identically to the view of A/primein
experiment Mac-forgeA/prime,Π/prime(n). In particular, the tags given to A/primebyChave
the same distribution as the tags that A/primereceives in Mac-forgeA/prime,Π/prime(n). Since
Coutputs a collision exactly when colloccurs, we have
Pr[Hash-collC,ΠH(n) = 1] = Pr[ coll].
Because Π His collision resistant, we conclude that Pr[ coll] is negligible.
We now proceed to prove that the second term in Equation (5.1) is negli-
gible. Consider the following adversary Aattacking Π in Mac-forgeA,Π(n):
AdversaryA:
The adversary is given access to a MAC oracle Mack(·).
•Compute GenH(1n) to obtain s.
•RunA/prime(1n). WhenA/primerequests a tag on the ith message
mi∈{0,1}∗, then: (1) compute ˆ mi:=Hs(mi); (2) obtain a
tagtion ˆmifrom the MAC oracle; and (3) give titoA/prime.
•WhenA/primeoutputs ( m∗,t), then output ( Hs(m∗),t).Hash Functions and Applications 161
ClearlyAruns in polynomial time. Consider experiment Mac-forgeA,Π(n). In
that experiment, the view of A/primewhen run as a subroutine by Ais distributed
identically to its view in experiment Mac-forgeA/prime,Π/prime(n). Furthermore, when-
ever both Mac-forgeA/prime,Π/prime(n) = 1 and colldo not occur,Aoutputs a valid
forgery. (In that case tis a valid tag on Hs(m∗) in scheme Π with respect
tok. The fact that colldid not occur means that Hs(m∗) was never asked by
Ato its own MAC oracle and so this is indeed a forgery.) Therefore,
Pr[Mac-forgeA,Π(n) = 1] = Pr[ Mac-forgeA/prime,Π/prime(n)∧coll],
and security of Π implies that the former probability is negligible. This con-
cludes the proof of the theorem.
5.3.2 HMAC
Allthe constructions of message authentication codes we have seen so far
are ultimately based on some block cipher. Is it possible to construct a secure
MAC (for arbitrary-length messages) based directly on a hash function? A
ﬁrst thought might be to deﬁne Mack(m) =H(k/bardblm); we might expect that
ifHis a “good” hash function then it should be diﬃcult for an attacker to
predict the value of H(k/bardblm/prime) given the value of H(k/bardblm), for any m/prime/negationslash=m, as-
sumingkis chosen at random (and unknown to the attacker). Unfortunately,
ifHis constructed using the Merkle–Damg˚ ard transform—as most real-world
hash functions are—then a MAC designed in this way is completely insecure,
as you are asked to show in Exercise 5.10.
Instead, we can try using twolayers of hashing. See Construction 5.7 for a
standardized scheme called HMACbased on this idea.
CONSTRUCTION 5.7
Let(GenH,H) be a hash function constructed by applying the Merkle–
Damg˚ ard transform to a compression function ( GenH,h) taking inputs
of length n+n/prime. (See text.) Let opadandipadbe ﬁxed constants of
lengthn/prime. Deﬁne a MAC as follows:
•Gen: on input 1n, runGenH(1n) to obtain a key s. Also choose
uniform k∈{0,1}n/prime. Output the key /angbracketlefts,k/angbracketright.
•Mac: on input a key/angbracketlefts,k/angbracketrightand a message m∈{0,1}∗, output
t:=Hs/parenleftBig
(k⊕opad)/bardblHs/parenleftbig
(k⊕ipad)/bardblm/parenrightbig/parenrightBig
.
•Vrfy: on input a key /angbracketlefts,k/angbracketright, a message m∈{0,1}∗, and a tag t,
output 1 if and only if t?=Hs/parenleftbig
(k⊕opad)/bardblHs/parenleftbig
(k⊕ipad)/bardblm/parenrightbig/parenrightbig
.
HMAC.162 Introduction to Modern Cryptography
/MT107 /MT109/MT49
/MT46/MT46/MT46
/MT116/MT73/MT86
/MT107
/MT73/MT86/MT111/MT112/MT97/MT100/MT104/MT115/MT104/MT115/MT104/MT115
/MT104/MT115/MT104/MT115/MT105/MT112/MT97/MT100
/MT107/MT105/MT110
/MT107/MT111/MT117/MT116/MT46/MT46/MT46
/MT97/MT112/MT112/MT101/MT110/MT100
/MT112/MT97/MT100/MT100/MT105/MT110/MT103
FIGURE 5.2 :HMAC, pictorially.
Why should we have any conﬁdence that HMAC is secure? One reason
is that we can view HMAC as a speciﬁc instantiation of the hash-and-MAC
paradigmfromtheprevioussection. Toseethis, wewilllook“underthehood”
at what happens when a message is authenticated; see Figure 5.2. We must
also specify parameters more carefully and go into a bit more detail regarding
the way the Merkle–Damg˚ ard transform is implemented in practice.
Say (GenH,H) is constructed based on a compression function ( GenH,h) in
whichhmaps inputs of length n+n/primeto outputs of length n(where, formally,
n/primeis a function of n). When we described the Merkle–Damg˚ ard transform
in Section 5.2, we assumed n/prime=n, but that need not always be the case.
We also said that the length of the message being hashed was encoded as
an extra message block that is appended to the message. In practice, the
length is instead encoded in a portionof a block using /lscript < n/primebits. That is,
computation of Hs(x) begins by padding xwith zeros to a string of length
exactly/lscriptless than a multiple of n/prime; it then appends the length L=|x|,
encoded using exactly /lscriptbits. The hash of the resulting sequence of n/prime-bit
blocksx1,...is then computed as in Construction 5.3. We will assume that
n+/lscript≤n/prime. This means, in particular, that if we hash an input xof length
n/prime+nthen the padded result (including the length) will be exactly 2 n/primebits
long. The proof of Theorem 5.4, showing that ( GenH,H) is collision resistant
if (GenH,h) is collision resistant, remains unchanged.
Coming back to HMAC, and looking at Figure 5.2, we can see that the
general form of HMAC involves hashing an arbitrary-length message down
to a short string ydef=Hs((k⊕ipad)/bardblm), and then computing the (secretly
keyed) function Hs((k⊕opad)/bardbly) of the result. But we can say more than
this. Note ﬁrst that the “inner” computation
/tildewideHs(m)def=Hs((k⊕ipad)/bardblm)Hash Functions and Applications 163
is collision resistant (assuming his), for any value of k⊕ipad. Moreover, the
ﬁrst step in the “outer” computation Hs((k⊕opad)/bardbly) is to compute a value
koutdef=hs(IV/bardbl(k⊕opad)). Then, we evaluate hs(kout/bardblˆy) where ˆyrefers to
the padded value of y(i.e., including the length of ( k⊕opad)/bardbly, which is
alwaysn/prime+nbits, encoded using exactly /lscriptbits). Thus, if we treat koutas
uniform—we will be more formal about this below—and assume that
/tildewidestMack(y)def=hs(k/bardblˆy) (5.2)
is a secure ﬁxed-length MAC, then HMAC can be viewed as an instantiation
of the hash-and-MAC approach with
HMAC s,k(m) =/tildewidestMackout(˜Hs(m)) (5.3)
(wherekout=hs(IV/bardbl(k⊕opad))). Because of the way the compression
function his typically designed (see Section 6.3.1), the assumption that /tildewidestMac
is a secure ﬁxed-length MAC is a reasonable one.
The roles of ipadandopad.Given the above, one might wonder why it
is necessary to incorporate kin the “inner” computation Hs((k⊕ipad)/bardblm).
(In particular, for the hash-and-MAC approach to be secure we require colli-
sion resistance in the ﬁrst step, which does not require any secret key.) The
reason is that this allows security of HMAC to be based on the potentially
weaker assumption that ( GenH,H) isweaklycollision resistant, where weak
collision resistanceis deﬁned by the following experiment: a key sis generated
usingGenHand a uniform secretkin∈{0,1}nis chosen. Then the adversary
is allowed to interact with a “hash oracle” that returns Hs
kin(m) in response
to the query m, whereHs
kinrefers to computation of Hsusing the Merkle–
Damg˚ ard transform applied to hs, but using the secret value kinas theIV.
(Refer again to Figure 5.2.) The adversary succeeds if it can output distinct
valuesm,m/primesuch that Hs
kin(m) =Hs
kin(m/prime), and we say that ( GenH,H) is
weakly collision resistant if every pptAsucceeds in this experiment with
only negligible probability. If ( GenH,H) is collision resistant then it is clearly
weakly collision resistant; the latter, however, is a weaker condition that is
potentially easier to satisfy. This is a good example of sound security engi-
neering. This defensive design strategy paid oﬀ when it was discovered that
the hash function MD5 (see Section 6.3.2) was notcollision resistant. The
collision-ﬁnding attacks on MD5 did not violate weak collision resistance, and
HMAC-MD5 was not broken even though MD5 was. This gave developers
time to replace MD5 in HMAC implementations, without immediate fear of
attack. (Despite this, HMAC-MD5 should no longer be used now that weak-
nesses in MD5 are known.)
The above discussion suggests that independent keys should be used in the
outer and inner computations. For reasons of eﬃciency, a single key kis used
for HMAC, but the key is used in combination with ipadandopadto derive164 Introduction to Modern Cryptography
two other keys. Deﬁne
Gs(k)def=hs/parenleftbig
IV/bardbl(k⊕opad)/parenrightbig
/bardblhs/parenleftbig
IV/bardbl(k⊕ipad)/parenrightbig
=kout/bardblkin.(5.4)
If we assumethat Gsis apseudorandomgeneratorfor any s, thenkoutandkin
can be treated as independent and uniform keys when kis uniform. Security
of HMAC then reduces to the security of the following construction:
Macs,kin,kout(m) =hs/parenleftbig
kout/bardblHs
kin(m)/parenrightbig
.
(Compare to Equation (5.3).) As noted earlier, this construction can be
proven secure (using a variant of the proof for the hash-and-MAC approach)
ifHis weakly collision resistant and the MAC deﬁned in Equation (5.2) is a
secure ﬁxed-length MAC.
THEOREM 5.8 Assume Gsas deﬁned in Equation (5.4) is a pseudo-
random generator for any s, the MAC deﬁned in Equation (5.2) is a secure
ﬁxed-length MAC for messages of length n, and(GenH,H)is weakly collision
resistant. Then HMAC is a secure MAC (for arbitrary-length messages ).
HMAC in practice. HMAC is an industry standard and is widely used in
practice. It is highly eﬃcient and easy to implement, and is supported by a
proof of security based on assumptions that are believed to hold for practical
hash functions. The importance of HMAC is partially due to the timeliness of
its appearance. Before the introduction of HMAC, many practitioners refused
to use CBC-MAC (with the claim that it was “too slow”) and instead used
heuristic constructions that were insecure. HMAC provided a standardized,
secure way of doing message authentication based on hash functions.
5.4 Generic Attacks on Hash Functions
What is the best securitywe canhope for ahash function Hto provide? We
explorethis question by showingtwo attacksthat are genericin the sense that
they apply to arbitrary hash functions. The existence of these attacks implies
lower bounds on the output length of Hneeded to achieve some desired level
of security, and therefore has important practical ramiﬁcations.
5.4.1 Birthday Attacks for Finding Collisions
LetH:{0,1}∗→{0,1}/lscriptbe a hash function. (Here and in the rest of the
chapter, we drop explicit mention of the hash key ssince it is not directly
relevant. One can also view sas being generated and ﬁxed before theseHash Functions and Applications 165
algorithms are applied.) There is a trivial collision-ﬁnding attack running in
timeO(2/lscript): simply evaluate Hon 2/lscript+ 1 distinct inputs; by the pigeonhole
principle, two of the outputs must be equal. Can we do better?
Generalizingtheabovealgorithm,saywechoose qdistinctinputs x1,...,x q,
compute yi:=H(xi), and check whether any of the two yivalues are equal.
What is the probability that this algorithm ﬁnds a collision? As we have
just said, if q >2/lscriptthen a collision occurs with probability 1. What is the
probability of a collision when qis smaller? It is somewhat diﬃcult to analyze
this probability exactly, and so we will instead analyze an idealized case in
whichHis treated as a random function.1That is, for each iwe assume
that the value yi=H(xi) is uniformly distributed in {0,1}/lscriptand independent
of any of the previous output values {yj}j<i(recall we assume all {xi}are
distinct). Wehavethusreducedourproblemtothe followingone: ifwechoose
valuesy1,...,y q∈{0,1}/lscriptuniformly at random, what is the probability that
there exist distinct i,jwithyi=yj?
This problem has been extensively studied, and is related to the so-called
birthday problem discussed in detail in Appendix A.4. For this reason, the
collision-ﬁnding algorithm we have described is often called a birthday attack .
The birthday problem is the following: if qpeople are in a room, what is the
probability that two of them have the same birthday? (Assume birthdays are
uniformly and independently distributed among the 365 days of a non-leap
year.) This is exactly analogous to our problem: if yirepresents the birthday
of person i, then we have y1,...,y q∈ {1,...,365}chosen uniformly, and
matching birthdays correspond to distinct i,jwithyi=yj(i.e., matching
birthdays correspond to collisions).
InAppendix A.4weshowthat for y1,...,y qchosenuniformlyin {1,...,N},
the probability of a collision is roughly 1 /2 whenq= Θ(N1/2). In the case of
birthdays, once thereareonly23people the probabilitythat sometwoofthem
have the same birthday is greater than 1 /2. In our setting, this means that
when the hash function has output length /lscript(and so the range is of size 2/lscript),
then taking q= Θ(2/lscript/2) yields a collision with probability roughly 1 /2.
From a concrete-securityperspective, the abovemeans that for a hash func-
tion to resist collision-ﬁnding attacks that run in time T(where we take the
time to evaluate Has our unit of time), the output length of the hash func-
tion needs to be at least 2log Tbits (since 2(2logT)/2=T). Taking speciﬁc
parameters, this means that if we want ﬁnding collisions to be as diﬃcult as
an exhaustive search over 128-bit keys, then we need the output length of the
hash function to be at least 256 bits. We stress that having an output this
long is only a necessary condition, not a suﬃcient one. We also note that
birthday attacks work only for ﬁnding collisions. There are no generic attacks
1Itcan be shown that this is (essentially) the worst case, and collisions occur with higher
probability if Hdeviates from random and the {xi}are chosen uniformly.166 Introduction to Modern Cryptography
for second preimage resistance or preimage resistance of a hash functions H
that require fewer than 2/lscriptevaluations of H(though see Section 5.4.3).
Finding meaningful collisions. The birthday attack just described gives a
collision that is not necessarily very useful. But the same idea can be used to
ﬁnd “meaningful”collisionsas well. Assume Alice wishes to ﬁnd two messages
xandx/primesuch that H(x) =H(x/prime), and furthermore xshould be a letter from
her employer explaining why she was ﬁred from work, while x/primeshould be
a ﬂattering letter of recommendation. (This might allow Alice to forge an
appropriatetag on a letter of recommendation if the hash-and-MAC approach
is being used by her employer to authenticate messages.) The observation
is that the birthday attack only requires the hash inputs x1,...,x qto be
distinct; they do not need to be random. Alice can carry out a birthday-type
attack by generating q= Θ(2/lscript/2) messages of the ﬁrst type and qmessages of
the second type, and then looking for collisions between messages of the two
types. A smallchangetothe analysisfromAppendix A.4showsthatthis gives
a collision between messages of diﬀerent types with probability roughly 1 /2.
A little thought shows that it is easy to write the same message in many
diﬀerent ways. For example, consider the following:
It ishard/diﬃcult/challenging/impossible toimagine/believe that
we willﬁnd/locate/hire another employee/person having similar
abilities/skills/character as Alice. She has done a great/super job.
Any combination of the italicized words is possible, and expresses the same
point. Thus, the sentence can be written in 4 ·2·3·2·3·2= 288 diﬀerent ways.
This is just one sentence and so it is actually easy to generate a message that
can be rewritten in 264diﬀerent ways—all that is needed are 64 words with
one synonym each. Alice can prepare 2/lscript/2letters explaining why she was ﬁred
and another 2/lscript/2letters of recommendation; with good probability, a collision
between the two types of letters will be found.
5.4.2 Small-Space Birthday Attacks
The birthday attacks described above require a large amount of memory;
speciﬁcally, they require the attacker to store all O(q) =O(2/lscript/2) values{yi},
because the attacker does not know in advance which pair of values will yield
a collision. This is a signiﬁcant drawback because memory is, in general,
a scarcer resource than time. It is arguably more diﬃcult to allocate and
manage storage for 260bytes than to execute 260CPU instructions. Further-
more, one can always let a computation run indeﬁnitely, whereas the memory
requirements of an algorithm must be satisﬁed as soon as that amount of
memory is needed.
We show here a better birthday attack with drastically reduced memory
requirements. In fact, it has similar time complexity and success probability
as before, but uses only constant memory. The attack begins by choosing aHash Functions and Applications 167
randomvalue x0andthencomputing xi:=H(xi−1)andx2i:=H(H(x2(i−1)))
fori= 1,2,.... (Note that xi=H(i)(x0) for alli, whereH(i)refers to i-fold
iteration of H.) In each step the values xiandx2iare compared; if they are
equal then there is a collision somewhere in the sequence x0,x1,...,x 2i−1.
The algorithm then ﬁnds the least value of jfor which xj=xj+i(note that
j≤isincej=iworks), and outputs xj−1,xj+i−1as a collision. This attack,
described formally as Algorithm 5.9 and analyzedbelow, only requires storage
of two hash values in each iteration.
ALGORITHM 5.9
Asmall-space birthday attack
Input:A hash function H:{0,1}∗→{0,1}/lscript
Output: Distinct x,x/primewithH(x) =H(x/prime)
x0←{0,1}/lscript+1
x/prime:=x:=x0
fori= 1,2,...do:
x:=H(x)
x/prime:=H(H(x/prime))
// nowx=H(i)(x0) andx/prime=H(2i)(x0)
ifx=x/primebreak
x/prime:=x, x:=x0
forj= 1 toi:
ifH(x) =H(x/prime)returnx,x/primeandhalt
elsex:=H(x), x/prime:=H(x/prime)
// nowx=H(j)(x0) andx/prime=H(i+j)(x0)
How many iterations of the ﬁrst loop do we expect before x/prime=x?Consider
the sequence of values x1,x2,..., wherexi=H(i)(x0) as deﬁned before. If
we model Has a random function, then each of these values is uniformly and
independently distributed in {0,1}/lscriptuntil the ﬁrst repeat occurs. Thus, we
expect a repeat to occur with probability 1 /2 in the ﬁrst q= Θ(2/lscript/2) terms
of the sequence. We show that when there is a repeat in the ﬁrst qelements,
the algorithm ﬁnds a repeat in at most qiterations of the ﬁrst loop:
CLAIM 5.10 Letx1,...,x qbe a sequence of values with xm=H(xm−1).
IfxI=xJwith1≤I < J≤q, then there is an i < Jsuch that xi=x2i.
PROOF The sequence xI,xI+1,...repeats with period ∆def=J−I. That
is, for all i≥Iandk≥0 it holds that xi=xi+k·∆. Letibe the smallest
multiple of ∆ that is also greater than or equal to I. We have i < Jsince the
sequence of ∆ values I,I+1,...I+(∆−1) =J−1 contains a multiple of ∆.
Sincei≥Iand 2i−i=iis a multiple of ∆, it follows that xi=x2i.168 Introduction to Modern Cryptography
Thus, if there is a repeated value in the sequence x1,...,x q, then there is
somei < qfor which xi=x2i. But then in iteration iof our algorithm, we
havex=x/primeand the algorithm breaks out of the ﬁrst loop. At that point in
the algorithm, we know that xi=xi+i. The algorithm then sets x/prime:=x(=xi)
andx:=x0, and proceeds to ﬁnd the smallest j≥0 for which xj=xj+i.
(Notej/negationslash= 0 because|x0|=/lscript+1.) It outputs xj−1,xj+i−1as a collision.
Finding meaningful collisions. The algorithm just described may not
seem amenable to ﬁnding meaningful collisions since it has no control overthe
elements sampled. Nevertheless, we show how ﬁnding meaningful collisions is
possible. The trick is to ﬁnd a collision in the right function!
Assume, as before, that Alice wishes to ﬁnd a collision between messages
of two diﬀerent “types,” e.g., a letter explaining why Alice was ﬁred and a
ﬂattering letter of recommendation that both hash to the same value. Then,
Alice writes each message so that there are /lscript−1 interchangeable words in
each; i.e., there are2/lscript−1messagesof eachtype. Deﬁne the one-to-onefunction
g:{0,1}/lscript→{0,1}∗suchthatthe /lscriptthbitoftheinputselectsbetweenmessages
of type 0 or type 1, and the ith bit (for 1≤i≤/lscript−1) selects between options
for theith interchangeable word in messages of the appropriate type. For
example, consider the sentences:
0: Bobisa good/hardworking andhonest/trustworthy worker/employee .
1: Bobisa diﬃcult/problematic andtaxing/irritating worker/employee .
Deﬁne a function gthat takes 4-bit inputs, where the last bit determines the
type of sentence output, and the initial three bits determine the choice of
words in that sentence. For example:
g(0000) = Bob is a good and honest worker.
g(0001) = Bob is a diﬃcult and taxing worker.
g(1010) = Bob is a hardworking and honest employee.
g(1011) = Bob is a problematic and taxing employee.
Now deﬁne f:{0,1}/lscript→ {0,1}/lscriptbyf(x)def=H(g(x)). Alice can ﬁnd a
collision in fusing the small-space birthday attack shown earlier. The point
here is that any collision x,x/primeinfyields two messages g(x),g(x/prime) that collide
underH. Ifx,x/primeisarandomcollisionthenweexpectthatwithprobability1 /2
thecollidingmessages g(x),g(x/prime)willbeofdiﬀerenttypes(since xandx/primediﬀer
in their ﬁnal bit with that probability). If the colliding messages are not of
diﬀerent types, the process can be repeated again from scratch.
5.4.3 *Time/Space Tradeoﬀs for Inverting Functions
In this section we consider the question of preimage resistance, i.e., we
are interested in algorithms for the problem of function inversion. Here, an
algorithm is given y=H(x) for uniform x, and the goal is to ﬁnd any x/primesuchHash Functions and Applications 169
thatH(x/prime) =y. We begin by assuming that the input and output lengths of
Hare equal, and brieﬂy consider the more general case at the end.
LetH:{0,1}/lscript→{0,1}/lscriptbe a function. Without exploiting any weaknesses
ofH, ﬁnding a preimage of a point ycan be done in time O(2/lscript) via an exhaus-
tive searchover the domain. We show that with signiﬁcant preprocessing, and
a relatively large amount of memory, it is possible to do better.
To be clear: we view preprocessing as a one-time operation and we will not
beoverlyconcernedwithitscost. Weareinsteadinterestedinthe on-linetime
required to invert Hat a point y, after the preprocessing has been done. This
is justiﬁed if the cost of preprocessing can be amortized over the inversion
of many points, or if we are willing to invest computational resources for
preprocessing before yis known for the beneﬁt of faster inversion afterwards.
In fact, it is trivial to use preprocessing to enable function inversion in
very little time. All we need to do is evaluate Hon every point during the
preprocessing phase, and then store the pairs {(x,H(x))}in a table, sorted by
their second entry. Upon receiving any point y, a preimage of ycan be found
easily by searching the table for a pair with second entry y. The drawback
here is that we need to allocate space for storing O(2/lscript) pairs in the table,
which can be prohibitive, if not impossible for large /lscript(e.g.,/lscript= 80).
The initial brute-force attack uses constant memory and O(2/lscript) time, while
the attack just described stores O(2/lscript) points and enables inversion in essen-
tially constant time. We now present an approach that allows an attacker
totrade oﬀ time and memory. Speciﬁcally, we show how to store O(22/lscript/3)
points and ﬁnd preimages in time O(22/lscript/3); other tradeoﬀs are possible.
A warmup. We begin by considering a simple case where the function H
deﬁnes a cycle, meaning that x,H(x),H(H(x)),...covers all of{0,1}/lscriptfor
any starting point x(note that most functions do not deﬁne a cycle, but we
assume this in order to demonstrate the idea in a very simple case). For
clarity, let N= 2/lscriptdenote the domain size.
In the preprocessing phase, the attacker simply exhausts the entire cycle,
beginning at an arbitrarystartingpoint x0and computing x1:=H(x0),x2:=
H(H(x0)), up to xN=H(N)(x0), where H(i)refers to i-fold evaluation of H.
Letxidef=H(i)(x0). We imagine partitioning the cycle into√
Nsegments of
length√
Neach, and having the attacker store the points at the beginning
and end of each such segment. That is, the attacker stores in a table pairs
of the form ( xi·√
N,x(i+ 1)·√
N),fori= 0 to√
N−1, sorted by the second
component of each pair. The resulting table contains O(√
N)points.
When the attacker is given a point yto invert in the on-line phase, it
checks which of y, H(y), H(2)(y), ...corresponds to the endpoint of a seg-
ment. (Each check just involves a table lookup on the second component of
the stored pairs.) Since ylies in some segment, it is guaranteed to hit an
endpoint within√
Nsteps. Once an endpoint x=x(i+1)·√
Nisidentiﬁed, the
attacker takes the starting point x/prime=xi·√
Nofthe corresponding segment170 Introduction to Modern Cryptography
/MT72 /MT72 /MT72
/MT72 /MT72 /MT72
/MT72 /MT72 /MT72/MT83/MT80/MT49
/MT83/MT80/MT50
/MT83/MT80/MT115/MT69/MT80/MT49
/MT69/MT80/MT50
/MT69/MT80/MT115
FIGURE 5.3 :Table generation. Only the ( SPi,EPi) pairs are stored.
and computes H(x/prime), H(2)(x/prime), ...untilyis reached; this immediately gives
the desired preimage. Observe that this takes at most√
Nevaluations of H.
Insummary, this attack stores O(√
N)points and ﬁnds preimages with
probability 1 using O(√
N)hash computations.
Hellman’s time/space tradeoﬀ. Martin Hellman introduced a more gen-
eral time/space tradeoﬀ applicable to an arbitrary function H(though the
analysis treats Has a random function). Hellman’s attack still stores the
starting point and endpoint of several segments, but in this case the segments
are “independent” rather than being part of one large cycle. In more detail:
lets,tbe parameters we will set later. The attack ﬁrst chooses suniform
starting points SP1,...,SP s∈{0,1}/lscript. For each such point SPi, it computes
a corresponding endpoint EPi:=H(t)(SPi) usingt-fold application of H.
(See Figure 5.3.) The attacker then stores the values {(SPi,EPi)}s
i=1in a
table, sorted by the second entry of each pair.
Upon receiving a value yto invert, the attack proceeds as in the simple
case discussed earlier. Speciﬁcally, it checks if any of y, H(y), ..., H(t−1)(y)
is equal to the endpoint of some segment (stopping as soon as the ﬁrst such
match isfound). It ispossible that noneofthesevalues isequal toan endpoint
(as we discuss below). However, if H(j)(y) =EPi=H(t)(SPi) for some
i,j, then the attacker computes H(t−j−1)(SPi) and checks whether this is a
preimage of y. The entire process requires at most tevaluations of H.
This seems to work, but there are several subtleties we have ignored. First,
it may happen that none of y, H(y), ..., H(t−1)(y) is the endpoint of a seg-
ment. This can happen if yis not in the collection of s·tvalues (not counting
the starting points) obtained during the initial process of generating the ta-
ble. We can set s·t≥Nin an attempt to include every /lscript-bit string in theHash Functions and Applications 171
table, but this does not solve the problem since there can be collisions in
the table itself—in fact, for s·t≥N1/2our previous analysis of the birth-
day problem tells us that collisions are likely—which will reduce the num-
ber of distinct points in the collection of values. A second problem, which
arises even if yisin the table, is that even if we ﬁnd a matching endpoint,
and soH(j)(y) =EPi=H(t)(SPi) for some i,j, this does not guarantee
thatH(t−j−1)(SPi) is a preimage of y. The issue here is that the segment
y, H(y), ..., H(t−1)(y) might collide with the ith segment even though yit-
self is not in that segment; see Figure 5.4. (Even if ylies in some segment,
the ﬁrst matching endpoint may not be in that segment.) We call this a false
positive. One might think this is unlikely to occur if His collision resistant;
again, however, we are dealing with a situation where more than√
Npoints
are involved and so collisions actually become likely.
/MT72 /MT72 /MT72
/MT72 /MT72/MT83/MT80/MT105
/MT121/MT69/MT80/MT105
/MT72
FIGURE 5.4 :Colliding in the on-line phase.
The problem of false positives can be addressed by modifying the algorithm
so that it always computes the entire sequence y, H(y), ..., H(t−1)(y), and
checks whether H(t−j−1)(SPi) is a preimage of yforeveryi,jsuch that
H(j)(y) =EPi. This is guaranteed to ﬁnd a preimage as long as yis in
the collection of values (not including the starting points) generated during
preprocessing. A concern now is that the running time of the algorithm might
increase, since each false positive incurs an additional O(t) hash evaluations.
One canshowthat the expected numberoffalse positivesis O(st2/N). (There
aretvalues in the sequence y, H(y), ..., H(t−1)(y) and at most stdistinct
points in the table. Treating Has a random function, the probability that
any point in the sequence equals some point in the table is 1 /N. The expected
number offalsepositivesisthus t·st·1/N=st2/N.) Thus, aslongas st2≈N,
which we will ensure for other reasons below, the expected number of false
positives is constant and dealing with false positives is expected to require
onlyO(t) additional hash computations.
Given the above modiﬁcation, the probability of inverting y=H(x) is
at least the probability that xis in the collection of points (not including
the endpoints) generated during preprocessing. We now lower bound this
probability, taken over the randomness of the preprocessing stage as well as172 Introduction to Modern Cryptography
uniform choice of x, treating Has a random function in the analysis. We
ﬁrst compute the expected number of distinct points in the table. Consider
what happens when the ith row of the table is generated. The starting point
SPiis uniform and there are at most ( i−1)·tdistinct points (not including
the endpoints) in the table already, so the probability that SPiis “new”
(i.e., not equal to any previous value) is at least 1 −(i−1)·t/N. What is
the probability that H(SPi) is new? If SPiis not new, then almost surely
neither is H(SPi). On the other hand, if SPiisnew then H(SPi) is uniform
(because we treat Has a random function) and so is new with probability at
least 1−((i−1)·t+1)/N. (We now have the additional point SPi.) Thus,
the probability that H(SPi) is new is at least
Pr[SPiis new]·Pr[H(SPi) is new|SPiis new]
≥/parenleftbigg
1−(i−1)·t
N/parenrightbigg
·/parenleftbigg
1−(i−1)·t+1
N/parenrightbigg
>/parenleftbigg
1−(i−1)·t+1
N/parenrightbigg2
.
Continuing in this way, the probability that H(t−1)(SPi) is new is at least
/parenleftbigg
1−i·t
N/parenrightbiggt
=/bracketleftBigg/parenleftbigg
1−i·t
N/parenrightbiggN
i·t/bracketrightBiggi·t2
N
≈e−it2/N.
Thethingtonoticehereisthatwhen it2≤N/2,thisprobabilityisatleast1 /2;
on the other hand, once it2> Nthe probability is rather small. Considering
the last row, when i=s, this means that we will not gain much additional
coverage if st2> N. A good setting of the parameters is thus st2=N/2.
Assuming this, the expected number of distinct points in the table is
s/summationdisplay
i=1t−1/summationdisplay
j=0Pr/bracketleftbig
H(j)(SPi) is new/bracketrightbig
≥s/summationdisplay
i=1t−1/summationdisplay
j=01
2=st
2.
The probability that xis “covered” is then at leastst
2N=1
4t.
This gives a weak time/space tradeoﬀ, in which we can use more space (and
consequently less time) at the expense of decreasing the probability of invert-
ingy. But we can do better by generating T= 4t“independent” tables. (This
increases both the space and time by a factor of T.) As long as we can treat
the probabilities of xbeing in each of the associated tables as independent,
the probability that at least one of these tables contains xis
1−Pr[no table contains x] = 1−/parenleftbigg
1−1
4t/parenrightbigg4t
≈1−e−1=0.63.
The only remaining question is how to generate an independent table. (Note
that generating a table exactly as before is the same as adding sadditionalHash Functions and Applications 173
rows to our original table, which we have already seen does not help.) We
can do this for the ith such table by applying some function Fiafter every
evaluation of H, where F1,...,F Tare all distinct. (A good choice might
be to set Fi(x) =x⊕cifor some ﬁxed constant cithat is diﬀerent in each
table.) Let Hidef=Fi◦H, i.e.,Hi(x) =Fi(H(x)). Then for the ith table
we again choose srandom starting points, but for each such point we now
compute Hi(SP),H(2)
i(SP), and so on. Upon receiving a value y=H(x)
to invert, the attacker ﬁrst computes y/prime=Fi(y) and then checks if any of
y/prime, Hi(y/prime), ..., H(t−1)
i(y/prime) corresponds to an endpoint in the ith table; this is
repeated for i= 1,...,T. (We omit further details.) While it is diﬃcult to
argue independence formally, this approach leads to good results in practice.
Choosing parameters. Summarizing the above discussion, we see that
as long as st2=N/2 we have an algorithm that stores O(s·T) =O(s·
t) =O(N/t) points during a preprocessing phase, and can then invert ywith
constant probability in time O(t·T) =O(t2). One setting ofthe parametersis
t=N1/3= 2/lscript/3, in which case we have an algorithm storing O(22/lscript/3) points
that ﬁnds preimages using O(22/lscript/3) hash computations. If a hash function
with 80 bits of output is used, then this is feasible in practice.
Handling diﬀerent domain and range. In practice, it is common to be
faced with a situation in which the domain and range of Hare diﬀerent. One
example is in the context of password cracking (see Section 5.6.3), where an
attacker has H(pw) but|pw|/lessmuch/lscript. In the general case, say xis chosen from
some domain Dwhich may be larger or smaller than {0,1}/lscript. While it is, of
course, possible to artiﬁcially expand the domain/range to make them match,
this will notbe useful for the attack described above. To see why, consider
the password example. For the attack to succeed we want pwto be in some
table of values generated during preprocessing. If we generate each row of the
table by simply computing H(SP),H(2)(SP),..., forSP∈D, thennoneof
these values (except possibly SPitself) will be equal to pw.
We can address this by applying a function Fi, as before, between each
evaluation of H, though now we choose Fimapping{0,1}/lscripttoD. This solves
the above issue, since Fi(H(SP)),(Fi◦H)(2)(SP),...now all lie in D.
Applications to key-recovery attacks. Time/space tradeoﬀs give at-
tacks on cryptographic primitives other than hash functions. One canonical
application—in fact, the application originally considered by Hellman—is an
attack on an arbitrary block cipher Fthat leads to recovery of the key. De-
ﬁneH(k)def=Fk(x) wherexis some arbitrary, but ﬁxed, input that will be
used for building the table. If an attacker can obtain Fk(x) for an unknown
keyk—either via a chosen-plaintext attack or by choosing xsuch that Fk(x)
is likely to be obtained in a known-plaintext attack—then by inverting Hthe
attacker learns (a candidate value for) k. Note that it is possible for the key
length of Fto diﬀer from its block length, but in this case we can use the
technique just described for handling Hwith diﬀerent domain and range.174 Introduction to Modern Cryptography
5.5 The Random-Oracle Model
There are several examples of constructions based on cryptographic hash
functions that cannot be proven secure based only on the assumption that
the hash function is collision or preimage resistant. (We will see some in
the following section.) In many cases, there appears to be nosimple and
reasonable assumption regarding the hash function that would be suﬃcient
for proving the construction secure.
Faced with this situation, there are several options. One is to look for
schemes that canbe proven secure based on some reasonable assumption
about the underlying hash function. This is a good approach, but it leaves
open the question of what to do until such schemes are found. Also, provably
secure constructions may be signiﬁcantly less eﬃcient than other approaches
that have not been proven secure. (This is a prominent issue that we will
encounter in the setting of public-key cryptography.)
Another possibility, of course, is to use an existing cryptosystem even if
it has no justiﬁcation for its security other than, perhaps, the fact that the
designers tried to attack it and were unsuccessful. This ﬂies in the face of ev-
erything we have said about the importance of the rigorous, modern approach
to cryptography, and it should be clear that this is unacceptable.
An approach that has been hugely successful in practice, and which oﬀers a
“middleground”betweenafullyrigorousproofofsecurityontheonehandand
no proof whatsoever on the other, is to introduce an idealized model in which
to provethe securityofcryptographicschemes. Although the idealizationmay
not be an accurate reﬂection of reality, we can at least derive some measure
of conﬁdence in the soundness of a scheme’s design from a proof within the
idealized model. As long as the model is reasonable, such proofs are certainly
better than no proofs at all.
The most popular example of this approach is the random-oracle model ,
whichtreatsacryptographichashfunction Hasatrulyrandomfunction. (We
have already seen an example of this in our discussion of time/space tradeoﬀs,
although there we wereanalyzingan attackrather than a construction.) More
speciﬁcally, the random-oracle model posits the existence of a public, random
function Hthat can be evaluated onlyby “querying”an oracle—which can be
thought of as a “black box”—that returns H(x) when given input x. (We will
discuss how this is to be interpreted in the following section.) To diﬀerentiate
things, the model we have been using until now (where no random oracle is
present) is often called the “standard model.”
Nooneclaimsthat arandomoracleexists, althoughtherehavebeen sugges-
tions that a random oracle could be implemented in practice using a trusted
party (i.e., some server on the Internet). Rather, the random-oracle model
provides a formal methodology that can be used to design and validate cryp-
tographic schemes using the following two-step approach:Hash Functions and Applications 175
1. First, a scheme is designed and proven secure in the random-oracle
model. That is, we assume the world contains a random oracle, and
construct and analyze a cryptographic scheme within this model. Stan-
dard cryptographic assumptions of the type we have seen until now may
be utilized in the proof of security as well.
2. When we want to implement the scheme in the real world, a random
oracle is not available. Instead, the random oracle is instantiated with
an appropriately designed cryptographic hash function ˆH. (We return
to this point at the end of this section.) That is, at each point where
the scheme dictates that a party should query the oracle for the value
H(x), the party instead computes ˆH(x) on its own.
The hope is that the cryptographic hash function used in the second step is
“suﬃciently good” at emulating a random oracle, so that the security proof
given in the ﬁrst step will carry over to the real-world instantiation of the
scheme. The diﬃculty here is that there is no theoretical justiﬁcation for this
hope, and in fact there are (contrived) schemes that can be proven secure in
the random-oraclemodel but are insecure no matter how the random oracle is
instantiated in the second step. Furthermore, it is not clear (mathematically
or heuristically) what it means for a hash function to be “suﬃciently good”
at emulating a random oracle, nor is it clear that this is an achievable goal.
In particular, no concrete instantiation ˆHcan ever behave like a random
function, since ˆHis deterministic and ﬁxed. For these reasons, a proof of
security in the random-oracle model should be viewed as providing evidence
that a scheme has no “inherent design ﬂaws,” but is nota rigorous proof that
any real-world instantiation of the scheme is secure. Further discussion on
how to interpret proofs in the random-oracle model is given in Section 5.5.2.
5.5.1 The Random-Oracle Model in Detail
Before continuing, let us pin down exactly what the random-oracle model
entails. A good way to think about the random-oracle model is as follows:
The “oracle” is simply a box that takes a binary string as input and returns
a binary string as output. The internal workings of the box are unknown and
inscrutable. Everyone—honest parties as well as the adversary—can interact
with the box, where such interaction consists of feeding in a binary string x
as input and receiving a binary string yas output; we refer to this as querying
the oracle on x, and call xitself aquerymade to the oracle. Queries to the
oracle are assumed to be private so that if some party queries the oracle on
inputxthen no one else learns x, or even learns that this party queried the
oracle at all. This makes sense, because calls to the oracle correspond (in the
real-worldinstantiation) to localevaluations ofa cryptographichash function.
An important property of this “box” is that it is consistent . That is, if the
box ever outputs yfor a particular input x, then it always outputs the same
answerywhen giventhe sameinput xagain. This means that wecan viewthe176 Introduction to Modern Cryptography
box as implementing a well-deﬁned function H; i.e., we deﬁne the function H
in terms of the input/output characteristics of the box. For convenience, we
thus speak of “querying H” rather than querying the box. No one “knows”
the entire function H(except the box itself); at best, all that is known are
the values of Hon the strings that have been explicitly queried thus far.
We have already discussed in Chapter 3 what it means to choose a random
function H. We onlyreiterateherethat there aretwoequivalent waystothink
about the uniform selection of H: either picture Hbeing chosen “in one shot”
uniformly from the set of all functions on some speciﬁed domain and range, or
imagine generating outputs for H“on-the-ﬂy,” as needed. Speciﬁcally, in the
secondcasewecanviewthefunctionasbeingdeﬁnedbyatablethatisinitially
empty. When the oracle receives a query xit ﬁrst checks whether x=xifor
some pair ( xi,yi) in the table; if so, the corresponding value yiis returned.
Otherwise, a uniform stringy∈{0,1}/lscriptis chosen (for some speciﬁed /lscript), the
answeryis returned, and the oracle stores ( x,y) in its table. This second
viewpoint is often conceptually easier to reason about, and is also technically
easier to deal with if His deﬁned over an inﬁnite domain (e.g., {0,1}∗).
When we deﬁned pseudorandom functions in Section 3.5.1, we also consid-
ered algorithms having oracle access to a random function. Lest there be any
confusion, we note that the usage of a random function there is very diﬀerent
from the usage of a random function here. There, a random function was
usedas a way of deﬁning what it means for a (concrete) keyed function to be
pseudorandom. In the random-oraclemodel, in contrast, the random function
is usedas part of a construction itself and must somehow be instantiated in
the real world if we want a concrete realization of the construction. A pseu-
dorandom function is not a random oracle because it is only pseudorandom if
the key is secret. However, in the random-oracle model all parties need to be
able to compute the function; thus there can be no secret key.
Deﬁnitions and Proofs in the Random-Oracle Model
Deﬁnitions in the random-oracle model are slightly diﬀerent from their
counterparts in the standard model because the probability spaces consid-
ered in each case are not the same. In the standard model a scheme Π is
secure if for all pptadversariesAthe probability of some event is below some
threshold, where this probability is taken over the random choices of the par-
ties running Πand those of the adversary A.Assuming the honest parties
who use Π in the real world make random choices as directed by the scheme,
satisfyingadeﬁnitionofthis sortguaranteessecurityforreal-worldusageofΠ.
In the random-oracle model, in contrast, a scheme Π may rely on an or-
acleH. As before, Π is secure if for all pptadversariesAthe probability
of some event is below some threshold, but now this probability is taken over
random choice of Has well as the random choices of the parties running Π
and those of the adversary A. When using Π in the real world, some (instan-
tiation of) Hmust be ﬁxed. Unfortunately, security of Π is not guaranteedHash Functions and Applications 177
for anyparticular choice of H. This indicates one reason why it is diﬃcult
to argue that any concrete instantiation of the oracle Hby a deterministic
function yields a secure scheme. (An additional, technical, diﬃculty is that
once a concrete function His ﬁxed, the adversary Ais no longer restricted to
querying Has an oracle but can instead look at and use the codeofHin the
course of its attack.)
Proofs in the random-oracle model can exploit the fact that His chosen
at random, and that the only way to evaluate H(x) is to explicitly query x
toH. Three properties in particular are especially useful; we sketch them
informally here, and show some simple applications of them below and in the
next section, but caution that a full understanding will likely have to wait
until we present formal proofs in the random-oracle model in later chapters.
The ﬁrst useful property of the random-oracle model is:
Ifxhas not been queried to H, then the value of H(x)isuniform .
This may seem superﬁcially similar to the guarantee provided by a pseudo-
random generator, but is actually much stronger. If Gis a pseudorandom
generator then G(x) is pseudorandom to an observer assuming xis chosen
uniformly at random and is completely unknown to the observer . IfHis a
random oracle, however, then H(x) is truly uniform to an observer as long as
the observer has not queried x. This is true even if xis known, or if xis not
uniform but ishard to guess. (For example, if xis ann-bit string where the
ﬁrst half of xis known and the last half is random then G(x) might be easy
to distinguish from random but H(x) will not be.)
The remaining two properties relate explicitly to proofs by reduction in the
random-oracle model. (It may be helpful here to review Section 3.3.2.) As
part of the reduction, the random oracle that the adversary Ainteracts with
must be simulated. That is: Awill submit queries to, and receive answers
from, what it believes to be the oracle, but the reduction itself must now
answer these queries. This turns out to give a lot of power. For starters:
IfAqueriesxtoH, the reduction can see this query and learn x.
This is sometimes called “extractability.” (This does not contradict the fact,
mentioned earlier, that queriesto the randomoracleare“private.” While that
is true in the random-oracle model itself, here we are using Aas a subroutine
within a reduction that is simulating the random oracle for A.) Finally:
The reduction can setthe value of H(x)(i.e., the response to
queryx) to a value of its choice, as long as this value is correctly
distributed, i.e., uniform.
This is called “programmability.” There is no counterpart to extractability
or programmability once His instantiated with any concrete function.178 Introduction to Modern Cryptography
Simple Illustrations of the Random-Oracle Model
At this point some examples may be helpful. The examples given here
are relatively simple, and do not use the full power that the random-oracle
model aﬀords. Rather, these examples are presented merely to provide a
gentle introduction to the model. In what follows, we assume a random oracle
mapping /lscriptin-bit inputs to /lscriptout-bit outputs, where /lscriptin,/lscriptout> n, the security
parameter (so /lscriptin,/lscriptoutare functions of n).
A random oracle as a pseudorandom generator. We ﬁrst show that,
for/lscriptout> /lscriptin, a random oracle can be used as a pseudorandom generator.
(We do not say that a random oracle isa pseudorandom generator, since a
random oracle is not a ﬁxed function.) Formally, we claim that for any ppt
adversaryA, there is a negligible function neglsuch that
/vextendsingle/vextendsingle/vextendsinglePr[AH(·)(y) = 1]−Pr[AH(·)(H(x)) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl(n),
where in the ﬁrst case the probability is taken over uniform choice of H,
uniform choice of y∈ {0,1}/lscriptout(n), and the randomness of A, and in the
second case the probability is taken over uniform choice of H, uniform choice
ofx∈{0,1}/lscriptin(n), and the randomness of A. We have explicitly indicated
thatAhas oracle access to Hin each case; once Hhas been chosen then A
can freely make queries to it.
LetSdenote the set of points on which Ahas queried H; of course,|S|is
polynomial in n. Observe that in the second case, the probability that x∈S
is negligible. This holds since Astarts with no information about x(note
thatH(x) by itself reveals nothing about xbecauseHis a random function),
and because Sis exponentially smaller than {0,1}/lscriptin. Moreover, conditioned
onx/negationslash∈Sin the second case, A’s input in each case is a uniform string that is
independent of the answers to A’s queries.
A random oracle as a collision-resistant hash function. If/lscriptout< /lscriptin,
a random oracle is collision resistant. That is, the success probability of any
pptadversaryAin the following experiment is negligible:
1. A random function His chosen.
2.Asucceeds if it outputs distinct x,x/primewithH(x) =H(x/prime).
To see this, assume without loss of generality that Aonly outputs values x,x/prime
that it had previously queried to the oracle, and that Anever makes the
same query to the oracle twice. Letting the oracle queries of Abex1,...,x q,
withq=poly(n), it is clear that the probability that Asucceeds is upper-
bounded by the probability that H(xi) =H(xj) for some i/negationslash=j. But this is
exactly equal to the probability that if we pick qstringsy1,...,y q∈{0,1}/lscriptout
independently and uniformly at random, we have yi=yjfor some i/negationslash=j. This
is exactly the birthday problem, and so using the results of Appendix A.4 we
have thatAsucceeds with negligible probability O(q2/2/lscriptout).Hash Functions and Applications 179
Constructing a pseudorandom function from a random oracle. It is
also rather easy to construct a pseudorandom function in the random-oracle
model. Suppose /lscriptin(n) = 2nand/lscriptout(n) =n, and deﬁne
Fk(x)def=H(k/bardblx),
where|k|=|x|=n. In Exercise 5.11 you are asked to show that this is a
pseudorandom function, namely, that for any polynomial-time Athe success
probability ofAin the following experiment is not more than 1 /2 plus a
negligible function:
1. A function Handvalues k∈{0,1}nandb∈{0,1}arechosenuniformly.
2. Ifb= 0, the adversary Ais given access to an oracle for Fk(·) =H(k/bardbl·).
Ifb= 1, thenAis given access to a random function mapping n-bit
inputs to n-bit outputs. (This random function is independent ofH.)
3.Aoutputs a bit b/prime, and succeeds if b/prime=b.
In step 2,Acan access Hin addition to the function oracle provided to it by
the experiment. (A pseudorandom function in the random-oracle model must
be indistinguishable from a random function that is independent of H.)
An interesting aspect of all the above claims is that they make no compu-
tational assumptions; they hold even for computationally unbounded adver-
saries as long as those adversaries are limited to making polynomially many
queries to the oracle. This has no counterpart in the real world, where we
have seen that computational assumptions are necessary.
5.5.2 Is the Random-Oracle Methodology Sound?
Schemes designed in the random-oracle model are implemented in the real
world by instantiating Hwith some concrete function. With the mechanics of
the random-oracle model behind us, we turn to a more fundamental question:
What do proofs of security in the random-oracle model guarantee
as far as security of any real-world instantiation?
This question does not have a deﬁnitive answer: there is currently debate
within the cryptographic community regarding how to interpret proofs in the
random-oracle model, and an active area of research is to determine what,
precisely, a proof of security in the random-oracle model implies vis-a-vis the
real world. We can only hope to give a ﬂavor of both sides of the debate.
Objections to the random-oracle model. The starting point for argu-
ments against using random oracles is simple: as we have already noted, there
is no formal or rigorous justiﬁcation for believing that a proof of security for
some scheme Π in the random-oracle model says anything about the security
of Π in the real world, once the random oracle Hhas been instantiated with180 Introduction to Modern Cryptography
any particular hash function ˆH. This is more than just theoretical uneasiness.
A little thought shows that noconcrete hash function can ever act as a “true”
random oracle. For example, in the random-oracle model the value H(x) is
“completely random” if xwas not explicitly queried. The counterpart would
be to require that ˆH(x) is random (or pseudorandom) if ˆHwas not explicitly
evaluated on x. How are we to interpret this in the real world? It is not even
clear what it means to “explicitly evaluate” ˆH: what if an adversary knows
some shortcut for computing ˆHthat does not involve running the actual code
forˆH? Moreover, ˆH(x) cannot possibly be random (or even pseudorandom)
since once the adversarylearnsthe descriptionof ˆH, the value ofthat function
onallinputs is immediately determined.
Limitations of the random-oracle model become clearer once we examine
the proof techniques introduced earlier. Recall that one proof technique is to
use the fact that a reduction can “see” the queries that an adversary Amakes
to the random oracle. If we replace the random oracle by a particular hash
function ˆH, this means we must provide a description of ˆHto the adversary
at the beginning of the experiment. But then Acan evaluate ˆHon its own,
without making any explicitqueries, and so a reduction will no longer have
the ability to “see” any queries made by A. (In fact, as noted previously, the
notionofAperformingexplicitevaluationsof ˆHmaynotbe trueandcertainly
cannot be formally deﬁned.) Likewise, proofs of security in the random-oracle
model allow the reduction to choose the outputs of Has it wishes, something
that is clearly not possible when a concrete function is used.
Evenif we arewilling to overlookthe abovetheoretical concerns, a practical
problem is that we do not currentlyhave a verygood understanding ofwhat it
means for a concrete hash function to be “suﬃciently good” at instantiating a
randomoracle. Forconcreteness,saywewanttoinstantiatethe randomoracle
usingsomeappropriatemodiﬁcation ofSHA-1(SHA-1 is acryptographichash
function discussed in Section 6.3.3). While for some particular scheme Π
it might be reasonable to assume that Π is secure when instantiated using
SHA-1, it is much less reasonable to assume that SHA-1 can take the place
of a random oracle in everyscheme designed in the random-oracle model.
Indeed, as we have said earlier, we knowthat SHA-1 is not a random oracle.
And it is not hard to design a scheme that is secure in the random-oracle
model, but is insecure when the random oracle is replaced by SHA-1.
We emphasize that an assumption of the form “SHA-1 acts like a random
oracle” is qualitatively diﬀerent from assumptions such as “SHA-1 is collision
resistant”or“AESis apseudorandomfunction.” The problemlies partlywith
the fact that there is no satisfactory deﬁnition of what the ﬁrst statement
means, while we do have such deﬁnitions for the latter two statements.
Becauseofthis, usingtherandom-oraclemodeltoprovesecurityofascheme
isqualitatively diﬀerent from, e.g., introducing a new cryptographic assump-
tion in order to prove a scheme secure in the standard model. Therefore,
proofs of security in the random-oracle model are less satisfying than proofs
of security in the standard model.Hash Functions and Applications 181
Support for the random-oracle model. Given all the problems with
the random-oracle model, why use it at all? More to the point: why has
the random-oracle model been so inﬂuential in the development of modern
cryptography (especially current practical usage of cryptography), and why
does it continue to be so widely used? As we will see, the random-oracle
model enables the design of substantially more eﬃcient schemes than those
we know how to construct in the standard model. As such, there are few
(if any) public-key cryptosystems used today having proofs of security in the
standard model, while there are numerous deployed schemes having proofs of
security in the random-oraclemodel. In addition, proofs in the random-oracle
model are almost universally recognized as lending conﬁdence to the security
of schemes being considered for standardization.
The fundamental reason for this is the belief that:
A proof of security in the random-oracle model is signiﬁcantly bet-
ter than no proof at all.
Although some disagree, we oﬀer the following in support of this assertion:
•A proof of security for a scheme in the random-oracle model indicates
that the scheme’s design is “sound,” in the sense that the only possible
attacks on a real-world instantiation of the scheme are those that arise
due to a weakness in the hash function used to instantiate the random
oracle. Thus, if a “good enough” hash function is used to instantiate the
random oracle, we should have conﬁdence in the security of the scheme.
Moreover, if a given instantiation of the scheme issuccessfully attacked,
we can simply replace the hash function being used with a “better” one.
•Importantly, there have been no successful real-world attacks on schemes
proven secure in the random-oracle model , when the random oracle was
instantiated properly. (We do not include here attacks on “contrived”
schemes, but remark that great care must be taken in instantiating the
randomoracle,asindicated byExercise5.10.) Thisgivesevidencetothe
usefulness of the random-oracle model in designing practical schemes.
Nevertheless, the above ultimately represent only intuitive speculation as
to the usefulness of proofs in the random-oracle model and—all else being
equal—proofs without random oracles are preferable.
Instantiating the Random Oracle
Properly instantiating a random oracle is subtle, and a full discussion is
beyondthescopeofthisbook. Hereweonlyalertthereaderthatusingan“oﬀ-
the-shelf” cryptographic hash function without modiﬁcation is not, generally
speaking, asoundapproach. Foronething, mostcryptographichashfunctions
are constructed using the Merkle–Damg˚ ard paradigm (cf. Section 5.2), which
can be distinguished easily from a random oracle when variable-length inputs182 Introduction to Modern Cryptography
areallowed. (SeeExercise5.10.) Also, insomeconstructionsitisnecessaryfor
theoutput ofthe randomoracletolieinacertainrange(e.g., theoracleshould
output elements of some group), which results in additional complications.
5.6 Additional Applications of Hash Functions
Weconclude this chapter with a brief discussion of some additional applica-
tions of cryptographic hash functions in cryptography and computer security.
5.6.1 Fingerprinting and Deduplication
When using a collision-resistant hash function H, the hash (or digest) of a
ﬁle serves as a unique identiﬁer for that ﬁle. (If any other ﬁle is found to have
the same identiﬁer, this implies a collision in H). The hash H(x) of a ﬁle xis
like a ﬁngerprint, and one can check whether two ﬁles are equal by comparing
their digests. This simple idea has many applications.
•Virus ﬁngerprinting: Virus scanners identify viruses and block or quar-
antine them. One of the most basic steps toward this goal is to store a
databasecontainingthehashesofknownviruses,andthentolookupthe
hash of a downloaded application or email attachment in this database.
Since only a short string needs to be recorded (and/or distributed) for
each virus, the overhead involved is feasible.
•Deduplication: Data deduplication is used to eliminate duplicate copies
of data, especially in the context of cloud storage where multiple users
rely on a single cloud service to store their data. The observation here is
that if multiple users wish to store the same ﬁle (e.g., a popular video),
then the ﬁle only needs to be stored once and need not be uploaded
separately by each user. Deduplication can be achieved by ﬁrst having
a user upload a hash of the new ﬁle they want to store; if a ﬁle with this
hash is already stored in the cloud, then the cloud-storage provider can
simply add a pointer to the existing ﬁle to indicate that this speciﬁc user
hasalsostoredthisﬁle. Thissavesbothcommunicationandstorage,and
the soundness of the methodology follows from the collision resistance
of the hash function.
•Peer-to-peer (P2P) ﬁle sharing : In P2P ﬁle-sharing systems, tables are
held by servers to provide a ﬁle-lookup service. These tables contain
the hashes of the available ﬁles, once again providing a unique identiﬁer
without using much memory.Hash Functions and Applications 183
It may be surprising that a small digest can uniquely identify every ﬁle
in the world. But this is the guarantee provided by collision-resistant hash
functions, which makes them useful in the settings above.
5.6.2 Merkle Trees
Consider a client who uploads a ﬁle xto a server. When the client later
retrieves x, it wants to make sure that the server returns the original, unmod-
iﬁed ﬁle. The client could simply store xand check that the retrieved ﬁle is
equal to x, but that defeats the purpose of using the server in the ﬁrst place.
We are looking for a solution in which the storage of the client is small.
A natural solution is to use the “ﬁngerprinting” approach described above.
The client can locally store the short digest h:=H(x); when the server
returns a candidate ﬁle x/primethe client need only check that H(x/prime)?=h.
What happens if we want to extend this solutionto multiple ﬁlesx1,...,x t?
There are two obvious ways of doing this. One is to simply hash each ﬁle
independently; the client will locally store the digests h1,...,h t, and verify
retrieved ﬁles as before. This has the disadvantage that the client’s storage
grows linearly in t. Another possibility is to hash all the ﬁles together. That
is, the client can compute h:=H(x1,...,x t) and store only h. The drawback
now is that when the client wants to retrieve and verify correctness of the ith
ﬁlexi, it needs to retrieve allthe ﬁles in order to recompute the digest.
Merkle trees , introduced by Ralph Merkle, give a tradeoﬀ between these
extremes. A Merkle tree computed over input values x1,...,x tis simply a
binary tree of depth log tin which the inputs are placed at the leaves, and the
value of each internal node is the hash of the values of its two children; see
Figure 5.5. (We assume tis a power of 2; if not, then we can ﬁx some input
values to nullor use an incomplete binary tree, depending on the application.)
x1x2x3x4x5x6x7x8h15 5 5 6 h5 7 7 7 8h1 9 9 9 :
H(x1,x2)H(x
; <x
= >H(x
? @x
A BH(x
C Dx
E F
FIGURE 5.5 : AMerkle tree.184 Introduction to Modern Cryptography
Fixing some hash function H, we denote byMTtthe function that takes t
input values x1,...,x t, computes the resulting Merkle tree, and outputs the
value of the root of the tree. (A keyed hash function yields a keyed function
MTtin the obvious way.) We have:
THEOREM5.11 Let(GenH,H)be collision resistant. Then (GenH,MTt)
is also collision resistant for any ﬁxed t.
Merkle trees thus provide an alternative to the Merkle–Damg˚ ard transform
for achieving domain extension for collision-resistant hash functions. (As de-
scribed, however, Merkle trees are notcollision resistant if the number of
input values tis allowed to vary.)
Merkle trees provide an eﬃcient solution to our original problem, since they
allow veriﬁcation of any of the original tinputs usingO(logt) communication.
The client computes h:=MTt(x1,...,x t), uploads x1,...,x tto the server,
and stores h(along with the number of ﬁles t) locally. When the client
retrieves the ith ﬁle, the server sends xialong with a “proof” πithat this
is the correct value. This proof consists of the values of the nodes in the
Merkle tree adjacent to the path from xito the root. From these values the
client can recompute the value of the root and verify that it is equal to the
stored value h. As an example, consider the Merkle tree in Figure 5.5. The
client computes h1...8:=MT8(x1,...,x 8), uploads x1,...,x 8to the server,
andstores h1...8locally. When theclient retrieves x3, theserversends x3along
withx4,h1...2=H(x1,x2), andh5...8=H(H(x5,x6),H(x7,x8)). (If ﬁles are
large we may wish to avoid sending any ﬁle other than the one the client has
requested. That caneasilybe doneifwedeﬁne the Merkletree overthe hashes
of the ﬁles rather than the ﬁles themselves. We omit the details.) The client
computes h/prime
1...4:=H(h1...2,H(x3,x4)) andh/prime
1...8:=H(h/prime
1...4,h5...8), and then
veriﬁes that h1...8?=h/prime
1...8.
IfHis collision resistant, it is infeasible for the server to send an incor-
rect ﬁle (and any proof) that will cause veriﬁcation to succeed. Using this
approach, the client’s local storage is constant (independent of the number of
ﬁlest), and the communication from server to client is proportional to log t.
5.6.3 Password Hashing
One of the most common and important uses of hash functions in computer
security is for password protection. Consider a user typing in a password
before using their laptop. To authenticate the user, some form of the user’s
password must be stored somewhere on their laptop. If the user’s password
is stored in the clear, then an adversary who steals the laptop can read the
user’s password oﬀ the hard drive and then login as that user. (It may seem
pointless to try to hide one’s password from an attacker who can already
read the contents of the hard drive. However, ﬁles on the hard drive may beHash Functions and Applications 185
encrypted with a key derived from the user’s password, and would thus only
be accessible after the password is entered. In addition, the user is likely to
use the same password at other sites.)
This risk can be mitigated by storing a hash of the password instead of the
password itself. That is, the hard drive stores the value hpw=H(pw) in
a password ﬁle; later, when the user enters its password pw, the operating
system checks whether H(pw)?=hpwbefore granting access. The same basic
approach is also used for password-based authentication on the web. Now, if
an attacker steals the hard drive (or breaks into a web server), all it obtains
is the hash of the password and not the password itself.
If the password is chosen from some relatively small space Dof possibilities
(e.g.,Dmight be a dictionary of English words, in which case |D|≈80,000),
an attacker can enumerate all possible passwords pw1,pw2,...∈Dand, for
each candidate pwi, check whether H(pwi) =hpw. We would like to claim
that an attacker can do no better than this. (This would also ensure that
the adversary could not learn the password of any user who chose a strong
password from a large space.) Unfortunately, preimage resistance (i.e., one-
wayness)of Hisnotsuﬃcienttoimplywhatwewant. Foronething, preimage
resistance only says that H(x) is hard to invert when xis chosen uniformly
from a large domain like {0,1}n. It says nothing about the hardness of invert-
ingHwhenxis chosen from some other space, or when xis chosen according
to some other distribution. Moreover, preimage resistance says nothing about
theconcrete amount of time needed to ﬁnd a preimage. For example, a hash
function Hfor which computing x∈{0,1}ngivenH(x) requires time 2n/2
could still qualify as preimage resistant, yet this would mean that a 30-bit
password could be recovered in only 215time.
If we model Has a random oracle, then we can formally prove the security
we want, namely, recovering pwfromhpw(assuming pwis chosen uniformly
fromD) requires|D|/2 evaluations of H, on average.
The above discussion assumes no preprocessing is done by the attacker. As
we have seen in Section 5.4.3, though, preprocessing can be used to generate
large tables that enable inversion (even of a random function!) faster than ex-
haustivesearch. Thisisasigniﬁcantconcernin practice: evenifauserchooses
their passwordasarandomcombinationof8alphanumericcharacters—giving
a password space of size N= 628≈247.6—there is an attack using time and
spaceN2/3≈232that will be highly eﬀective. The tables only need to be
generated once, and can be used to crack hundreds of thousands of passwords
in case of a server breach. Such attacks are routinely carried out in practice.
Mitigation. We brieﬂy describe two mechanisms used to mitigate the threat
of password cracking; further discussion can be found in texts on computer
security. One technique is to use “slow” hash functions, or to slow down
existing hash functions by using multiple iterations (i.e., computing H(I)(pw)
forI/greatermuch1). This has the eﬀect of slowing down legitimate users by a factor
ofI, which is not a problem if Iis set to some “moderate” value (e.g., 1,000).186 Introduction to Modern Cryptography
On the other hand, it has a signiﬁcant impact on an adversary attempting to
crack thousands of passwords at once.
A secondmechanismis to introducea salt. When a userregisterstheir pass-
word, the laptop/server will generate a long random value s(a “salt”) unique
to that user, and store ( s,hpw=H(s,pw)) instead of merely storing H(pw)
as before. Since sis unknown to the attacker in advance, preprocessing is
ineﬀective and the best an attacker can do is to wait until it obtains the pass-
word ﬁle and then do a linear-time exhaustive search over the domain Das
discussed before. Note also that since a diﬀerent salt is used for each stored
password, a separate brute-force search is needed to recover each password.
5.6.4 Key Derivation
All the symmetric-key cryptosystems we have seen require a uniformly dis-
tributed bit-string for the secret key. Often, however, it is more convenient
for two parties to rely on shared information such as a password or biometric
data that is notuniformly distributed. (Jumping ahead, in Chapter 10 we
will see how parties can interact to generate a high-entropy shared secret that
isnotuniformly distributed.) The parties could try to use their shared infor-
mation directly as a secret key, but in general this will not be secure (since,
e.g., private-key schemes all assume a uniformly distributed key). Moreover,
the shared data may not even have the correct format to be used as a secret
key (it may be too long, for example).
Truncating the shared secret, or mapping it in some other ad hoc way
to a string of the correct length, may lose a signiﬁcant amount of entropy.
(We deﬁne one notion of entropy more formally below, but for now one can
think of entropy as the logarithm of the space of possible shared secrets.) For
example, imagine twopartiessharea passwordcomposedof28randomupper-
caseletters, andwanttouseacryptosystemwitha128-bitkey. Sincethereare
26 possibilities for each character, there are 2628>2130possible passwords. If
the password is shared in ASCII format, each character is stored using 8 bits,
and sothe total length ofthe passwordis224bits. Ifthe partiestruncate their
password to the ﬁrst 128 bits, they will be using only the ﬁrst 16 characters
of their password. However, this will not be a uniformly distributed 128-bit
string! In fact, the ASCII representations of the letters A–Z lie between 0x41
and 0x5A; in particular, the ﬁrst 3 bits of every byte are always 010. This
means that 37.5% of the bits of the resulting key will be ﬁxed , and the 128-bit
key the parties derive will have only about 75 bits of entropy (i.e., there are
only 275or so possibilities for the key).
What we need is a generic solution for deriving a key from a high-entropy
(but not necessarily uniform) shared secret. Before continuing, we deﬁne the
notion of entropy we consider here.Hash Functions and Applications 187
DEFINITION 5.12 A probability distribution Xhasmbitsofmin-entropy
if for every ﬁxed value xit holds that PrX←X[X=x]≤2−m. That is, even
the most likely outcome occurs with probability at most 2−m.
The uniform distribution over a set of size Shas min-entropy log S. A dis-
tribution in which one element occurs with probability 1 /10 and 90 elements
each occur with probability 1 /100 has min-entropy log10 ≈3.3. The min-
entropy of a distribution measures the probability with which an attacker can
guess a value sampled from that distribution; the attacker’sbest strategy is to
guess the most likely value, and so if the distribution has min-entropy mthe
attacker guesses correctly with probability at most 2−m. This explains why
min-entropy (rather than other notions of entropy) is useful in our context.
An extension of min-entropy, called computational min-entropy , is deﬁned as
above except that the distribution is only required to be computationally in-
distinguishable from a distribution with the given min-entropy. (The notion
of computational indistinguishability is formally deﬁned in Section 7.8.)
Akey-derivation function provides a way to obtain a uniformly distributed
string from any distribution with high (computational) min-entropy. It is not
hard to see that if we model a hash function Has a random oracle, then H
serves as a good key-derivation function. Consider an attacker’s uncertainty
aboutH(X), where Xis sampled from a distribution with min-entropy m(as
a technical point, we require the distribution to be independent of H). Each
of the attacker’s queries to Hcan be viewed as a “guess” for the value of X;
by assumption on the min-entropy of the distribution, an attacker making q
queries to Hwill query H(X) with probability at most q·2−m. If the attacker
does not query XtoH, thenH(X) is a uniform string.
It is also possible to design key-derivation functions, without relying on the
random-oracle model, using keyed hash functions called (strong) extractors .
The key for the extractor must be uniform, but need not be kept secret. One
standard for this is called HKDF; see the references at the end of the chapter.
5.6.5 Commitment Schemes
Acommitment scheme allows one party to “commit” to a message mby
sending a commitment value com, while obtaining the following seemingly
contradictory properties:
•Hiding:the commitment reveals nothing about m.
•Binding: it is infeasible for the committer to output a commitment com
that it can later “open” as two diﬀerent messages m,m/prime. (In this sense,
comtruly “commits” the committer to some well-deﬁned value.)
A commitment scheme can be seen as a digital envelope: sealing a message in
an envelope and handing it over to another party provides privacy (until the188 Introduction to Modern Cryptography
envelope is opened) and binding (since the envelope is sealed).
Formally, a (non-interactive) commitment scheme is deﬁned by a random-
ized algorithm Genthat outputs public parameters paramsand an algorithm
Comthat takes paramsand a message m∈{0,1}nand outputs a commit-
mentcom; we will make the randomness used by Comexplicit, and de-
note it by r. A sender commits to mby choosing uniform r, computing
com:=Com(params,m;r), and sending it to a receiver. The sender can later
decommit comand reveal mby sending m,rto the receiver; the receiver
veriﬁes this by checking that Com(params,m;r)?=com.
Hiding, informally, meansthat comrevealsnothingabout m; bindingmeans
that it is impossible to output a commitment comthat can be opened two
diﬀerent ways. We deﬁne these properties formally now.
The commitment hiding experiment HidingA,Com(n):
1. Parameters params←Gen(1n)are generated.
2. The adversary Ais given input params, and outputs a pair of
messages m0,m1∈{0,1}n.
3. A uniform b∈{0,1}is chosen and com←Com(params,mb;r)
is computed.
4. The adversary Ais givencomand outputs a bit b/prime.
5. The output of the experiment is 1if and only if b/prime=b.
The commitment binding experiment BindingA,Com(n):
1. Parameters params←Gen(1n)are generated.
2.Ais given input paramsand outputs (com,m,r,m/prime,r/prime).
3. The output of the experiment is deﬁned to be 1if and only if
m/negationslash=m/primeandCom(params,m;r) =com=Com(params,m/prime;r/prime).
DEFINITION 5.13 A commitment scheme Comissecureif for all ppt
adversariesAthere is a negligible function neglsuch that
Pr/bracketleftbig
HidingA,Com(n) = 1/bracketrightbig
≤1
2+negl(n)
and
Pr/bracketleftbig
BindingA,Com(n) = 1/bracketrightbig
≤negl(n).
Itiseasytoconstructasecurecommitmentschemefromarandomoracle H.
To commit to a message m, the sender chooses uniform r∈ {0,1}nand
outputscom:=H(m/bardblr). (In the random-oracle model, Genandparamsare
not needed since H, in eﬀect, serves as the public parameters of the scheme.)
Intuitively, hiding follows from the fact that an adversaryqueries H(⋆/bardblr) withHash Functions and Applications 189
only negligible probability (since ris a uniform n-bit string); if it never makes
a query of this form then H(m/bardblr) reveals nothing about m. Binding follows
from the fact that His collision resistant.
Commitment schemes can be constructed without random oracles (in fact,
from one-way functions), but the details are beyond the scope of this book.
References and Additional Reading
Collision-resistant hash functions were formally deﬁned by Damg˚ ard [52].
Additional discussion regarding notions of security for hash functions besides
collision resistance can be found in [120, 150]. The Merkle–Damg˚ ard trans-
form was introduced independently by Damg˚ ard and Merkle [53, 123]
HMAC was introduced by Bellare et al. [14] and later standardized [131].
The small-space birthday attack described in Section 5.4.2 relies on a cycle-
ﬁnding algorithm of Floyd. Related algorithms and results are described at
http://en.wikipedia.org/wiki/Cycle_detection . The idea for ﬁnding
meaningful collisions using the small-space attack is by Yuval [180]. The
possibility of parallelizing collision-ﬁnding attacks, which can oﬀer signiﬁcant
speedups in practice, is discussed in [170]. Time/space tradeoﬀs for function
inversion were introduced by Hellman [87], with practical improvements—not
discussed here—given by Rivest (unpublished) and by Oechslin [134].
The ﬁrst formal treatment of the random-oraclemodel was given by Bellare
and Rogaway [21], although the idea of using a “random-looking” function
in cryptographic applications had been suggested previously, most notably
by Fiat and Shamir [65]. Proper instantiation of a random oracle based on
concrete cryptographic hash functions is discussed in [21, 22, 23, 48]. The
seminal negative result concerning the random-oraclemodel is that of Canetti
et al. [41], who show (contrived) schemes that are secure in the random-oracle
model but are insecure for anyconcrete instantiation of the random oracle.
Merkle trees were introduced in [121]. Key-derivation functions used in
practice include HKDF, PBKDF2, and bcrypt. See [109] for a formal treat-
ment of the problem and an analysis of HKDF.
Exercises
5.1Provide formal deﬁnitions for second preimage resistance and preimage
resistance. Provethat any hash function that is collision resistant is sec-
ond preimage resistant, and any hash function that is second preimage
resistant is preimage resistant.190 Introduction to Modern Cryptography
5.2 Let ( Gen1,H1) and (Gen2,H2) be two hash functions. Deﬁne ( Gen,H)
so thatGenrunsGen1andGen2to obtain keys s1ands2, respectively.
Then deﬁne Hs1,s2(x) =Hs1
1(x)/bardblHs2
2(x).
(a) Prove that if at least one of ( Gen1,H1) and (Gen2,H2) is collision
resistant, then ( Gen,H) is collision resistant.
(b) Determine whether an analogous claim holds for second preimage
resistanceandpreimageresistance,respectively. Proveyouranswer
in each case.
5.3 Let ( Gen,H) be a collision-resistant hash function. Is ( Gen,ˆH) deﬁned
byˆHs(x)def=Hs(Hs(x)) necessarily collision resistant?
5.4 Provide a formal proof of Theorem 5.4 (i.e., describe the reduction).
5.5 Generalize the Merkle–Damg˚ ard transform (Construction 5.3) for the
case when the ﬁxed-length hash function hhas input length n+κ(with
κ >0) and output length n, and the length of the input to Hshould be
encoded as an /lscript-bit value (as discussed in Section 5.3.2). Prove collision
resistance of ( Gen,H), assuming collision resistance of ( Gen,h).
5.6 For each of the following modiﬁcations to the Merkle–Damg˚ ard trans-
form (Construction 5.3), determine whether the result is collision resis-
tant. If yes, provide a proof; if not, demonstrate an attack.
(a) Modify the construction so that the input length is not included
at all (i.e., output zBand not zB+1=hs(zB/bardblL)). (Assume the
resulting hash function is only deﬁned for inputs whose length is
an integer multiple of the block length.)
(b) Modifytheconstructionsothatinsteadofoutputting z=hs(zB/bardblL),
the algorithm outputs zB/bardblL.
(c) Instead of using an IV, just start the computation from x1. That
is, deﬁne z1:=x1and then compute zi:=hs(zi−1/bardblxi) fori=
2,...,B+1 and output zB+1as before.
(d) Instead of using a ﬁxed IV, setz0:=Land then compute zi:=
hs(zi−1/bardblxi) fori= 1,...,Band output zB.
5.7 Assume collision-resistant hash functions exist. Show a construction
of a ﬁxed-length hash function ( Gen,h) that is notcollision resistant,
but such that the hash function ( Gen,H) obtained from the Merkle–
Damg˚ ard transform to ( Gen,h) as in Construction 5.3 iscollision resis-
tant.
5.8 Prove or disprove: if ( Gen,h) is preimage resistant, then so is the hash
function ( Gen,H) obtained by applying the Merkle–Damg˚ ard transform
to (Gen,h) as in Construction 5.3.Hash Functions and Applications 191
5.9 Prove or disprove: if ( Gen,h) is second preimage resistant, then so is
the hash function ( Gen,H) obtained by applying the Merkle–Damg˚ ard
transform to ( Gen,h) as in Construction 5.3.
5.10 Before HMAC, it was common to deﬁne a MAC for arbitrary-length
messages by Macs,k(m) =Hs(k/bardblm) where His a collision-resistant
hash function.
(a) Show that this is never a secure MAC when His constructed via
the Merkle–Damg˚ ard transform. (Assume the hash key sis known
to the attacker, and only kis kept secret.)
(b) Provethatthis isasecureMACif Hismodeledasarandomoracle.
5.11 Prove that the construction of a pseudorandom function given in Sec-
tion 5.5.1 is secure in the random-oracle model.
5.12 Prove Theorem 5.11.
5.13 Show how to ﬁnd a collision in the Merkle tree construction if tis not
ﬁxed. Speciﬁcally, show how to ﬁnd two sets of inputs x1,...,x tand
x/prime
1,...,x/prime
2tsuch thatMTt(x1,...,x t) =MT2t(x/prime
1,...,x/prime
2t).
5.14 Consider the scenariointroduced in Section 5.6.2 in which a client stores
ﬁles on a server and wants to verify that ﬁles are returned unmodiﬁed.
(a) Provide a formal deﬁnition of security for this setting.
(b) Formalize the construction based on Merkle trees as discussed in
Section 5.6.2.
(c) Prove that your construction is secure relative to your deﬁnition
under the assumption that ( GenH,H) is collision resistant.
5.15 Prove that the commitment scheme discussed in Section 5.6.5 is secure
in the random-oracle model.Chapter 6
Practical Constructions of
Symmetric-Key Primitives
In previous chapters we have demonstrated how secure encryption schemes
and message authentication codes can be constructed from cryptographic
primitives such as pseudorandom generators, pseudorandom permutations,
and hash functions. One question we have not yet addressed, however, is
how these cryptographic primitives are constructed in the ﬁrst place, or even
whether they exist at all! In the next chapter we will study this question from
a theoretical vantage point, and show constructions of pseudorandom gener-
ators and pseudorandom permutations based on quite weak assumptions. (It
turns out that hash functions are more diﬃcult to construct, and appear to
require stronger assumptions. We will see a provably secure construction of
hash functions in Section 8.4.2.) In this chapter, our focus will be on compar-
atively heuristic, but far more eﬃcient, constructions of these primitives that
are widely used in practice.
As just mentioned, the constructions that we will explorein this chapter are
heuristic in the sense that they cannot be proven secure based on any weaker
assumption. These constructions are, however, based on a number of design
principles, some of which can be justiﬁed by theoretical analysis. Perhaps
more importantly, many of these constructions have withstood years of public
scrutiny and attempted cryptanalysis and, given this, it is quite reasonable to
assume the security of these constructions.
In some sense there is no fundamental diﬀerence between assuming, say,
that factoring is hard and assuming that AES (a block cipher we will study
in detail later in this chapter) is a pseudorandom permutation. There is,
however, a signiﬁcant qualitative diﬀerence between these assumptions.1The
primary diﬀerence is that the former assumption is more believable since it
seemingly relates to a weaker requirement: the assumption that large integers
arehardtofactorisarguablymorenaturalthantheassumptionthatAESwith
auniform keyisindistinguishablefrom arandompermutation. Otherrelevant
diﬀerences between the assumptions are that factoring has been studied much
longer than the problem of distinguishing AES from a random permutation,
1Itshould be clear that the discussion in this paragraph is informal, as we cannot formally
argue about any of this when we cannot even prove that factoring is hard in the ﬁrst place!
193194 Introduction to Modern Cryptography
and was recognized as a hard problem well before the advent of cryptographic
schemes based on it.
To summarize, it is reasonable to assume that the recommended construc-
tions described in this chapter are secure, and people are comfortable relying
on such assumptions in practice. Still, it would be preferable to base security
of cryptographic primitives on weaker and more long-standing assumptions.
As we will see in Chapter 7, this is (in principle) possible; unfortunately, the
constructions we will see there are orders of magnitude less eﬃcient than the
constructions described here, and as such are not useful in practice.
The Aim of This Chapter
The main aims ofthis chapter are(1) to presentsome design principles used
in the construction of modern cryptographic primitives, and (2) to introduce
the reader to some popular constructions used extensively in the real world.
We caution that:
•It isnotthe aim of this chapter to teach readers how to design new
cryptographic primitives. On the contrary, we believe that the design of
new primitives requires signiﬁcant expertise and eﬀort, and is not some-
thing to be attempted lightly. Those who are interested in developing
additional expertise in this area are advised to read the more advanced
references included at the end of the chapter.
•It isnotour intent to present all the low-level details of the various
primitives we discuss here, and our descriptions should not be relied
upon for implementation. In fact, our descriptions are sometimes pur-
posefully inaccurate, as we omit certain details that are not relevant to
the broader conceptual point we are trying to emphasize.
6.1 Stream Ciphers
Recall from Section 3.3.1 that a stream cipher is deﬁned by two determin-
istic algorithms ( Init,GetBits). TheInitalgorithm takes as input a key kand
an (optional) initialization vector IVand returns some initial state st. The
GetBitsalgorithm can be used to generate an inﬁnite stream of bits y1,y2,...
based on st. The main requirement of a stream cipher is that it should behave
likeapseudorandomgenerator,namely, when kischosenuniformlyatrandom
the resulting sequence y1,y2,...should be indistinguishable from a sequence
of uniform and independent bits by any computationally bounded attacker.
(InSection3.6.1wenotedthatstreamciphersmustsometimessatisfystronger
security requirements. We do not explicitly address this here.)Practical Constructions of Symmetric-Key Primitives 195
We have already pointed out (see the end of Section 3.5.1) that stream
ciphers can be constructed easily from block ciphers, which are a stronger
primitive. The primary motivation for using the dedicated stream-cipher
constructions introduced in this section is eﬃciency, especially in resource-
constrained environments (e.g., in hardware where there may be a desire to
keep the number of gates small). Attacks have been shown against several
recent constructions of stream ciphers, however, and their security appears
much more tenuous than is the case for block ciphers. We therefore recom-
mend using block ciphers (possibly in stream-cipher mode) when possible.
6.1.1 Linear-Feedback Shift Registers
We begin by discussing linear-feedback shift registers (LFSRs). These have
been used historically for pseudorandom-number generation, as they are ex-
tremely eﬃcient to implement in hardware, and generate output having good
statistical properties. By themselves, however, they do notgive cryptograph-
ically strong pseudorandom generators, and in fact we will show an easy key-
recovery attack on LFSRs. Nevertheless, LFSRs can be used as a component
in building stream ciphers with better security.
/MT115/MT50 /MT115/MT49 /MT115/MT48 /MT115/MT51
FIGURE 6.1 :Alinear-feedback shift register.
An LFSR consists of an array of nregisters sn−1,...,s 0along with a feed-
back loop speciﬁed by a set of nfeedback coeﬃcients cn−1,...,c 0. (See Fig-
ure 6.1.) The size of the array is called the degreeof the LFSR. Each register
stores a single bit, and the state stof the LFSR at any point in time is simply
the set of bits contained in the registers. The state of the LFSR is updated
in each of a series of “clock ticks” by shifting the values in all the registers
to the right, and setting the new value of the left-most register equal to the
XOR of some subset of the current registers, with the subset determined by
the feedback coeﬃcients. That is, if the state at some time tiss(t)
n−1,...,s(t)
0,
then the state after the next clock tick is s(t+1)
n−1,...,s(t+1)
0with
s(t+1)
i:=s(t)
i+1, i = 0,...,n−2
s(t+1)
n−1:=n−1/circleplusdisplay
i=0cis(t)
i.
Figure 6.1 shows a degree-4 LFSR with c0=c2= 1 and c1=c3= 0.196 Introduction to Modern Cryptography
At each clock tick, the LFSR outputs the value of the right-most register s0.
If the initial state of the LFSR is s(0)
n−1,...,s(0)
0, the ﬁrst nbits of the output
stream are exactly s(0)
0,...,s(0)
n−1. The next output bit is s(1)
n−1=/circleplustextn−1
i=0cis(0)
i.
If we denote the output bits by y1,y2,..., whereyi=s(i−1)
0, then
yi=s(0)
i−1, i= 1,...,n
yi=n−1/circleplusdisplay
j=0cjyi−n+j−1i > n.
As an example using the LFSR from Figure 6.1, if the initial state is
(0,0,1,1) then the states for the ﬁrst few time periods are
(0,0,1,1)
(1,0,0,1)
(1,1,0,0)
(1,1,1,0)
(1,1,1,1)
and the output (which can be read oﬀ the right-most column of the above) is
the stream of bits 1 ,1,0,0,1,....
The state of the LFSR consists of nbits; thus, the LFSR can cycle through
atmost2npossiblestatesbeforerepeating. Whenthestatesrepeattheoutput
bits repeat, andthis meansthatthe output sequencewill beginrepeatingafter
at most 2noutput bits have been generated. A maximum-length LFSR cycles
through all 2n−1 nonzero states before repeating. (Note that if the all-0
state is ever realized then the LFSR remains in that state forever, which is
why we exclude it.) Whether an LFSR is maximal length or not depends only
on the feedback coeﬃcients; if it is maximal length then, once it is initialized
in any nonzero state, it will cycle through all 2n−1 nonzero states. It is well
understood how to set the feedback coeﬃcients to obtain a maximal-length
LFSR, although the details are beyond the scope of this book.
Reconstruction attacks. Theoutputofamaximal-lengthLFSRofdegree n
has good statistical properties; for example, every n-bit string occurs with
roughly equal frequency in the output stream of the LFSR. Nevertheless,
LFSRs are not good pseudorandom generators for cryptographic purposes
becausetheiroutputispredictable. Thisfollowsfromthe factthatanattacker
can reconstruct the entire state of a degree- nLFSR after observing at most
2noutput bits. To see this, assume both the initial state and the feedback
coeﬃcients of some LFSR are unknown. The ﬁrst noutput bits y1,...,y n
of the LFSR exactly reveal the initial state. Given the next noutput bits
yn+1,...,y 2n, the attacker can set up a system of nlinear equations in the nPractical Constructions of Symmetric-Key Primitives 197
unknowns c0,...,c n−1:
yn+1=cn−1yn⊕···⊕c0y1
...
y2n=cn−1y2n−1⊕···⊕c0yn.
One can show that the above equations are linearly independent (modulo 2)
for a maximal-length LFSR, and so uniquely determine the feedback coeﬃ-
cients. (The solution can be found eﬃciently using linear algebra.) With the
feedback coeﬃcients known, all subsequent output bits of the LFSR can be
easily computed.
6.1.2 Adding Nonlinearity
The linear relationships between the outputs bits of an LFSR are exactly
what enable an easy attack. To thwart such attacks, we must introduce
some nonlinearity, i.e., some operations other than XORs. There are several
diﬀerent approaches to doing so, and we only explore some of them here.
Nonlinear feedback. One obvious way to modify LFSRs is to make the
feedback loop nonlinear. A nonlinear-feedback shift register (FSR) will again
consist of an array of registers, each containing a single bit. As before, the
state of the FSR is updated in each of a series of clock ticks by shifting the
values in all the registers to the right; now, however, the new value of the
left-most register is a nonlinear function of the current registers. In other
words, if the state at some time tiss(t)
0,...,s(t)
n−1then the state after the
next clock tick is s(t+1)
0,...,s(t+1)
n−1with
s(t+1)
i:=s(t)
i+1, i = 0,...,n−2
s(t+1)
n−1:=g(s(t)
0,...,s(t)
n−1)
for some nonlinear function g. As before, the FSR outputs the value of the
right-most register s0at each clock tick.
It is possible to design nonlinear FSRs with maximal length and such that
the output has good statistical properties.
Nonlinear combination generators. Another approach is to introduce
nonlinearity in the output sequence. In the most basic case, we could have
an LFSR as before (where the new value of the left-most register is again
computed as a linear function of the current registers), but where the output
at each clock tick is a nonlinear function gof all the current registers, rather
than just the right-most register. It is important here that gbebalanced in
the sense that Pr[ g(s0,...,s n−1) = 1]≈1/2 (where the probability is over
uniform choice of s0,...,s n−1); otherwise, although it might be diﬃcult to198 Introduction to Modern Cryptography
reconstruct the entire state of the LFSR based on the output, the output
stream will be biased and hence easily distinguishable from uniform.
A variant of the above is to use several LFSRs (with each individual output
stream computed, as before, by simply taking the value of the right-most
registerofeachLFSR),andtogeneratetheactualoutputstreambycombining
the output of the individual LFSRs in some nonlinear way. This yields what
is known as a (nonlinear) combination generator . The individual LFSRs need
not have the same degree, and in fact the cycle length of the combination
generator will be maximized if they do nothave the same degree. Here, care
must be taken to ensure that the output stream of the combination generator
is not too highly correlated with any of the output streams of the individual
LFSRs; high correlation can lead to attacks on the individual LFSRs, thereby
defeating the purpose of using several LFSRs in the construction.
6.1.3 Trivium
To illustrate the ideas from the previous section, we brieﬂy describe the
streamcipher Trivium. Thisstreamcipherwasselectedaspartoftheportfolio
of the eSTREAM project, a European eﬀort completed in 2008 whose goal
was to identify new stream ciphers. Trivium was designed to have a simple
description and to admit a compact hardware implementation.
/MT97/MT110/MT100
/MT97/MT110/MT100
/MT97/MT110/MT100
FIGURE 6.2 :Aschematic illustration of Trivium with (from top to
bottom) three coupled, nonlinear FSRs A,B, andC.
Trivium uses three coupled, nonlinear FSRs denoted by A,B, andCand
having degree 93, 84, and 111, respectively. (See Figure 6.2.) The state st
of Trivium is simply the 288 bits comprising the values in all the registersPractical Constructions of Symmetric-Key Primitives 199
of these FSRs. The GetBitsalgorithm for Trivium works as follows: At each
clock tick, the output of each FSR is the XOR of its right-most register and
one additional register; the output of Trivium is the XOR of the output bits
of the three FSRs. The FSRs are coupled: at each clock tick, the new value
of the left-most register of each FSR is computed as a function of one of the
registers in the same FSR and a subset of the registers from a second FSR.
(The feedback function for Adepends on one register of Aand four registers
ofC; the feedback function for Bdepends on one register of Band four
registers of A; and the feedback function for Cdepends on one register of C
and four registers of B.) The feedback function in each case is nonlinear.
TheInitalgorithm of Trivium accepts an 80-bit key and an 80-bit IV. The
key is loaded into the 80 left-most registers of A, and the IVis loaded into
the 80 left-most registers of B. The remaining registers are set to 0, except
for the three right-most registers of C, which are set to 1. Then GetBitsis run
4·288 times (with output discarded), and the resulting state is taken as st0.
To date, no cryptanalytic attacks better than exhaustive key search are
known against the full Trivium cipher.
6.1.4 RC4
LFSRs are eﬃcient when implemented in hardware, but have poor perfor-
mance in software. For this reason, alternate designs of stream ciphers have
been explored. A prominent example is RC4, which was designed by Ron
Rivest in 1987. RC4 is remarkable for its speed and simplicity, and resisted
serious attack for several years. It is widely used today, and we discuss it for
this reason; we caution the reader, however, that recent attacks have shown
serious cryptographic weaknesses in RC4 and it should no longer be used.
ALGORITHM 6.1
Initalgorithm for RC4
Input:16-byte key k
Output: Initial state ( S,i,j)
(Note: All addition is done modulo 256)
fori= 0 to 255:
S[i] :=i
k[i] :=k[imod 16]
j:= 0
fori= 0 to 255:
j:=j+S[i]+k[i]
SwapS[i] andS[j]
i:= 0, j:= 0
return(S,i,j)
ThestateofRC4isa256-bytearray S,whichalwayscontainsapermutation
of the elements 0 ,...,255, along with two values i,j∈{0,...,255}. TheInit200 Introduction to Modern Cryptography
algorithm for RC4 is presented as Algorithm 6.1. For simplicity we assume
a 16-byte (128-bit) key k, although the algorithm can handle keys between
1 byte and 256 bytes long. We index the bytes of SasS[0],...,S[255], and
the bytes of the key as k[0],...,k[15].
During initialization, Sis ﬁrst set to the identity permutation (i.e., with
S[i] =iforalli)andkisexpandedto256bytesbyrepetition. Theneachentry
ofSis swapped at least once with another entry of Sin a “pseudorandom”
location. The indices i,jare set to 0, and ( S,i,j) is output as the initial state.
The state is then used to generate a sequence of output bits, as shown in
Algorithm 6.2. The index iis simply incremented (modulo 256), and jis
changed in some “pseudorandom” way. Entries S[i] andS[j] are swapped,
and the value of Sat position S[i] +S[j] (again computed modulo 256) is
output. Note that each entry of Sis swapped with some other entry of S
(possibly itself) at least once every 256 iterations, ensuring good “mixing” of
the permutation S.
ALGORITHM 6.2
GetBitsalgorithm for RC4
Input:Current state ( S,i,j)
Output: Output byte y; updated state ( S,i,j)
(Note: All addition is done modulo 256)
i:=i+1
j:=j+S[i]
SwapS[i] andS[j]
t:=S[i]+S[j]
y:=S[t]
return(S,i,j),y
RC4 was not designed to take an IVas input; however, in practice an IV
is often incorporated by simply concatenating it with the actual key k/primebefore
initialization. That is, a random IVof the desired length is chosen, kis set
to be equal to the concatenation of IVandk/prime(this can be done by either
prepending or appending IV), and then Initis run as in Algorithm 6.1 to
generate an initial state. Output bits are then produced using Algorithm 6.2
exactly as before. Assuming RC4 is being used in unsynchronized mode (see
Section 3.6.1), the IVwould then be sent in the clear to the receiver—who
presumably alreadyhas the actual key k/prime—thus enabling them to generatethe
same initial state and hence the same output stream. This method of incor-
porating an IVis used in the Wired Equivalent Privacy (WEP) encryption
standard for protecting communications in 802.11 wireless networks.
One should be concerned by this relatively ad hoc way of modifying RC4
to accept an IV. Even if RC4 were a secure stream cipher when using (only)
a key as originally designed, there is no reason to believe that it should bePractical Constructions of Symmetric-Key Primitives 201
secure when modiﬁed to use an IVin this way. Indeed, contrary to the key,
theIVis revealed to an attacker (since it is sent in the clear); furthermore,
using diﬀerent IVs with the same ﬁxed key k/prime—as would be done when using
RC4 in unsynchronized mode—means that relatedvalueskare being used to
initialize the state of RC4. As we will see below, both of these issues lead to
attacks when RC4 is used in this fashion.
Attacks on RC4. Although RC4 is pervasive in modern systems, various
attackson RC4havebeen knownforseveralyears. Due tothis, RC4shouldno
longer be used; instead, a more modern stream cipher or block cipher should
be used in its place.
We begin by demonstrating a simple statistical attack on RC4 that does
not rely on the honest parties’ using an IV. The attack exploits the fact that
the second output byte of RC4 is (slightly) biasedtoward0. Let Stdenote the
state of the array Saftertiterations of GetBits, withS0denoting the initial
state. Treating S0(heuristically) as a uniform permutation of {0,...,255},
with probability 1 /256·(1−1/255)≈1/256, it holds that S0[2] = 0 and
Xdef=S0[1]/negationslash= 2. Assume for a moment that this is the case. In the ﬁrst
iteration of GetBits, the value of iis incremented to 1, and jis set equal to
S0[i] =S0[1] =X. ThenS0[1] andS0[X] are swapped, so that at the end
of the iteration we have S1[X] =S0[1] =X. In the second iteration, iis
incremented to 2 and jis assigned the value
j+S1[i] =X+S1[2] =X+S0[2] =X,
sinceS0[2] = 0. Then S1[2] andS1[X] are swapped, so that S2[X] =S1[2] =
S0[2] = 0 and S2[2] =S1[X] =X. Finally, the value of S2at position
S2[i]+S2[j] =S2[2]+S2[X] =Xisoutput; this isexactlythe value S2[X] = 0.
WhenS0[2]/negationslash= 0 the second output byte is uniformly distributed. Overall,
then, the probability that the second output byte is 0 is
Pr[S0[2] = 0 and S0[1]/negationslash= 2]+1
256·/parenleftBig
1−Pr[S0[2] = 0 and S0[1]/negationslash= 2]/parenrightBig
=1
256+1
256·/parenleftbigg
1−1
256/parenrightbigg
≈2
256,
ortwice what would be expected for a uniform value.
By itself the above might not be viewed as a particularly serious attack,
although it does seem to indicate underlying structural problems with RC4.
A more serious attack against RC4 is possible when an IVis incorporated by
prepending it to the key. This attack can used to recover the key, regardless
of its length, and is thus more serious than a distinguishing attack such as
the one described above. Importantly, this attack can be used to completely
break the WEP encryption standard mentioned earlier, and was inﬂuential in
getting the standard replaced.
The core of the attack is a way to extend knowledge of the ﬁrst nbytes
ofkto knowledge of the ﬁrst ( n+ 1) bytes of k. Note that when an IVis202 Introduction to Modern Cryptography
prepended to the actual key k/prime(sok=IV/bardblk/prime), the ﬁrst few bytes of kare
given to the attacker for free! If the IVisnbytes long, then the adversary
can use this attack to ﬁrst recover the ( n+1)st byte of k(which is the ﬁrst
byte of the real key k/prime), then the next byte of k, and so on, until it deduces
the entire key.
Assume the IVis 3 bytes long, as is the case for WEP. The attacker waits
until the ﬁrst two bytes of the IVhave a speciﬁc form. The attack can be
carried out with several possibilities for the ﬁrst two bytes of the IV, but
we look at the case where the IVtakes the form IV= (3,255,X) forXan
arbitrary byte. This means, of course, that k[0] = 3,k[1] = 255, and k[2] =X
in Algorithm 6.1. One can check that after the ﬁrst four iterations of the
second loop of Init, we have
S[0] = 3, S[1] = 0, S[3] =X+6+k[3]. (6.1)
In the next 252 iterations of the Initalgorithm, iis always greater than 3. So
the values of S[0],S[1], andS[3] are not subsequently modiﬁed as long as j
never takes on the values 0, 1, or 3. If we (heuristically) treat jas taking
on a uniform value in each iteration, this means that S[0],S[1], andS[3] are
not subsequently modiﬁed with probability (253 /256)252≈0.05, or 5% of
the time. Assuming this is the case, the ﬁrst byte output by GetBitswill be
S[3] =X+6+k[3]; since Xis known, this reveals k[3].
So, the attacker knows that 5% of the time the ﬁrst byte of the output is
correlated with k[3] as described above. (This is much better than random
guessing, which is correct 1 /256 = 0.4% of the time.) Thus, by collecting
suﬃciently many samples of the ﬁrst byte of the output—for several IVs
having the correctform—the attackergets a high-conﬁdence estimate for k[3].
6.2 Block Ciphers
Recall from Section 3.5.1 that a block cipher is an eﬃcient, keyed permu-
tationF:{0,1}n×{0,1}/lscript→{0,1}/lscript. This means the function Fkdeﬁned by
Fk(x)def=F(k,x) is a bijection (i.e., a permutation), and moreover Fkand its
inverseF−1
kare eﬃciently computable given k. We refer to nas thekey length
and/lscriptas theblock length ofF, and here we explicitly allow them to diﬀer. The
key length and block length are now ﬁxed constants, whereas in Chapter 3
they were viewed as functions of a security parameter. This puts us in the
setting of concrete security rather than asymptotic security.2The concrete
2Although a block cipher with ﬁxed key length has no “security parameter” to speak of, we
still view security as depending on the length of the key and thus denote this value by n.Practical Constructions of Symmetric-Key Primitives 203
security requirements for block ciphers are quite stringent, and a block cipher
is generally only considered “good” if the best known attack (without pre-
processing) has time complexity roughly equivalent to a brute-force search for
the key. Thus, if a cipher with key length n= 256 can be broken in time 2128,
the cipher is (generally) considered insecure even though a 2128-time attack is
still infeasible. In contrast, in an asymptotic setting an attack of complexity
2n/2is not considered eﬃcient since it requires exponential time (and thus a
cipher where such an attack is possible might still satisfy the deﬁnition of be-
ing a pseudorandom permutation). In the concrete setting, however, we must
worry about the actual complexity of the attack (rather than its asymptotic
behavior). Furthermore, there is a concern that existence of such an attack
may indicate some more fundamental weakness in the design of the cipher.
Block ciphers are designed to behave, at a minimum, as (strong) pseudo-
random permutations; see Deﬁnition 3.28. Modeling block ciphers as pseu-
dorandom permutations allows proofs of security for constructions based on
block ciphers, and also makes explicit the necessary requirements of a block
cipher. A solid understanding of what block ciphers are supposed to achieveis
instrumental in their design. The view that block ciphers should be modeled
as pseudorandom permutations has, at least in the recent past, served as a
major inﬂuence in their design. As an example, the call for proposals for the
recent Advanced Encryption Standard (AES) that we will encounter later in
this chapter stated the following evaluation criterion:
The security provided by an algorithm is the most important fac-
tor.... Algorithms will be judged on the following factors...
•The extent to which the algorithm output is indistinguishable
from a random permutation ...
Modern block ciphers are suitable for all the constructions using pseudoran-
dom permutations (or pseudorandom functions) we have seen in this book.
Often, block ciphers are designed (and assumed) to satisfy even stronger
security properties, as we discuss brieﬂy in Section 6.3.1.
Notwithstanding the fact that block ciphers are not, on their own, encryp-
tion schemes, the standard terminology for attacks on a block cipher Fis:
•In aknown-plaintext attack , the attackerisgiven pairsofinputs/outputs
{(xi,Fk(xi))}(for an unknown key k), with the{xi}outside the at-
tacker’s control.
•In achosen-plaintext attack , the attacker is given {Fk(xi)}(again, for
an unknown key k) for a series of inputs {xi}chosen by the attacker.
•In achosen-ciphertext attack , the attacker is given {Fk(xi)}for{xi}
chosen by the attacker, as well as {F−1
k(yi)}for chosen{yi}.
Viewing the key length as a parameter makes sense when comparing block ciphers with
diﬀerent key lengths, or when using a block cipher that supports keys of diﬀerent lengths.204 Introduction to Modern Cryptography
Besides using the above to distinguish Fkfrom a uniform permutation, we
will also be interested in key-recovery attacks in which the attacker is able to
recover the key kafter interacting with Fk. (This is stronger than being able
to distinguish Fkfrom uniform.)
With respect to this taxonomy, a pseudorandom permutation cannot be
distinguished from a uniform permutation under a chosen-plaintext attack,
while a strong pseudorandom permutation cannot be so distinguished even
under a chosen-ciphertext attack.
6.2.1 Substitution-Permutation Networks
A block cipher must behave like a random permutation. There are 2/lscript!
permutations on /lscript-bit strings, so representing an arbitrary permutation with
an/lscript-bit block length requires log(2/lscript!)≈/lscript·2/lscriptbits. This is impractical for
/lscript >20 and infeasible for /lscript >50. (Looking ahead, modern block ciphers have
block lengths /lscript≥128.) The challenge when designing a block cipher is to
construct a set of permutations with a concisedescription (namely, a short
key) that behaveslike a randompermutation. In particular, just asevaluating
a random permutation at two inputs that diﬀer in only a single bit should
yield two (almost) independent outputs (they are not completely independent
since they cannot be equal), so too changing one bit of the input to Fk(·),
wherekis uniform and unknown to an attacker, should yield an (almost)
independent result. This implies that a one-bit change in the input should
“aﬀect” every bit of the output. (Note that this does not mean that all the
output bits will be changed—that would be diﬀerent behavior than one would
expect for a random permutation. Rather, we just mean informally that each
bit of the output is changed with probability roughly half.) This takes some
work to achieve.
The confusion-diﬀusion paradigm. In addition to his work on perfect se-
crecy, Shannon also introduced a basic paradigm for constructing concise,
random-looking permutations. The basic idea is to construct a random-
looking permutation Fwith a large block length from many smaller random
(or random-looking) permutations {fi}with small block length. Let us see
how this works on the most basic level. Say we want Fto have a block length
of 128 bits. We can deﬁne Fas follows: the key kforFwill specify 16 per-
mutations f1,...,f 16that each have an 8-bit (1-byte) block length.3Given
an input x∈{0,1}128, we parse it as 16 bytes x1···x16and then set
Fk(x) =f1(x1)/bardbl···/bardblf16(x16). (6.2)
These round functions {fi}are said to introduce confusion intoF.
3Anarbitrary permutation on 8 bits can be represented using log(28!)≈1600 bits, so the
length of the key for Fis about 16 ·1600 bits, or 3 kbytes. This is much smaller than the
≈128·2128bits that would be required to specify an arbitrary permutation on 128 bits.Practical Constructions of Symmetric-Key Primitives 205
It should be immediately clear, however, that Fas deﬁned above will not
be pseudorandom. Speciﬁcally, if xandx/primediﬀer only in their ﬁrst bit then
Fk(x) andFk(x/prime) will diﬀer only in their ﬁrst byte (regardless of the key k).
In contrast, if Fwere a truly random permutation then changing the ﬁrst bit
of the input would be expected to aﬀect all bytes of the output.
Forthis reason, a diﬀusion stepis introducedwherebythe bits ofthe output
are permuted, or “mixed,” using a mixing permutation . This has the eﬀect of
spreadingalocal change(e.g., achangein the ﬁrst byte) throughoutthe entire
block. The confusion/diﬀusion steps—together called a round—are repeated
multiple times. This helps ensure that changing a single bit of the input will
aﬀect all the bits of the output.
As an example, a two-round block cipher following this approach would
operate as follows. First, confusion is introduced by computing the interme-
diate result f1(x1)/bardbl···/bardblf16(x16) as in Equation (6.2). The bits of the result
are then “shuﬄed,” or re-ordered, to give x/prime. Thenf/prime
1(x/prime
1)/bardbl···/bardblf/prime
16(x/prime
16) is
computed (where x/prime=x/prime
1···x/prime
16), using possibly diﬀerent functions f/prime
i, and
the bits of the result are permuted to give output x/prime/prime. The{fi},{f/prime
i}, and
the mixing permutation(s) could be random and dependent on the key, as we
have described above. In practice, however, they are specially designed and
ﬁxed, and the key is incorporated in a diﬀerent way, as we will describe below.
Substitution-permutation networks. A substitution-permutation net-
work (SPN) can be viewed as a direct implementation of the confusion-
diﬀusion paradigm. The diﬀerence is that now the round functions have a
particular form rather than being chosen from the set of all possible permu-
tations on some domain. Speciﬁcally, rather than having (a portion of) the
keykspecify an arbitrary permutation f, we instead ﬁx a public “substitu-
tion function” (i.e., permutation) Scalled an S-box, and then let kdeﬁne the
function fgiven by f(x) =S(k⊕x).
Toseehowthisworksconcretely,consideranSPNwitha64-bitblocklength
based on a collection of 8-bit (1-byte) S-boxesS1,...,S 8. (See Figure 6.3.)
Evaluating the cipher proceeds in a series of rounds, where in each round we
apply the following sequence of operations to the 64-bit input xof that round
(the input to the ﬁrst round is just the input to the cipher):
1.Key mixing: Setx:=x⊕k, wherekis the current-round sub-key;
2.Substitution: Setx:=S1(x1)/bardbl···/bardblS8(x8), where xiis theith byte of x;
3.Permutation: Permute the bits of xto obtain the output of the round.
The output of each round is fed as input to the next round. After the last
round there is a ﬁnal key-mixing step , and the result is the output of the
cipher. (By Kerckhoﬀs’ principle, we assume the S-boxes and the mixing per-
mutation(s) are public and known to any attacker. This means that without a
ﬁnal key-mixing step, the last substitution and permutation steps would oﬀer
no additional security since they do not depend on the key.) Figure 6.4 shows206 Introduction to Modern Cryptography
/MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115
/MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115 /MT56/MT32/MT98/MT105/MT116/MT115/MT83/MT49 /MT83/MT50 /MT83/MT51 /MT83/MT52 /MT83/MT53 /MT83/MT54 /MT83/MT55 /MT83/MT56/MT54/MT52/MT45/MT98/MT105/MT116/MT32/MT105/MT110/MT116/MT101/MT114/MT109/MT101/MT100/MT105/MT97/MT116/MT101
/MT54/MT52/MT45/MT98/MT105/MT116/MT32/MT105/MT110/MT116/MT101/MT114/MT109/MT101/MT100/MT105/MT97/MT116/MT101
/MT54/MT52/MT45/MT98/MT105/MT116/MT32/MT111/MT117/MT116/MT112/MT117/MT116/MT54/MT52/MT45/MT98/MT105/MT116/MT32/MT105/MT110/MT112/MT117/MT116
/MT54/MT52/MT45/MT98/MT105/MT116/MT32/MT115/MT117/MT98/MT45/MT107/MT101/MT121
FIGURE 6.3 :Asingle round of a substitution-permutation network.
the high-level structure of an SPN with a 16-bit block length and a diﬀerent
set of 4-bit S-boxes used in each round.
Diﬀerent sub-keys (orround keys ) are used in each round. The actual key
of the block cipher is sometimes called the master key . The round sub-keys
are derived from the master key accordingto a key schedule . The key schedule
is often simple and may work by just taking diﬀerent subsets of the bits of the
master key, although more complex schedules can also be deﬁned. An r-round
SPN has r(full) rounds of key mixing, S-box substitution, and application of
a mixing permutation, followed by a ﬁnal key-mixing step. (This means that
in anr-round SPN, r+1 sub-keys are used.)
Any SPN is invertible (given the key). To see this, we show that given the
output of the SPN and the key it is possible to recoverthe input. It suﬃces to
show that a single round can be inverted; this implies the entire SPN can be
inverted by workingfrom the ﬁnal round back to the beginning. But inverting
a single round is easy: the mixing permutation can easily be inverted since
it is just a re-ordering of bits. Since the S-boxes are permutations (i.e., one-
to-one), these too can be inverted. The result can then be XORed with the
appropriate sub-key to obtain the original input. Therefore:
PROPOSITION 6.3 LetFbe a keyed function deﬁned by an SPN in
which the S-boxes are all permutations. Then regardless of the key schedule
and the number of rounds, Fkis a permutation for any k.Practical Constructions of Symmetric-Key Primitives 207
/MT120/MT49
/MT114/MT111/MT117/MT110/MT100/MT32/MT49/MT120/MT49/MT54
/MT114/MT111/MT117/MT110/MT100/MT32/MT50
/MT114/MT111/MT117/MT110/MT100/MT32/MT51/MT83/MT49 /MT83/MT50 /MT83/MT51 /MT83/MT52
/MT83/MT53 /MT83/MT54 /MT83/MT55 /MT83/MT56
/MT83/MT57 /MT83/MT49/MT48 /MT83/MT49/MT49 /MT83/MT49/MT50/MT105/MT110/MT112/MT117/MT116
/MT115/MT117/MT98/MT45/MT107/MT101/MT121/MT32 /MT107/MT49/MT32/MT109/MT105/MT120/MT105/MT110/MT103
/MT115/MT117/MT98/MT45/MT107/MT101/MT121/MT32 /MT107/MT50/MT32/MT109/MT105/MT120/MT105/MT110/MT103
/MT115/MT117/MT98/MT45/MT107/MT101/MT121/MT32 /MT107/MT51/MT32/MT109/MT105/MT120/MT105/MT110/MT103
FIGURE 6.4 :Asubstitution-permutation network.
The number of rounds, along with the exact choices of the S-boxes, mixing
permutations, and key schedule, are what ultimately determine whether a
given block cipher is trivially breakable or highly secure. We now discuss a
basic principle behind the design of the S-boxes and mixing permutations.
The avalanche eﬀect. As noted repeatedly, an important property in any
block cipher is that a small change in the input must “aﬀect” every bit of
the output. We refer to this as the avalanche eﬀect . One way to induce the
avalanche eﬀect in a substitution-permutation network is to ensure that the
following two properties hold (and suﬃciently many rounds are used):
1. TheS-boxes are designed so that changing a single bit of the input to
anS-box changes at least two bitsin the output of the S-box.
2. The mixing permutations are designed so that the output bits of any
givenS-box are used as input to multiple S-boxes in the next round.208 Introduction to Modern Cryptography
To see how this yields the avalanche eﬀect, at least heuristically, assume that
theS-boxes are all such that changing a single bit of the input of the S-box
results in a change in exactly two bits of the output of the S-box, and that the
mixing permutations are chosen as required above. For concreteness, assume
theS-boxes have input/output size of 8 bits, and that the block length of
the cipher is 128 bits. Consider now what happens when the block cipher is
applied to two inputs that diﬀer in a single bit:
1. After the ﬁrst round, the intermediate values diﬀer in exactly two bit-
positions. This is because XORing the current sub-key maintains the
1-bit diﬀerence in the intermediate values, and sothe inputs to all the S-
boxes except one are identical. In the one S-box where the inputs diﬀer,
the output of the S-box causes a 2-bit diﬀerence. The mixing permu-
tation applied to the results changes the positions of these diﬀerences,
but maintains a 2-bit diﬀerence.
2. Themixingpermutationappliedatthe endoftheﬁrstroundspreadsthe
two bit-positions where the intermediate results diﬀer into two diﬀerent
S-boxes in the second round. This remains true even after the appropri-
ate sub-key is XORed with the result of the previous round. So, in the
second round there are now twoS-boxes that receive inputs diﬀering
by a single bit. Thus, at the end of the second round the intermediate
values diﬀer in 4 bits.
3. Continuing the same argument, we expect 8 bits of the intermediate
value to be aﬀected after the 3rd round, 16 bits to be aﬀected after the
4th round, and all 128 bits of the output to be aﬀected at the end of
the 7th round.
The last point is not quite precise and it is certainly possible that there will be
fewer diﬀerences than expected at the end of some round. (In fact, this must
be the case because the outputs should not diﬀer in all their bits, either.) For
this reason, it is customary to use many more than 7 rounds. However, the
above analysis gives a lower bound on the number of rounds: if fewer than
7 rounds are used then there must be some set of output bits that are not
aﬀected by a single-bit change in the input, implying that it will be possible
to distinguish the cipher from a random permutation.
One might expect that the “best”wayto design S-boxeswould be to choose
them at random (subject to the restriction that they are permutations). In-
terestingly, this turns out not to be the case, at least if we want to satisfy the
design criterion mentioned earlier. Consider the case of an S-box operating
on 4-bit inputs and let xandx/primebe two distinct values. Let y=S(x), and
now consider choosing uniform y/prime/negationslash=yas the value of S(x/prime). There are 4
strings that diﬀer from yin only 1 bit, and so with probability 4 /15 we will
choosey/primethat does notdiﬀer from yin two or more bits. The problem is
compounded when we consider all pairs of inputs that diﬀer in a single bit.Practical Constructions of Symmetric-Key Primitives 209
We conclude based on this example that, as a general rule, the S-boxes must
be designed carefully rather than being chosen blindly at random. Random
S-boxes are also not good for defending against attacks like the ones we will
show in Section 6.2.6.
If a block cipher should also be strongly pseudorandom, then the avalanche
eﬀect must also apply to its inverse. That is, changing a single bit of the
output should aﬀect every bit of the input. For this it is useful if the S-boxes
are designed so that changing a single bit of the output of an S-box changes
at least two bits of the input to the S-box. Achieving the avalanche eﬀect in
both directions is another reason for further increasing the number of rounds.
Attacking Reduced-Round SPNs
Experience, along with many years of cryptanalytic eﬀort, indicate that
substitution-permutation networks are a good choice for constructing pseu-
dorandom permutations as long as care is taken in the choice of the S-boxes,
the mixing permutations, and the key schedule. The Advanced Encryption
Standard, describedinSection6.2.5,issimilarinstructuretothesubstitution-
permutation network described above, and is widely believed to be a strong
pseudorandom permutation.
The strength of a cipher Fconstructed in this way depends heavily on the
number of rounds. In order to obtain more of an insight into substitution-
permutation networks, we will demonstrate attacks on SPNs having very few
rounds. These attacks are straightforward, but are worth seeing as they
demonstrate conclusively why a large number of rounds is needed.
A trivial case. We ﬁrst consider a trivial case where Fconsists of one full
round and no ﬁnal key-mixing step. We show that an adversary given only
asingleinput/output pair ( x,y) can easily learn the secret key kfor which
y=Fk(x). The adversarybegins with the output value yand then inverts the
mixing permutation and the S-boxes. It can do this, as noted before, because
the full speciﬁcationofthemixingpermutationandthe S-boxesispublic. The
intermediate value that the adversary computes is exactly x⊕k(assuming,
without loss of generality, that the master key is used as the sub-key in the
only round of the network). Since the adversary also knows the input x, it
can immediately derive the secret key k. This is therefore a complete break.
Although this is a trivial attack, it demonstrates that in any substitution-
permutation network there is no security gained by performing S-box substi-
tution or applying a mixing permutation after the ﬁnal sub-key mixing.
Attacking a one-round SPN. Now we have one full round followed by a
key-mixing step. For concreteness, we assume a 64-bit block length and S-
boxes with 8-bit (1-byte) input/output length. We assume independent 64-bit
sub-keys k1,k2are used for the two key-mixing steps, and so the master key
k1/bardblk2of the SPN is 128 bits long.210 Introduction to Modern Cryptography
A ﬁrst observation is that we can extend the attack from the trivial case
above to give a key-recovery attack here using much less than 2128work.
The idea is as follows: Given a single input/output pair ( x,y) as before, the
attacker enumerates over all possible values for the second-round sub-key k2.
For each such value, the attacker can invert the ﬁnal key-mixing step to get
a candidate intermediate value y/prime. We have seen above that given an input x
and an output y/primeof a (full) SPN round, a unique possible sub-key k1can be
easily identiﬁed. Thus, for each possible choice of k2the attacker derives a
unique corresponding k1for which k1/bardblk2can be the master key. In this way,
the attacker obtains (in 264time) a list of 264possibilities for the master key.
These can be narrowed down using additional input/output pairs in roughly
264additional time; see also below.
A better attack is possible by noting that individual bits of the output
depend on only part of the master key. Fix some given input/output pair
(x,y) as before. Now, the adversary will enumerate over all possible values
for theﬁrst byte ofk2. It can XOR each such value with the ﬁrst byte of y
to obtain a candidate value for the output of the ﬁrst S-box. Inverting this
S-box, the attackerlearnsa candidatevalue for the inputto thatS-box. Since
the input to that S-box is the XOR of 8 bits of xand 8 bits of k1(where the
positions of those bits depend on the ﬁrst-round mixing permutation and are
known to the attacker), this yields a candidate value for 8 bits of k1.
To summarize: for each candidate value of the ﬁrst byte of k2, there is a
uniquepossible corresponding value for some 8 bits of k1. Put diﬀerently,
this means that for some 16 bits of the master key, the attacker has reduced
the number of possible values for those bits from 216to 28. The attacker can
tabulateallthosefeasiblevaluesin 28time. Thiscanberepeatedforeachbyte
ofk2, giving8 lists—each containing28values—that togethercharacterizethe
possible values of the entire master key. The attacker has thus reduced the
number of possible master keys to (28)8= 264, as in the earlier attack. The
total time to do this, however, is now 8 ·28= 211, a dramatic improvement.
The attacker can use additional input/output pairs to further reduce the
space of possible keys. Consider the list of 28feasible values for some set of
16 bits of the master key. The attackerknows that the correct value from that
list must be consistent with any additional input/output pairs the attacker
learns. Heuristically, any incorrect value from the list is consistent with some
additional input/output pair ( x/prime,y/prime) with probability no better than random
guessing; since each 16-bit value from the table can be used to compute 1 byte
of the output given the input x/prime, we expect that an incorrect value will be
consistent with the actual output y/primewith probability 2−8. A small number of
additional input/output pairs will thus suﬃce to narrow down allthe tables
to just a single value each, at which point the entire master key is known.
There is an important lesson to be learned here. The attack is possible
since diﬀerent parts of the key can be isolated from other parts. Thus, further
diﬀusion is needed to make sure that all the bits of the key aﬀect all of the
bits of the output. Multiple rounds are needed for this to take place.Practical Constructions of Symmetric-Key Primitives 211
Attacking a two-round SPN. It is possible to extend the above ideas to
give a better-than-brute-force attack on a two-round SPN using independent
sub-keys in each round; we leave this as an exercise.
Instead, we simply note that a two-round SPN will not be a good pseudo-
random permutation. Here we rely on the fact, mentioned earlier, that the
avalanche eﬀect does not occur after only two rounds (of course, this depends
on the block length of the cipher and the input/output length of the S-boxes,
but with reasonable parameters this will be the case). An attacker can distin-
guish a two-round SPN from a uniform permutation if it learns the result of
evaluating the SPN on two inputs that diﬀer in a single bit: in a two-round
SPN many bits of the two outputs will be the same, something not expected
to occur for a random permutation.)
6.2.2 Feistel Networks
Feistel networks oﬀer another approach for constructing block ciphers. An
advantage of Feistel networks over substitution-permutation networks is that
the underlying functions used in a Feistel network—in contrastto the S-boxes
used in SPNs—need not be invertible. A Feistel network thus gives a way to
construct an invertible function from non-invertible components. This is im-
portant because a good block cipher should have “unstructured” behavior (so
it looks random), yet requiring all the components of a construction to be
invertible inherently introduces structure. Requiring invertibility also intro-
duces an additional constraint on S-boxes, making them harder to design.
A Feistel network operates in a series of rounds. In each round, a keyed
round function is applied in the manner described below. Round functions
need not be invertible. They will typically be constructed from components
likeS-boxes and mixing permutations, but a Feistel network can deal with
anyround functions irrespective of their design.
In a balancedFeistel network(the only type we will consider), the ith round
function ˆfitakes as input a sub-key kiand an/lscript/2-bit string and outputs an
/lscript/2-bit string. As in the case of SPNs, a master key kis used to derive sub-
keys for each round. When some master key is chosen, thereby determining
each sub-key ki, we deﬁne fi:{0,1}/lscript/2→{0,1}/lscript/2viafi(R)def=ˆfi(ki,R).
Note that the round functions ˆfiare ﬁxed and publicly known, but the fi
depend on the master key and so are not known to the attacker.
Theith round of a Feistel network operates as follows. The input to the
roundisdividedintotwohalvesdenoted Li−1andRi−1(the “left”and“right”
halves, respectively). If the block length of the cipher is /lscriptbits, then Li−1and
Ri−1each has length /lscript/2. The output ( Li,Ri) of the round is
Li:=Ri−1andRi:=Li−1⊕fi(Ri−1). (6.3)
In anr-round Feistel network, the /lscript-bit input to the network is parsed as
(L0,R0), and the output is the /lscript-bit value ( Lr,Rr) obtained after applying
allrrounds. A three-round Feistel network is shown in Figure 6.5.212 Introduction to Modern Cryptography
/MT76/MT50/MT102/MT49
/MT76/MT51 /MT82/MT51/MT82/MT50/MT102/MT50
/MT102/MT51/MT76/MT49 /MT82/MT49/MT76/MT48 /MT82/MT48
FIGURE 6.5 :Athree-round Feistel network.
Inverting a Feistel network. A Feistel network is invertible regardless of
the{fi}(and thus regardless of the round functions {ˆfi}). To show this we
need only show that each round of the network can be inverted if the {fi}
are known. Given the output ( Li,Ri) of the ith round, we can compute
(Li−1,Ri−1) as follows: ﬁrst set Ri−1:=Li. Then compute
Li−1:=Ri⊕fi(Ri−1).
This gives the value ( Li−1,Ri−1) that was the input of this round (i.e., it
computes the inverse of Equation (6.3)). Note that fiis evaluated only in the
forward direction, so it need not be invertible. We thus have:
PROPOSITION 6.4 LetFbe a keyed function deﬁned by a Feistel net-
work. Then regardless of the round functions {ˆfi}and the number of rounds,
Fkis an eﬃciently invertible permutation for all k.
As in the case of substitution-permutation networks, attacks on Feistel net-
works are possible when the number of rounds is too low. We will see such
attacks when we discuss DES in the next section. Theoretical results concern-
ing the security of Feistel networks are discussed in Section 7.6.
6.2.3 DES – The Data Encryption Standard
The Data Encryption Standard, or DES, was developed in the 1970s by
IBM (with help from the National Security Agency) and adopted in 1977 asPractical Constructions of Symmetric-Key Primitives 213
a Federal Information Processing Standard for the US. In its basic form, DES
is no longer considered secure due to its short key length of 56 bits, which
makes it vulnerable to brute-force attacks. Nevertheless, it remains in wide
use today in the strengthened form of triple-DES, described in Section 6.2.4.
DES is of great historical signiﬁcance. It has undergone intensive scrutiny
within the cryptographic community, arguably more than any other crypto-
graphic algorithm in history. The common consensus is that, apart from its
keylength, DESisanextremelywell-designedcipher. Indeed, evenaftermany
years, the best known attack on DES in practice is an exhaustive search over
all 256possible keys. (As we will see, there are important theoretical attacks
on DES that require less computation; however, these attacks assume certain
conditions that seem diﬃcult to realize in practice.)
In this section, we provide a high-level overview of the main components of
DES. We stress that we will not provide a full speciﬁcation that is correct in
everydetail, andsomepartsofthe designwillbeomittedfromourdescription.
Our aim is to present the basic ideas underlying the construction of DES, and
not all the low-level details; the reader interested in such details can consult
the references at the end of this chapter.
The Design of DES
The DES block cipher is a 16-round Feistel network with a block length of
64 bits and a key length of 56 bits. The same round function ˆfis used in each
of the 16 rounds. The round function takes a 48-bit sub-key and, as expected
for a (balanced) Feistel network, a 32-bit input (namely, half a block). The
key schedule of DES is used to derive a sequence of 48-bit sub-keys k1,...,k 16
from the 56-bit master key. The key schedule of DES is relatively simple,
with each sub-key kibeing a permuted subset of 48 bits of the master key.
For our purposes, it suﬃces to note that the 56 bits of the master key are
divided into two halves—a “left half” and a “right half”—each containing 28
bits. (This division occurs after an initial permutation is applied to the key,
but we ignore this in our description.) In each round, the left-most 24 bits
of the sub-key are taken as some subset of the 28 bits in the left half of the
master key, and the right-most 24 bits of the round sub-key are taken as some
subset of the 28 bits in the right half of the master key. We stress that the
entire key schedule (including the manner in which bits are divided into the
left and right halves, and which bits are used in forming each sub-key ki) is
ﬁxed and public, and the only secret is the master key itself.
The DES round function. The DES round function ˆf—sometimes called
theDES mangler function —is constructed using a paradigm we have previ-
ously analyzed: it is (essentially) just a substitution-permutation network! In
more detail, computation of ˆf(ki,R) withki∈{0,1}48andR∈{0,1}32pro-
ceeds as follows: ﬁrst, Risexpanded to a 48-bit value R/prime. This is carried out
by simply duplicating half the bits of R; we denote this by R/prime:=E(R) where214 Introduction to Modern Cryptography
/MT51/MT50/MT45/MT98/MT105/MT116/MT32/MT105/MT110/MT112/MT117/MT116 /MT52/MT56/MT45/MT98/MT105/MT116/MT32/MT115/MT117/MT98/MT45/MT107/MT101/MT121
/MT52/MT56/MT45/MT98/MT105/MT116/MT32/MT105/MT110/MT116/MT101/MT114/MT109/MT101/MT100/MT105/MT97/MT116/MT101/MT69
/MT52/MT56/MT45/MT98/MT105/MT116/MT32/MT105/MT110/MT116/MT101/MT114/MT109/MT101/MT100/MT105/MT97/MT116/MT101
/MT51/MT50/MT45/MT98/MT105/MT116/MT32/MT105/MT110/MT116/MT101/MT114/MT109/MT101/MT100/MT105/MT97/MT116/MT101/MT115/MT49/MT115/MT50/MT115/MT51/MT115/MT52/MT115/MT53 /MT115/MT55/MT115/MT56 /MT115/MT54
/MT51/MT50/MT45/MT98/MT105/MT116/MT32/MT111/MT117/MT116/MT112/MT117/MT116
FIGURE 6.6 :The DES mangler function.
Eis called the expansion function . Following this, computation proceeds ex-
actly as in our earlier discussion of SPNs: The expanded value R/primeis XORed
withki, which is also 48 bits long, and the resulting value is divided into 8
blocks, each of which is 6 bits long. Each block is passed through a (diﬀerent)
S-box that takes a 6-bit input and yields a 4-bit output; concatenating the
output from the 8 S-boxes gives a 32-bit result. A mixing permutation is then
applied to the bits of this result to obtain the ﬁnal output. See Figure 6.6.
One diﬀerence as compared to our original discussion of SPNs is that the
S-boxes here are notinvertible; indeed, they cannot be invertible since their
inputs are longer than their outputs. Further discussion regarding the struc-
tural details of the S-boxes is given below.
We stress once again that everything in the above description (including
theS-boxes themselves as well as the mixing permutation) is publicly known .
The only secret is the master key which is used to derive all the sub-keys.
TheS-boxes and the mixing permutation. The eight S-boxes that
form the “core” of ˆfare a crucial element of the DES construction and were
very carefully designed. Studies of DES have shown that if the S-boxes were
slightly modiﬁed, DES would have been much more vulnerable to attack.Practical Constructions of Symmetric-Key Primitives 215
This should serve as a warning to anyone who wishes to design a block cipher:
seemingly arbitrary choices are not arbitrary at all, and if not made correctly
may render the entire construction insecure.
Recall that each S-box maps a 6-bit input to a 4-bit output. Each S-box
can be viewed as a table with 4 rows and 16 columns, where each cell of the
table contains a 4-bit entry. A 6-bit input can be viewed as indexing one of
the 26= 64 = 4×16 cells of the table in the following way: The ﬁrst and last
input bits are used to choose the table row, and bits 2–5 are used to choose
the table column. The 4-bit entry at some position of the table represents the
output value for the input associated with that position.
The DES S-boxes have the following properties (among others):
1. Each S-box is a 4-to-1 function. (That is, exactly 4 inputs are mapped
to each possible output.) This follows from the properties below.
2. Each row in the table contains each of the 16 possible 4-bit strings
exactly once.
3. Changing one bitof any input to an S-box always changes at least two
bitsof the output.
The mixing permutation was also designed carefully. In particular it has
the property that the four output bits from any Sbox will aﬀect the input
to sixS-boxes in the next round. (This is possible because of the expansion
function that is applied in the next round before the S-boxes are computed.)
The DES avalanche eﬀect. The design of the mangler function ensures
that DES exhibits a strong avalanche eﬀect. In order to see this, we will
trace the diﬀerence between the intermediate values in a DES computation
of two inputs that diﬀer by just a single bit. Let us denote the two inputs to
the cipher by ( L0,R0) and (L/prime
0,R/prime
0), where we assume that R0=R/prime
0and so
the single-bit diﬀerence occurs in the left half of the inputs (it may help to
refer to Equation (6.3) and Figure 6.6 in what follows). After the ﬁrst round
the intermediate values ( L1,R1) and (L/prime
1,R/prime
1) still diﬀer by only a single bit,
although now this diﬀerence is in the right half. In the second round of DES,
the right half of each input is run through ˆf. Assuming that the bit where R1
andR/prime
1diﬀer is not duplicated in the expansion step, the intermediate values
before applying the S-boxes still diﬀer by only a single bit. By property 3
of theS-boxes, the intermediate values aftertheS-box computation diﬀer
in at least twobits. The result is that the intermediate values ( L2,R2) and
(L/prime
2,R/prime
2) diﬀer in threebits: there is a 1-bit diﬀerence between L2andL/prime
2
(carried over from the diﬀerence between R1andR/prime
1) and a 2-bit diﬀerence
between R2andR/prime
2.
The mixing permutation spreads the two-bit diﬀerence between R2andR/prime
2
such that, in the following round, each of the two bits is used as input to a
diﬀerent S-box, resulting in a diﬀerence of at least 4 bits in the right halves of
the intermediate values. (If either or both of the two bits in which R2andR/prime
2216 Introduction to Modern Cryptography
diﬀer are duplicated by E, the diﬀerence may be even greater.) There is also
now a 2-bit diﬀerence in the left halves. As with a substitution-permutation
network, we have an exponential eﬀect and so after 7 rounds we expect all 32
bits in the right half to be aﬀected (and after 8 rounds all 32 bits in the left
half will be aﬀected as well).
DES has 16 rounds, and so the avalanche eﬀect occurs very early in the
computation. This ensures that the computation of DES on similar inputs
yields independent-looking outputs.
Attacks on Reduced-Round DES
A useful exercise for understanding more about the DES construction and
its security is to look at the behavior of DES with only a few rounds. We
will show attacks on one-, two-, and three-round variants of DES (recall that
the real DES has 16 rounds). DES with three rounds or fewer cannot be a
pseudorandomfunction becausethreeroundsarenotenoughforthe avalanche
eﬀect to occur. Thus, we will be interested in demonstrating more diﬃcult
(and more damaging) key-recovery attacks which compute the key kusing
only a relatively small number of input/output pairs computed using that
key. Some of the attacks are similar to those we have seen in the context of
substitution-permutation networks; here, however, we will see how they are
applied to a concrete block cipher rather than to an abstract design.
The attacks below will be known-plaintext attacks in which the adversary
knowssomeplaintext/ciphertextpairs {(xi,yi)}withyi=DESk(xi) forsome
secret key k. When we describe the attacks, we will focus on a particular in-
put/output pair ( x,y) and will describe the information about the key that
the adversary can derive from this pair. Continuing to use the notation de-
veloped earlier, we denote the left and right halves of the input xasL0and
R0, respectively, and let Li,Ridenote the left and right halves after the ith
round. Recall that Edenotes the DES expansion function, kidenotes the
sub-key used in round i, andfi(R) =ˆf(ki,R) denotes the actual function
being applied in the Feistel network in the ith round.
One-round DES. Say we are given an input/output pair ( x,y). In one-
round DES, we have y= (L1,R1), where L1=R0andR1=L0⊕f1(R0).
We therefore know an input/output pair for f1; speciﬁcally, we know that
f1(R0) =R1⊕L0. By applying the inverse of the mixing permutation to the
outputR1⊕L0, we obtain the intermediate value consisting of the outputs
from all the S-boxes, where the ﬁrst 4 bits are the output from the ﬁrst S-box,
the next 4 bits are the output from the second S-box, and so on.
Consider the (known) 4-bit output of the ﬁrst S-box. Since each S-box is a
4-to-1function, this means there areexactly four possible inputs to this S-box
that would result in the given output, and similarly for all the other S-boxes;
each such input is 6 bits long. The input to the S-boxes is simply the XOR
ofE(R0) with the sub-key k1. SinceR0, and hence E(R0), is known, we canPractical Constructions of Symmetric-Key Primitives 217
compute a set of four possible values for each 6-bit portion of k1. This means
we have reduced the number of possible keys k1from 248to 448/6= 48= 216
(since there are four possibilities for each of the eight 6-bit portions of k1).
This is already a small number and so we can just try all the possibilities on
a diﬀerent input/output pair ( x/prime,y/prime) to ﬁnd the right key. We thus obtain the
key using only two known plaintexts in time roughly 216.
Two-round DES. In two-roundDES,the output yisequalto( L2,R2)where
L1=R0
R1=L0⊕f1(R0)
L2=R1=L0⊕f1(R0)
R2=L1⊕f2(R1).
L0,R0,L2, andR2are known from the given input/output pair ( x,y), and
thus we also know L1=R0andR1=L2. This means that we know the
input/output of both f1andf2, and so the same method used in the attackon
one-round DES can be used here to determine both k1andk2in time roughly
2·216. This attack works even if k1andk2are completely independent keys,
although in fact the key schedule of DES ensures that many of the bits of k1
andk2are equal (which can be used to further speed up the attack).
Three-round DES. Referring to Figure 6.5, the output value yis now equal
to (L3,R3). Since L1=R0andR2=L3, the only unknown values in the
ﬁgure are R1andL2(which are equal).
Now we no longer have the input/output to any round function fi. For
example, the output value of f2is equal to L1⊕R2, where both of these
values are known. However, we do notknow the value R1that is input to f2.
Similarly, we can determine the inputs to f1andf3but not the outputs of
those functions. Thus, the attack we used to break one-round and two-round
DES will not work here.
Instead of relying on full knowledge of the input and output of one of
the round functions, we will use knowledge of a certain relation between the
inputs and outputs of f1andf3. Observe that the output of f1is equal to
L0⊕R1=L0⊕L2, and the output of f3is equal to L2⊕R3. Therefore,
f1(R0)⊕f3(R2) = (L0⊕L2)⊕(L2⊕R3) =L0⊕R3,
where both L0andR3are known. That is, the XOR of the outputs of f1and
f3is known. Furthermore, the input to f1isR0and the input to f3isL3,
both of which are known. We conclude that we can determine the inputs to
f1andf3, and the XOR of their outputs. We now describe an attack that
ﬁnds the secret key based on this information.
Recall that the key schedule of DES has the property that the master key is
divided into a “left half,” which we denote by kL, and a “right half” kR, each
containing 28 bits. Furthermore, the 24 left-most bits of the sub-key used in218 Introduction to Modern Cryptography
each round are taken only from kL, and the 24 right-most bits of each sub-key
are taken only from kR. This means that kLaﬀects only the inputs to the
ﬁrst four S-boxes in any round, while kRaﬀects only the inputs to the last
fourS-boxes. Since the mixing permutation is known, we also know which
bits of the output of each round function come out of each S-box.
The idea behind the attack is to separately traverse the key space for each
half of the master key, giving an attack with complexity roughly 2 ·228rather
than complexity 256. Such an attack will be possible if we can verify a guess
of half the master key, and we now show how this can be done. Say we guess
some value for kL, the left half of the master key. We know the input R0
off1, and so using our guess of kLwe can compute the input to the ﬁrst
fourS-boxes. This means that we can compute half the output bits of f1
(the mixing permutation spreads out the bits we know, but since the mixing
permutation is known we know exactly which bits these are). Likewise, we
can compute the same locations in the output of f3by using the known input
L3tof3and the same guess for kL. Finally, we can compute the XOR of
these output values and check whether they match the appropriate bits in the
known value of the XOR of the outputs of f1andf3. If they are not equal,
then our guess for kLis incorrect. A correct guess for kLwill always pass
this test, and so will not be eliminated, but an incorrect guess is expected to
pass this test only with probability roughly 2−16(since we check equality of
16 bits in two computed values). There are 228possible values for kL, so if
each incorrect value remains a viable candidate with probability 2−16then we
expect to be left with only 228·2−16= 212possibilities for kLafter the above.
By performing the above for each half of the master key, we obtain in time
2·228approximately212candidates for the left half and 212candidates for the
right half. Since each combination of the left half and right half is possible,
we have 224candidate keys overall and can run a brute-force search over this
set using an additional input/output pair ( x/prime,y/prime). (An alternative approach
which is more eﬃcient is to simply repeat the previous attack using the 212
remaining candidates for each half-key.) The time complexity of the attack is
roughly 2·228+224<230, which is much less than 256.
Security of DES
After almost 30 years of intensive study, the best known practical attack
on DES is still an exhaustive search through its key space. (We discuss some
important theoretical attacks in Section 6.2.6. These attacks require a large
number of input/output pairs, which would be diﬃcult to obtain in an attack
on any real-world system using DES.) Unfortunately, the 56-bit key length
of DES is short enough that an exhaustive search through all 256possible
keys is now feasible. Already in the late 1970s there were strong objections
to the choice of such a short key for DES. Back then, the objection was
theoretical, as the computational power needed to search through that manyPractical Constructions of Symmetric-Key Primitives 219
keys was generally unavailable.4The practicality of a brute-force attack on
DES, however, was demonstrated in 1997 when the ﬁrst of a set of DES
challengessetupbyRSASecuritywassolvedbytheDESCHALLprojectusing
thousandsofcomputerscoordinatedacrosstheInternet; thecomputationtook
96 days. A second challenge was broken the following year in just 41 days
by thedistributed.net project. A signiﬁcant breakthrough came in 1998
when the third challenge was solved in just 56 hours . This impressive feat
was achieved via a special-purpose DES-breaking machine called Deep Crack
that was built by the Electronic Frontier Foundation at a cost of $250,000. In
1999, a DES challenge was solved in just over 22 hours as a combined eﬀort of
Deep Crack and distributed.net . The current state-of-the-art is the DES
cracking box by PICO Computing, which uses 48 FPGAs and can ﬁnd a DES
key in approximately 23 hours.
The time/space tradeoﬀs discussed in Section 5.4.3 show that exhaustive
key-search attacks can be accelerated using pre-computation and additional
memory. Due to the short key length of DES, time/space tradeoﬀs can be
especially eﬀective. Speciﬁcally, using pre-processing it is possible to generate
a table a few terabytes large that then enables recovery of a DES key with
high probability froma single input/output pairusing approximately238DES
evaluations (which can be computed in mere minutes). The bottom line is
that DES has a key that is far too short, and cannot be considered secure for
any serious application today.
A secondarycause for concern is the relatively short block length of DES. A
short block length is problematic because the concrete security of many con-
structions based on block ciphers depends on the block length— even if the
cipher used is “perfect.” For example, the proof of security for CTR mode
(cf. Theorem 3.32) shows that even when a completely random function is
used an attacker can break the security of this encryption scheme with prob-
ability 2q2/2/lscriptif it obtains qplaintext/ciphertext pairs. In the case of DES
where/lscript= 64, this means that if an attacker obtains only q= 230plain-
text/ciphertext pairs, security is compromised with high probability. Obtain-
ing plaintext/ciphertext pairs is relatively easy if an adversary eavesdrops on
the encryption of messages containing known headers, redundancies, etc.
The insecurity of DES has nothing to do with its design per se, but rather
is due to its short key length (and, to a lesser extent, its short block length).
This is a great tribute to the designers of DES, who seem to have succeeded
in constructing an almost “perfect” block cipher (besides its too-short key).
Since DES itself seems not to have signiﬁcant structural weaknesses, it makes
senseto useDES asa building blockforconstructingblockcipherswith longer
keys. We discuss this further in Section 6.2.4.
4In1977, it was estimated that a computer that could crack DES in one day would cost
$20 million to build.220 Introduction to Modern Cryptography
The replacement for DES—the Advanced Encryption Standard (AES), cov-
ered later in this chapter—was explicitly designed to address concerns regard-
ing the short key length and block length of DES. AES supports 128-, 192-,
or 256-bit keys, and a block length of 128 bits.
Better-than-brute-force attacks on DES were ﬁrst shown in the early 1990s
byBihamandShamir,whodevelopedatechniquecalled diﬀerential cryptanal-
ysis. Theirattacktakestime 237and requires247chosenplaintexts. Whilethe
attack was a breakthrough from a theoretical standpoint, it does not appear
to be of much practical concern since it is hard to imagine a realistic scenario
where an adversary can obtain this many encryptions of chosen plaintexts.
Interestingly, the work of Biham and Shamir indicated that the DES S-
boxes had been speciﬁcally designed to be resistant to diﬀerential cryptanal-
ysis, suggesting that the technique of diﬀerential cryptanalysis was known
(but not publicly revealed) by the designers of DES. After Biham and Shamir
announced their result, this suspicion was conﬁrmed.
Linear cryptanalysis was developed by Matsui in the mid-1990s and was
also applied successfully to DES. The advantage of this attack is that it uses
knownplaintexts rather than chosenplaintexts. Nevertheless, the number of
plaintext/ciphertext pairs required—about 243—is still huge.
We brieﬂy describe diﬀerential and linear cryptanalysis in Section 6.2.6.
6.2.4 3DES: Increasing the Key Length of a Block Cipher
The main weakness of DES is its short key. It thus makes sense to try to
design a block cipher with a larger key length using DES as a building block.
Some approaches to doing so are discussed in this section. Although we refer
to DES frequently throughout the discussion, and DES is the most prominent
block cipher to which these techniques have been applied, everything we say
here applies generically to anyblock cipher.
Internal modiﬁcations vs. “black-box” constructions. There are two
general approaches one could take to constructing another cipher based on
DES. The ﬁrst approach would be to somehow modify the internal structure
of DES, while increasing the key length. For example, one could leave the
round function untouched and simply use a 128-bit master key with a diﬀer-
ent key schedule (still choosing a 48-bit sub-key in each round). Or, one could
change the S-boxes themselves and use a larger sub-key in each round. The
disadvantageofsuchapproachesis that bymodifying DES—in eventhe small-
est way—we lose the conﬁdence we have gained in DES by virtue of the fact
that it hasremainedresistantto attackforsomany years. Cryptographiccon-
structions are very sensitive, and even mild, seemingly insigniﬁcant changes
can render a construction completely insecure.5Changing the internals of a
block cipher is therefore not recommended.
5Infact, various results to this eﬀect have been shown for DES; e.g., changing the S-boxes
or the mixing permutation can make DES much more vulnerable to attack.Practical Constructions of Symmetric-Key Primitives 221
An alternative approach that does not suﬀer from the above problem is to
use DES as a “black box” and not touch its internal structure at all. In this
approach we treat DES as a “perfect” block cipher with a 56-bit key, and
construct a new block cipher that only invokes the original, unmodiﬁed DES.
Since DES itself is not tampered with, this is a much more prudent approach,
and is the one we will pursue here.
Double Encryption
LetFbe a block cipher with an n-bit key length and /lscript-bit block length.
Then a new block cipher F/primewith a key of length 2 ncan be deﬁned by
F/prime
k1,k2(x)def=Fk2(Fk1(x)),
wherek1andk2areindependent keys. Forthe casewhere FisDES,weobtain
a cipherF/primecalled 2DES that takes a 112-bitkey; if exhaustive key searchwere
the best available attack, a key length of 112 bits would be suﬃcient since
an attack requiring time 2112is completely out of reach. Unfortunately, we
now show an attack on F/primethat runs in time roughly 2n, signiﬁcantly less than
the 22ntime one would hope would be necessary to carry out an exhaustive
search for a 2 n-bit key. This means that the new block cipher is essentially
no better than the old one, even though it has a key that is twice as long.6
The attack is called a “meet-in-the-middle attack,” for reasons that will
soon become clear. Say the adversary is given a single input/output pair
(x,y), where y=F/prime
k∗
1,k∗
2(x) =Fk∗
2(Fk∗
1(x)) for unknown k∗
1,k∗
2. The adversary
can narrow down the set of possible keys in the following way:
1. For each k1∈{0,1}n, compute z:=Fk1(x) and store ( z,k1) in a list L.
2. For each k2∈{0,1}n, compute z:=F−1
k2(y) and store ( z,k2) in a list L/prime.
3. Entries ( z1,k1)∈Land (z2,k2)∈L/primeare amatchifz1=z2. For each
such match, add ( k1,k2) to a set S. (Matches can be found easily after
sortingLandL/primeby their ﬁrst components.)
See Figure 6.7 for a graphical depiction of the attack.
The attack takes time O(n·2n), and requires space O((n+/lscript)·2n). The set
Soutput by this algorithm contains exactly those values ( k1,k2) for which
Fk1(x) =F−1
k2(y) (6.4)
or, equivalently, for which y=F/prime
k1,k2(x). In particular, ( k∗
1,k∗
2)∈S. On
the other hand, a pair ( k1,k2)/negationslash= (k∗
1,k∗
2) is (heuristically) expected to satisfy
Equation (6.4) with probability 2−/lscriptif we treat Fk1(x) andF−1
k2(y) as uniform
6This is not quite true since a brute-force attack on Fcan be carried out in time 2nand
constant memory, whereas the attack we show on F/primerequires 2ntimeand2nmemory .
Nevertheless, the attack illustrates that F/primedoes not achieve the desired level of security.222 Introduction to Modern Cryptography
/MT120 /MT122/MT42 /MT121/MT70/MT107/MT42/MT49/MT32/MT40/MT120/MT41/MT122
/MT70/MT107/MT49/MT32/MT40/MT120/MT41
/MT122/MT146/MT45/MT49/MT70/MT107/MT42/MT50/MT32/MT40/MT121/MT41
/MT45/MT49/MT70/MT107/MT146/MT50/MT32/MT40/MT121/MT41/MT45/MT49/MT70/MT107/MT50/MT32/MT40/MT121/MT41
FIGURE 6.7 :Ameet-in-the-middle attack.
/lscript-bit strings, and so the expected size of Sis 22n·2−/lscript= 22n−/lscript. Using an-
other few input/output pairs, and taking the intersection of the sets that are
obtained, the correct ( k∗
1,k∗
2) can be identiﬁed with very high probability.
Triple Encryption
The obvious generalization of the preceding approach is to apply the block
cipherthreetimes in succession. Two variants of this approach are common:
Variant 1: three keys. Choosethree independent keys k1,k2,k3and deﬁne
F/prime/prime
k1,k2,k3(x)def=Fk3(F−1
k2(Fk1(x))).
Variant 2: two keys. Choose two independent keys k1,k2and then deﬁne
F/prime/prime
k1,k2(x)def=Fk1(F−1
k2(Fk1(x))).
Before comparing the security of the two alternatives we note that the middle
invocation of Fis reversed. If Fis a suﬃciently good cipher this makes no
diﬀerence as far as security is concerned, since if Fis a strong pseudorandom
permutation then F−1must be too. The reason for reversing the second
application of Fis to obtain backwardcompatibility: if one sets k1=k2=k3,
the resulting function is equivalent to a single invocation of Fusing key k1.
Security of the ﬁrst variant. The key length of the ﬁrst variant is 3 n, and
so we might hope that the best attack on this cipher would require time 23n.
However, the cipher is susceptible to a meet-in-the-middle attack just as in
the case of double encryption, though the attack now takes time 22n. This
is the best known attack. Thus, although this variant is not as secure as one
might have hoped, it obtains suﬃcient security for all practical purposes even
forn= 56 (assuming, of course, the original cipher Fhas no weaknesses).Practical Constructions of Symmetric-Key Primitives 223
Security of the second variant. The key length of this variant is 2 nand
so the best we can hope for is security against attacks running in time 22n.
There is no known attack with better time complexity when the adversary
is given only a small number of input/output pairs. (See Exercise 6.13 for
an attack using 2nchosen plaintexts.) Thus, two-key triple encryption is a
reasonable choice in practice.
Triple-DES (3DES). Triple-DES (or 3DES) is based on a triple invocation
of DES using two or three keys, as described above. 3DES was standardized
in 1999, and is widely used today. Its main drawbacks are its relatively small
block length and the fact that it is relatively slow since it requires 3 full block-
cipher operations. Since the minimum recommended key length nowadays is
128 bits, 2-key 3DES is no longer recommended (due to its key length of only
112 bits). These drawbacks have led to the replacement of DES/triple-DES
by the Advanced Encryption Standard, presented in the next section.
6.2.5 AES – The Advanced Encryption Standard
In January 1997, the United States National Institute of Standards and
Technology (NIST) announced that it would hold a competition to select a
new block cipher—to be called the Advanced Encryption Standard , or AES—
to replace DES. The competition began with an open call for teams to submit
candidate block ciphers for evaluation. A total of 15 diﬀerent algorithms
were submitted from all over the world, including contributions from many
of the best cryptographers and cryptanalysts. Each team’s candidate cipher
was intensively analyzed by members of NIST, the public, and (especially)
the other teams. Two workshops were held, one in 1998 and one in 1999, to
discuss and analyze the various submissions. Following the second workshop,
NIST narrowed the ﬁeld down to 5 “ﬁnalists” and the second round of the
competition began. A third AES workshop was held in April 2000, inviting
additional scrutiny on the ﬁve ﬁnalists. In October 2000, NIST announced
that the winning algorithm was Rijndael (a block cipher designed by the
Belgian cryptographers Vincent Rijmen and Joan Daemen), although NIST
conceded that any of the 5 ﬁnalists would have made an excellent choice.
In particular, no serious security vulnerabilities were found in any of the 5
ﬁnalists, and the selection of a “winner” was based in part on properties such
as eﬃciency, performance in hardware, ﬂexibility, etc.
The process of selecting AES was ingenious because any group that sub-
mitted an algorithm, and was therefore interested in having its algorithm
adopted, had strong motivation to ﬁnd attacks on the other submissions. In
this way,the world’sbestcryptanalystsfocusedtheirattentiononﬁndingeven
the slightest weaknesses in the candidate ciphers submitted to the competi-
tion. Afteronlyafewyearseachcandidatealgorithmwasalreadysubjectedto
intensive study, thus increasing our conﬁdence in the security of the winning
algorithm. Of course, the longer the algorithm is used and studied without224 Introduction to Modern Cryptography
being broken, the more our conﬁdence will continue to grow. Today, AES is
widely used and no signiﬁcant security weaknesses have been discovered.
The AES construction. In this section, we present the high-level structure
of Rijndael/AES. (Technically speaking, Rijndael and AES are not the same
thing but the diﬀerences are unimportant for our discussion here.) As with
DES, we will not present a full speciﬁcation and our description should not
be used as a basis for implementation. Our aim is only to provide a general
idea of how the algorithm works.
The AES block cipher has a 128-bit block length and can use 128-, 192-, or
256-bit keys. The length of the key aﬀects the key schedule (i.e., the sub-key
that is used in each round) as well as the number of rounds, but does not
aﬀect the high-level structure of each round.
In contrast to DES, which uses a Feistel structure, AES is essentially a
substitution-permutation network. During computation of the AES algo-
rithm, a 4-by-4 arrayof bytes called the stateis modiﬁed in a series of rounds.
The state is initially set equal to the input to the cipher (note that the input
is 128 bits, which is exactly 16 bytes). The following operations are then
applied to the state in a series of four stages during each round:
Stage 1 – AddRoundKey :IneveryroundofAES,a128-bitsub-keyisderived
from the master key, and is interpreted as a 4-by-4 array of bytes. The
state array is updated by XORing it with this sub-key.
Stage 2 – SubBytes :In this step, each byte of the state array is replaced by
another byte according to a single ﬁxed lookup table S. This substitu-
tion table (or S-box) is a bijection over {0,1}8.
Stage 3 – ShiftRows :In this step, the bytes in each row of the state array
are shifted to the left as follows: the ﬁrst row of the array is untouched,
the second row is shifted one place to the left, the third row is shifted
two places to the left, and the fourth row is shifted three places to the
left. All shifts are cyclic so that, e.g., in the second row the ﬁrst byte
becomes the fourth byte.
Stage 4 – MixColumns :In this step, an invertible transformation is applied
to the four bytes in each column. (Technically speaking, this is a linear
transformation—i.e., matrix multiplication—over an appropriate ﬁeld.)
This transformation has the property that if two inputs diﬀer in b >0
bytes, then applying the transformation yields two outputs diﬀering in
at least 5−bbytes.
In the ﬁnal round, MixColumns is replaced with AddRoundKey . This prevents
an adversaryfrom simply inverting the last three stages, which do not depend
on the key.
By viewing stages 3 and 4 together as a “mixing” step, we see that each
round of AES has the structure of a substitution-permutation network: thePractical Constructions of Symmetric-Key Primitives 225
round sub-key is ﬁrst XORed with the input to the current round; next, a
small, invertible function is applied to “chunks” of the resulting value; ﬁnally,
thebitsoftheresultaremixedinordertoobtaindiﬀusion. Theonlydiﬀerence
is that, unlike our previous description of substitution-permutation networks,
here the mixing step does not consist of a simple shuﬄing of the bits but is
instead carried out using a shuﬄing plus an invertible linear transformation.
(Simplifying things a bit and looking at a trivial 3-bit example, shuﬄing the
bits ofx=x1/bardblx2/bardblx3might, e.g., map xtox/prime=x2/bardblx1/bardblx3. An invertible
linear transformation might map xtox1⊕x2/bardblx2⊕x3/bardblx1⊕x2⊕x3.)
The number of rounds depends on the key length. Ten rounds are used for
a 128-bit key, 12 rounds for a 192-bit key, and 14 rounds for a 256-bit key.
Security of AES. As we have mentioned, the AES cipher was subject to
intense scrutiny during the selection process and has continued to be studied
ever since. To date, there are no practical cryptanalytic attacks that are
signiﬁcantly better than an exhaustive search for the key.
We conclude that, as of today, AES constitutes an excellent choice for any
cryptographic scheme that requires a (strong) pseudorandom permutation. It
is free, standardized, eﬃcient, and highly secure.
6.2.6 *Diﬀerential and Linear Cryptanalysis
Blockciphersarerelativelycomplicated, andassucharediﬃcult toanalyze.
Nevertheless, one should not be fooled into thinking that a complicated cipher
is diﬃcult to break. On the contrary, it is very hard to construct a secure
block cipher and surprisingly easy to ﬁnd attacks on most constructions (no
matter how complicated they appear). This should serve as a warning that
non-experts should not try to construct new ciphers. Given the availability
of triple-DES and AES, it is hard to justify using anything else.
In this section we describe two tools that are now a standard part of the
cryptanalyst’s toolbox. Our goal here is give a taste of some advanced crypt-
analysis, as well as to reinforce the idea that designing a secure block cipher
involves careful choice of its components.
Diﬀerential cryptanalysis. This technique, which can lead to a chosen-
plaintext attack on a block cipher, was ﬁrst presented in the late 1980s by
Biham and Shamir, who used it to attack DES in 1993. The basic idea behind
the attack is to tabulate speciﬁc diﬀerences in the input that lead to speciﬁc
diﬀerences in the output with probability greater than would be expected for
a random permutation. Speciﬁcally, say the diﬀerential (∆x,∆y)occurs in
some keyed permutation F/primewith probability pif for uniform inputs x1andx2
satisfying x1⊕x2= ∆x, and uniform choice of key k, the probability that
F/prime
k(x1)⊕F/prime
k(x2) = ∆ yisp. For any ﬁxed (∆ x,∆y) andx1,x2satisfying
x1⊕x2= ∆x, if we choose a uniform function f:{0,1}/lscript→{0,1}/lscript, we have
Pr[f(x1)⊕f(x2) = ∆ y] = 2−/lscript. In a weak block cipher, however, there may226 Introduction to Modern Cryptography
be diﬀerentials that occur with signiﬁcantly higher probability. This can be
leveraged to give a full key-recovery attack, as we now show for SPNs.
We describe the basic idea, and then work through a concrete example. Let
Fbe a block cipher with /lscript-bit block length which is an r-round SPN, and let
F/prime
k(x) denote the intermediate result in a computation of Fk(x) after applying
the key-mixing step of round r. (That is, F/primeexcludes the S-box substitution
and mixing permutation of the last round, as well as the ﬁnal key-mixing
step.) Say there is a diﬀerential (∆ x,∆y) inF/primethat occurs with probability
p/greatermuch2−/lscript. It is possible to exploit this high-probability diﬀerential to learn
bits of the ﬁnal mixing sub-key kr+1. The high-level idea is as follows: let
{(xi
1,xi
2)}L
i=1be a collection of Lpairs of random inputs with diﬀerential ∆ x,
i.e., with xi
1⊕xi
2= ∆xfor alli. Using a chosen-plaintext attack, obtain
the values yi
1=Fk(xi
1) andyi
2=Fk(xi
2) for all i. Now, for all possible
bitstrings k∗∈{0,1}/lscript, compute ˜ yi
1=F/prime
k(xi
1) and ˜yi
2=F/prime
k(xi
2), assuming the
value of the ﬁnal sub-key kr+1isk∗. This is done by inverting the ﬁnal key-
mixing step using k∗, and then inverting the mixing permutation and S-boxes
of round r, which do not depend on the master key. When k∗=kr+1, we
expect that a p-fraction of the pairs will satisfy ˜ yi
1⊕˜yi
2= ∆y. On the other
hand, when k∗/negationslash=kr+1we may heuristically expect only a 2−/lscript-fraction of the
pairs to yield this diﬀerential. By setting Llarge enough, the correct value of
the ﬁnal sub-key kr+1can be determined.
This works, but is not very eﬃcient since in each step we enumerate over 2/lscript
possible values. We can do better by guessing portions of kr+1at a time.
More concretely, assume the S-boxes in Fhave 1-byte input/output length,
and focus on the ﬁrst byte of ∆ y, which we assume is nonzero. It is possible
to verify if the diﬀerential holds in that byte by guessing only 8 bits of kr+1,
namely, the 8 bits that correspond (after the round- rmixing permutation)
to the output of the ﬁrst S-box. Thus, proceeding as above, we can learn
these 8 bits by enumerating over all possible values for those bits, and seeing
which value yields the desired diﬀerential in the ﬁrst byte with the highest
probability. Incorrect guesses for those 8 bits yield the expected diﬀerential
in that byte with (heuristic) probability 2−8, but the correct guess will give
the expected diﬀerential with probability roughly p+2−8; this is because with
probability pthe diﬀerential holds on the entire block (so in particular for the
ﬁrst byte), and when this is not the case then we can treat the diﬀerential in
the ﬁrst byte as random. Note that diﬀerent diﬀerentials may be needed to
learn diﬀerent portions of kr+1.
In practice, various optimizations are performed to improve the eﬀective-
ness of the above test or, more speciﬁcally, to increase the gap between the
probability that an incorrect guess yields the diﬀerential vs. the probability
that a correct guess does. One optimization is to use a low-weight diﬀeren-
tial in which ∆ yhas many zero bytes in the positions that enter the S-boxes
in round r. Any pairs ˜ y1,˜y2satisfying such a diﬀerential have equal values
entering many of the S-boxes in round r, and so will result in output values
y1,y2that are equal in the correspondingbit-positions (depending on the ﬁnalPractical Constructions of Symmetric-Key Primitives 227
mixing permutation). This means that when performing the test described
earlier, one cansimply discardanypairs( yi
1,yi
2) that do not agreein those bit-
positions (since the correspondingintermediate values (˜ y1,˜y2) cannot possibly
satisfy the diﬀerential, for any choice of the ﬁnal sub-key). This signiﬁcantly
improves the eﬀectiveness of the attack.
Oncekr+1is known, the attacker can “peel oﬀ” the ﬁnal key-mixing step,
as well as the mixing permutation and S-box substitution steps of round r
(since these do not depend on the master key), and then apply the same
attack—using a diﬀerent diﬀerential—to ﬁnd the rth-round sub-key kr, and
so on, until it learns all sub-keys (or, equivalently, the entire master key).
A worked example. We work through a “toy” example, illustrating also
how a good diﬀerential can be found. We use a four-round SPN with a block
length of 16 bits, based on a single S-box with 4-bit input/output length. The
S-box is deﬁned as follows (the table shows how each 4-bit input is mapped
to a 4-bit output):
Input: 0000 0001 0010 0011 0100 0101 0110 0111
Output: 0000 1011 0101 0001 0110 1000 1101 0100
Input: 1000 1001 1010 1011 1100 1101 1110 1111
Output: 1111 0111 0010 1100 1001 0011 1110 1010
The mixing permutation, showing where each bit is moved for each of the
16bits in a block, is as follows:
In:12 3 4 5 6 7 8 9 10 11 12 13 14 15 16
Out:7 2 3 8 12 5 11 9 10 1 14 13 4 6 16 15
FIGURE 6.8 :The eﬀect of the input diﬀerence ∆ x= 1111 in our S-box.228 Introduction to Modern Cryptography
We ﬁrst ﬁnd a diﬀerential in the S-box. Let S(x) denote the output of the
S-boxon input x. Consider the diﬀerential ∆ x= 1111. Then, for example, we
haveS(0000)⊕S(1111) = 0000⊕1010 = 1010 and so in this case a diﬀerence
of 1111 in the inputs leads to a diﬀerence of 1010 in the outputs. Let us see if
this relation holds frequently. We have S(0001) = 1011 and S(0001⊕1111)=
S(1110) = 1110, and so here a diﬀerence of 1111 in the inputs does not
lead to a diﬀerence of 1010 in the outputs. However, S(0100) = 0110 and
S(0100⊕1111) = S(1011) = 1100 and so in this case, a diﬀerence of 1111
in the inputs yields a diﬀerence of 1010 in the outputs. In Figure 6.8 we
have tabulated results for all possible inputs. We see that halfthe time a
diﬀerence of 1111 in the inputs yields a diﬀerence of 1010 in the outputs.
Thus, (1111 ,1010) is a diﬀerential in Sthat occurs with probability 1 /2.
0123456789ABCDEF
0
1
2
3
4
5
6
7
8
9
A
B
C
D
E
F16000000000000000
0000400022220040
0000020202242200
0224040000000220
0002226020002000
0220000040004220
0202000002020404
0200242202000200
0002000200022224
0202220402200000
0040202420200000
0020002002004240
0000000044040004
0422002200000004
0242400000002020
0000022020820000Output DifferenceInput Difference∆y∆x
FIGURE 6.9 :Diﬀerentials in our S-box.
This same process can be carried out for all 24input diﬀerences ∆ xto
calculate the probability of every diﬀerential. Namely, for each pair (∆ x,∆y)
we tabulate the number of 4-bit inputs xfor which S(x)⊕S(x⊕∆x) = ∆y.
We have done this for our example S-box in Figure 6.9. (For conciseness we
represent (∆ x,∆y) using hexadecimal notation.) The table should be read as
follows: entry ( i,j) counts how many inputs with diﬀerence imap to outputs
with diﬀerence j. Observe,for example, that thereare8inputs with diﬀerence
0xF= 1111 that map to output 0xA= 1010, as we have shown above. This is
the highest-probability diﬀerential (apart from the trivial diﬀerential (0 ,0)).
But there are other diﬀerentials of interest: an input diﬀerence of 0x4= 0100
maps to an output diﬀerence of 0x6= 0110 with probability 6 /16 = 3/8, and
there are several diﬀerentials with probability 4 /16 = 1/4.Practical Constructions of Symmetric-Key Primitives 229
0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0
1 1 0 0
1 0 0 0
0 0 0 1
0 1 0 0
1 0 0 0
1 1 1 1
0 1 1 0 0 0 1 1 0 0 0 0 0 0 0 00xC=1100
maps to
0x8=1000
w.p. 1/4
0x1=0001
maps to
0x4=0100
w.p. 1/4
0x8=1000
maps to
0xF=1111
w.p. 1/4
FIGURE 6.10 :Tracing diﬀerentials through a four-round SPN that uses
theS-box and mixing permutation given in the text.
We now extend this to ﬁnd a good diﬀerential for the ﬁrst three rounds of
the SPN. Consider evaluating the SPN on two inputs that have a diﬀerential
of 0000 1100 0000 0000, and tracing the diﬀerential between the intermediate
values at each step of this evaluation. (Refer to Figure 6.10, which shows the
four full rounds of the SPN plus the ﬁnal key-mixing step. For clarity, the ﬁg-
ure omits the mixing permutation in the 4th round; that mixing permutation
just has the eﬀect of shuﬄing the bits of the diﬀerential, and so can easily
be taken into account in the attack.) The key-mixing step in the ﬁrst round
does not aﬀect the diﬀerential, and so the inputs to the second S-box in the
ﬁrst round have diﬀerential 1100. We see from Figure 6.9 that a diﬀerence of
0xC= 1100 in the inputs to the S-box yields a diﬀerence of 0x8= 1000 in
the outputs of the S-box with probability 1 /4. So with probability 1 /4 the
diﬀerential in the output of the 2nd S-box after round 1 is a single bit which is230 Introduction to Modern Cryptography
moved by the mixing permutation from the 5th position to the 12th position.
(The inputs to the other S-boxes are equal, so their outputs are equal and the
diﬀerential of the outputs is 0000.) Assuming this to be the case, the input
diﬀerence to the third S-box in the second round is 0x1= 0001 (once again,
the key-mixing step in the second round does not aﬀect the diﬀerential); using
Figure 6.9 we have that with probability 1 /4 the output diﬀerence from that
S-box is0x4= 0100. Thus, once again there is just a single output bit that
is diﬀerent, and it is moved from the 10th position to the ﬁrst position by the
mixing permutation. Finally, consulting Figure 6.9 yet again, we see that an
input diﬀerence of 0x8= 1000 to the S-box results in an output diﬀerence of
0xF= 1111 with probability 1 /4. The bits in positions 1, 2, 3, and 4 are then
moved by the mixing permutation to positions 7, 2, 3, and 8.
Overall, then, we see that an input diﬀerence of ∆ x= 0000 1100 0000 0000
yields the output diﬀerence ∆ y= 0110001100000000after three roundswith
probability at least1
4·1
4·1
4=1
64.7(We multiply the probabilities since we
heuristically assume independence of each round.) For a random function, the
probability that any given diﬀerential occurs is just 2−16= 1/65536. Thus,
the diﬀerential we havefound occurswith probabilitysigniﬁcantlyhigherthan
what would be expected for a random function. Observe also that we have
found a low-weight diﬀerential.
We can use this diﬀerential to ﬁnd the ﬁrst 8 bits of the ﬁnal sub-key k5.
As discussed earlier, we begin by letting {(xi
1,xi
2)}L
i=1be a set of Lpairs of
random inputs with diﬀerential ∆ x. Using a chosen-plaintext attack, we then
obtain the values yi
1=Fk(xi
1) andyi
2=Fk(xi
2) for alli. Now, for all possible
values for the initial 8 bits of k5, we compute the initial 8 bits of ˜ yi
1,˜yi
2, the
intermediate values after the key-mixing step of the 4th round. (We can do
this because we only need to invert the two left-most S-boxesof the 4th round
in order to derivethose 8 bits.) When we guess the correctvalue for the initial
8bitsofk5, weexpectthe8-bitdiﬀerential01100011tooccurwithprobability
at least 1 /64. Heuristically, an incorrect guess yields the expected diﬀerential
only with probability 2−8= 1/256. By setting Llarge enough, we can (with
high probability) identify the correct value.
Diﬀerential attacks in practice. Diﬀerential cryptanalysis is very power-
ful, andhasbeenusedtoattackrealciphers. AprominentexampleisFEAL-8,
which was proposed as an alternative to DES in 1987. A diﬀerential attack
on FEAL-8 was found that requires just 1,000 chosen plaintexts. In 1991, it
took less than 2 minutes using this attack to ﬁnd the entire key. Today, any
proposed cipher is tested for resistance to diﬀerential cryptanalysis.
A diﬀerential attack was the ﬁrst attack on DES to require less time than a
simple brute-forcesearch. While an interestingtheoreticalresult, the attackis
not of signiﬁcant concern in practice since it requires 247chosen plaintexts. It
7This is a lower bound on the probability of the diﬀerential, since there may be other
diﬀerences in the intermediate values that result in the same diﬀerence in the outputs.Practical Constructions of Symmetric-Key Primitives 231
isverydiﬃcultforanattackertoobtainthismanychosenplaintext/ciphertext
pairs in most real-world applications. Interestingly, small modiﬁcations to
theS-boxes of DES make the cipher much more vulnerable to diﬀerential
attacks. Personal testimony of the DES designers (after diﬀerential attacks
were discovered in the outside world) has conﬁrmed that the S-boxes of DES
were designed speciﬁcally to thwart diﬀerential attacks.
Linear cryptanalysis. Linear cryptanalysis was developed by Matsui in the
early 1990s. We will only describe the technique at a high level. The basic
idea is to consider linear relationships between the input and output that
hold with higher probability than would be expected for a random function.
In more detail, say that bit positions i1,...,iinandi/prime
1,...,i/prime
outhavelinear
biasεif, for uniform xandk, andydef=Fk(x), it holds that
/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr[xi1⊕···⊕xiin⊕yi/prime
1⊕···⊕yi/prime
out= 0]−1
2/vextendsingle/vextendsingle/vextendsingle/vextendsingle=ε,
wherexi,yidenotethe ithbitsof xandy. Forarandomfunctionandanyﬁxed
set of bit positions, we expect the bias to be close to 0. Matsui showed how
to use a large enough bias in a cipher Fto ﬁnd the secret key. Besides giving
another method for attacking ciphers, an important feature of this attack is
that it does not require chosenplaintexts, but rather knownplaintexts suﬃce.
This is very signiﬁcant, since an encrypted ﬁle can provide a huge amount of
known plaintext, whereas gathering encryptions of chosen plaintexts is much
more diﬃcult. Matsui showed that DES can be broken with just 243known
plaintext/ciphertext pairs.
Impact on block-cipher design. Modern block ciphers are designed and
evaluated based, in part, on their resistance to diﬀerential and linear crypt-
analysis. When constructing a block cipher, designers choose S-boxes and
other componentsso asto minimize diﬀerential probabilitiesand linear biases.
We remarkthat it is not possible to eliminate allhigh-probabilitydiﬀerentials
in anS-box: any S-boxwillhave somediﬀerentialthat occursmorefrequently
than others. Still, these deviations can be minimized. Moreover, increasing
the number of rounds (and choosing the mixing permutation carefully) can
both reduce the diﬀerential probabilities as well as make it more diﬃcult for
cryptanalysts to ﬁnd any diﬀerentials to exploit.
6.3 Hash Functions
Recall from Chapter 5 that the primary security requirement for a hash
function Hiscollision resistance ; that is, it should be diﬃcult to ﬁnd a
collision, or distinct inputs x,x/primesuch that H(x) =H(x/prime). (We drop mention232 Introduction to Modern Cryptography
of any key here, since real-world hash functions are generally unkeyed.) If the
hash function has /lscript-bit output length, then the best we can hope for is that
it should be infeasible to ﬁnd a collision using substantially fewer than 2/lscript/2
invocations of H. (See Section 5.4.1.) We would also like the hash function
to achieve (second) preimage resistance against attacks running in time much
less than 2/lscript, although we do not consider such attacks in our discussion here.
Hash functions are generally constructed in two steps. First, a compression
function (i.e., a ﬁxed-length hash function) his designed; next, some mecha-
nism is used to extend hsoasto handle arbitraryinput lengths. In Section 5.2
we have already shown one approach—the Merkle–Damg˚ ard transform—for
the second step. Here, we explore a technique for designing the underlying
compression function. We also discuss some hash functions used in prac-
tice. A theoretical construction of a compression function based on a number-
theoretic assumption is given in Section 8.4.2.
6.3.1 Hash Functions from Block Ciphers
Perhaps surprisingly, it is possible to build a collision-resistant compression
function from a blockcipher that satisﬁescertain additional properties. There
are several ways to do this; one of the most common is via the Davies–Meyer
construction . LetFbe a block cipher with n-bit key length and /lscript-bit block
length. We can then deﬁne the compression function h:{0,1}n+/lscript→{0,1}/lscript
byh(k,x)def=Fk(x)⊕x. (See Figure 6.11.)
/MT120
/MT107 /MT70/MT104/MT40/MT107/MT44/MT32/MT120/MT41
FIGURE 6.11 :The Davies–Meyer construction.
We do not know how to prove collision resistance of the resulting compres-
sion function based only on the assumption that Fis a strong pseudorandom
permutation, and in fact there are reasons to believe such a proof is not pos-
sible. We can, however, prove collision resistance if we are willing to model F
as anideal cipher . The ideal-cipher model is a strengthening of the random-
oracle model (see Section 5.5), in which we posit that all parties have access
to an oracle for a random keyed permutation F:{0,1}n×{0,1}/lscript→{0,1}/lscript
as well as its inverse F−1(i.e., such that F−1(k,F(k,x)) =xfor allk,x).
Another way to think of this is that each key k∈{0,1}nspeciﬁes an indepen-
dent, uniform permutation F(k,·) on/lscript-bit strings. As in the random-oracle
model, the onlyway to compute F(orF−1) is to explicitly query the oracle
with (k,x) and receive back F(k,x) (orF−1(k,x)).Practical Constructions of Symmetric-Key Primitives 233
Analyzingconstructions in the ideal-ciphermodel comeswith all the advan-
tages and disadvantages of working in the random-oracle model, as discussed
at length in Section 5.5. We only add here that the ideal-cipher model implies
the absence of related-key attacks , in the sense that (as we have just said) the
permutations F(k,·) andF(k/prime,·) must behave independently even if, for ex-
ample,kandk/primediﬀer in only a single bit. In addition, there can be no “weak
keys”k(say, the all-0 key) for which F(k,·) is easily distinguishable from
random. It also means that F(k,·) should “behave randomly” even when kis
known. For any real-world cipher F, these properties do notnecessarily hold
(and are not even well deﬁned) even if Fis a strong pseudorandom permu-
tation, and the reader may note that we have not discussed these properties
in any of our analysis of real-world block-cipher constructions. (In fact, DES
and triple-DES do not satisfy these properties.) Any block cipher being used
to instantiate an ideal cipher must be evaluated with respect to these more
stringent requirements.
We prove the following theorem in a concrete setting, but the proof could
be adapted easily for the asymptotic setting as well.
THEOREM 6.5 IfFis modeled as an ideal cipher, then the Davies–Meyer
construction yields a collision-resistant compression function. Concretely, any
attacker making q <2/lscript/2queries to its ideal-cipher oracles ﬁnds a collision
with probability at most q2/2/lscript.
PROOF To be clear, we consider here the probabilistic experiment in
whichFis sampled at random (more precisely, for each k∈ {0,1}nthe
function F(k,·) :{0,1}/lscript→{0,1}/lscriptis chosen uniformly from the set Perm/lscriptof
permutations on /lscript-bit strings) and then the attacker is given oracle access to
FandF−1. The attacker then tries to ﬁnd a colliding pair ( k,x), (k/prime,x/prime), i.e.,
for which F(k,x)⊕x=F(k/prime,x/prime)⊕x/prime. No computational bounds areplaced on
the attacker other than bounding the number of oracle queries it makes. We
assume that if the attacker outputs a colliding pair ( k,x),(k/prime,x/prime) then it has
previously made the oracle queries necessary to compute the values F(k,x)
andF(k/prime,x/prime). We also assume the attacker never makes the same query more
than once, and never queries F−1(k,y) once it has learned that y=F(k,x)
(and vice versa). All these assumptions are without loss of generality.
Consider the ith query the attacker makes to its oracles. A query ( ki,xi)
toFreveals only the hash value hidef=h(ki,xi) =F(ki,xi)⊕xi; similarly,
a query to F−1giving the result xi=F−1(ki,yi) yields only the hash value
hidef=h(ki,xi) =yi⊕F−1(ki,yi). The attacker does not obtain a collision
unlesshi=hjfor some i/negationslash=j.
Fixi,jwithi > jand consider the probability that hi=hj. At the
time of the ith query, the value of hjis ﬁxed. A collision between hiand
hjis obtained on the ith query only if the attacker queries ( ki,xi) toFand
obtains the result F(ki,xi) =hj⊕xi, or queries ( ki,yi) toF−1and obtains234 Introduction to Modern Cryptography
the result F−1(ki,yi) =hj⊕yi. Either event occurs with probability at most
1/(2/lscript−(i−1)) since, for example, F(ki,xi) is uniform over {0,1}/lscriptexcept
that it cannot be equal to any value F(ki,x) already deﬁned by the attacker’s
(at most) i−1 previous oracle queries using key ki. Sincei≤q <2/lscript/2, the
probability that hi=hjis at most 2 /2/lscript.
Taking a union bound over all/parenleftbigq
2/parenrightbig
< q2/2 distinct pairs i,jgives the result
stated in the theorem.
Davies–Meyer and DES. Aswe have mentioned above, one must take care
when instantiating the Davies–Meyer construction with any concrete block
cipher, since the cipher must satisfy additional properties (beyond being a
strong pseudorandom permutation) in order for the resulting construction to
be secure. In Exercise 6.21 we explore what goes wrong when DES is used in
the Davies–Meyer construction.
This should serve as a warning that the proof of security for the Davies–
Meyer construction in the ideal-cipher model does not necessarily translate
into real security when instantiated with a real cipher. Nevertheless, as we
will describe below, this paradigm has been used to construct practical hash
functions that have resisted attack (but speciﬁcally when the block cipher at
the center of the construction was designed speciﬁcally for this purpose).
In conclusion, the Davies–Meyer construction is a useful paradigm for con-
structing collision-resistant compression functions. However, it should notbe
applied to block ciphers designed for encryption, like DES and AES.
6.3.2 MD5
MD5 is a hash function with a 128-bit output length. It was designed in
1991 and for some time was believed to be collision resistant. Over a period of
several years, various weaknesses began to be found in MD5 but these did not
appearto lead to anyeasywayto ﬁnd collisions. Shockingly, in 2004a team of
Chinese cryptanalysts presented a new method for ﬁnding collisions in MD5;
they were easily able to convince others that their approach was correct by
demonstrating an explicit collision! Since then, the attack has been improved
and today collisions can be found in under a minute on a desktop PC. In
addition, the attacks have been extended so that even “controlled collisions”
(e.g., two postscript ﬁles generating arbitrary viewable content) can be found.
Due to these attacks, MD5 should not be used anywhere cryptographic se-
curityisneeded. We mentionMD5onlybecauseitisstill foundinlegacycode.
6.3.3 SHA-0, SHA-1, and SHA-2
TheSecure Hash Algorithm (SHA) refers to a series of cryptographic hash
functions standardized by NIST. Perhaps the most well known of these is
SHA-1, which was introduced in 1995. This algorithm has a 160-bit output
length and supplanted a predecessor called SHA-0, which was withdrawn due
to unspeciﬁed ﬂaws discovered in that algorithm.Practical Constructions of Symmetric-Key Primitives 235
At the time of this writing, an explicit collision has yet to be found in
SHA-1. However, theoretical analysis over the past few years indicates that
collisions in SHA-1 can be found using signiﬁcantly fewer than the 280hash-
function evaluations that would be necessary using a birthday attack, and it
is conjectured that a collision will be found soon. It is therefore recommended
to migrate to SHA-2, which does not currently appear to have the same weak-
nesses. SHA-2 is comprised of two related functions: SHA-256 and SHA-512,
with 256- and 512-bit output lengths, respectively.
All hash functions in the SHA family are constructed using the same basic
design, which incorporates components we have already seen: A compres-
sion function is ﬁrst deﬁned by applying the Davies–Meyer construction to
a block cipher, and this is then extended to support arbitrary length inputs
using the Merkle–Damg˚ ard transform. One interesting thing here is that the
block cipher in each case was designed speciﬁcally for building the compres-
sion function. In fact, it was only retroactively that the underlying compo-
nents in the compression functions were isolated and analyzed as the block
ciphers SHACAL-1 (for SHA-1) and SHACAL-2 (for SHA-2). These ciphers
are themselves intriguing, as they have large block lengths (160 and 256 bits,
respectively) and 512-bit keys.
6.3.4 SHA-3 (Keccak)
In the aftermath of the collision attack on MD5 and the theoretical weak-
nesses found in SHA-1, NIST announced in late 2007 a public competition
to design a new cryptographic hash function to be called SHA-3. Submitted
algorithms were required to support at least 256- and 512-bit output lengths.
As in the case of the AES competition from roughly 10 years earlier, the
competition was completely open and transparent; anyone could submit an
algorithm for consideration, and the public was invited to submit their opin-
ions on any of the candidates. The 51 ﬁrst-round candidates were narrowed
down to 14 in December 2008, and these were further reduced to ﬁve ﬁnalists
in 2010. The remaining candidates were subject to intense scrutiny by the
cryptographic community over the next two years. In October 2012, NIST
announced the selection of Keccakas the winner of the competition. As of
the time of this writing, this algorithm is undergoing standardization as the
next-generation replacement for SHA-2.
Keccak is unusual in several respects. (Interestingly, one of the reasons
Keccak was chosen is because its structure is very diﬀerent from that of
SHA-1 and SHA-2.) At its core, it is based on an unkeyed permutation f
with a large block length of 1600 bits; this is radically diﬀerent from, e.g.,
the Davies–Meyer construction, which relies on a keyedpermutation. Fur-
thermore, Keccak does not use the Merkle–Damg˚ ard transform to handle
arbitrary input lengths. Instead, it uses a newer approach called the sponge
construction . Keccak—and the sponge construction more generally—can be
analyzed in the random-permutation model in which we postulate that parties236 Introduction to Modern Cryptography
have access to an oracle for a random permutation f:{0,1}/lscript→{0,1}/lscript(and
possibly its inverse). This is weaker than the ideal-cipher model; indeed, we
can easily obtain a random permutation in the ideal-cipher model by simply
ﬁxing the key to the cipher to be any constant value.
It will be fascinating to watch the new hash standard evolve, and to see
how quickly developers adapt from SHA-1/SHA-2 to the newer SHA-3.
References and Additional Reading
Additional information on LFSRs and stream ciphers can be found in the
Handbook of Applied Cryptography [120] or the more recent text by Paar and
Pelzl [135]. Further details regarding eSTREAM, as well as a detailed spec-
iﬁcation of Trivium, can be found at http://www.ecrypt.eu.org/stream .
See the work of AlFardan et al. [9] for a recent survey of attacks on RC4.
The confusion-diﬀusion paradigm and substitution-permutation networks
were introduced by Shannon [154] and Feistel [64]. See the thesis of Heys [90]
forfurtherinformationregardingSPNdesign. Bettergenericattacksonthree-
round SPNs than what we have shown here are known [31]. Miles and Vi-
ola [126] give a theoretical analysis of SPNs.
Feistel networkswere ﬁrst described in [64]. A theoretical analysis of Feistel
networks was given by Luby and Rackoﬀ [116]; see Chapter 7.
More details on DES, AES, and block-cipher constructions in general can
be found in the text by Knudsen and Robshaw [106]. The meet-in-the-middle
attack on double encryption is due to Diﬃe and Hellman [59]. The attack on
two-keytripleencryptionmentionedinthetext(andexploredinExercise6.13)
is by Merkle and Hellman [124]. Theoretical analysis of the security of double
and triple encryption can be found in [6, 24].
DESX is another technique for increasing the eﬀective key length of DES.
The secret key consists of values ki,ko∈{0,1}64, andk∈{0,1}56, and the
cipher is deﬁned by
DESX ki,k,ko(x)def=ko⊕DESk(x⊕ki).
This methodology was ﬁrst studied by Even and Mansour [63] in a slightly
diﬀerentcontext. ItsapplicationtoDESwasproposedinunpublished workby
Rivest, and its security was later analyzed by Kilian and Rogaway [105, 149].
Diﬀerential cryptanalysis was introduced by Biham and Shamir [29] and
its application to DES is described in a book by those authors [30]. Copper-
smith [45] describes design principles of the DES S-boxes in light of the public
discovery of diﬀerential cryptanalysis. Linear cryptanalysis was discovered by
Matsui [118], who shows its application to DES there. For more information
on these advanced cryptanalytic techniques, we refer the readerto the tutorialPractical Constructions of Symmetric-Key Primitives 237
on diﬀerential and linear cryptanalysis by Heys [91] or to the aforementioned
book by Knudsen and Robshaw [106].
For further information about MD5 and SHA-1 see [120]. Note, however,
thattheirtreatmentpre-datestheattacksbyWangetal.[175,174]. Construc-
tions of compression functions from block ciphers are analyzed in [143, 33].
The sponge construction is described and analyzed by Bertoni et al. [28]. For
additional details about the SHA-3 competition, see the NIST webpage at
http://csrc.nist.gov/groups/ST/hash/sha-3/index.html .
Exercises
6.1Assume a degree-6 LFSR with c0=c5= 1 and c1=c2=c3=c4= 0.
(a) What are the ﬁrst 10 bits output by this LFSR if it starts in initial
state (1,1,1,1,1,1)?
(b) Is this LFSR maximal length?
6.2 In this question we consider a nonlinear combination generator, where
we have a degree- nLFSR but the output at each time step is not s0
but instead g(s0,...,s n−1) for some nonlinear function g. Assume the
feedback coeﬃcients of the LFSR are known, but its initial state is
not. Show that each of the following choices of gdoes not yield a good
pseudorandom generator:
(a)g(s0,...,s n−1) =s0∧s1.
(b)g(s0,...,s n−1) = (s0∧s1)⊕s2.
6.3 LetFbe a block cipher with n-bit key length and block length. Say
thereisakey-recoveryattackon Fthatsucceedswithprobability1using
nchosen plaintexts and minimal computational eﬀort. Prove formally
thatFcannot be a pseudorandom permutation.
6.4 Inourattackonaone-roundSPN,weconsideredablocklengthof64bits
and 16S-boxes that each take a 4-bit input. Repeat the analysis for the
case of 8 S-boxes, each taking an 8-bit input. What is the complexity of
the attack now? Repeat the analysis again with a 128-bit block length
and 16S-boxes that each take an 8-bit input.
6.5 Consider a modiﬁed SPN where instead of carrying out the key-mixing,
substitution, and permutation steps in alternating order for r(full)
rounds, the cipher instead ﬁrst applies rrounds of key mixing, then
carries out rrounds of substitution, and ﬁnally applies rmixing permu-
tations. Analyze the security of this construction.238 Introduction to Modern Cryptography
6.6 In this question we assume a two-round SPN with 64-bit block length.
(a) Assume independent 64-bit sub-keys are used in each round, so the
master key is 192bits long. Show a key-recoveryattackusing much
less than 2192time.
(b) Assume the ﬁrst and third sub-keys are equal, and the second sub-
key is independent, so the master key is 128 bits long. Show a
key-recovery attack using much less than 2128time.
6.7 What is the output of an r-round Feistel network when the input is
(L0,R0) in each of the following two cases:
(a) Each round function outputs all 0s, regardless of the input.
(b) Each round function is the identity function.
6.8 LetFeistel f1,f2(·) denote a two-round Feistel network using functions f1
andf2(in that order). Show that if Feistel f1,f2(L0,R0) = (L2,R2), then
Feistel f2,f1(R2,L2) = (R0,L0).
6.9 For this exercise, rely on the description of DES given in this chapter,
but use the fact that in the actual construction of DES the two halves of
the output of the ﬁnal round of the Feistel network are swapped. That
is, if the output of the ﬁnal round of the Feistel network is ( L16,R16),
then the output of DES is ( R16,L16).
(a) Show that the only diﬀerence between computation of DESkand
DES−1
kis the order in which sub-keys are used. (Rely on the
previous exercise.)
(b) Show that for k= 056it holds that DESk(DESk(x)) =x.
Hint:Consider the sub-keys generated from this key.
(c) Find three other DES keys with the same property. These keys are
known as weak keys for DES. (Note: the keys you ﬁnd will diﬀer
from the actual weak keys of DES because of diﬀerences in our
presentation.)
(d) Do these 4 weak keys represent a serious vulnerability in the use
of triple-DES as a pseudorandom permutation? Explain.
6.10 Show that DES has the property that DESk(x) =DES¯k(¯x)for ev-
ery keykand input x(where ¯zdenotes the bitwise complement of z).
(This is called the complementarity property of DES.) Does this repre-
sent a serious vulnerability in the use of triple-DES as a pseudorandom
permutation? Explain.Practical Constructions of Symmetric-Key Primitives 239
6.11 Describe attacks on the following modiﬁcations to DES:
(a) Each sub-key is 32 bits long, and the round function simply XORs
the sub-key with the input to the round (i.e., ˆf(k,R) =ki⊕R).
For this question, the key schedule is unimportant and you can
treat the sub-keys kias independent keys.
(b) Instead of using diﬀerent sub-keys in every round, the same 48-bit
sub-key is used in every round. Show how to distinguish the cipher
from a random permutation in /lessmuch248time.
Hint:Exercises 6.8 and 6.9 may help...
6.12 (This exercise relies on Exercise 6.9.) Our goal is to show that for any
weak key kof DES, it is easy to ﬁnd an input xsuch that DESk(x) =x.
(a) Assume we evaluate DESkon input ( L0,R0), and the output after
8roundsoftheFeistelnetworkis( L8,R8)withL8=R8. Showthat
the output of DESk(L0,R0) is (L0,R0). (Recall from Exercise 6.9
that DES swaps the two halves of the 16th round of the Feistel
network before outputting the result.)
(b) Show how to ﬁnd an input ( L0,R0) with the property in part (a).
6.13 This question illustrates an attack on two-key triple encryption. Let
Fbe a block cipher with n-bit block length and key length, and set
F/prime
k1,k2(x)def=Fk1(F−1
k2(Fk1(x))).
(a) Assume that given a pair ( m1,m2) it is possible to ﬁnd in constant
time all keys k2such that m2=F−1
k2(m1). Show how to recover
the entire key for F/prime(with high probability) in time roughly 2n
using three known input/output pairs.
(b) In general, it will notbe possible to ﬁnd k2as above in constant
time. However, show that by using a preprocessing step taking 2n
time it is possible, given m2, to ﬁnd in (essentially) constant time
all keysk2such that m2=F−1
k2(0n).
(c) Assume k1is known and that the pre-processing step above has
already been run. Show how to use the value y=F/prime
k1,k2(x) for a
singlechosenplaintext xto determine k2in constant time.
(d) Put the above components together to devise an attack that re-
covers the entire key of F/primeby running in roughly 2ntime and
requesting the encryption of roughly 2nchosen inputs.
6.14 Say the key schedule of DES is modiﬁed as follows: the left half of the
master key is used to derive all the sub-keys in rounds 1–8, while the
right half of the master key is used to derive all the sub-keys in rounds
9–16. Show an attack on this modiﬁed scheme that recovers the entire
key in time roughly 228.240 Introduction to Modern Cryptography
6.15 Let f:{0,1}m×{0,1}/lscript→{0,1}/lscriptandg:{0,1}n×{0,1}/lscript→{0,1}/lscript
be secure block ciphers with m > n, and deﬁne Fk1,k2(x) =fk1(gk2(x)).
Show a key-recovery attack on Fusing timeO(2m) and spaceO(/lscript·2n).
6.16 Deﬁne DESY k,k/prime(x) =DESk(x⊕k/prime). The key length of DESYis 120
bits. Showakey-recoveryattackon DESYtakingtimeandspace ≈264.
6.17 Choose random S-boxes and mixing permutations for SPNs of diﬀerent
sizes, and develop diﬀerential attacks against them. We recommend
trying ﬁve-round SPNs with 16-bit and 24-bit block lengths, using S-
boxes with 4-bit input/output. Write code to compute the diﬀerential
tables, and to carry out the attack.
6.18 Implement the time/space tradeoﬀ for 40-bit DES (i.e., ﬁx the ﬁrst 16
bitsofthekeyofDESto0). Calculatethetimeandmemoryneeded, and
empirically estimate the probability of success. Experimentally verify
the increase in success probability as the number of tables is increased.
(Warning: this is a big project!)
6.19 For each of the following constructions of a compression function hfrom
a block cipher F, either show an attack or prove collision resistance in
the ideal-cipher model:
(a)h(k,x) =Fk(x).
(b)h(k,x) =Fk(x)⊕k⊕x.
(c)h(k,x) =Fk(x)⊕k.
6.20 ConsiderusingDES toconstruct acompressionfunction in the following
way: Deﬁne h:{0,1}112→{0,1}64ash(x1,x2)def=DESx1(DESx2(064))
where|x1|=|x2|= 56.
(a) Write down an explicit collision in h.
Hint:Use Exercise 6.9(a–b).
(b) Show how to ﬁnd a preimage of an arbitraryvalue y(that is,x1,x2
such that h(x1/bardblx2) =y) in roughly 256time.
(c) Show a more clever preimage attack that runs in roughly 232time
and succeeds with high probability.
Hint:Rely on the results of Appendix A.4.
6.21 Let Fbe a block cipher for which it is easy to ﬁnd ﬁxed points for some
key: namely, there is a key kfor which it is easy to ﬁnd inputs xfor
whichFk(x) =x. Find a collision in the Davies–Meyer construction
when applied to F. (Consider this in light of Exercise 6.12.)Chapter 7
*Theoretical Constructions of
Symmetric-Key Primitives
In Chapter3 we introduced the notion of pseudorandomnessand deﬁned some
basic cryptographic primitives including pseudorandom generators, functions,
and permutations. We showed in Chapters 3 and 4 that these primitives serve
as the building blocks for all of private-key cryptography. As such, it is of
great importance to understand these primitives from a theoretical point of
view. In this chapter we formally introduce the concept of one-way func-
tions—functionsthatare,informally,easytocomputebuthardtoinvert—and
show how pseudorandom generators, functions, and permutations can be con-
structed under the sole assumption that one-way functions exist.1Moreover,
we will see that one-way functions are necessary for “non-trivial” private-key
cryptography. That is: the existence of one-way functions is equivalent to
the existence of all (non-trivial) private-key cryptography . This is one of the
major contributions of modern cryptography.
The constructions we show in this chapter should be viewed as comple-
mentary to the constructions of stream ciphers and block ciphers discussed in
the previous chapter. The focus of the previous chapter was on how various
cryptographic primitives are currently realized in practice, and the intent of
that chapter was to introduce some basic approaches and design principles
that are used. Somewhat disappointing, though, was the fact that none of
the constructions we showed could be provensecure based on any weaker
(i.e., more reasonable) assumptions. In contrast, in the present chapter we
will provethat it is possible to construct pseudorandompermutations starting
from the very mild assumption that one-wayfunctions exist. This assumption
is more palatable than assuming, say, that AES is a pseudorandom permuta-
tion, both because it is a qualitatively weakerassumption and also because we
have a number of candidate, number-theoretic one-way functions that have
been studied for many years, even before the advent of cryptography. (See the
very beginning of Chapter 6 for further discussion of this point.) The down-
side, however, is that the constructions we show here are all far less eﬃcient
than those of Chapter 6, and thus are not actually used. It remains an impor-
tant challenge for cryptographers to “bridge this gap” and develop provably
1This is not quite true since we are for the most part going to rely on one-way permutations
in this chapter. But it is known that one-way functions suﬃce.
241242 Introduction to Modern Cryptography
secure constructions of pseudorandom generators, functions, and permuta-
tions whose eﬃciency is comparable to the best available stream ciphers and
block ciphers.
Collision-resistant hash functions. In contrast to the previous chapter,
here we do not consider collision-resistant hash functions. The reason is that
constructionsofsuchhashfunctions fromone-wayfunctionsareunknownand,
in fact, there is evidence suggesting that such constructions are impossible.
We will turn to provable constructions of collision-resistant hash functions—
based on speciﬁc, number-theoretic assumptions—in Section 8.4.2.
A note regarding this chapter. The material in this chapter is somewhat
more advanced than the material in the rest of this book. This material is
not used explicitly elsewhere, and so this chapter can be skipped if desired.
Having said this, we have tried to present the material in such a way that it
is understandable (with eﬀort) to an advanced undergraduate or beginning
graduate student. We encourage all readers to peruse Sections 7.1 and 7.2,
which introduce one-way functions and provide an overview of the rest of this
chapter. We believe that familiarity with at least some of the topics covered
here is important enough to warrant the eﬀort.
7.1 One-Way Functions
Inthis section we formally deﬁne one-way functions, and then brieﬂy dis-
cuss some candidates that are widely believed to satisfy this deﬁnition. (We
will see more examples of conjectured one-way functions in Chapter 8.) We
next introduce the notion of hard-core predicates , which can be viewed as
encapsulating the hardness of inverting a one-way function and will be used
extensively in the constructions that follow in subsequent sections.
7.1.1 Deﬁnitions
A one-way function f:{0,1}∗→{0,1}∗is easy to compute, yet hard to
invert. The ﬁrst condition is easy to formalize: we will simply require that
fbe computable in polynomial time. Since we are ultimately interested in
building cryptographic schemes that are hard for a probabilistic polynomial-
time adversary to break except with negligible probability, we will formalize
the second condition by requiring that it be infeasible for any probabilistic
polynomial-time algorithm to invert f—that is, to ﬁnd a preimage of a given
valuey—except with negligible probability. A technical point is that this
probability is taken over an experiment in which yis generated by choosing a
uniform element xof the domain of fand then setting y:=f(x) (rather than*Theoretical Constructions of Symmetric-Key Primitives 243
choosing yuniformly from the range of f). The reason for this should become
clear from the constructions we will see in the remainder of the chapter.
Letf:{0,1}∗→{0,1}∗be a function. Consider the following experiment
deﬁned for any algorithm Aand any value nfor the security parameter:
The inverting experiment InvertA,f(n)
1. Choose uniform x∈{0,1}n, and compute y:=f(x).
2.Ais given1nandyas input, and outputs x/prime.
3. The output of the experiment is deﬁned to be 1iff(x/prime) =y,
and0otherwise.
We stress thatAneed not ﬁnd the original preimage x; it suﬃces forAto
ﬁnd any value x/primefor which f(x/prime) =y=f(x). We give the security parameter
1ntoAin the second step to stress that Amay run in time polynomial in
the security parameter n, regardless of the length of y.
We can now deﬁne what it means for a function fto be one-way.
DEFINITION 7.1 A function f:{0,1}∗→ {0,1}∗isone-way if the
following two conditions hold:
1.(Easy to compute:) There exists a polynomial-time algorithm Mf
computing f; that is, Mf(x) =f(x)for allx.
2.(Hard to invert:) For every probabilistic polynomial-time algorithm
A, there is a negligible function neglsuch that
Pr[InvertA,f(n) = 1]≤negl(n).
Notation. In this chapter we will often make the probability space more
explicit by subscripting (part of) it in the probability notation. For example,
we can succinctly express the second requirement in the deﬁnition above as
follows: For every probabilistic polynomial-time algorithm A, there exists a
negligible function neglsuch that
Pr
x←{0,1}n/bracketleftbig
A(1n,f(x))∈f−1(f(x))/bracketrightbig
≤negl(n).
(Recall that x←{0,1}nmeans that xis chosen uniformly from {0,1}n.) The
probability above is also taken over the randomness used by A, which here is
left implicit.
Successful inversion of one-way functions. A function that is notone-
way is not necessarily easy to invert all the time (or even “often”). Rather,
the converse of the second condition of Deﬁnition 7.1 is that there exists a
probabilistic polynomial-time algorithm Aand a non-negligible function γ244 Introduction to Modern Cryptography
such thatAinvertsf(x) with probability at least γ(n) (where the probability
is taken over uniform choice of x∈{0,1}nand the randomness of A). This
means, in turn, that there exists a positive polynomial p(·) such that for
inﬁnitely many values of n, algorithmAinvertsfwith probability at least
1/p(n). Thus, if there exists an Athat inverts fwith probability n−10for
all even values of n(but always fails to invert fwhennis odd), then fis
not one-way—even though Aonly succeeds on half the values of n, and only
succeeds with probability n−10(for values of nwhere it succeeds at all).
Exponential-time inversion. Any one-way function can be inverted at any
pointyin exponential time, by simply trying all values x∈{0,1}nuntil a
valuexis found such that f(x) =y. Thus, the existence of one-way functions
is inherently an assumption about computational complexity andcomputa-
tional hardness . That is, it concerns a problem that can be solved in principle
but is assumed to be hard to solve eﬃciently.
One-way permutations. We will often be interested in one-way functions
with additional structural properties. We say a function fislength-preserving
if|f(x)|=|x|for allx. A one-way function that is length-preserving and one-
to-one is called a one-way permutation . Iffis a one-way permutation, then
any value yhas a unique preimage x=f−1(y). Nevertheless, it is still hard
to ﬁndxin polynomial time.
One-way function/permutation families. The above deﬁnitions of one-
way functions and permutations are convenient in that they consider a single
function overan inﬁnite domain and range. However, most candidate one-way
functions and permutations do not ﬁt neatly into this framework. Instead,
there is an algorithm that generates some set of parameters Iwhich deﬁne
a function fI; one-wayness here means essentially that fIshould be one-way
with all but negligible probability over choice of I. Because each value of
Ideﬁnes a diﬀerent function, we now refer to families of one-way functions
(resp., permutations). We give the deﬁnition now, and refer the reader to the
next section for a concrete example. (See also Section 8.4.1.)
DEFINITION 7.2 A tupleΠ = (Gen,Samp,f)of probabilistic polynomial-
time algorithms is a function family if the following hold:
1. Theparameter-generationalgorithmGen , on input 1n, outputsparameters
Iwith|I|≥n. Each value of Ioutput by Gendeﬁnes setsDIandRI
that constitute the domain and range, respectively, of a function fI.
2. ThesamplingalgorithmSamp , on input I, outputsa uniformly distributed
element ofDI.
3. The deterministic evaluationalgorithm f, on input Iandx∈DI, outputs
an element y∈RI. We write this as y:=fI(x).*Theoretical Constructions of Symmetric-Key Primitives 245
Πis apermutation family if for each value of Ioutput by Gen(1n), it holds
thatDI=RIand the function fI:DI→DIis a bijection.
Let Π be a function family. What follows is the natural analogue of the
experiment introduced previously.
The inverting experiment InvertA,Π(n):
1.Gen(1n)is run to obtain I, and then Samp(I)is run to obtain
a uniform x∈DI. Finally, y:=fI(x)is computed.
2.Ais givenIandyas input, and outputs x/prime.
3. The output of the experiment is 1iffI(x/prime) =y.
DEFINITION 7.3 A function/permutation family Π = (Gen,Samp,f)
isone-wayif for all probabilistic polynomial-time algorithms Athere exists a
negligible function neglsuch that
Pr[InvertA,Π(n) = 1]≤negl(n).
Throughout this chapter we work with one-way functions/permutations
over an inﬁnite domain (as in Deﬁnition 7.1), rather than working with fam-
ilies of one-way functions/permutations. This is primarily for convenience,
and does not signiﬁcantly aﬀect any of the results. (See Exercise 7.7.)
7.1.2 Candidate One-Way Functions
One-way functions are of interest only if they exist. We do not know how
to prove they exist unconditionally (this would be a major breakthrough in
complexity theory), so we must conjecture or assume their existence. Such a
conjecture is based on the fact that several natural computational problems
have received much attention, yet still have no polynomial-time algorithm for
solving them. Perhaps the most famous such problem is integer factorization ,
i.e., ﬁnding the prime factors of a large integer. It is easy to multiply two
numbers and obtain their product, but diﬃcult to take a number and ﬁnd its
factors. This leads us to deﬁne the function fmult(x,y) =x·y. If we do not
place any restriction on the lengths of xandy, thenfmultis easy to invert:
with high probability x·ywill beeven, in which case (2 ,xy/2) is an inverse.
This issue can be addressed by restricting the domain of fmultto equal-length
primesxandy. We return to this idea in Section 8.2.
Anothercandidate one-wayfunction, not relyingdirectly on numbertheory,
is based on the subset-sum problem and is deﬁned by
fss(x1,...,x n,J) =/parenleftBig
x1,...,x n,/bracketleftBig/summationtext
j∈Jxjmod 2n/bracketrightBig/parenrightBig
,246 Introduction to Modern Cryptography
where each xiis ann-bit string interpreted as an integer, and Jis ann-
bit string interpreted as specifying a subset of {1,...,n}. Inverting fsson
an output ( x1,...,x n,y) requires ﬁnding a subset J/prime⊆{1,...,n}such that/summationtext
j∈J/primexj=ymod 2n. Students who have studied NP-completeness may re-
callthatthisproblemis NP-complete. Buteven P/negationslash=NPdoesnotimply that
fssis one-way:P/negationslash=NPwould mean that every polynomial-time algorithm
fails to solve the subset-sum problem on at least one input, whereas for fssto
be aone-wayfunction it is required that everypolynomial-timealgorithmfails
to solve the subset-sum problem (at least for certain parameters) almost al-
ways. Thus, our belief that the function above is one-way is based on the lack
of known algorithms to solve this problem even with “small” probability on
random inputs, and not merely on the fact that the problem is NP-complete.
We conclude by showinga family of permutations that is believed to be one-
way. Let Genbe a probabilistic polynomial-time algorithm that, on input 1n,
outputs an n-bit prime palong with a special element g∈{2,...,p−1}. (The
element gshould be a generator ofZ∗
p; see Section 8.3.3.) Let Sampbe an
algorithm that, given pandg, outputs a uniform integer x∈{1,...,p−1}.
Finally, deﬁne
fp,g(x) = [gxmodp].
(The fact that fp,gcan be computed eﬃciently follows from the results in
Appendix B.2.3.) It can be shown that this function is one-to-one, and thus
a permutation. The presumed diﬃculty of inverting this function is based on
the conjectured hardness of the discrete-logarithm problem ; we will have much
more to say about this in Section 8.3.
Finally, we remark that very eﬃcient one-way functions can be obtained
from practical cryptographic constructions such as SHA-1 or AES under the
assumption that they are collision resistant or a pseudorandom permutation,
respectively; seeExercises7.4and7.5. (Technicallyspeaking, theycannotsat-
isfy the deﬁnition of one-wayness since they have ﬁxed-length input/output
and so we cannot look at their asymptotic behavior. Nevertheless, it is plau-
sible to conjecture that they are one-way in a concrete sense.)
7.1.3 Hard-Core Predicates
By deﬁnition, a one-wayfunction is hard to invert. Stated diﬀerently: given
y=f(x), the value xcannot be computed in its entirety by any polynomial-
time algorithm (except with negligible probability; we ignore this here). One
might get the impression that nothing about xcan be determined from f(x)
in polynomial time. This is notnecessarily the case. Indeed, it is possible for
f(x) to “leak” a lot of information about xeven iffis one-way. For a trivial
example, let gbeaone-wayfunctionanddeﬁne f(x1,x2)def= (x1,g(x2)), where
|x1|=|x2|. It is easy to show that fis also a one-way function (this is left as
an exercise), even though it reveals half its input.*Theoretical Constructions of Symmetric-Key Primitives 247
For our applications, we will need to identify a speciﬁc piece of information
aboutxthat is “hidden” by f(x). This motivates the notion of a hard-core
predicate . A hard-core predicate hc:{0,1}∗→{0,1}of a function fhas the
property that hc(x) is hard to compute with probability signiﬁcantly better
than 1/2 givenf(x). (Since hcis a boolean function, it is always possible to
compute hc(x) with probability 1 /2 by random guessing.) Formally:
DEFINITION 7.4 A function hc:{0,1}∗→{0,1}is ahard-core predi-
cate of a function fifhccan be computed in polynomial time, and for every
probabilistic polynomial-time algorithm Athere is a negligible function negl
such that
Pr
x←{0,1}n[A(1n,f(x)) =hc(x)]≤1
2+negl(n),
where the probability is taken over the uniform choice of xin{0,1}nand the
randomness ofA.
We stress that hc(x) is eﬃciently computable given x(since the function
hccan be computed in polynomial time); the deﬁnition requires that hc(x)
is hard to compute given f(x). The above deﬁnition does not require fto
be one-way; if fis a permutation, however, then it cannot have a hard-core
predicate unless it is one-way. (See Exercise 7.13.)
Simple ideas don’t work. Consider the predicate hc(x)def=/circleplustextn
i=1xiwhere
x1,...,x ndenote the bits of x. One might hope that this is a hard-core
predicate of any one-way function f: iffcannot be inverted, then f(x) must
hide at least one of the bits xiof its preimage x, which would seem to imply
that the exclusive-or of all of the bits of xis hard to compute. Despite its
appeal, this argument is incorrect. To see this, let gbe a one-way function
and deﬁne f(x)def= (g(x),/circleplustextn
i=1xi). It is not hard to show that fis one-way.
However, it is clear that f(x) does not hide the value of hc(x) =/circleplustextn
i=1xi
because this is part of its output; therefore, hc(x) is not a hard-core predicate
off. Extending this, one can show that for any ﬁxed predicate hc, there is a
one-way function ffor which hcis not a hard-core predicate of f.
Trivial hard-core predicates. Some functions have “trivial” hard-core
predicates. For example, let fbe the function that drops the last bit of
its input (i.e., f(x1···xn) =x1···xn−1). It is hard to determine xngiven
f(x) sincexnis independent of the output; thus, hc(x) =xnis a hard-core
predicate of f. However, fis not one-way. When we use hard-core predicates
for our constructions, it will become clear why trivial hard-core predicates of
this sort are of no use.248 Introduction to Modern Cryptography
7.2 From One-Way Functions to Pseudorandomness
The goal of this chapter is to show how to construct pseudorandom genera-
tors,functions,andpermutationsbasedonanyone-wayfunction/permutation.
In this section, we give an overview of these constructions. Details are given
in the sections that follow.
A hard-core predicate from any one-way function. The ﬁrst step is
to show that a hard-core predicate exists for any one-way function. Actually,
it remains open whether this is true; we show something weaker that suﬃces
for our purposes. Namely, we show that given a one-way function fwe can
construct a diﬀerent one-wayfunction galong with a hard-corepredicate of g.
THEOREM 7.5 (Goldreich–Levin theorem) Assume one-way func-
tions (resp., permutations) exist. Then there exists a one-way function (resp.,
permutation) gand a hard-core predicate hcofg.
Letfbe a one-way function. Functions gandhcare constructed as follows:
setg(x,r)def= (f(x),r), for|x|=|r|, and deﬁne
hc(x,r)def=n/circleplusdisplay
i=1xi·ri,
wherexi(resp.,ri) denotes the ith bit of x(resp.,r). Notice that if ris
uniform, then hc(x,r) outputs the exclusive-or of a random subset of the bits
ofx. (When ri= 1 the bit xiis included in the XOR, and otherwise it is
not.) The Goldreich–Levin theorem essentially states that if fis a one-way
function then f(x) hides the exclusive-or of a random subset of the bits of x.
Pseudorandom generators from one-way permutations. The next step
is to show how a hard-core predicate of a one-way permutation can be used to
construct a pseudorandom generator. (It is known that a hard-core predicate
of a one-way function suﬃces, but the proof is extremely complicated and
well beyond the scope of this book.) Speciﬁcally, we show:
THEOREM 7.6 Letfbe a one-way permutation and let hcbe a hard-core
predicate of f. Then,G(s)def=f(s)/bardblhc(s)is a pseudorandom generator with
expansion factor /lscript(n) =n+1.
As intuition for why Gas deﬁned in the theorem constitutes a pseudoran-
dom generator, note ﬁrst that the initial nbits of the output of G(s) (i.e., the
bits off(s)) aretrulyuniformly distributed when sis uniformly distributed,
by virtue of the fact that fis a permutation. Next, the fact that hcis a
hard-core predicate of fmeans that hc(s) “looks random”—i.e., is pseudo-*Theoretical Constructions of Symmetric-Key Primitives 249
random—even given f(s) (assuming again that sis uniform). Putting these
observations together, we see that the entire output of Gis pseudorandom.
Pseudorandom generators with arbitrary expansion. The existence of
a pseudorandom generator that stretches its seed by even a single bit (as we
have just seen) is already highly non-trivial. But for applications (e.g., for
eﬃcient encryption of large messages as in Section 3.3), we need a pseudoran-
dom generator with much larger expansion. Fortunately, we can obtain any
polynomial expansion factor we want:
THEOREM 7.7 If there exists a pseudorandom generator with expansion
factor/lscript(n) =n+1, then for any polynomial polythere exists a pseudorandom
generator with expansion factor poly(n).
We conclude that pseudorandom generators with arbitrary (polynomial)
expansion can be constructed from any one-way permutation.
Pseudorandom functions/permutations from pseudorandom gener-
ators.Pseudorandom generators suﬃce for constructing EAV-secure private-
key encryption schemes. For achieving CPA-secure private-key encryption
(not to mention message authentication codes), however, we relied on pseu-
dorandom functions. The following result shows that the latter can be con-
structed from the former:
THEOREM 7.8 If there exists a pseudorandom generator with expansion
factor/lscript(n) = 2n, then there exists a pseudorandom function.
In fact, we can do even more:
THEOREM 7.9 If there exists a pseudorandom function, then there exists
a strong pseudorandom permutation.
Combining all the above theorems, as well as the results of Chapters 3
and 4, we have the following corollaries:
COROLLARY 7.10 Assuming the existence of one-way permutations,
there exist pseudorandom generators with any polynomial expansion factor,
pseudorandom functions, and strong pseudorandom permutations.
COROLLARY 7.11 Assuming the existence of one-way permutations,
there exist CCA-secure private-key encryption schemes and secure message
authentication codes.
As noted earlier, it is possible to obtain all these results based solely on the
existence of one-way functions .250 Introduction to Modern Cryptography
7.3 Hard-Core Predicates from One-Way Functions
Inthis section, we prove Theorem 7.5 by showing the following:
THEOREM 7.12 Letfbe a one-way function and deﬁne gbyg(x,r)def=
(f(x),r), where|x|=|r|. Deﬁne gl(x,r)def=/circleplustextn
i=1xi·ri, wherex=x1···xn
andr=r1···rn. Thenglis a hard-core predicate of g.
Due to the complexity of the proof, we prove three successively stronger
results culminating in what is claimed in the theorem.
7.3.1 A Simple Case
We ﬁrst show that if there exists a polynomial-time adversary Athatal-
wayscorrectly computes gl(x,r) giveng(x,r) = (f(x),r), then it is possible
to invert fin polynomial time. Given the assumption that fis a one-way
function, it follows that no such adversary Aexists.
PROPOSITION 7.13 Letfandglbe as in Theorem 7.12. If there exists
a polynomial-time algorithm Asuch thatA(f(x),r) =gl(x,r)for allnand
allx,r∈{0,1}n, then there exists a polynomial-time algorithm A/primesuch that
A/prime(1n,f(x)) =xfor allnand allx∈{0,1}n.
PROOF We constructA/primeas follows.A/prime(1n,y) computes xi:=A(y,ei)
fori= 1,...,n, whereeidenotes the n-bit string with 1 in the ith position
and 0 everywhere else. Then A/primeoutputsx=x1···xn. ClearlyA/primeruns in
polynomial time.
In the execution of A/prime(1n,f(ˆx)), the value xicomputed byA/primesatisﬁes
xi=A(f(ˆx),ei) =gl(ˆx,ei) =n/circleplusdisplay
j=1ˆxj·ei
j= ˆxi.
Thus,xi= ˆxifor alliand soA/primeoutputs the correct inverse x= ˆx.
Iffisone-way, it is impossible for any probabilistic polynomial-time al-
gorithm to invert fwith non-negligible probability. Thus, we conclude that
there is no polynomial-time algorithm that always correctly computes gl(x,r)
from (f(x),r). This is a rather weak result that is very far from our ultimate
goal of showing that gl(x,r) cannot be computed (with probability signiﬁ-
cantly better than 1 /2) given ( f(x),r).*Theoretical Constructions of Symmetric-Key Primitives 251
7.3.2 A More Involved Case
We now show that it is hard for any probabilistic polynomial-time algo-
rithmAtocompute gl(x,r) from(f(x),r) with probabilitysigniﬁcantlybetter
than 3/4. We will again show that any such Awould imply the existence of a
polynomial-time algorithm A/primethat inverts fwith non-negligible probability.
Notice that the strategy in the proof of Proposition 7.13 fails here because it
may be thatAneversucceeds when r=ei(although it may succeed, say,
on all other values of r). Furthermore, in the present case A/primedoes not know
if the resultA(f(x),r) is equal to gl(x,r) or not; the only thing A/primeknows is
that with high probability, algorithm Ais correct. This further complicates
the proof.
PROPOSITION 7.14 Letfandglbe as in Theorem 7.12. If there exists
a probabilistic polynomial-time algorithm Aand a polynomial p(·)such that
Pr
x,r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
≥3
4+1
p(n)
for inﬁnitely many values of n, then there exists a probabilistic polynomial-
time algorithmA/primesuch that
Pr
x←{0,1}n/bracketleftbig
A/prime(1n,f(x))∈f−1(f(x))/bracketrightbig
≥1
4·p(n)
for inﬁnitely many values of n.
PROOF The main observation underlying the proof of this proposition is
that for every r∈{0,1}n, the values gl(x,r⊕ei) andgl(x,r) together can be
used to compute the ith bit of x. (Recall that eidenotes the n-bit string with
0s everywhere except the ith position.) This is true because
gl(x,r)⊕gl(x,r⊕ei)
=
n/circleplusdisplay
j=1xj·rj
⊕
n/circleplusdisplay
j=1xj·(rj⊕ei
j)
=xi·ri⊕/parenleftbig
xi·¯ri/parenrightbig
=xi,
where ¯riis the complement of ri, and the second equality is due to the fact
that forj/negationslash=i, the value xj·rjappears in both sums and so is canceled out.
The above demonstrates that if Aanswers correctly on both ( f(x),r) and
(f(x),r⊕ei), thenA/primecan correctly compute xi. Unfortunately,A/primedoes not
know whenAanswers correctly and when it does not; A/primeknows only thatA
answerscorrectlywith “high”probability. Forthis reason, A/primewillusemultiple
random values of r, using each one to obtain an estimate of xi, and will then
take the estimate occurring a majority of the time as its ﬁnal guess for xi.252 Introduction to Modern Cryptography
As a preliminary step, we show that for many x’s the probability that A
answers correctly for both ( f(x),r) and (f(x),r⊕ei), whenris uniform, is
suﬃciently high. This allows us to ﬁx xand then focus solely on uniform
choice of r, which makes the analysis easier.
CLAIM 7.15 Letnbe such that
Pr
x,r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
≥3
4+1
p(n).
Then there exists a set Sn⊆{0,1}nof size at least1
2p(n)·2nsuch that for
everyx∈Snit holds that
Pr
r←{0,1}n[A(f(x),r) =gl(x,r)]≥3
4+1
2p(n).
PROOF Letε(n) = 1/p(n), and deﬁne Sn⊆{0,1}nto be the set of all
x’s for which
Pr
r←{0,1}n[A(f(x),r) =gl(x,r)]≥3
4+ε(n)
2.
Wehave
Pr
x,r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
=1
2n/summationdisplay
x∈{0,1}nPr
r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
=1
2n/summationdisplay
x∈SnPr
r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
+1
2n/summationdisplay
x/negationslash∈SnPr
r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
≤|Sn|
2n+1
2n·/summationdisplay
x/negationslash∈Sn/parenleftbigg3
4+ε(n)
2/parenrightbigg
≤|Sn|
2n+/parenleftbigg3
4+ε(n)
2/parenrightbigg
.
Since3
4+ε(n)≤Prx,r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
, straightforward algebra
gives|Sn|≥ε(n)
2·2n.
The following now follows as an easy consequence.
CLAIM 7.16 Letnbe such that
Pr
x,r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
≥3
4+1
p(n).*Theoretical Constructions of Symmetric-Key Primitives 253
Then there exists a set Sn⊆{0,1}nof size at least1
2p(n)·2nsuch that for
everyx∈Snand every iit holds that
Pr
r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/logicalanddisplay
A(f(x),r⊕ei) =gl(x,r⊕ei)/bracketrightBig
≥1
2+1
p(n).
PROOF Letε(n) = 1/p(n), and take Snto be the set guaranteed by the
previous claim. We know that for any x∈Snwe have
Pr
r←{0,1}n[A(f(x),r)/negationslash=gl(x,r)]≤1
4−ε(n)
2.
Fixi∈{1,...,n}. Ifris uniformly distributed then so is r⊕ei; thus
Pr
r←{0,1}n[A(f(x),r⊕ei)/negationslash=gl(x,r⊕ei)]≤1
4−ε(n)
2.
Weareinterestedinlower-boundingtheprobabilitythat Aoutputsthecorrect
answer for bothgl(x,r) andgl(x,r⊕ei); equivalently, we want to upper-bound
the probability that Afails to output the correct answer in eitherof these
cases. Note that randr⊕eiare not independent, so we cannot just multiply
the probabilities of failure. However, we can apply the union bound (see
Proposition A.7) and sum the probabilities of failure. That is, the probability
thatAisincorrect on either gl(x,r) orgl(x,r⊕ei) is at most
/parenleftbigg1
4−ε(n)
2/parenrightbigg
+/parenleftbigg1
4−ε(n)
2/parenrightbigg
=1
2−ε(n),
and soAis correct on bothgl(x,r) andgl(x,r⊕ei) with probability at least
1/2+ε(n). This proves the claim.
Forthe restofthe proofwe set ε(n)=1/p(n)and consideronly thosevalues
ofnfor which
Pr
x,r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
≥3
4+ε(n). (7.1)
The previous claim states that for an ε(n)/2 fraction of inputs x, and any i,
algorithmAanswers correctly on both ( f(x),r) and (f(x),r⊕ei) with prob-
ability at least 1 /2+ε(n) over uniform choice of r, and from now on we focus
only on such values of x. We construct a probabilistic polynomial-time algo-
rithmA/primethat inverts f(x) with probability at least 1 /2 whenx∈Sn. This
suﬃces to prove Proposition 7.14 since then, for inﬁnitely many values of n,
Pr
x←{0,1}n[A/prime(1n,f(x))∈f−1(f(x))]
≥Pr
x←{0,1}n[A/prime(1n,f(x))∈f−1(f(x))|x∈Sn]·Pr
x←{0,1}n[x∈Sn]
≥1
2·ε(n)
2=1
4p(n).254 Introduction to Modern Cryptography
AlgorithmA/prime, given as input 1nandy, works as follows:
1. Fori= 1,...,ndo:
•Repeatedly choose a uniform r∈{0,1}nand computeA(y,r)⊕
A(y,r⊕ei) as an “estimate” for the ith bit of the preimage of y.
After doing this suﬃciently many times (see below), let xibe the
“estimate” that occurs a majority of the time.
2. Output x=x1···xn.
We sketch an analysis of the probability that A/primecorrectly inverts its given
inputy. (We allow ourselves to be a bit laconic, since a full proof for a more
diﬃcult caseis givenin the followingsection.) Say y=f(ˆx) and recallthat we
assume here that nis such that Equation (7.1) holds and ˆ x∈Sn. Fix some i.
The previous claim implies that the estimate A(y,r)⊕A(y,r⊕ei) is equal
togl(ˆx,ei) with probability at least1
2+ε(n)over choice of r. By obtaining
suﬃciently many estimatesand letting xibe the majorityvalue, A/primecanensure
thatxiis equal to gl(ˆx,ei) with probability at least 1 −1
2n.Of course, we
need to makesure that polynomiallymany estimatesareenough. Fortunately,
sinceε(n) = 1/p(n) for some polynomial pand an independent value of ris
used for obtaining each estimate, the Chernoﬀ bound (cf. Proposition A.14)
shows that polynomially many estimates suﬃce.
Summarizing, we have that for each ithe value xicomputed byA/primeis in-
correct with probability at most1
2n.Aunion bound thus shows that A/primeis
incorrect for someiwith probability at most n·1
2n=1
2.That is,A/primeis correct
for alli—and thus correctly inverts y—with probability at least 1 −1
2=1
2.
This completes the proof of Proposition 7.14.
A corollary of Proposition 7.14 is that if fisaone-way function, then for
any polynomial-time algorithm Athe probability that Acorrectly guesses
gl(x,r) when given ( f(x),r) is at most negligibly more than 3 /4.
7.3.3 The Full Proof
We assume familiarity with the simpliﬁed proofs in the previous sections,
and build on the ideas developed there. We rely on some terminology and
standard results from probability theory discussed in Appendix A.3.
We prove the following proposition, which implies Theorem 7.12:
PROPOSITION 7.17 Letfandglbe as in Theorem 7.12. If there exists
a probabilistic polynomial-time algorithm Aand a polynomial p(·)such that
Pr
x,r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
≥1
2+1
p(n)*Theoretical Constructions of Symmetric-Key Primitives 255
for inﬁnitely many values of n, then there exists a probabilistic polynomial-
time algorithmA/primeand a polynomial p/prime(·)such that
Pr
x←{0,1}n/bracketleftbig
A/prime(1n,f(x))∈f−1(f(x))/bracketrightbig
≥1
p/prime(n)
for inﬁnitely many values of n.
PROOF Once again we set ε(n) = 1/p(n) and consider only those values
ofnfor which Pr x,r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
≥1
2+1
p(n).The following
is analogous to Claim 7.15 and is proved in the same way.
CLAIM 7.18 Letnbe such that
Pr
x,r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/bracketrightBig
≥1
2+ε(n).
Then there exists a set Sn⊆{0,1}nof size at leastε(n)
2·2nsuch that for every
x∈Snit holds that
Pr
r←{0,1}n[A(f(x),r) =gl(x,r)]≥1
2+ε(n)
2. (7.2)
If we start by trying to prove an analogue of Claim 7.16, the best we can
claim here is that when x∈Snwe have
Pr
r←{0,1}n/bracketleftBig
A(f(x),r) =gl(x,r)/logicalanddisplay
A(f(x),r⊕ei) =gl(x,r⊕ei)/bracketrightBig
≥ε(n)
for anyi. Thus, if we try to use A(f(x),r)⊕A(f(x),r⊕ei) as an estimate
forxi, all we can claim is that this estimate will be correct with probability
at leastε(n), which may not be any better than taking a random guess! We
cannot claim that ﬂipping the result gives a good estimate, either.
Instead,wedesign A/primesothatitcomputes gl(x,r)andgl(x,r⊕ei)byinvoking
Aonly once. We do this by having A/primerunA(x,r⊕ei), and havingA/primesimply
“guess” the value gl(x,r) itself. The naive way to do this would be to choose
ther’s independently, as before, and to have A/primemake an independent guess
ofgl(x,r) for each value of r. But then the probability that all such guesses
are correct—which, as we will see, is necessary if A/primeis to output the correct
inverse—would be negligible because polynomially many r’s are used.
The crucial observation of the present proof is that A/primecan generate the r’s
in apairwise-independent manner and make its guesses in a particular way so
that with non-negligible probability all its guesses are correct. Speciﬁcally, in
order to generate mvalues of r, we haveA/primeselect/lscript=⌈log(m+1)⌉indepen-
dent and uniformly distributed strings s1,...,s/lscript∈{0,1}n. Then, for every
nonempty subset I⊆{1,...,/lscript}, we setrI:=⊕i∈Isi. Since there are 2/lscript−1256 Introduction to Modern Cryptography
nonempty subsets, this deﬁnes a collection of 2⌈log(m+1)⌉−1≥mstrings.
Each such string is uniformly distributed. The strings are not independent,
but they arepairwise independent. To see this, notice that for every two
subsetsI/negationslash=Jthere is an index j∈I∪Jsuch that j /∈I∩J. Without loss of
generality, assume j/negationslash∈I. Then the value of sjis uniform and independent of
the value of rI. Sincesjis included in the XOR that deﬁnes rJ, this implies
thatrJis uniform and independent of rIas well.
We now have the following two important observations:
1. Given gl(x,s1),...,gl(x,s/lscript), it is possible to compute gl(x,rI) for every
subsetI⊆{1,...,/lscript}. This is because
gl(x,rI) =gl(x,⊕i∈Isi) =⊕i∈Igl(x,si).
2. IfA/primesimply guesses the values of gl(x,s1),...,gl(x,s/lscript) by choosing a
uniform bit for each, then allthese guesses will be correct with proba-
bility 1/2/lscript. Ifmis polynomial in the security parameter n, then 1/2/lscriptis
not negligible, and sowith non-negligible probability A/primecorrectlyguesses
all the values gl(x,s1),...,gl(x,s/lscript).
Combining the above yields a way of obtaining m=poly(n) uniform and
pairwise-independent strings {rI}along with correctvalues for{gl(x,rI)}
with non-negligible probability. These values can then be used to compute xi
in the same way as in the proof of Proposition 7.14. Details follow.
The inversion algorithm A/prime.We now provide a full description of an
algorithmA/primethat receives inputs 1n,yand tries to compute an inverse of y.
The algorithm proceeds as follows:
1. Set/lscript:=⌈log(2n/ε(n)2+1)⌉.
2. Chooseuniform, independent s1,...,s/lscript∈{0,1}nandσ1,...,σ/lscript∈{0,1}.
3. For every nonempty subset I⊆{1,...,/lscript}, compute rI:=⊕i∈Isiand
σI:=⊕i∈Iσi.
4. Fori= 1,...,ndo:
(a) For every nonempty subset I⊆{1,...,/lscript}, set
xI
i:=σI⊕A(y,rI⊕ei).
(b) Setxi:=majorityI{xI
i}(i.e., take the bit that appeared a majority
of the time in the previous step).
5. Output x=x1···xn.*Theoretical Constructions of Symmetric-Key Primitives 257
It remains to compute the probability that A/primeoutputs x∈f−1(y). As
in the proof of Proposition 7.14, we focus only on nas in Claim 7.18 and
assumey=f(ˆx) for some ˆ x∈Sn. Eachσirepresents a “guess” for the value
ofgl(ˆx,si). As noted earlier, with non-negligible probability all these guesses
are correct; we show that conditioned on this event, A/primeoutputsx= ˆxwith
probability at least 1 /2.
Assume σi=gl(ˆx,si) for all i. ThenσI=gl(ˆx,rI) for all I. Fix an in-
dexi∈{1,...,n}and consider the probability that A/primeobtains the correct
valuexi= ˆxi. For any nonempty Iwe haveA(y,rI⊕ei) =gl(ˆx,rI⊕ei) with
probability at least1
2+ε(n)/2over choice of r; this follows because ˆ x∈Sn
andrI⊕eiis uniformly distributed. Thus, for any nonempty subset Iwe have
Pr[xI
i= ˆxi]≥1
2+ε(n)/2.Moreover, the{xI
i}I⊆{1,...,/lscript}are pairwise indepen-
dent because the {rI}I⊆{1,...,/lscript}(and hence the{rI⊕ei}I⊆{1,...,/lscript}) are pairwise
independent. Since xiis deﬁned to be the value that occurs a majority of the
time among the{xI
i}I⊆{1,...,/lscript}, we can apply Proposition A.13 to obtain
Pr[xi/negationslash= ˆxi]≤1
4·(ε(n)/2)2·(2/lscript−1)
≤1
4·(ε(n)/2)2·(2n/ε(n)2)
=1
2n.
The above holds for all i, so by applying a union bound we see that the
probability that xi/negationslash= ˆxiforsomeiis at most 1 /2. That is, xi= ˆxiforalli
(and hence x= ˆx) with probability at least 1 /2.
Putting everything together: Let nbe as in Claim 7.18 and y=f(ˆx). With
probability at least ε(n)/2 we have ˆ x∈Sn. All the guesses σiare correct
with probability at least
1
2/lscript≥1
2·(2n/ε(n)2+1)>ε(n)2
5n
fornsuﬃciently large. Conditioned on both the above, A/primeoutputs x= ˆx
with probability at least 1 /2. The overall probability with which A/primeinverts
its input is thus at least ε(n)3/20n= 1/(20np(n)3) for inﬁnitely many n.
Since 20 np(n)3is polynomial in n, this proves Proposition 7.17.
7.4 Constructing Pseudorandom Generators
Weﬁrst show how to construct pseudorandom generators that stretch their
input by a single bit, under the assumption that one-way permutations exist.
We then show how to extend this to obtain any polynomial expansion factor.258 Introduction to Modern Cryptography
7.4.1 Pseudorandom Generators with Minimal Expansion
Letfbe a one-way permutation with hard-core predicate hc. This means
thathc(s)“looksrandom”given f(s), whensisuniform. Furthermore,since f
isapermutation, f(s)itselfisuniformlydistributed. (Applyingapermutation
to a uniformly distributed value yields a uniformly distributed value.) So if s
is a uniform n-bit string, the ( n+1)-bit string f(s)/bardblhc(s) consists of a uniform
n-bit string plus on additional bit that looks uniform even conditioned on the
initialnbits; in other words, this ( n+1)-bit string is pseudorandom . Thus,
the algorithm Gdeﬁned by G(s) =f(s)/bardblhc(s) is a pseudorandom generator.
THEOREM 7.19 Letfbe a one-way permutation with hard-core predi-
catehc. Then algorithm Gdeﬁned by G(s) =f(s)/bardblhc(s)is a pseudorandom
generator with expansion factor /lscript(n) =n+1.
PROOF LetDbe a probabilistic polynomial-time algorithm. We prove
that there is a negligible function neglsuch that
Pr
r←{0,1}n+1[D(r) = 1]−Pr
s←{0,1}n[D(G(s)) = 1]≤negl(n).(7.3)
A similar argument shows that there is a negligible function negl/primefor which
Pr
s←{0,1}n[D(G(s)) = 1]−Pr
r←{0,1}n+1[D(r) = 1]≤negl/prime(n),
which completes the proof.
Observe ﬁrst that
Pr
r←{0,1}n+1[D(r) = 1] = Pr
r←{0,1}n,r/prime←{0,1}[D(r/bardblr/prime) = 1]
= Pr
s←{0,1}n,r/prime←{0,1}[D(f(s)/bardblr/prime) = 1]
=1
2·Pr
s←{0,1}n[D/parenleftbig
f(s)/bardblhc(s)/parenrightbig
= 1]
+1
2·Pr
s←{0,1}n[D/parenleftbig
f(s)/bardblhc(s)/parenrightbig
=1],
using the fact that fis a permutation for the second equality, and that a
uniform bit r/primeis equal to hc(s) with probability exactly 1 /2 for the third
equality. Since
Pr
s←{0,1}n[D(G(s)) = 1] = Pr
s←{0,1}n[D(f(s)/bardblhc(s)) = 1]
(by deﬁnition of G), this means that Equation (7.3) is equivalent to
1
2·/parenleftbigg
Pr
s←{0,1}n[D/parenleftbig
f(s)/bardblhc(s)/parenrightbig
=1]−Pr
s←{0,1}n[D/parenleftbig
f(s)/bardblhc(s)/parenrightbig
= 1]/parenrightbigg
≤negl(n).*Theoretical Constructions of Symmetric-Key Primitives 259
Consider the following algorithm Athat is given as input a value y=f(s)
and tries to predict the value of hc(s):
1. Choose uniform r/prime∈{0,1}.
2. RunD(y/bardblr/prime). IfDoutputs 0, output r/prime; otherwise output ¯ r/prime.
ClearlyAruns in polynomial time. By deﬁnition of A, we have
Pr
s←{0,1}n[A(f(s)) =hc(s)]
=1
2·Pr
s←{ 0,1}n[A(f(s)) =hc(s)|r/prime=hc(s)]
+1
2·Pr
s←{0,1}n[A(f(s)) =hc(s)|r/prime/negationslash=hc(s)]
=1
2·/parenleftbigg
Pr
s←{ 0,1}n[D(f(s)/bardblhc(s)) = 0]+ Pr
s←{0,1}n[D(f(s)/bardblhc(s)) = 1]/parenrightbigg
=1
2·/parenleftbigg/parenleftbigg
1−Pr
s←{0,1}n[D(f(s)/bardblhc(s)) = 1]/parenrightbigg
+ Pr
s←{0,1}n[D(f(s)/bardblhc(s)) = 1]/parenrightbigg
=1
2+1
2·/parenleftbigg
Pr
s←{ 0,1}n[D(f(s)/bardblhc(s)) = 1]−Pr
s←{0,1}n[D(f(s)/bardblhc(s)) = 1]/parenrightbigg
.
Sincehcis a hard-core predicate of f, it follows that there exists a negligible
function neglfor which
1
2·/parenleftbigg
Pr
s←{ 0,1}n[D/parenleftbig
f(s)/bardblhc(s)/parenrightbig
=1]−Pr
s←{0,1}n[D/parenleftbig
f(s)/bardblhc(s)/parenrightbig
= 1]/parenrightbigg
≤negl(n),
as desired.
7.4.2 Increasing the Expansion Factor
Wenowshowthatthe expansionfactorofapseudorandomgeneratorcanbe
increased by any desired (polynomial) amount. This means that the previous
construction, with expansion factor /lscript(n) =n+1, suﬃces for constructing a
pseudorandom generator with arbitrary (polynomial) expansion factor.
THEOREM 7.20 If there exists a pseudorandom generator Gwith expan-
sion factor n+1, then for any polynomial polythere exists a pseudorandom
generator ˆGwith expansion factor poly(n).
PROOF We ﬁrst consider constructing a pseudorandom generator ˆGthat
outputsn+2 bits. ˆGworks as follows: Given an initial seed s∈{0,1}n, it260 Introduction to Modern Cryptography
computes t1:=G(s) to obtain n+ 1 pseudorandom bits. The initial nbits
oft1are then used again as a seed for G; the resulting n+1 bits, concatenated
with the ﬁnal bit of t1, yield the ( n+ 2)-bit output. (See Figure 7.1.) The
second application of Guses a pseudorandom seed rather than a random
one. The proof of security we give next shows that this does not impact the
pseudorandomness of the output.
We now prove that ˆGis a pseudorandom generator. Deﬁne three sequences
of distributions{H0
n}n=1,...,{H1
n}n=1,..., and{H2
n}n=1,..., where each of H0
n,
H1
n, andH2
nis a distribution on strings of length n+2. In distribution H0
n, a
uniform string t0∈{0,1}nis chosen and the output is ˆG(t0). In distribution
H1
n, a uniform string t1∈{0,1}n+1is chosen and parsed as s1/bardblσ1(wheres1
aretheinitial nbitsoft1andσ1istheﬁnalbit). Theoutputis t2:=G(s1)/bardblσ1.
In distribution H2
n, the output is a uniform string t2∈{0,1}n+2. We denote
byt2←Hi
nthe process of generating an ( n+ 2)-bit string t2according to
distribution Hi
n.
Fix an arbitrary probabilistic polynomial-time distinguisher D. We ﬁrst
claim that there is a negligible function negl/primesuch that
/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
t2←H0n[D(t2) = 1]−Pr
t2←H1n[D(t2) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle≤negl/prime(n). (7.4)
To see this, consider the polynomial-time distinguisher D/primethat, on input
t1∈{0,1}n+1, parses t1ass1/bardblσ1with|s1|=n, computes t2:=G(s1)/bardblσ1,
and outputs D(t2). Clearly D/primeruns in polynomial time. Observe that:
1. Ift1is uniform, the distribution on t2generated by D/primeis exactly that
of distribution H1
n. Thus,
Pr
t1←{0,1}n+1[D/prime(t1) = 1] = Pr
t2←H1
n[D(t2) = 1].
2. Ift1=G(s) for uniform s∈{0,1}n, the distribution on t2generated by
D/primeis exactly that of distribution H0
n. That is,
Pr
s←{0,1}n[D/prime(G(s)) = 1] = Pr
t2←H0n[D(t2) = 1].
Pseudorandomness of Gimplies that there is a negligible function negl/primewith
/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
s←{0,1}n[D/prime(G(s)) = 1]−Pr
t1←{0,1}n+1[D/prime(t1) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle≤negl/prime(n).
Equation (7.4) follows.
We next claim that there is a negligible function negl/prime/primesuch that
/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
t2←H1n[D(t2) = 1]−Pr
t2←H2n[D(t2) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle≤negl/prime/prime(n). (7.5)*Theoretical Constructions of Symmetric-Key Primitives 261
To see this, consider the polynomial-time distinguisher D/prime/primethat, on input
w∈{0,1}n+1, chooses uniform σ1∈{0,1}, setst2:=w/bardblσ1, and outputs
D(t2). Ifwis uniform then so is t2; thus,
Pr
w←{0,1}n+1[D/prime/prime(w) = 1] = Pr
t2←H2n[D(t2) = 1].
On the other hand, if w=G(s) for uniform s∈{0,1}n, thent2is distributed
exactly according to H1
nand so
Pr
s←{0,1}n[D/prime/prime(G(s)) = 1] = Pr
t2←H1n[D(t2) = 1].
As before, pseudorandomness of Gimplies Equation (7.5).
Putting everything together, we have
/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
s←{0,1}n[D(ˆG(s)) = 1]−Pr
r←{0,1}n+2[D(r) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle(7.6)
=/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
t2←H0
n[D(t2) = 1]−Pr
t2←H2
n[D(t2) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle
≤/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
t2←H0n[D(t2) = 1]−Pr
t2←H1n[D(t2) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle
+/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
t2←H1n[D(t2) = 1]−Pr
t2←H2n[D(t2) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle
≤negl/prime(n)+negl/prime/prime(n),
using Equations (7.4) and (7.5). Since Dwas an arbitrary polynomial-time
distinguisher, this proves that ˆGis a pseudorandom generator.
The general case. The same idea as above can be iteratively applied to
generate as many pseudorandom bits as desired. Formally, say we wish to
construct a pseudorandom generator ˆGwith expansion factor n+p(n), for
some polynomial p. On input s∈{0,1}n, algorithm ˆGdoes (cf. Figure 7.1):
1. Sett0:=s. Fori= 1,...,p(n) do:
(a) Letsi−1betheﬁrst nbitsofti−1, andletσi−1denotetheremaining
i−1 bits. (When i= 1,s0=t0andσ0is the empty string.)
(b) Setti:=G(s/prime
i−1)/bardblσi−1.
2. Output tp(n).
We show that ˆGis a pseudorandom generator. The proof uses a common
technique known as a hybrid argument . (Actually, even the case of p(n) = 2,
above, used a simple hybrid argument.) The main diﬀerence with respect to
thepreviousproofisatechnicalone. Previously,wecoulddeﬁneandexplicitly
work with three sequences of distributions {H0
n},{H1
n}, and{H2
n}. Here that
is not possible since the number of distributions to consider grows with n.262 Introduction to Modern Cryptography
/MT116/MT49 /MT116/MT50 /MT116/MT112/MT40/MT110/MT41/MT71 /MT115/MT48 /MT115/MT49/MT115/MT49
/MT115/MT50/MT115/MT50
/MT71
/MT116/MT48/MT32/MT61/MT32/MT115
FIGURE 7.1 :Increasing the expansion of a pseudorandom generator.
For anynand 0≤j≤p(n), letHj
nbe the distribution on strings of length
n+p(n) deﬁned as follows: chooseuniform tj∈{0,1}n+j, then run ˆGstarting
from iteration j+1 and output tp(n). (When j=p(n) this means we simply
choose uniform tp(n)∈{0,1}n+p(n)and output it.) The crucial observation
is thatH0
ncorresponds to outputting ˆG(s) for uniform s∈ {0,1}n, while
Hp(n)
ncorresponds to outputting a uniform ( n+p(n))-bit string. Fixing any
polynomial-time distinguisher D, this means that
/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
s←{0,1}n[D(ˆG(s)) = 1]−Pr
r←{0,1}n+p(n)[D(r) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle
=/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
t←H0n[D(t) = 1]−Pr
t←Hp(n)
n[D(t) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle.(7.7)
We prove the above is negligible, hence ˆGis a pseudorandom generator.
FixDas above, and consider the distinguisher D/primethat does the following
when given a string w∈{0,1}n+1as input:
1. Choose uniform j∈{1,...,p(n)}.
2. Choose uniform σ/prime
j∈{0,1}j−1. (When j= 1 then σ/prime
jis the empty
string.)
3. Settj:=w/bardblσ/prime
j. Then run ˆGstarting from iteration j+ 1 to com-
putetp(n)∈{0,1}n+p(n). Output D(tp(n)).
ClearlyD/primeruns in polynomial time. Analyzing the behavior of D/primeis more
complicated than before, although the underlying ideas are the same. Fix n*Theoretical Constructions of Symmetric-Key Primitives 263
and say D/primechoosesj=j∗. Ifwis uniform, then tj∗is uniform and so the
distribution on tdef=tp(n)is exactly that of distribution Hj∗
n. That is,
Pr
w←{0,1}n+1[D/prime(w) = 1|j=j∗] = Pr
t←Hj∗
n[D(t) = 1].
Since each value for jis chosen with equal probability,
Pr
w←{0,1}n+1[D/prime(w) = 1] =1
p(n)·p(n)/summationdisplay
j∗=1Pr
w←{0,1}n+1[D/prime(w) = 1|j=j∗]
=1
p(n)·p(n)/summationdisplay
j∗=1Pr
t←Hj∗
n[D(t) = 1]. (7.8)
On the other hand, say D/primechoosesj=j∗andw=G(s) for uniform
s∈{0,1}n. Deﬁning tj∗−1=s/bardblσ/prime
j∗, we see that tj∗−1is uniform and so
the experiment involving D/primeis equivalent to running ˆGfrom iteration j∗to
compute tp(n). That is, the distribution on tdef=tp(n)is now exactly that of
distribution Hj∗−1
n, and so
Pr
s←{0,1}n[D/prime(G(s)) = 1|j=j∗] = Pr
t←Hj∗−1
n[D(t) = 1].
Therefore,
Pr
s←{0,1}n[D/prime(ˆG(s)) = 1] =1
p(n)·p(n)/summationdisplay
j∗=1Pr
s←{0,1}n[D/prime(G(s)) = 1|j=j∗]
=1
p(n)·p(n)/summationdisplay
j∗=1Pr
t←Hj∗−1
n[D(t) = 1]
=1
p(n)·p(n)−1/summationdisplay
j∗=0Pr
t←Hj∗
n[D(t) = 1]. (7.9)
We can now analyze how well D/primedistinguishes outputs of Gfrom random:
/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
s←{0,1}n[D/prime(G(s)) = 1]−Pr
w←{0,1}n+1[D/prime(w) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle(7.10)
=1
p(n)·/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglep(n)−1/summationdisplay
j∗=0Pr
t←Hj∗
n[D(t) = 1]−p(n)/summationdisplay
j∗=1Pr
t←Hj∗
n[D(t) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle
=1
p(n)·/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
t←H0n[D(t) = 1]−Pr
t←Hp(n)
n[D(t) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle,264 Introduction to Modern Cryptography
relying on Equations (7.8) and (7.9) for the ﬁrst equality. (The second equal-
ity holds because the same terms are included in each sum, except for the
ﬁrst term of the left sum and the last term of the right sum.) Since Gis a
pseudorandom generator, the term on the left-hand side of Equation (7.10) is
negligible; because pis polynomial, this implies that Equation (7.7) is negli-
gible, completing the proof that ˆGis a pseudorandom generator.
Putting it all together. Letfbe a one-way permutation. Taking the
pseudorandom generatorwith expansion factor n+1 from Theorem 7.19, and
increasing the expansion factor to n+/lscriptusing the approach from the proof of
Theorem 7.20, we obtain the following pseudorandom generator ˆG:
ˆG(s) =f(/lscript)(s)/bardblhc(f(/lscript−1)(s))/bardbl···/bardblhc(s),
wheref(i)(s) refers to i-fold iteration of f. Note that ˆGuses/lscriptevaluations
off, and generates one pseudorandom bit per evaluation using the hard-core
predicate hc.
Connection to stream ciphers. Recall from Section 3.3.1 that a stream
cipher(without an IV) isdeﬁned byalgorithms( Init,GetBits), whereInittakes
a seeds∈{0,1}nand returns initial state st, andGetBitstakes as input the
current state stand outputs a bit σand updated state st/prime. The construction
ˆGfrom the preceding proof ﬁts nicely into this paradigm: take Initto be
the trivial algorithm that outputs st=s, and deﬁne GetBits(st) to compute
G(st), parse the result as st/prime/bardblσwith|st/prime|=n, and output the bit σand
updated state st/prime. (If we use this stream cipher to generate p(n) output bits
starting from seed s, then we get exactly the ﬁnal p(n) bits of ˆG(s) in reverse
order.) The preceding proofshowsthat this yields a pseudorandomgenerator.
Hybrid arguments. Ahybrid argument is a basic tool for proving indis-
tinguishability when a basic primitive is (or several diﬀerent primitives are)
applied multiple times. Somewhat informally, the technique works by deﬁn-
ing a series of intermediate “hybrid distributions” that bridge between two
“extreme distributions” that we wish to proveindistinguishable. (In the proof
above, these extreme distributions correspond to the output of ˆGand a ran-
dom string.) To apply the proof technique, three conditions should hold.
First, the extreme distributions should match the original cases of interest.
(In the proof above, H0
nwas equal to the distribution induced by ˆG, while
Hp(n)
nwas the uniform distribution.) Second, it must be possible to translate
the capability of distinguishing consecutive hybrid distributions into breaking
some underlying assumption. (Above, we essentially showed that distinguish-
ingHi
nfromHi+1
nwas equivalent to distinguishing the output of Gfrom
random.) Finally, the number of hybrid distributions should be polynomial.
See also Theorem 7.32.*Theoretical Constructions of Symmetric-Key Primitives 265
7.5 Constructing Pseudorandom Functions
Wenow show how to construct a pseudorandom function from any (length-
doubling) pseudorandom generator. Recall that a pseudorandom function is
an eﬃciently computable, keyed function Fthat is indistinguishable from a
truly random function in the sense described in Section 3.5.1. For simplicity,
we restrict our attention here to the case where Fis length preserving, mean-
ing that for k∈{0,1}nthe function Fkmapsn-bit inputs to n-bit outputs.
A (length-preserving) pseudorandom function can be viewed, informally, as
a pseudorandom generator with expansion factor n·2n; given such a pseu-
dorandom generator Gwe could deﬁne Fk(i) (for 0≤i <2n) to be the ith
n-bit block of G(k). The reason this does not work is that Fmust be eﬃ-
ciently computable; there are exponentially many blocks, and we need a way
to compute the ith block without having to compute all other blocks.
We will do this by computing “blocks” of the output by walking down a
binary tree. We exemplify the construction by ﬁrst showing a pseudoran-
dom function taking 2-bit inputs. Let Gbe a pseudorandom generator with
expansion factor 2 n. If we use Gas in the proof of Theorem 7.20 we can
obtain a pseudorandom generator ˆGwith expansion factor 4 nthat uses three
invocations of G. (We produce nadditional pseudorandom bits each time G
is applied.) If we deﬁne F/prime
k(i) (where 0≤i <4 andiis encoded as a 2-bit
binary string) to be the ith block of ˆG(k), then computation of F/prime
k(3) would
require computing all of ˆGand hence three invocations of G. We show how
to construct a pseudorandom function Fusing only two invocations of Gon
any input.
LetG0andG1be functions denoting the ﬁrst and second halves of the
output of G; i.e.,G(k) =G0(k)/bardblG1(k) where|G0(k)|=|G1(k)|=|k|. Deﬁne
Fas follows:
Fk(00) =G0(G0(k))Fk(10) =G0(G1(k))
Fk(01) =G1(G0(k))Fk(11) =G1(G1(k)).
We claim that the four strings above are pseudorandom even when viewed
together. (This suﬃces to prove that Fis pseudorandom.) Intuitively, this
is because G0(k)/bardblG1(k) =G(k) is pseudorandom and hence indistinguishable
from a uniform 2 n-bit string k0/bardblk1. But then
G0(G0(k))/bardblG1(G0(k))/bardblG0(G1(k))/bardblG1(G1(k))
is indistinguishable from
G0(k0)/bardblG1(k0)/bardblG0(k1)/bardblG1(k1) =G(k0)/bardblG(k1).
SinceGis a pseudorandom generator, the above is indistinguishable from a
uniform 4 n-bit string. A formal proof uses a hybrid argument.266 Introduction to Modern Cryptography
Generalizing this idea, we can obtain a pseudorandom function on n-bit
inputs by deﬁning
Fk(x) =Gxn(···Gx1(k)···),
wherex=x1···xn; seeConstruction7.21. Theintuitionforwhythisfunction
is pseudorandom is the same as before, but the formal proof is complicated
by the fact that there are now exponentially many inputs to consider.
CONSTRUCTION 7.21
LetGbe a pseudorandom generator with expansion factor /lscript(n) = 2n,
and deﬁne G0,G1as in the text. For k∈{0,1}n, deﬁne the function
Fk:{0,1}n→{0,1}nas:
Fk(x1x2···xn) =Gxn(···(Gx2(Gx1(k)))···).
A pseudorandom function from a pseudorandom generator.
Itisuseful to view this construction as deﬁning, for each key k∈{0,1}n, a
complete binary tree of depth nin which each node contains an n-bit value.
(See Figure 7.2, in which n= 3.) The root has value k, and for every in-
ternal node with value k/primeits left child has value G0(k/prime) and its right child
has value G1(k/prime). The result Fk(x) forx=x1···xnis then deﬁned to be
the value on the leaf node reached by traversing the tree according to the
bits ofx, wherexi= 0 means “go left” and xi= 1 means “go right.” (The
function is only deﬁned for inputs of length n, and thus only values on the
leaves are ever output.) The size of the tree is exponential in n. Nevertheless,
to compute Fk(x) the entire tree need not be constructed or stored; only n
evaluations of Gare needed.
/MT48
/MT48 /MT49
/MT48 /MT49/MT48 /MT49/MT49
/MT48 /MT49
/MT48 /MT49/MT48 /MT49/MT107
/MT71/MT32/MT32/MT40/MT107/MT41/MT48
/MT71/MT32/MT32/MT40/MT71/MT32/MT32/MT40 /MT107/MT41/MT41/MT48 /MT49
/MT70/MT32/MT32/MT40/MT48/MT49/MT49/MT41/MT32/MT61/MT32/MT71/MT32/MT32/MT40/MT71/MT32/MT32/MT40/MT71/MT32/MT32/MT40 /MT107/MT41/MT41/MT41 /MT49 /MT49 /MT48 /MT107
FIGURE 7.2 :Constructing a pseudorandom function.*Theoretical Constructions of Symmetric-Key Primitives 267
THEOREM 7.22 IfGis a pseudorandom generator with expansion factor
/lscript(n) = 2n, then Construction 7.21 is a pseudorandom function.
PROOF We ﬁrst show that for any polynomial tit is infeasible to distin-
guisht(n) uniform 2 n-bit strings from t(n) pseudorandom strings; i.e., for any
polynomial tand any pptalgorithm A, the following is negligible:
/vextendsingle/vextendsinglePr/bracketleftbig
A/parenleftbig
r1/bardbl···/bardblrt(n)/parenrightbig
= 1/bracketrightbig
−Pr/bracketleftbig
A/parenleftbig
G(s1)/bardbl···/bardblG(st(n))/parenrightbig
= 1/bracketrightbig/vextendsingle/vextendsingle,
where the ﬁrst probability is over uniform choice of r1,...,r t(n)∈{0,1}2n,
and the second probability is over uniform choice of s1,...,s t(n)∈{0,1}n.
The proof is by a hybrid argument. Fix a polynomial tand apptalgo-
rithmA, and consider the following algorithm A/prime:
Distinguisher A/prime:
A/primeis given as input a string w∈{0,1}2n.
1. Choose uniform j∈{1,...,t(n)}.
2. Choose uniform, independent values r1,...,r j−1∈{0,1}2n
andsj+1,...,s t(n)∈{0,1}n.
3. Output A/parenleftbig
r1/bardbl···/bardblrj−1/bardblw/bardblG(sj+1)/bardbl···/bardblG(st(n))/parenrightbig
.
For any nand 0≤i≤t(n), letGi
ndenote the distribution on strings of
length 2n·t(n) in which the ﬁrst i“blocks” of length 2 nare uniform and the
remaining t(n)−iblocks are pseudorandom. Note that Gt(n)
ncorresponds to
the distribution in which all t(n) blocks are uniform, while G0
ncorresponds to
the distribution in which all t(n) blocks are pseudorandom. That is,
/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
y←Gt(n)
n[A(y) = 1]−Pr
y←G0
n[A(y) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle(7.11)
=/vextendsingle/vextendsinglePr/bracketleftbig
A/parenleftbig
r1/bardbl···/bardblrt(n)/parenrightbig
= 1/bracketrightbig
−Pr/bracketleftbig
A/parenleftbig
G(s1)/bardbl···/bardblG(st(n))/parenrightbig
= 1/bracketrightbig/vextendsingle/vextendsingle
SayA/primechoosesj=j∗. If its input wis a uniform 2 n-bit string, then Ais run
on an input distributed according to Gj∗
n. If, on the other hand, w=G(s) for
uniform s, thenAis run on an input distributed according to Gj∗−1
n. This
means that
Pr
r←{0,1}2n[A/prime(r) = 1] =1
t(n)·t(n)/summationdisplay
j=1Pr
y←Gj
n[A(y) = 1]
and
Pr
s←{0,1}n[A/prime(G(s)) = 1] =1
t(n)·t(n)−1/summationdisplay
j=0Pr
y←Gj
n[A(y) = 1].268 Introduction to Modern Cryptography
Therefore,
/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
r←{0,1}2n[A/prime(r) = 1]−Pr
s←{0,1}n[A/prime(G(s)) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle(7.12)
=1
t(n)·/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
y←Gt(n)
n[A(y) = 1]−Pr
y←G0n[A(y) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle.
SinceGis a pseudorandom generator and A/primeruns in polynomial time, we
know that the left-hand side of Equation (7.12) must be negligible; because
t(n) is polynomial, this implies that the left-hand side of Equation (7.11) is
negligible as well.
Turning to the crux of the proof, we now show that Fas in Construc-
tion 7.21isapseudorandomfunction. Let Dbe anarbitrary pptdistinguisher
that is given1nasinput. We showthat Dcannotdistinguish between the case
when it is given oracle access to a function that is equal to Fkfor a uniform k,
or a function chosen uniformly from Funcn. (See Section 3.5.1.) To do so, we
use another hybrid argument. Here, we deﬁne a sequence of distributions over
the values at the leaves of a complete binary tree of depth n. By associating
each leaf with a string of length nas in Construction 7.21, we can equiva-
lently view these as distributions over functions mapping n-bit inputs to n-bit
outputs. For any nand 0≤i≤n, letHi
nbe the following distribution over
the values at the leaves of a binary tree of depth n: ﬁrst choose values for the
nodes at level iindependently and uniformly from {0,1}n. Then for every
node at level ior below with value k, its left child is given value G0(k) and its
right child is given value G1(k). Note that Hn
ncorresponds to the distribu-
tion in which all values at the leaves are chosen uniformly and independently,
and thus corresponds to choosing a uniform function from Funcn, whereas H0
n
corresponds to choosing a uniform key kin Construction 7.21 since in that
case only the root (at level 0) is chosen uniformly. That is,
/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
k←{0,1}n[DFk(·)(1n) = 1]−Pr
f←Funcn[Df(·)(1n) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle
=/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
f←H0n[Df(·)(1n) = 1]−Pr
f←Hnn[Df(·)(1n) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle.(7.13)
We show that Equation (7.13) is negligible, completing the proof.
Lett=t(n)beapolynomialupperboundonthenumberofqueries Dmakes
to its oracle on input 1n. Deﬁne a distinguisher Athat tries to distinguish
t(n) uniform 2 n-bit strings from t(n) pseudorandom strings, as follows:
Distinguisher A:
Ais given as input a 2 n·t(n)-bit string w1/bardbl···/bardblwt(n).
1. Choose uniform j∈{0,...,n−1}. In what follows, A(im-
plicitly) maintains a binary tree of depth nwithn-bit values
at (a subset of the) internal nodes at depth j+1 and below.*Theoretical Constructions of Symmetric-Key Primitives 269
2. RunD(1n). When Dmakes oracle query x=x1···xn, look
at the preﬁx x1···xj. There are two cases:
•IfDhas never made a query with this preﬁx before, then
usex1···xjto reacha node von thejth level of the tree.
Take the next unused 2 n-bit string wand set the value
of the left child of node vto the left half of w, and the
value of the right child of vto the right half of w.
•IfDhas made a query with preﬁx x1···xjbefore, then
nodex1···xj+1has already been assigned a value.
Using the value at node x1···xj+1, compute the value at the
leaf corresponding to x1···xnas in Construction 7.21, and
return this value to D.
3. When execution of Dis done, output the bit returned by D.
Aruns in polynomial time. It is important here that Adoes not need to
store the entire binary tree of exponential size. Instead, it “ﬁlls in” the values
of at most 2 t(n) nodes in the tree. Say Achoosesj=j∗. Observe that:
1. IfA’s input is a uniform 2 n·t(n)-bit string, then the answers it gives
toDare distributed exactly as if Dwere interacting with a function
chosen from distribution Hj∗+1
n. This holds because the values of the
nodes at level j∗+1 of the tree are uniform and independent.
2. IfA’s input consists of t(n) pseudorandom strings—i.e., wi=G(si) for
uniform seed si—then the answers it gives to Dare distributed exactly
as ifDwere interacting with a function chosen from distribution Hj∗
n.
Thisholdsbecausethe valuesofthe nodesatlevel j∗ofthe tree(namely,
thes-values)areuniformandindependent. (These s-valuesareunknown
toA, but this makes no diﬀerence.)
Proceeding as before, one can show that
/vextendsingle/vextendsinglePr/bracketleftbig
A/parenleftbig
r1/bardbl···/bardblrt(n)/parenrightbig
= 1/bracketrightbig
−Pr/bracketleftbig
A/parenleftbig
G(s1)/bardbl···/bardblG(st(n))/parenrightbig
= 1/bracketrightbig/vextendsingle/vextendsingle(7.14)
=1
n·/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
f←H0
n[Df(·)(1n) = 1]−Pr
f←Hn
n[Df(·)(1n) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle.
We have shown earlier that Equation (7.14) must be negligible. The above
thus implies that Equation (7.13) must be negligible as well.
7.6 Constructing (Strong) Pseudorandom Permutations
Wenext show how pseudorandom permutations and strong pseudorandom
permutations can be constructed from any pseudorandom function. Recall270 Introduction to Modern Cryptography
from Section 3.5.1that a pseudorandompermutation is a pseudorandomfunc-
tion that is also eﬃciently invertible, while a strongpseudorandom permuta-
tion is additionally hard to distinguish from a random permutation even by
an adversary given oracle access to both the permutation and its inverse .
Feistel networks revisited. A Feistel network, introduced in Section 6.2.2,
provides a way of constructing an invertible function from an arbitrary set
of functions. A Feistel network operates in a series of rounds. The input to
theith round is a string of length 2 n, divided into two n-bit halves Li−1and
Ri−1(the “left half” and the “right half,” respectively). The output of the
ith round is the 2 n-bit string ( Li,Ri) where
Li:=Ri−1andRi:=Li−1⊕fi(Ri−1)
for some eﬃciently computable (but not necessarily invertible) function fi
mapping n-bitinputsto n-bitoutputs. Wedenoteby Feistel f1,...,frther-round
Feistel network using functions f1,...,f r. (That is, Feistel f1,...,fr(L0,R0) out-
puts the 2 n-bit string ( Lr,Rr).) We saw in Section 6.2.2 that Feistel f1,...,fris
an eﬃciently invertible permutation regardless of the {fi}.
We can deﬁne a keyed permutation by using a Feistel network in which the
{fi}depend on a key. For example, let F:{0,1}n×{0,1}n→{0,1}nbe a
pseudorandom function, and deﬁne the keyed permutation F(1)as
F(1)
k(x)def=Feistel Fk(x).
(Note that F(1)
khas ann-bit key and maps 2 n-bit inputs to 2 n-bit outputs.)
IsF(1)pseudorandom? A little thought shows that it is decidedly not. For
any key k∈{0,1}n, the ﬁrst nbits of the output of F(1)
k(that is, L1) are
equal to the last nbits of the input (i.e., R0), something that occurs with
only negligible probability for a random function.
Trying again, deﬁne F(2):{0,1}2n×{0,1}2n→{0,1}2nas follows:
F(2)
k1,k2(x)def=Feistel Fk1,Fk2(x). (7.15)
(Note that k1andk2are independent keys.) Unfortunately, F(2)is not pseu-
dorandom either, as you are asked to show in Exercise 7.16.
Given this, it may be somewhat surprising that a three-round Feistel net-
workispseudorandom. Deﬁne the keyed permutation F(3), taking a key of
length 3nand mapping 2 n-bit inputs to 2 n-bit outputs, as follows:
F(3)
k1,k2,k3(x)def=Feistel Fk1,Fk2,Fk3(x) (7.16)
where, once again, k1,k2, andk3are independent. We have:
THEOREM 7.23 IfFis a pseudorandom function, then F(3)is a pseu-
dorandom permutation.*Theoretical Constructions of Symmetric-Key Primitives 271
/MT76/MT48
/MT70/MT107/MT49/MT82/MT48
/MT76/MT49 /MT82/MT49/MT70/MT107/MT50
/MT70/MT107/MT51/MT76/MT50 /MT82/MT50
/MT76/MT51 /MT82/MT51
FIGURE 7.3 :Athree-round Feistel network, as used to construct a
pseudorandom permutation from a pseudorandom function.
PROOF In the standard way, we can replace the pseudorandom functions
used in the construction of F(3)with functions chosen uniformly at random
instead. Pseudorandomness of Fimplies that this has only a negligible eﬀect
on the output of any probabilistic polynomial-time distinguisher interacting
withF(3)as an oracle. We leave the details as an exercise.
LetDbe a probabilistic polynomial-time distinguisher. In the remainder
of the proof, we show the following is negligible:
/vextendsingle/vextendsingle/vextendsinglePr[DFeistel f1,f2,f3(·)(1n) = 1]−Pr[Dπ(·)(1n) = 1]/vextendsingle/vextendsingle/vextendsingle,
where the ﬁrst probability is taken over uniform and independent choice of
f1,f2,f3fromFuncn, and the second probability is taken over uniform choice
ofπfromPerm2n. Fix some value for the security parameter n, and let
q=q(n) denote a polynomial upper bound on the number of oracle queries
made by D. We assume without loss of generality that Dnever makes the
same oracle query twice. Focusing on D’s interaction with Feistel f1,f2,f3(·),
let (Li
0,Ri
0) denote the ith query Dmakes to its oracle, and let ( Li
1,Ri
1),
(Li
2,Ri
2), and (Li
3,Ri
3) denote the intermediate values after rounds 1, 2, and 3,
respectively, that result from that query. (See Figure 7.3.) Note that D
chooses ( Li
0,Ri
0) and sees the result ( Li
3,Ri
3), but does not directly observe
(Li
1,Ri
1) or (Li
2,Ri
2).
We say there is a collision at R1ifRi
1=Rj
1for some distinct i,j. We ﬁrst
prove that a collision at R1occurs with only negligible probability. Consider
any ﬁxed, distinct i,j. IfRi
0=Rj
0thenLi
0/negationslash=Lj
0, but then
Ri
1=Li
0⊕f1(Ri
0)/negationslash=Lj
0⊕f1(Rj
0) =Rj
1.272 Introduction to Modern Cryptography
IfRi
0/negationslash=Rj
0thenf1(Ri
0) andf1(Rj
0) are uniform and independent, so
Pr/bracketleftBig
Li
0⊕f1(Ri
0) =Lj
0⊕f1(Rj
0)/bracketrightBig
= Pr/bracketleftBig
f1(Rj
0) =Li
0⊕f1(Ri
0)⊕Lj
0/bracketrightBig
= 2−n.
Taking a union bound over all distinct i,jshows that the probability of a
collision at R1is at most q2/2n.
Say there is a collision at R2ifRi
2=Rj
2for some distinct i,j. We prove
that conditioned on no collision at R1, the probability of a collision at R2is
negligible. The analysis is as above: consider any ﬁxed i,j, and note that if
there is no collision at R1thenRi
1/negationslash=Rj
1. Thusf2(Ri
1) andf2(Rj
1) are uniform
and independent, and therefore
Pr/bracketleftBig
Li
1⊕f2(Ri
1) =Lj
1⊕f2(Rj
1)|no collision at R1/bracketrightBig
= 2−n.
(Notethat f2isindependent of f1, makingthe abovecalculationeasy.) Taking
a union bound over all distinct i,jgives
Pr[collision at R2|no collision at R1]≤q2/2n.
Notethat Li
3=Ri
2=Li
1⊕f2(Ri
1); so,conditionedontherebeingnocollision
atR1, the values L1
3,...,Lq
3are all independent and uniformly distributed
in{0,1}n. Ifweadditionallyconditionontheeventthatthereisnocollisionat
R2, then the values L1
3,...,Lq
3are uniformly distributed among all sequences
ofqdistinctvalues in{0,1}n. Similarly, Ri
3=Li
2⊕f3(Ri
2); thus, conditioned
on there being no collision at R2, the values R1
3,...,Rq
3are all uniformly
distributed in{0,1}n, independent of each other as well as L1
3,...,Lq
3.
To summarize: when querying F(3)(with uniform round functions) on a
series of qdistinct inputs, except with negligible probability the output val-
ues (L1
3,R1
3), ..., (Lq
3,Rq
3) are distributed such that the {Li
3}are uniform
and independent, but distinct, n-bit values, and the {Ri
3}are uniform and
independent n-bit values. In contrast, when querying a random permutation
on a series of qdistinct inputs, the output values ( L1
3,R1
3), ..., (Lq
3,Rq
3) are
uniform and independent, but distinct, 2 n-bit values. The best distinguishing
attack for D, then, is to guess that it is interacting with a random permuta-
tion ifLi
3=Lj
3for some distinct i,j. But that event occurs with negligible
probability even in that case. This can be turned into a formal proof.
F(3)is not astrongpseudorandompermutation, as youareaskedto demon-
strate in Exercise7.17. Fortunately, adding a fourth round doesyield a strong
pseudorandom permutation. The details are given as Construction 7.24.
THEOREM7.25 IfFis apseudorandom function, then Construction 7.24
is a strong pseudorandom permutation that maps 2n-bit inputs to 2n-bit out-
puts(and uses a 4n-bit key).*Theoretical Constructions of Symmetric-Key Primitives 273
CONSTRUCTION 7.24
LetFbe a keyed, length-preserving function. Deﬁne the keyed permu-
tationF(4)as follows:
•Inputs: A keyk= (k1,k2,k3,k4) with|ki|=n, and an input
x∈{0,1}2nparsed as ( L0,R0) with|L0|=|R0|=n.
•Computation:
1. Compute L1:=R0andR1:=L0⊕Fk1(R0).
2. Compute L2:=R1andR2:=L1⊕Fk2(R1).
3. Compute L3:=R2andR3:=L2⊕Fk3(R2).
4. Compute L4:=R3andR4:=L3⊕Fk4(R3).
5. Output ( L4,R4).
A strong pseudorandom permutation from any pseudorandom function.
7.7 Assumptions for Private-Key Cryptography
Wehave shown that (1) if there exist one-way permutations, then there
exist pseudorandom generators; (2) if there exist pseudorandom generators,
then there exist pseudorandom functions; and (3) if there exist pseudorandom
functions, then there exist (strong) pseudorandom permutations. Although
we did not prove it here, it is possible to construct pseudorandom generators
from one-way functions . We thus have the following fundamental theorem:
THEOREM 7.26 If one-way functions exist, then so do pseudorandom
generators, pseudorandom functions, and strong pseudorandom permutations.
All the private-key schemes we have studied in Chapters 3 and 4 can be
constructed from pseudorandom generators/functions. We therefore have:
THEOREM 7.27 If one-way functions exist, then so do CCA-secure
private-key encryption schemes and secure message authentication codes.
That is, one-way functions are suﬃcient for all private-key cryptography .
Here, we show that one-way functions are also necessary .
Pseudorandomness implies one-way functions. We begin by showing
that pseudorandom generators imply the existence of one-way functions:274 Introduction to Modern Cryptography
PROPOSITION 7.28 If a pseudorandom generator exists, then so does
a one-way function.
PROOF LetGbe a pseudorandomgeneratorwith expansion factor /lscript(n) =
2n. (By Theorem 7.20, we know that the existence of a pseudorandom gen-
erator implies the existence of one with this expansion factor.) We show that
Gitself is one-way. Eﬃcient computability is straightforward (since Gcan
be computed in polynomial time). We show that the ability to invert Gcan
be translated into the ability to distinguish the output of Gfrom uniform.
Intuitively, this holds because the ability to invert Gimplies the ability to
ﬁnd the seed used by the generator.
LetAbe an arbitrary probabilistic polynomial-time algorithm. We show
that Pr[InvertA,G(n) = 1]isnegligible(cf. Deﬁnition7.1). Toseethis, consider
the following pptdistinguisher D: on input a string w∈{0,1}2n, runA(w)
to obtain output s. IfG(s) =wthen output 1; otherwise, output 0.
We now analyze the behavior of D. First consider the probability that D
outputs 1 when its input string wis uniform. Since there areat most 2nvalues
in the range of G(namely, the values {G(s)}s∈{0,1}n), the probability that w
is in the range of Gis at most 2n/22n= 2−n. When wis not in the range
ofG, it is impossible for Ato compute an inverse of wand thus impossible
forDto output 1. We conclude that
Pr
w←{0,1}2n[D(w) = 1]≤2−n.
On the other hand, if w=G(s) for a seed s∈{0,1}nchosen uniformly at
randomthen, bydeﬁnition, Acomputesacorrectinverse(and so Doutputs 1)
with probability exactly equal to Pr[ InvertA,G(n) = 1]. Thus,
/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
w←{0,1}2n[D(w) = 1]−Pr
s←{0,1}n[D(G(s)) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle≥Pr[InvertA,G(n) = 1]−2−n.
SinceGis a pseudorandom generator, the above must be negligible. Since
2−nis negligible, this implies that Pr[ InvertA,G(n) = 1] is negligible as well
and soGis one-way.
Non-trivial private-key encryption impliesone-way functions. Propo-
sition 7.28 does not imply that one-way functions are needed for constructing
secure private-key encryption schemes, since it may be possible to construct
the latter without relying on a pseudorandom generator. Furthermore, it is
possible to construct perfectly secret encryption schemes (see Chapter 2), as
long as the plaintext is no longer than the key. Thus, a proof that secure
private-key encryption implies one-way functions requires more care.
PROPOSITION 7.29 If there exists an EAV-secure private-key encryp-
tion scheme that encrypts messages twice as long as its key, then a one-way
function exists.*Theoretical Constructions of Symmetric-Key Primitives 275
PROOF Let Π = ( Enc,Dec) be a private-key encryption scheme that has
indistinguishable encryptions in the presence of an eavesdropperand encrypts
messages of length 2 nwhen the key has length n. (We assume for simplicity
that the key is chosen uniformly.) Say that when an n-bit key is used, Enc
uses at most /lscript(n) bits of randomness. Denote the encryption of a message m
using key kand randomness rbyEnck(m;r).
Deﬁne the following function f:
f(k,m,r)def=Enck(m;r)/bardblm,
where|k|=n,|m|= 2n, and|r|=/lscript(n). We claim that fis a one-way func-
tion. Clearly it can be eﬃciently computed; we show that it is hard to invert.
LettingAbe an arbitrary pptalgorithm, we show that Pr[ InvertA,f(n) = 1]
is negligible (cf. Deﬁnition 7.1).
Considerthefollowingprobabilisticpolynomial-timeadversary A/primeattacking
private-key encryption scheme Π (i.e., in experiment PrivKeav
Π,A/prime(n)):
AdversaryA/prime(1n)
1. Choose uniform m0,m1←{0,1}2nand output them. Re-
ceive in return a challenge ciphertext c.
2. RunA(c/bardblm0) to obtain ( k/prime,m/prime,r/prime). Iff(k/prime,m/prime,r/prime) =c/bardblm0,
output 0; else, output 1.
We now analyze the behavior of A/prime. Whencis an encryption of m0, then
c/bardblm0is distributed exactly as f(k,m0,r) for uniform k,m0, andr. Therefore,
Aoutputs a valid inverse of c/bardblm0(and henceA/primeoutputs 0) with probability
exactly equal to Pr[ InvertA,f(n) = 1].
On the other hand, when cis an encryption of m1thencis independent
ofm0. For any ﬁxed value of the challenge ciphertext c, there are at most
2npossible messages (one for each possible key) to which ccan correspond.
Sincem0is a uniform 2 n-bit string, this means the probability there exists
some key kfor which Deck(c) =m0is at most 2n/22n= 2−n. This gives
an upper bound on the probability with which Acan possibly output a valid
inverse of c/bardblm0underf, and hence an upper bound on the probability with
whichA/primeoutputs 0 in that case.
Putting the above together, we have:
Pr/bracketleftbig
PrivKeav
Π,A/prime(n) = 1/bracketrightbig
=1
2·Pr[A/primeoutputs 0|b= 0]+1
2·Pr[A/primeoutputs 1|b= 1]
≥1
2·Pr[InvertA,f(n) = 1]+1
2·/parenleftbig
1−2−n/parenrightbig
=1
2+1
2·/parenleftbig
Pr[InvertA,f(n) = 1]−2−n/parenrightbig
.276 Introduction to Modern Cryptography
SecurityofΠ meansthat Pr/bracketleftbig
PrivKeav
Π,A/prime(n) = 1/bracketrightbig
≤1
2+negl(n) forsomenegligi-
ble function negl. This, in turn, implies that Pr[ InvertA,f(n) = 1] is negligible,
completing the proof that fis one-way.
Message authentication codes imply one-way functions. Itisalso true
thatmessageauthenticationcodessatisfyingDeﬁnition4.2implytheexistence
of one-way functions. As in the case of private-key encryption, a proof of
this fact is somewhat subtle because unconditional message authentication
codesdoexist when there is an a priori bound on the number of messages
that will be authenticated. (See Section 4.6.) Thus, a proof relies on the
fact that Deﬁnition 4.2 requires security even when the adversary sees the
authentication tags of an arbitrary (polynomial) number of messages. The
proof is somewhat involved, so we do not give it here.
Discussion. We concludethat theexistence ofone-wayfunctions is necessary
and suﬃcient for all (non-trivial) private-key cryptography. In other words,
one-way functions are a minimal assumption as far as private-key cryptog-
raphy is concerned. Interestingly, this appears not to be the case for hash
functions and public-key encryption, where one-way functions are known to
be necessary but are not known (or believed) to be suﬃcient.
7.8 Computational Indistinguishability
The notion of computational indistinguishability is central to the theory of
cryptography, and it underlies much of what we have seen in Chapter 3 and
this chapter. Informally, two probability distributions are computationally
indistinguishable if no eﬃcient algorithm can tell them apart (or distinguish
them). In more detail, consider two distributions XandYover strings of
some length /lscript; that is, XandYeach assigns some probability to every string
in{0,1}/lscript. When we say that some algorithm Dcannot distinguish these two
distributions, we mean that Dcannot tell whether it is given a string sampled
according to distribution Xor whether it is given a string sampled according
to distribution Y. Put diﬀerently, if we imagine Doutputting “0” when it
believes its input was sampled according to Xand outputting “1” if it thinks
its input was sampled according to Y, then the probability that Doutputs
“1” should be roughly the same regardless of whether Dis provided with a
sample from Xor fromY. In other words, we want
/vextendsingle/vextendsingle/vextendsinglePr
s←X[D(s) = 1]−Pr
s←Y[D(s) = 1]/vextendsingle/vextendsingle/vextendsingle
to be small.*Theoretical Constructions of Symmetric-Key Primitives 277
This should be reminiscent of the way we deﬁned pseudorandom generators
and, indeed, we will soon formally redeﬁne the notion of a pseudorandom
generator using this terminology.
The formal deﬁnition of computational indistinguishability refers to prob-
ability ensembles , which are inﬁnite sequences of probability distributions.
(This formalism is necessary for a meaningful asymptotic approach.) Al-
though the notion can be generalized, for our purposes we consider proba-
bility ensembles in which the underlying distributions are indexed by natural
numbers. If for every natural number nwe have a distribution Xn, then
X={Xn}n∈Nis a probability ensemble. It is often the case that Xn=Yt(n)
for some function t, in which case we write {Yt(n)}n∈Nin place of{Xn}n∈N.
We will only be interested in eﬃciently sampleable probability ensembles.
An ensembleX={Xn}n∈Nis eﬃciently sampleable if there is a probabilistic
polynomial-timealgorithm Ssuchthattherandomvariables S(1n)andXnare
identically distributed. That is, algorithm Sis an eﬃcient way of sampling X.
We can now formally deﬁne what it means for two ensembles to be compu-
tationally indistinguishable.
DEFINITION 7.30 Two probability ensembles X={Xn}n∈Nand
Y={Yn}n∈Narecomputationally indistinguishable , denotedXc≡Y, if for
every probabilistic polynomial-time distinguisher Dthere exists a negligible
function neglsuch that:
/vextendsingle/vextendsingle/vextendsingle/vextendsinglePr
x←Xn[D(1n,x) = 1]−Pr
y←Yn[D(1n,y) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle≤negl(n).
In the deﬁnition, Dis given the unary input 1nso it can run in time
polynomial in n. This is important when the outputs of XnandYnmay have
length less than n. As shorthandin probabilityexpressions,we will sometimes
writeXas a placeholder for a random sample from distribution X. That is,
we would write Pr[ D(1n,Xn) = 1] in place of Pr x←Xn[D(1n,x) = 1].
The relation of computational indistinguishability is transitive: if Xc≡Y
andYc≡Z, thenXc≡Z.
Pseudorandomness and pseudorandom generators. Pseudorandom-
ness is just a special case of computational indistinguishability. For any in-
teger/lscript, letU/lscriptdenote the uniform distribution over {0,1}/lscript. We can deﬁne a
pseudorandom generator as follows:
DEFINITION 7.31 Let/lscript(·)be a polynomial and let Gbe a (deterministic)
polynomial-time algorithm where for all sit holds that|G(s)|=/lscript(|s|). We
say that Gis apseudorandom generator if the following two conditions hold:
1.(Expansion:) For every nit holds that /lscript(n)> n.278 Introduction to Modern Cryptography
2.(Pseudorandomness:) The ensemble{G(Un)}n∈Nis computationally
indistinguishable from the ensemble {U/lscript(n)}n∈N.
Many of the other deﬁnitions and assumptions in this book can also be cast
as special cases or variants of computational indistinguishability.
Multiple samples. An important theorem regarding computational indis-
tinguishability is that polynomially many samples of (eﬃciently sampleable)
computationally indistinguishable ensembles are also computationally indis-
tinguishable.
THEOREM 7.32 LetXandYbe eﬃciently sampleable probability ensem-
bles that are computationally indistinguishable. Then, for every polynomial p,
the ensembleX={(X(1)
n,...,X(p(n))
n)}n∈Nis computationally indistinguish-
able from the ensemble Y={(Y(1)
n,...,Y(p(n))
n)}n∈N.
For example, let Gbe a pseudorandom generator with expansion factor 2 n,
in which case the ensembles {G(Un)}n∈Nand{U2n}n∈Nare computationally
indistinguishable. In the proof of Theorem 7.22 we showed that for any poly-
nomialtthe ensembles
{(G(Un),...,G(Un)/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright
t(n))}n∈Nand{(U2n,...,U 2n/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright
t(n))}n∈N
are also computationally indistinguishable. Theorem 7.32 is proved by a hy-
brid argument in exactly the same way.
References and Additional Reading
The notion of a one-way function was ﬁrst proposed by Diﬃe and Hell-
man [58] and later formalized by Yao [179]. Hard-core predicates were in-
troduced by Blum and Micali [37], and the fact that there exists a hard-core
predicate for every one-way function was proved by Goldreich and Levin [79].
Theﬁrstconstructionofpseudorandomgenerators(underaspeciﬁcnumber-
theoretic hardness assumption) was given by Blum and Micali [37]. The con-
struction of a pseudorandom generator from any one-way permutation was
given by Yao [179], and the result that pseudorandom generators can be con-
structed from any one-way function was shown by H˚ astad et al. [85]. Pseu-
dorandom functions were deﬁned and constructed by Goldreich, Goldwasser
and Micali [78] and their extension to (strong) pseudorandom permutations
was shown by Luby and Rackoﬀ [116]. The fact that one-way functions are a*Theoretical Constructions of Symmetric-Key Primitives 279
necessary assumption for most of private-key cryptography was shown in [93].
The proof of Proposition 7.29 is from [72].
Our presentation is heavily inﬂuenced by Goldreich’s book [75], which is
highlyrecommendedforthoseinterestedinexploringthetopicsofthis chapter
in greater detail.
Exercises
7.1Provethat if thereexists aone-wayfunction, then thereexists aone-way
function fsuch that f(0n) = 0nfor every n. Note that for inﬁnitely
many values y, it is easy to compute f−1(y). Why does this not contra-
dict one-wayness?
7.2 Prove that if fis a one-way function, then the function gdeﬁned by
g(x1,x2)def= (f(x1),x2), where|x1|=|x2|, is also a one-way function.
Observe that greveals half of its input, but is nevertheless one-way.
7.3 Prove that if there exists a one-way function, then there exists a length-
preserving one-way function.
Hint:Letfbe a one-way function and let p(·) be a polynomial such
that|f(x)| ≤p(|x|). (Justify the existence of such a p.) Deﬁne f/prime(x)def=
f(x)/bardbl10p(|x|)−|f(x)|. Further modify f/primeto get a length-preserving func-
tion that remains one-way.
7.4 Let( Gen,H)beacollision-resistanthashfunction, where Hmapsstrings
of length 2 nto strings of length n. Prove that the function family
(Gen,Samp,H) is one-way (cf. Deﬁnition 7.3), where Sampis the trivial
algorithm that samples a uniform string of length 2 n.
Hint:Choosing uniform x∈ {0,1}2nand ﬁnding an inverse of y=
Hs(x) does not guarantee a collision. But it does yield a collision most
of the time...
7.5 LetFbe a (length-preserving) pseudorandom permutation.
(a) Show that the function f(x,y) =Fx(y) is not one-way.
(b) Show that the function f(y) =F0n(y) (where n=|y|) is not one-
way.
(c) Prove that the function f(x) =Fx(0n) (where n=|x|) is one-way.
7.6 Letfbe a length-preserving one-way function, and let hcbe a hard-
core predicate of f. Deﬁne GasG(x) =f(x)/bardblhc(x). IsGnecessarily a
pseudorandom generator? Prove your answer.280 Introduction to Modern Cryptography
7.7 Prove that there exist one-way functions if and only if there exist one-
way function families. Discuss why your proof does not carry over to
the case of one-way permutations.
7.8 Letfbe a one-way function. Is g(x)def=f(f(x)) necessarily a one-way
function? What about g/prime(x)def=f(x)/bardblf(f(x))? Prove your answers.
7.9 Let Π = ( Gen,Samp,f) be a function family. A function hc:{0,1}∗→
{0,1}is ahard-core predicate of Π if it is eﬃciently computable and if
for every pptalgorithmAthere is a negligible function neglsuch that
Pr
I←Gen(1n),x←Samp(I)[A(I,fI(x)) =hc(I,x)]≤1
2+negl(n).
Provea version of the Goldreich–Levin theorem for this setting, namely,
if a one-way function (resp., permutation) family Π exists, then there
exists aone-wayfunction (resp., permutation) family Π/primeand a hard-core
predicate hcof Π/prime.
7.10 Show a construction of a pseudorandom generator from any one-way
permutation family. You may use the result of the previous exercise.
7.11 This exercise is for students who have taken a course in complexity
theory or are otherwise familiar with NPcompleteness.
(a) Show that the existence of one-way functions implies P/negationslash=NP.
(b) Assume that P /negationslash=NP. Show that there exists a function f
that is: (1) computable in polynomial time, (2) hard to invert
in the worst case (i.e., for all probabilistic polynomial-time A,
Prx←{0,1}n[f(A(f(x))) =f(x)]/negationslash= 1), but (3) is notone-way.
7.12 Let x∈{0,1}nand denote x=x1···xn. Prove that if there exists a
one-way function, then there exists a one-way function fsuch that for
everyithere is an algorithm Aisuch that
Pr
x←{0,1}n[Ai(f(x)) =xi]≥1
2+1
2n.
(This exercise demonstrates that it is not possible to claim that every
one-way function hides at least one speciﬁcbit of the input.)
7.13 Show that if a one-to-one function fhas a hard-core predicate, then f
is one-way.
7.14 Show that if Construction 7.21 is modiﬁed in the natural way so that
Fk(x) is deﬁned for every nonempty string xof length at most n, then
the construction is no longer a pseudorandom function.*Theoretical Constructions of Symmetric-Key Primitives 281
7.15 Prove that if there exists a pseudorandom function that, using a key of
lengthn, mapsn-bit inputs to single-bit outputs, then there exists a
pseudorandom function that maps n-bit inputs to n-bit outputs.
Hint:Use a key of length n2, and prove your construction secure using
a hybrid argument.
7.16 Provethatatwo-roundFeistelnetworkusingpseudorandomroundfunc-
tions (as in Equation (7.15)) is not pseudorandom.
7.17 Prove that a three-round Feistel network using pseudorandom round
functions (as in Equation (7.16)) is not strongly pseudorandom.
Hint:This is signiﬁcantly more diﬃcult than the previous exercise. Use
a distinguisher that makes two queries to the permutation and one query
to its inverse.
7.18 Consider the keyed permutation F∗deﬁned by
F∗
k(x)def=Feistel Fk,Fk,Fk(x).
(Note that the same key is used in each round.) Show that F∗is not
pseudorandom.
7.19 Let Gbe a pseudorandom generator with expansion factor /lscript(n) =n+1.
Prove that Gis a one-way function.
7.20 LetX,Y,Zbe probability ensembles. Prove that if Xc≡YandYc≡Z,
thenXc≡Z.
7.21 Prove Theorem 7.32.
7.22 LetX={Xn}n∈NandY={Yn}n∈Nbe computationally indistinguish-
able probability ensembles. Provethat for any probabilistic polynomial-
time algorithmA, the ensembles{A(Xn)}n∈Nand{A(Yn)}n∈Narecom-
putationally indistinguishable.Part III
Publ
ic-Key (Asymmetric)
Cry
ptographyChapter 8
Number Theory and Cryptographic
Hardness Assumptions
Moderncryptosystemsareinvariablybasedonanassumptionthat someprob-
lem is hard. In Chapters 3 and 4, for example, we saw that private-key
cryptography—both encryption schemes and message authentication codes—
can be based on the assumption that pseudorandom permutations (a.k.a.
block ciphers) exist. Recall, roughly, this means that there exists some keyed
permutation Ffor which it is hard to distinguish in polynomial time between
interactions with Fk(for a uniform, unknown key k) and interactions with a
truly random permutation.
On the face of it, the assumption that pseudorandom permutations exist
seems quite strong and unnatural, and it is reasonable to ask whether this
assumptionistrueorwhetherthereisanyevidencetosupportit. InChapter6
we explored how block ciphers are constructed in practice. The fact that
existing constructions are resistant to attack serves as an indication that the
existence of pseudorandom permutations is plausible. Still, it may be diﬃcult
to believe that there are noeﬃcient distinguishing attacks on existing block
ciphers. Moreover, the current state of our theory is such that we do not
know how to prove the pseudorandomness of any of the existing practical
constructions relative to any “simpler” or “more reasonable” assumption. All
in all, this is not entirely a satisfying state of aﬀairs.
In contrast, as mentioned in Chapter 3 (and investigated in detail in Chap-
ter 7) it is possible to provethat pseudorandom permutations exist based
on the much milder assumption that one-way functions exist. (Informally,
a function is one-way if it is easy to compute but hard to invert; see Sec-
tion 8.4.1.) Apart from a brief discussion in Section 7.1.2, however, we have
not seen concrete examples of functions believed to be one-way.
One goal of this chapter is to introduce various problems believed to be
“hard,” and to present conjectured one-way functions based on those prob-
lems.1This chapter can thus be viewed as a culmination of a “top down”
approach to private-key cryptography. (See Figure 8.1.) That is, in Chap-
ters 3 and 4 we have shown that private-key cryptography can be based on
pseudorandom functions and permutations. We have then seen that the latter
1Recall we currently do not know how to provethat one-way functions exist, so the best we
can do is base one-way functions on assumptions regarding the hardness of certain problems.
285286 Introduction to Modern Cryptography
can be instantiated in practice using block ciphers, as explored in Chapter 6,
or can be constructed in a rigorous fashion from any one-way function, as
shown in Chapter 7. Here, we take this one step further and show how one-
way functions can be based on certain hard mathematical problems.
/MT80/MT114/MT105/MT118/MT97/MT116/MT101/MT45/MT75/MT101/MT121
/MT69/MT110/MT99/MT114/MT121/MT112/MT116/MT105/MT111/MT110/MT77/MT101/MT115/MT115/MT97/MT103/MT101
/MT65/MT117/MT116/MT104/MT101/MT110/MT116/MT105/MT99/MT97/MT116/MT105/MT111/MT110
/MT67/MT111/MT100/MT101/MT115
/MT80/MT115/MT101/MT117/MT100/MT111/MT114/MT97/MT110/MT100/MT111/MT109
/MT80/MT101/MT114/MT109/MT117/MT116 /MT97/MT116/MT105/MT111/MT110/MT115
/MT66/MT108/MT111/MT99/MT107
/MT67/MT105/MT112/MT104/MT101/MT114/MT115/MT80/MT115/MT101/MT117/MT100/MT111/MT114/MT97/MT110/MT100/MT111/MT109
/MT71/MT101/MT110/MT101/MT114/MT97/MT116/MT111/MT114/MT115
/MT79/MT110/MT101/MT45/MT87/MT97/MT121
/MT70/MT117/MT110/MT99/MT116/MT105/MT111/MT110/MT115
/MT82/MT83/MT65/MT44/MT32/MT70/MT97/MT99/MT116/MT111/MT114/MT105/MT110/MT103/MT44
/MT68/MT105/MT115/MT99/MT114/MT101/MT116/MT101/MT32/MT76/MT111/MT103/MT97/MT114/MT105/MT116/MT104/MT109/MT84/MT104/MT105/MT115/MT32/MT99/MT104/MT97/MT112/MT116/MT101/MT114/MT67/MT104/MT97/MT112/MT116/MT101/MT114/MT32/MT55 /MT67/MT104/MT97/MT112/MT116/MT101/MT114/MT32/MT54/MT67/MT104/MT97/MT112/MT116/MT101/MT114/MT32/MT51 /MT67/MT104/MT97/MT112/MT116/MT101/MT114/MT32/MT52
FIGURE 8.1 :Private-key cryptography: a top-down approach.
The examples we explore are number theoretic in nature, and we therefore
begin with a short introduction to number theory and group theory. Be-
cause we are also interested in problems that can be solved eﬃciently (even a
one-way function needs to be easy to compute in one direction, and a cryp-
tographic scheme must admit eﬃcient algorithms for the honest parties), we
also initiate a study of algorithmic number theory. Even the reader who is
familiar with number theory or group theory is encouraged to read this chap-
ter, since algorithmic aspects are typically ignored in a purely mathematical
treatment of these topics.
Asecondgoalofthischapteristodevelopthematerialneeded for public-key
cryptography , whose study we will begin in Chapter 10. Strikingly, although
in the private-key setting there exist eﬃcient constructions of the necessary
primitives (block ciphers and hash functions) without invoking any number
theory, in the public-key setting all known constructions rely on hard number-
theoretic problems . The material in this chapter thus serves both as a culmi-
nation ofwhat we havestudied sofarwith regardto private-keycryptography,
as well as the foundation for public-key cryptography.Number Theory and Cryptographic Hardness Assumptions 287
8.1 Preliminaries and Basic Group Theory
Webegin with a review of prime numbers and basic modular arithmetic.
Even the reader who has seen these topics before should skim the next two
sections since some of the materialmay be new and we include proofs for most
of the stated results.
8.1.1 Primes and Divisibility
The set of integers is denoted by Z. Fora,b∈Z, we say that adividesb,
writtena|b, if there exists an integer csuch that ac=b. Ifadoes not divide
b, we write a/negationslash|b. (We are primarily interested in the case where a,b, andc
are all positive, although the deﬁnition makes sense even when one or more
of these is negative or zero.) A simple observation is that if a|banda|cthen
a|(Xb+Yc) for any X,Y∈Z.
Ifa|bandais positive, we call aadivisorofb. Ifin addition a/negationslash∈{1,b}then
ais called a nontrivial divisor, or a factor, ofb. A positive integer p >1 is
primeif it has no factors; i.e., it has only two divisors: 1 and itself. A positive
integer greater than 1 that is not prime is called composite . By convention,
the number 1 is neither prime nor composite.
A fundamental theorem of arithmetic is that every integer greater than 1
can be expressed uniquely (up to ordering) as a product of primes. That is,
any positive integer N >1 can be written as N=/producttext
ipei
i, where the{pi}
are distinct primes and ei≥1 for all i; furthermore, the {pi}(and{ei}) are
uniquely determined up to ordering.
Wearefamiliarwiththeprocessof division with remainder fromelementary
school. The following proposition formalizes this notion.
PROPOSITION 8.1 Letabe an integer and let bbe a positive integer.
Then there exist unique integers q,rfor which a=qb+rand0≤r < b.
Furthermore, given integers aandbas in the proposition it is possible to
compute qandrin polynomial time; see Appendix B.1. (An algorithm’s
running time is measured as a function of the length(s) of its input(s). An
important point in the context of algorithmic number theory is that integer
inputs arealwaysassumedtoberepresentedin binary. The runningtime ofan
algorithm taking as input an integer Nis therefore measured in terms of /bardblN/bardbl,
thelength of the binary representation of N. Note that/bardblN/bardbl=⌊logN⌋+1.)
Thegreatest common divisor of two integers a,b, written gcd( a,b), is the
largest integer csuch that c|aandc|b. (We leave gcd(0 ,0) undeﬁned.) The
notion of greatest common divisor makes sense when either or both of a,bare
negative but we will typically have a,b≥1; anyway, gcd( a,b) = gcd(|a|,|b|).288 Introduction to Modern Cryptography
Note that gcd( b,0) = gcd(0 ,b) =b; also, if pis prime then gcd( a,p) is either
equal to 1 or p. If gcd(a,b) = 1 we say that aandbarerelatively prime .
The following is a useful result:
PROPOSITION 8.2 Leta,bbe positive integers. Then there exist in-
tegersX,Ysuch that Xa+Yb= gcd(a,b). Furthermore, gcd(a,b)is the
smallest positive integer that can be expressed in this way.
PROOF Consider the set Idef={ˆXa+ˆYb|ˆX,ˆY∈Z}. Note that a,b∈I,
and soIcertainly contains some positive integers. Let dbe the smallest
positive integer in I. We show that d= gcd(a,b); sincedcan be written as
d=Xa+Ybfor some X,Y∈Z(because d∈I), this proves the theorem.
To show this, we must prove that d|aandd|b, and that dis the largest
integer with this property. In fact, we can show that ddivides every element
inI. To see this, take an arbitrary c∈Iand write c=X/primea+Y/primebwith
X/prime,Y/prime∈Z. Using division with remainder (Proposition 8.1) we have that
c=qd+rwithq,rintegers and 0≤r < d. Then
r=c−qd=X/primea+Y/primeb−q(Xa+Yb) = (X/prime−qX)a+(Y/prime−qY)b∈I.
Ifr/negationslash= 0, this contradicts our choice of das thesmallest positive integer in I
(because r < d). So,r= 0 and hence d|c. This shows that ddivides every
element of I.
Sincea∈Iandb∈I, the above shows that d|aandd|band sodis a
common divisor of aandb. It remains to show that it is the largest common
divisor. Assume there is an integer d/prime> dsuch that d/prime|aandd/prime|b. Then by
the observation made earlier, d/prime|Xa+Yb. Since the latter is equal to d, this
meansd/prime|d. But this is impossible if d/primeis larger than d. We conclude that d
is the largest integer dividing both aandb, and hence d= gcd(a,b).
Givenaandb,theEuclidean algorithm can be used to compute gcd( a,b)
in polynomial time. The extended Euclidean algorithm can be used to com-
puteX,Y(as in the above proposition) in polynomial time as well. See
Appendix B.1.2 for details.
The preceding proposition is very useful in proving additional results about
divisibility. We show two examples now.
PROPOSITION 8.3 Ifc|abandgcd(a,c) = 1, thenc|b. Thus, if pis
prime and p|abthen either p|aorp|b.
PROOF Sincec|abwe have γc=abfor some integer γ. If gcd(a,c) = 1
then, by the previous proposition, we know there exist integers X,Ysuch thatNumber Theory and Cryptographic Hardness Assumptions 289
1 =Xa+Yc. Multiplying both sides by b, we obtain
b=Xab+Ycb=Xγc+Ycb=c·(Xγ+Yb).
Since (Xγ+Yb) is an integer, it follows that c|b.
The second part of the proposition follows from the fact that if p/negationslash|athen
gcd(a,p) = 1.
PROPOSITION 8.4 Ifa|N,b|N,andgcd(a,b) = 1, thenab|N.
PROOF Writeac=N,bd=N, and (using Proposition 8.2) 1 = Xa+Yb,
wherec,d,X,Y are all integers. Multiplying both sides of the last equation
byNwe obtain
N=XaN+YbN=Xabd+Ybac=ab(Xd+Yc),
showing that ab|N.
8.1.2 Modular Arithmetic
Leta,b,N∈ZwithN >1. We use the notation [ amodN] to denote the
remainder of aupon division by N. In more detail: by Proposition 8.1 there
exist unique q,rwitha=qN+rand 0≤r < N, and we deﬁne [ amodN] to
be equal to this r. Note therefore that 0 ≤[amodN]< N. We refer to the
process of mapping ato [amodN] asreduction modulo N.
We say that aandbarecongruent modulo N, written a=bmodN, if
[amodN] = [bmodN], i.e., if the remainder when ais divided by Nis the
same as the remainder when bis divided by N. Note that a=bmodNif and
only ifN|(a−b). By way of notation, in an expression such as
a=b=c=···=zmodN,
the understanding is that everyequal sign in this sequence (and not just the
last) refers to congruence modulo N.
Note that a= [bmodN] implies a=bmodN, but not vice versa. For
example, 36 = 21 mod 15 but 36 /negationslash= [21 mod 15] = 6. (On the other hand,
[amodN] = [bmodN] if and only if a=bmodN.)
Congruence modulo Nis an equivalence relation: i.e., it is reﬂexive ( a=
amodNfor alla), symmetric ( a=bmodNimpliesb=amodN), and tran-
sitive (if a=bmodNandb=cmodN, thena=cmodN). Congruence
moduloNalso obeys the standard rules of arithmetic with respect to addi-
tion, subtraction, and multiplication; so, for example, if a=a/primemodNand
b=b/primemodNthen (a+b) = (a/prime+b/prime) modNandab=a/primeb/primemodN. A con-
sequence is that we can “reduce and then add/multiply” instead of having to
“add/multiply and then reduce,” which can often simplify calculations.290 Introduction to Modern Cryptography
Example 8.5
Let us compute [1093028 ·190301mod 100]. Since 1093028= 28 mod 100 and
190301= 1 mod 100, we have
1093028·190301 = [1093028mod 100] ·[190301mod 100] mod 100
= 28·1 = 28 mod 100 .
The alternate way of calculating the answer (i.e., computing the product
1093028·190301 and then reducing the result modulo 100) is less eﬃcient. ♦
Congruence modulo Ndoesnot(in general) respect division. That is, if
a=a/primemodNandb=b/primemodNthen it is not necessarily true that a/b=
a/prime/b/primemodN; in fact, the expression “ a/bmodN” is not always well-deﬁned.
As a speciﬁc example that often causes confusion, ab=cbmodNdoesnot
necessarily imply that a=cmodN.
Example 8.6
TakeN= 24. Then 3·2 = 6 = 15·2 mod 24, but 3/negationslash= 15 mod 24. ♦
In certain cases, however, we can deﬁne a meaningful notion of division.
If for a given integer bthere exists an integer csuch that bc= 1 mod N, we
say that bisinvertible moduloNand call ca (multiplicative) inverseofb
moduloN. Clearly, 0 is never invertible. It is also not diﬃcult to show that if
cis a multiplicative inverse of bmoduloNthen so is [ cmodN]. Furthermore,
ifc/primeis another multiplicative inverse of bthen [cmodN] = [c/primemodN]. When
bis invertible we can therefore simply let b−1denote the uniquemultiplicative
inverse of bthat lies in the range {1,...,N−1}.
Whenbis invertible modulo N, we deﬁne division by bmoduloNas mul-
tiplication by b−1(i.e., we deﬁne [ a/bmodN]def= [ab−1modN]). We stress
that division by bisonly deﬁned whenbis invertible. If ab=cbmodNand
bis invertible, then we may divide each side of the equation by b(or, really,
multiply each side by b−1) to obtain
(ab)·b−1= (cb)·b−1modN⇒a=cmodN.
We see that in this case, division works “as expected.” Invertible integers
moduloNare therefore “nicer” to work with, in some sense.
The natural question is: which integers are invertible modulo a given mod-
ulusN? We can fully answer this question using Proposition 8.2:
PROPOSITION 8.7 Letb,Nbe integers, with b≥1andN >1. Thenb
is invertible modulo Nif and only if gcd(b,N) = 1.
PROOF Assume bis invertible modulo N, and let cdenote its inverse.
Sincebc= 1 mod N, this implies that bc−1 =γNfor some γ∈Z. Equiv-Number Theory and Cryptographic Hardness Assumptions 291
alently,bc−γN= 1. Since, by Proposition 8.2, gcd( b,N) is the smallest
positive integer that can be expressed in this way, and there is no positive
integer smaller than 1, this implies that gcd( b,N) = 1.
Conversely, if gcd( b,N) = 1 then by Proposition 8.2 there exist integers
X,Ysuch that Xb+YN= 1. Reducing each side of this equation modulo N
givesXb= 1 mod N, and we see that Xis a multiplicative inverse of b. (In
fact, this gives an eﬃcient algorithm to compute inverses.)
Example 8.8
Letb= 11 and N= 17. Then (−3)·11+2·17 = 1, and so 14 = [ −3 mod 17]
is the inverse of 11. One can verify that 14 ·11 = 1 mod 17. ♦
Addition, subtraction, multiplication, and computation of inverses (when
they exist) modulo Ncan all be carried out in polynomial time; see Ap-
pendix B.2. Exponentiation (i.e., computing [ abmodN] forb >0 an integer)
can also be computed in polynomial time; see Appendix B.2.3.
8.1.3 Groups
LetGbe a set. A binary operation ◦onGis simply a function ◦(·,·)
that takes as input two elements of G. Ifg,h∈Gthen instead of using the
cumbersome notation ◦(g,h), we write g◦h.
We now introduce the important notion of a group.
DEFINITION 8.9 Agroupis a setGalong with a binary operation ◦for
which the following conditions hold:
•(Closure:) For allg,h∈G,g◦h∈G.
•(Existence of an identity:) There exists an identitye∈Gsuch that
for allg∈G,e◦g=g=g◦e.
•(Existence of inverses:) For allg∈Gthere exists an element h∈G
such that g◦h=e=h◦g. Such an his called an inverseofg.
•(Associativity:) For allg1,g2,g3∈G,(g1◦g2)◦g3=g1◦(g2◦g3).
WhenGhas a ﬁnite number of elements, we say Gisﬁniteand let|G|denote
theorderof the group (that is, the number of elements in G).
A group Gwith operation◦isabelianif the following holds:
•(Commutativity:) For allg,h∈G,g◦h=h◦g.
When the binary operation is understood, we simply call the set Ga group.
Wewillalwaysdealwithﬁnite, abeliangroups. We willbe carefultospecify,
however, when a result requires these assumptions.292 Introduction to Modern Cryptography
Associativity implies that we do not need to include parentheses when writ-
ing long expressions; that is, the notation g1◦g2◦···◦gnis unambiguous
since it does not matter in what order we evaluate the operation ◦.
One can show that the identity element in a group Gisunique, and so we
can therefore refer to theidentity of a group. One can also show that each
elementgof a group has a uniqueinverse. See Exercise 8.1.
IfGis a group, a set H⊆Gis asubgroup of GifHitself forms a group
under the same operation associated with G. To check that His a subgroup,
we need to verify closure, existence of identity and inverses, and associativity
as per Deﬁnition 8.9. (In fact, associativity—as well as commutativity if Gis
abelian—is inherited automatically from G.) Every group Galways has the
trivial subgroups Gand{1}. We call Hastrictsubgroup of GifH/negationslash=G.
In general, we will not use the notation ◦to denote the group operation.
Instead, we will use either additive notation or multiplicative notation de-
pending on the group under discussion. This does not imply that the group
operation corresponds to integer addition or multiplication; it is merely useful
notation. When using additive notation, the group operation applied to two
elements g,his denoted g+h; the identity is denoted by 0; the inverse of an
elementgis denoted by−g; and we write h−gin place of h+(−g). When
using multiplicative notation, the group operation applied to g,his denoted
byg·hor simply gh; the identity is denoted by 1; the inverse of an element
gis denoted by g−1; and we sometimes write h/gin place of hg−1.
At this point, it may be helpful to see some examples.
Example 8.10
A set may be a group under one operation, but not another. For example,
the set of integers Zis an abelian group under addition: the identity is the
element 0, and every integer ghas inverse−g. On the other hand, it is not a
group under multiplication since, for example, the integer 2 does not have a
multiplicative inverse in the integers. ♦
Example 8.11
The set of real numbers Ris not a group under multiplication, since 0 does
not have a multiplicative inverse. The set of nonzero real numbers, however,
is an abelian group under multiplication with identity 1. ♦
The following example introduces the group ZNthat we will use frequently.
Example 8.12
LetN >1 be an integer. The set {0,...,N−1}with respect to addition
moduloN(i.e., where a+bdef= [a+bmodN]) is an abelian group of order N.
Closure is obvious; associativity and commutativity follow from the fact that
the integers satisfy these properties; the identity is 0; and, since a+(N−a) =
0 modN, it follows that the inverse of any element ais [(N−a) modN]. WeNumber Theory and Cryptographic Hardness Assumptions 293
denote this group by ZN. (We will also sometimes use ZNto denote the set
{0,...,N−1}without regard to any particular group operation.) ♦
We end this section with an easy lemma that formalizes a “cancelation law”
for groups.
LEMMA 8.13 LetGbe a group and a,b,c∈G. Ifac=bc, thena=b.
In particular, if ac=cthenais the identity in G.
PROOF We know ac=bc. Multiplying both sides by the unique inverse
c−1ofc, we obtain a=b. In detail:
ac=bc⇒(ac)c−1= (bc)·c−1⇒a(cc−1) =b(cc−1)⇒a·1 =b·1
⇒a=b.
Compare the above proof to the discussion (preceding Proposition 8.7) re-
garding a cancelation law for division modulo N. As indicated by the sim-
ilarity, the invertible elements modulo Nform a group under multiplication
moduloN. We will return to this example in more detail shortly.
Group Exponentiation
It is often useful to be able to describe the group operation applied mtimes
to a ﬁxed element g, where mis a positive integer. When using additive
notation, we express this as m·gormg; that is,
mg=m·gdef=g+···+g/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright
mtimes.
Notethat misaninteger, whilegisagroup element . Somgdoesnotrepresent
the group operation applied to mandg(indeed, we are working in a group
where the group operation is written additively). Thankfully, however, the
notation “behaves as it should”; so, for example, if g∈Gandm,m/primeare
integers then ( mg)+(m/primeg) = (m+m/prime)g,m(m/primeg) = (mm/prime)g, and 1·g=g. In
an abelian group Gwithg,h∈G, (mg)+(mh) =m(g+h).
When using multiplicative notation, we express application of the group
operation mtimes to an element gbygm. That is,
gmdef=g···g/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright
mtimes.
The familiar rules of exponentiation hold: gm·gm/prime=gm+m/prime, (gm)m/prime=gmm/prime,
andg1=g. Also, if Gis an abelian group and g,h∈Gthengm·hm= (gh)m.294 Introduction to Modern Cryptography
All these are simply “translations” of the results from the previous paragraph
to the setting of groups written multiplicatively rather than additively.
The above notation is extended in the natural way to the case when mis
zero or a negative integer. When using additive notation we deﬁne 0 ·gdef= 0
and (−m)·gdef=m·(−g) forma positive integer. (Note that in the equation
‘0·g= 0’ the 0 on the left-hand side is the integer 0 while the 0 on the right-
hand side is the identity element in the group.) Observe that −gis the inverse
ofgand, as one would expect, ( −m)·g=−(mg). When using multiplicative
notation, g0def= 1 and g−mdef= (g−1)m. Again, g−1is the inverse of g, and we
haveg−m= (gm)−1.
Letg∈Gandb≥0 be an integer. Then the exponentiation gbcan be
computed using a polynomial number of underlying group operations in G.
Thus, if the group operation can be computed in polynomial time then so can
exponentiation. This is discussed in Appendix B.2.3.
We now know enough to prove the following remarkable result:
THEOREM 8.14 LetGbe a ﬁnite group with m=|G|, the order of the
group. Then for any element g∈G,gm= 1.
PROOF We prove the theorem only when Gis abelian (although it holds
for any ﬁnite group). Fix arbitrary g∈G, and let g1,...,g mbe the elements
ofG. We claim that
g1·g2···gm= (gg1)·(gg2)···(ggm).
To see this, note that ggi=ggjimpliesgi=gjby Lemma 8.13. So each ofthe
melements in parentheses on the right-hand side is distinct. Because there
are exactly melements in G, themelements being multiplied together on the
right-hand side are simply all elements of Gin some permuted order. Since
Gis abelian, the order in which elements are multiplied does not matter, and
so the right-hand side is equal to the left-hand side.
Again using the fact that Gis abelian, we can “pull out” all occurrences of
gand obtain
g1·g2···gm= (gg1)·(gg2)···(ggm) =gm·(g1·g2···gm).
Appealing once again to Lemma 8.13, this implies gm= 1.
An important corollaryof the above is that we can work “modulo the group
order” in the exponent:
COROLLARY 8.15 LetGbe a ﬁnite group with m=|G|>1. Then for
anyg∈Gand any integer x, we have gx=g[xmodm].Number Theory and Cryptographic Hardness Assumptions 295
PROOF Sayx=qm+r, whereq,rare integers and r= [xmodm]. Then
gx=gqm+r=gqm·gr= (gm)q·gr= 1q·gr=gr
(using Theorem 8.14), as claimed.
Example 8.16
Written additively, the above corollary says that if gis an element in a group
of orderm, thenx·g= [xmodm]·g. As an example, consider the group Z15
of order m= 15, and take g= 11. The corollary says that
152·11 = [152 mod 15] ·11 = 2·11 = 11+11 = 22 = 7 mod 15 .
The above agrees with the fact (cf. Example 8.5) that we can “reduce and
then multiply” rather than having to “multiply and then reduce.” ♦
Another corollary that will be extremely useful for cryptographic applica-
tions is the following:
COROLLARY 8.17 LetGbe a ﬁnite group with m=|G|>1. Let
e >0be an integer, and deﬁne the function fe:G→Gbyfe(g) =ge.
Ifgcd(e,m) = 1, thenfeis a permutation (i.e., a bijection). Moreover,
ifd=e−1modmthenfdis the inverse of fe. (Note by Proposition 8.7,
gcd(e,m) = 1implieseis invertible modulo m.)
PROOF SinceGis ﬁnite, the second part of the claim implies the ﬁrst;
thus, we need only show that fdis the inverse of fe. This is true because for
anyg∈Gwe have
fd(fe(g)) =fd(ge) = (ge)d=ged=g[edmodm]=g1=g,
where the fourth equality follows from Corollary 8.15.
8.1.4 The Group Z∗
N
Asdiscussed in Example 8.12, the set ZN={0,...,N−1}is a group under
addition modulo N. Can we deﬁne a group with respect to multiplication
moduloN? In doing so, we will have to eliminate those elements in ZNthat
arenotinvertible; e.g., wewillhavetoeliminate0sinceithasnomultiplicative
inverse. Nonzero elements may also fail to be invertible (cf. Proposition 8.7).
Whichelements b∈{1,...,N−1}areinvertiblemodulo N? Proposition8.7
says that these are exactly those elements bfor which gcd( b,N) = 1. We have296 Introduction to Modern Cryptography
also seen in Section 8.1.2 that whenever bis invertible, it has an inverse lying
in the range{1,...,N−1}. This leads us to deﬁne, for any N >1, the set
Z∗
Ndef={b∈{1,...,N−1}|gcd(b,N) = 1};
i.e.,Z∗
Nconsists of integers in the set {1,...,N−1}that are relatively prime
toN. Thegroupoperationismultiplicationmodulo N; i.e.,abdef= [abmodN].
We claim that Z∗
Nis an abelian group with respect to this operation.
Since 1 is always in Z∗
N, the set clearly contains an identity element. The
discussion above shows that each element in Z∗
Nhas a multiplicative in-
verse in the same set. Commutativity and associativity follow from the fact
that these properties hold over the integers. To show that closure holds, let
a,b∈Z∗
N; then [abmodN] has inverse [ b−1a−1modN], which means that
gcd([abmodN],N) = 1 and so ab∈Z∗
N. Summarizing:
PROPOSITION 8.18 LetN >1be an integer. Then Z∗
Nis an abelian
group under multiplication modulo N.
Deﬁneφ(N)def=|Z∗
N|, the order of the group Z∗
N. (φis called the Euler phi
function.) What is the value of φ(N)? First consider the case when N=p
is prime. Then allelements in{1,...,p−1}are relatively prime to p, and
soφ(p) =|Z∗
p|=p−1. Next consider the case that N=pq, wherep,qare
distinct primes. If an integer a∈{1,...,N−1}is not relatively prime to
N, then either p|aorq|a(acannot be divisible by both pandqsince this
would imply pq|abuta < N=pq). The elements in {1,...,N−1}divisible
bypare exactly the ( q−1) elements p,2p,3p,...,(q−1)p, and the elements
divisible by qare exactly the ( p−1) elements q,2q,...,(p−1)q. The number
of elements remaining (i.e., those that are neither divisible by pnorq) is
therefore given by
(N−1)−(q−1)−(p−1) =pq−p−q+1 = (p−1)(q−1).
We have thus proved that φ(N) = (p−1)(q−1) when Nis the product of
two distinct primes pandq.
You are asked to prove the following general result (used only rarely in the
rest of the book) in Exercise 8.4:
THEOREM 8.19 LetN=/producttext
ipei
i, where the{pi}are distinct primes and
ei≥1. Thenφ(N) =/producttext
ipei−1
i(pi−1).
Example 8.20
TakeN= 15 = 5·3. Then Z∗
15={1,2,4,7,8,11,13,14}and|Z∗
15|= 8 =
4·2 =φ(15). The inverse of 8 in Z∗
15is 2, since 8·2 = 16 = 1 mod 15. ♦Number Theory and Cryptographic Hardness Assumptions 297
We have shown that Z∗
Nis a group of order φ(N). The following are now
easy corollaries of Theorem 8.14 and Corollary 8.17:
COROLLARY 8.21 Take arbitrary integer N >1anda∈Z∗
N. Then
aφ(N)= 1 mod N.
For the speciﬁc case that N=pis prime and a∈{1,...,p−1}, we have
ap−1= 1 mod p.
COROLLARY 8.22 FixN >1. For integer e >0deﬁnefe:Z∗
N→Z∗
N
byfe(x) = [xemodN]. Ifeis relatively prime to φ(N)thenfeis a permuta-
tion. Moreover, if d=e−1modφ(N)thenfdis the inverse of fe.
8.1.5 *Isomorphisms and the Chinese Remainder Theorem
Two groups are isomorphic if they have the same underlying structure.
From a mathematical point of view, an isomorphism of a group Gprovides
an alternate, but equivalent, way of thinking about G. From a computational
perspective, an isomorphism provides a diﬀerent way to represent elements
inG, which can often have a signiﬁcant impact on algorithmic eﬃciency.
DEFINITION 8.23 LetG,Hbe groups with respect to the operations
◦G,◦H, respectively. A function f:G→His anisomorphism from GtoHif:
1.fis a bijection, and
2. For all g1,g2∈Gwe have f(g1◦Gg2) =f(g1)◦Hf(g2).
If there exists an isomorphism from GtoHthen we say that these groups are
isomorphic and write G/similarequalH.
In essence, an isomorphism from GtoHis just a renaming of elements of G
as elements of H. Note that if Gis ﬁnite and G/similarequalH, thenHmust be ﬁnite
and of the same size as G. Also, if there exists an isomorphism ffromGto
Hthenf−1is an isomorphism from HtoG. It is possible, however, that fis
eﬃciently computable while f−1is not (or vice versa).
The aim of this section is to use the language of isomorphisms to better
understand the group structure of ZNandZ∗
NwhenN=pqis a product of
two distinct primes. We ﬁrst need to introduce the notion of a direct product
of groups. Given groups G,Hwith group operations ◦G,◦H, respectively, we
deﬁne a new group G×H(thedirect product of GandH) as follows. The
elements of G×Hare ordered pairs ( g,h) withg∈Gandh∈H; thus, if G298 Introduction to Modern Cryptography
hasnelements and Hhasn/primeelements, G×Hhasn·n/primeelements. The group
operation◦onG×His applied component-wise; that is:
(g,h)◦(g/prime,h/prime)def= (g◦Gg/prime, h◦Hh/prime).
We leave it to Exercise 8.8 to verify that G×His indeed a group. The above
notation can be extended to direct products of more than two groups in the
natural way, although we will not need this for what follows.
We may now state and prove the Chinese remainder theorem .
THEOREM 8.24 (Chinese remainder theorem) LetN=pqwhere
p,q >1are relatively prime. Then
ZN/similarequalZp×ZqandZ∗
N/similarequalZ∗
p×Z∗
q.
Moreover, let fbe the function mapping elements x∈{0,...,N−1}to pairs
(xp,xq)withxp∈{0,...,p−1}andxq∈{0,...,q−1}deﬁned by
f(x)def= ([xmodp],[xmodq]).
Thenfis an isomorphism from ZNtoZp×Zq, and the restriction of fto
Z∗
Nis an isomorphism from Z∗
NtoZ∗
p×Z∗
q.
PROOF For any x∈ZNthe output f(x) is a pair of elements ( xp,xq)
withxp∈Zpandxq∈Zq. We claim that if x∈Z∗
N, then (xp,xq)∈Z∗
p×Z∗
q.
Indeed, if xp/negationslash∈Z∗
pthen this means that gcd([ xmodp], p)/negationslash= 1. But then
gcd(x,p)/negationslash= 1. This implies gcd( x,N)/negationslash= 1, contradicting the assumption that
x∈Z∗
N. (An analogous argument holds if xq/negationslash∈Z∗
q.)
We nowshowthat fisan isomorphismfrom ZNtoZp×Zq. (The proofthat
it is an isomorphism from Z∗
NtoZ∗
p×Z∗
qis similar.) Let us start by proving
thatfis one-to-one. Say f(x) = (xp,xq) =f(x/prime). Then x=xp=x/primemodp
andx=xq=x/primemodq. This in turn implies that ( x−x/prime) is divisible by
bothpandq. Since gcd( p,q) = 1, Proposition 8.4 says that pq=Ndivides
(x−x/prime). But then x=x/primemodN. Forx,x/prime∈ZN, this means that x=x/prime
and sofis indeed one-to-one. Since |ZN|=N=p·q=|Zp|·|Zq|, the sizes
ofZNandZp×Zqare the same. This in combination with the fact that fis
one-to-one implies that fis bijective.
In the following paragraph, let + Ndenote addition modulo N, and let /squareplus
denote the group operation in Zp×Zq(i.e., addition modulo pin the ﬁrst
component and addition modulo qin the second component). To conclude
the proof that fis an isomorphism from ZNtoZp×Zq, we need to show that
for alla,b∈ZNit holds that f(a+Nb) =f(a)/squareplusf(b).Number Theory and Cryptographic Hardness Assumptions 299
To see that this is true, note that
f(a+Nb) =/parenleftBig
[(a+Nb) modp],[(a+Nb) modq]/parenrightBig
=/parenleftBig
[(a+b) modp],[(a+b) modq]/parenrightBig
=/parenleftBig
[amodp],[amodq]/parenrightBig
/squareplus/parenleftBig
[bmodp],[bmodq]/parenrightBig
=f(a)/squareplusf(b).
(For the second equality, above, we use the fact that [[ XmodN] modp] =
[[Xmodp] modp] whenp|N; see Exercise 8.9.)
AnextensionoftheChineseremaindertheoremsaysthatif p1,p2,...,p/lscriptare
pairwise relatively prime (i.e., gcd( pi,pj) = 1 for all i/negationslash=j) andNdef=/producttext/lscript
i=1pi,
then
ZN/similarequalZp1×···×Zp/lscriptandZ∗
N/similarequalZ∗
p1×···×Z∗
p/lscript.
An isomorphism in each case is obtained by a natural extension of the one
used in the theorem above.
By way of notation, with Nunderstood and x∈{0,1,...,N−1}we write
x↔(xp,xq) forxp= [xmodp] andxq= [xmodq]. That is, x↔(xp,xq) if
and only if f(x) = (xp,xq), where fis as in the theorem above. One way to
think about this notation is that it means “ x(inZN)corresponds to (xp,xq)
(inZp×Zq).” The same notation is used when dealing with x∈Z∗
N.
Example 8.25
Take 15 = 5·3, and consider Z∗
15={1,2,4,7,8,11,13,14}. The Chinese
remainder theorem says this group is isomorphic to Z∗
5×Z∗
3. We can compute
1↔(1,1) 2↔(2,2) 4↔(4,1) 7↔(2,1)
8↔(3,2) 11↔(1,2) 13↔(3,1) 14↔(4,2),
where each pair ( a,b) witha∈Z∗
5andb∈Z∗
3appears exactly once. ♦
Using the Chinese Remainder Theorem
If two groups are isomorphic, then they both serve as representations of the
same underlying “algebraic structure.” Nevertheless, the choice of which rep-
resentation to use can aﬀect the computational eﬃciency of group operations.
We discuss this abstractly, and then in the speciﬁc context of ZNandZ∗
N.
LetG,Hbe groups with operations ◦G,◦H, respectively, and say fis an
isomorphism from GtoHwhere both fandf−1can be computed eﬃciently.
Then for g1,g2∈Gwe can compute g=g1◦Gg2in two ways: either by
directly computing the group operation in G, or via the following steps:
1. Compute h1=f(g1) andh2=f(g2);300 Introduction to Modern Cryptography
2. Compute h=h1◦Hh2using the group operation in H;
3. Compute g=f−1(h).
The above extends in the natural way when we want to compute multiple
groupoperationsin G(e.g., to compute gxforsomeinteger x). Which method
is better depends on the relative eﬃciency of computing the group operation
in each group, as well as the eﬃciency of computing fandf−1.
We now turn to the speciﬁc case of computations modulo N, whenN=pq
is a product of distinct primes. The Chinese remainder theorem shows that
addition, multiplication, or exponentiation (which is just repeated multiplica-
tion)modulo Ncanbe“transformed”toanalogousoperationsmodulo pandq.
Building on Example 8.25, we show some simple examples with N= 15.
Example 8.26
Say we want to compute the product 14 ·13 modulo 15 (i.e., in Z∗
15). Exam-
ple 8.25 gives 14↔(4,2) and 13↔(3,1). InZ∗
5×Z∗
3, we have
(4,2)·(3,1) = ([4·3 mod 5] ,[2·1 mod 3]) = (2 ,2).
Note (2,2)↔2, which is the correct answer since 14 ·13 = 2 mod 15. ♦
Example 8.27
Say we want to compute 1153mod 15. Example 8.25 gives 11 ↔(1,2). Notice
that 2 =−1 mod 3 and so
(1,2)53= ([153mod 5],[(−1)53mod 3]) = (1 ,[−1 mod 3]) = (1 ,2).
Thus, 1153mod 15 = 11. ♦
Example 8.28
Say we want to compute [29100mod 35]. We ﬁrst compute the correspon-
dence 29↔([29 mod 5], [29 mod 7]) = ([ −1 mod 5] ,1). Using the Chinese
remainder theorem, we have
([−1 mod 5],1)100= ([(−1)100mod 5],[1100mod 7]) = (1 ,1),
and it is immediate that (1 ,1)↔1. We conclude that [29100mod 35] = 1.♦
Example 8.29
Say we want to compute [1825mod 35]. We have 18 ↔(3,4) and so
1825mod 35↔(3,4)25= ([325mod 5],[425mod 7]).
SinceZ∗
5is a group of order 4, we can “work modulo 4 in the exponent” (cf.
Corollary 8.15) and see that
325= 3[25 mod 4]= 31= 3 mod 5 .Number Theory and Cryptographic Hardness Assumptions 301
Similarly,
425= 4[25 mod 6]= 41= 4 mod 7 .
Thus, ([325mod 5],[425mod 7]) = (3 ,4)↔18 and so [1825mod 35] = 18.♦
One thing we have not yet discussed is how to convert back and forth
between the representation of an element modulo Nand its representation
modulopandq. The conversion can be carried out eﬃciently provided the
factorization of Nis known. Assuming pandqare known, it is easy to map
an element xmoduloNto its corresponding representation modulo pandq:
the element xcorresponds to ([ xmodp],[xmodq]), and both the modular
reductions can be carried out eﬃciently (cf. Appendix B.2).
For the other direction, we make use of the following observation: an ele-
ment with representation ( xp, xq) can be written as
(xp, xq) =xp·(1,0)+xq·(0,1).
So, if we can ﬁnd elements 1 p,1q∈{0,...,N−1}such that 1 p↔(1,0) and
1q↔(0,1), then (appealing to the Chinese remainder theorem) we know that
(xp, xq)↔[(xp·1p+xq·1q) modN].
Sincep,qare distinct primes, gcd( p,q) = 1. We can use the extended Eu-
clidean algorithm (cf. Appendix B.1.2) to ﬁnd integers X,Ysuch that
Xp+Yq= 1.
Note that Yq= 0 mod qandYq= 1−Xp= 1 mod p. This means that
[YqmodN]↔(1,0); i.e., [YqmodN] = 1p. Similarly, [ XpmodN] = 1q.
In summary, we can convert an element represented as ( xp,xq) to its rep-
resentation modulo Nin the following way (assuming pandqare known):
1. Compute X,Ysuch that Xp+Yq= 1.
2. Set 1 p:= [YqmodN] and 1 q:= [XpmodN].
3. Compute x:= [(xp·1p+xq·1q) modN].
If many such conversions will be performed, then 1 p,1qcan be computed
once-and-for-all in a preprocessing phase.
Example 8.30
Takep= 5,q= 7, and N= 5·7 = 35. Say we are given the representation
(4,3) and want to convert this to the corresponding element of Z35. Using
the extended Euclidean algorithm, we compute
3·5−2·7 = 1.302 Introduction to Modern Cryptography
Thus, 1 p= [−2·7 mod 35] = 21 and 1 q= [3·5 mod 35] = 15. (We can check
that these are correct: e.g., for 1 p= 21 we can verify that [21 mod 5] = 1 and
[21 mod 7] = 0.) Using these values, we can then compute
(4,3) = 4·(1,0)+3·(0,1)
↔[4·1p+3·1qmod 35]
= [4·21+3·15 mod 35] = 24 .
Since 24 = 4 mod 5 and 24 = 3 mod 7, this is indeed the correct result. ♦
8.2 Primes, Factoring, and RSA
Inthis section, we show the ﬁrst examples of number-theoretic problems
that are conjectured to be “hard.” We begin with a discussion of one of the
oldest problems: integer factorization or justfactoring .
Given a composite integer N, the factoring problem is to ﬁnd integers
p,q >1 such that pq=N. Factoring is a classic example of a hard problem,
both because it is so simple to describe and since it has been recognized as a
hard computational problem for a long time (even before its use in cryptog-
raphy). The problem can be solved in exponential timeO(√
N·polylog(N))
usingtrial division : that is, by exhaustively checking whether pdividesN
forp= 2,...,⌊√
N⌋.(This method requires√
Ndivisions, each one taking
polylog(N) =/bardblN/bardblctime for some constant c.) This always succeeds because
although the largestprime factor of Nmay be as large as N/2, thesmallest
prime factor of Ncan be at most⌊√
N⌋.Although algorithms with better
running time are known (see Chapter 9), no polynomial-time algorithm for
factoring has been demonstrated despite many years of eﬀort.
Considerthefollowingexperimentforagivenalgorithm Aandparameter n:
The weak factoring experiment w-FactorA(n):
1. Choose two uniform n-bit integers x1,x2.
2. Compute N:=x1·x2.
3.Ais givenN, and outputs x/prime
1,x/prime
2>1.
4. The output of the experiment is deﬁned to be 1ifx/prime
1·x/prime
2=N,
and0otherwise.
We have just said that the factoring problem is believed to be hard. Does
this mean that
Pr[w-FactorA(n) = 1]≤negl(n)
is negligible for every pptalgorithmA? Not at all. For starters, the number
Nin the above experiment is evenwith probability 3 /4 (this occurs whenNumber Theory and Cryptographic Hardness Assumptions 303
eitherx1orx2is even); it is, of course, easy for Ato factor Nin this case.
While we can make A’s job more diﬃcult by requiring Ato output integers
x/prime
1,x/prime
2of length n, it remains the case that x1orx2(and hence N) might
have small prime factors that can still be easily found. For cryptographic
applications, we will need to prevent this.
As this discussion indicates, the “hardest” numbers to factor are those
havingonlylargeprimefactors. Thissuggestsredeﬁningtheaboveexperiment
so thatx1,x2are random n-bitprimesrather than random n-bitintegers,
and in fact such an experiment will be used when we formally deﬁne the
factoring assumption in Section 8.2.3. For this experiment to be useful in a
cryptographic setting, however, it is necessary to be able to generate random
n-bit primes eﬃciently . This is the topic of the next two sections.
8.2.1 Generating Random Primes
A natural approach to generating a random n-bit prime is to repeatedly
choose random n-bit integers until we ﬁnd one that is prime; we repeat this
at mostttimes or until we are successful. See Algorithm 8.31 for a high-level
description of the process.
ALGORITHM 8.31
Generating a random prime – high-level outline
Input:Lengthn; parameter t
Output: A uniform n-bit prime
fori= 1 tot:
p/prime←{0,1}n−1
p:= 1/bardblp/prime
ifpis prime returnp
returnfail
Notethatthealgorithmforcestheoutputtobeanintegeroflength exactlyn
(rather than length at mostn) by ﬁxing the high-order bit of pto “1.” Our
convention throughout this book is that an “integer of length n” means an
integer whose binary representation with most signiﬁcant bit equal to 1 is
exactlynbits long.
Given a way to determine whether or not a given integer pis prime, the
above algorithm outputs a uniform n-bit prime conditioned on the event that
itdoesnotoutput fail. Theprobabilitythatthealgorithmoutputs faildepends
ont, and for our purposes we will want to set tso as to obtain a failure
probability that is negligible in n. To show that Algorithm 8.31 leads to an
eﬃcient (i.e., polynomial-time in n) algorithm for generating primes, we need
a better understanding of two issues: (1) the probability that a uniform n-
bit integer is prime and (2) how to eﬃciently test whether a given integer304 Introduction to Modern Cryptography
pis prime. We discuss these issues brieﬂy now, and defer a more in-depth
exploration of the second topic to the following section.
The distribution of primes. Theprime number theorem , an important
result in mathematics, gives fairly precise bounds on the fraction of integers
of a given length that are prime. For our purposes, we need only a weak,
one-sided version of that result that we do not prove here:
THEOREM 8.32 (Bertrand’s postulate) For any n >1, the fraction
ofn-bit integers that are prime is at least 1/3n.
Returning to the approach for generating primes described above, this implies
that if we set t= 3n2then the probability that a prime is notchosen in all t
iterations of the algorithm is at most
/parenleftbigg
1−1
3n/parenrightbiggt
=/parenleftBigg/parenleftbigg
1−1
3n/parenrightbigg3n/parenrightBiggn
≤/parenleftbig
e−1/parenrightbign=e−n
(using Inequality A.2), which is negligible in n. Thus, using poly(n) iterations
weobtain analgorithmforwhichthe probabilityofoutputting failisnegligible
inn. (Tighter results than Theorem 8.32 are known, and so in practice even
fewer iterations are needed.)
Testing primality. The problem of eﬃciently determining whether a given
number is prime has a long history. In the 1970s the ﬁrst eﬃcient algorithms
for testing primality were developed. These algorithms were probabilistic and
hadthefollowingguarantee: iftheinput pwereaprimenumber,thealgorithm
would always output “prime.” On the other hand, if pwere composite, then
the algorithm would almost alwaysoutput “composite,” but might output the
wrong answer (“prime”) with probability negligible in the length of p. Put
diﬀerently, ifthealgorithmoutputs“composite”then pisdeﬁnitelycomposite,
but if the output is “prime” then it is very likely that pis prime but it is also
possible that a mistake has occurred (and pis really composite).2
When using a randomized primality test of this sort in Algorithm 8.31 (the
prime-generation algorithm shown earlier), the output of the algorithm is a
uniform prime of the desired length so long as the algorithm does not output
failandthe randomized primality test did not err during the execution of
the algorithm. This means that an additional source of error (besides the
possibilityofoutputting fail) isintroduced, andthealgorithmmaynowoutput
a composite number by mistake. Since we can ensure that this happens with
only negligible probability, this remote possibility is of no practical concern
and we can safely ignore it.
2There also exist probabilistic primality tests that work in the opposite way: they always
correctly identify composite numbers but sometimes make a mistake when given a prime
as input. We will not consider algorithms of this type.Number Theory and Cryptographic Hardness Assumptions 305
Adeterministic polynomial-timealgorithmfortestingprimalitywasdemon-
strated in a breakthroughresult in 2002. That algorithm, although running in
polynomial time, is slower than the probabilistic tests mentioned above. For
this reason, probabilistic primality tests are still used exclusively in practice
for generating large prime numbers.
In Section 8.2.2 we describe and analyze one of the most commonly used
probabilistic primality tests: the Miller–Rabin algorithm. This algorithm
takes two inputs: an integer pand a parameter t(in unary) that determines
the error probability. The Miller–Rabin algorithm runs in time polynomial in
/bardblp/bardblandt, and satisﬁes:
THEOREM 8.33 Ifpis prime, then the Miller–Rabin test always outputs
“prime.” If pis composite, the algorithm outputs “composite” except with
probability at most 2−t.
Putting it all together. Given the preceding discussion, we can now de-
scribeapolynomial-timeprime-generationalgorithmthat, oninput n, outputs
ann-bit prime except with probability negligible in n; moreover, conditioned
on the output pbeing prime, pis a uniformly distributed n-bit prime. The
full procedure is described in Algorithm 8.34.
ALGORITHM 8.34
Generating a random prime
Input:Lengthn
Output: A uniform n-bit prime
fori= 1 to 3n2:
p/prime←{0,1}n−1
p:= 1/bardblp/prime
runthe Miller–Rabin test on input pand parameter 1n
ifthe output is “prime,” returnp
returnfail
Generating primes of a particular form. Itissometimes desirable to
generate a random n-bit prime pof a particular form, for example, satisfying
p= 3 mod 4 or such that p= 2q+ 1 where qis also prime ( pof the latter
type are called strong primes ). In this case, appropriate modiﬁcations of the
prime-generation algorithm shown above can be used. (For example, in order
to obtain a prime of the form p= 2q+1, modify the algorithm to generate a
random prime q, compute p:= 2q+1, and then output pif it too is prime.)
While these modiﬁed algorithms work well in practice, rigorous proofs that
they run in polynomial time and fail with only negligible probability are more
complex (and, in some cases, rely on unproven number-theoretic conjectures306 Introduction to Modern Cryptography
regarding the density of primes of a particular form). A detailed exploration
of these issues is beyond the scope of this book, and we will simply assume
the existence of appropriate prime-generation algorithms when needed.
8.2.2 *Primality Testing
We now describe the Miller–Rabin primality test and prove Theorem 8.33.
(We rely on the material presented in Section 8.1.5.) This material is not used
directly in the rest of the book.
The key to the Miller–Rabin algorithm is to ﬁnd a property that distin-
guishes primes and composites. Let Ndenote the input number to be tested.
We start with the following observation: if Nis prime then|Z∗
N|=N−1,
and so for any a∈{1,...,N−1}we haveaN−1= 1 mod Nby Theorem 8.14.
This suggests testing whether Nis prime by choosing a uniform element a
and checking whether aN−1?= 1 mod N. IfaN−1/negationslash= 1 mod N, thenNcan-
not be prime. Conversely, we might hope that if Nis not prime then there
is a reasonable chance that we will pick awithaN−1/negationslash= 1 mod N, and so
by repeating this test many times we can determine whether Nis prime or
not with high conﬁdence. The above approach is shown as Algorithm 8.35.
(Recall that exponentiation modulo Nand computation of greatest common
divisors can be carried out in polynomial time. Choosing a uniform element
of{1,...,N−1}can also be done in polynomial time. See Appendix B.2.)
ALGORITHM 8.35
Primality testing – ﬁrst attempt
Input:IntegerNand parameter 1t
Output: A decision as to whether Nis prime or composite
fori= 1 tot:
a←{1,...,N−1}
ifaN−1/negationslash= 1 mod Nreturn“composite”
return“prime”
IfNisprime the algorithm always outputs “prime.” If Niscomposite, the
algorithmoutputs “composite”ifin anyiterationitﬁndsan a∈{1,...,N−1}
such that aN−1/negationslash= 1 mod N. Observe that if a/negationslash∈Z∗
NthenaN−1/negationslash= 1 mod N.
(If gcd(a,N)/negationslash= 1 then gcd( aN−1,N)/negationslash= 1 and so [ aN−1modN] cannot
equal 1.) For now, we therefore restrict our attention to a∈Z∗
N. We re-
fer to any such awithaN−1/negationslash= 1 mod Nas awitness that Nis composite , or
simply a witness. We might hope that when Nis composite there are many
witnesses, andthus the algorithmﬁnds suchawitnesswith “high”probability.
This intuition is correct provided there is at least one witness . Before proving
this, we need two group-theoretic lemmas.Number Theory and Cryptographic Hardness Assumptions 307
PROPOSITION 8.36 LetGbe a ﬁnite group, and H⊆G. Assume His
nonempty, and for all a,b∈Hwe have ab∈H. ThenHis a subgroup of G.
PROOF We need to verify that Hsatisﬁes all the conditions of Deﬁni-
tion 8.9. By assumption, His closed under the group operation. Associativity
inHis inherited automatically from G. Letm=|G|(here is where we use
the fact that Gis ﬁnite), and consider an arbitrary element a∈H. Closure
ofHmeans that Hcontains am−1=a−1as well as am= 1. Thus, Hcontains
the inverse of each of its elements, as well as the identity.
LEMMA 8.37 LetHbe a strict subgroup of a ﬁnite group G(i.e.,H/negationslash=G).
Then|H|≤|G|/2.
PROOF Let¯hbe an element of Gthat isnotinH; sinceH/negationslash=G, we
know such an ¯hexists. Consider the set ¯Hdef={¯hh|h∈H}. We show
that (1)|¯H|=|H|, and (2) every element of ¯Hlies outside of H; i.e., the
intersection of Hand¯His empty. Since both Hand¯Hare subsets of G, these
imply|G|≥|H|+|¯H|= 2|H|, proving the lemma.
For anyh1,h2∈H, if¯hh1=¯hh2then, multiplying by ¯h−1on each side, we
haveh1=h2. This shows that every distinct element h∈Hcorresponds to a
distinct element ¯hh∈¯H, proving (1).
Assumetowardacontradictionthat ¯hh∈Hforsome h. Thismeans ¯hh=h/prime
for some h/prime∈H, and so ¯h=h/primeh−1. Now,h/primeh−1∈HsinceHis a subgroup
andh/prime,h−1∈H. But this means that ¯h∈H, in contradiction to the way ¯h
was chosen. This proves (2) and completes the proof of the lemma.
The following theorem will enable us to analyze the algorithm given earlier.
THEOREM 8.38 FixN. Say there exists a witness that Nis composite.
Then at least half the elements of Z∗
Nare witnesses that Nis composite.
PROOF LetBadbe the set of elements in Z∗
Nthat are notwitnesses;
that is,a∈BadmeansaN−1= 1 mod N. Clearly, 1∈Bad. Ifa,b∈Bad,
then (ab)N−1=aN−1·bN−1= 1·1 = 1 mod Nand hence ab∈Bad. By
Lemma8.36,weconcludethat Badisasubgroupof Z∗
N. Since(byassumption)
there is at least one witness, Badis astrictsubgroup of Z∗
N. Lemma 8.37
then shows that |Bad|≤|Z∗
N|/2, showing that at least half the elements of
Z∗
NarenotinBad(and hence are witnesses).
LetNbe composite. If there exists a witness that Niscomposite, then
there are at least |Z∗
N|/2 witnesses. The probability that we ﬁnd either a
witness or an element not in Z∗
Nin any given iteration of the algorithm is308 Introduction to Modern Cryptography
thus at least 1 /2, and so the probability that the algorithm does not ﬁnd a
witness in any ofthe titerations(and hence the probabilitythat the algorithm
mistakenly outputs “prime”) is at most 2−t.
The above, unfortunately, does not give a complete solution since there are
inﬁnitely many composite numbers Nthat do not have anywitnesses that
they are composite! Such values Nare known as Carmichael numbers ; a
detailed discussion is beyond the scope of this book.
Happily, a reﬁnement of the above test can be shown to work for all N.
LetN−1 = 2ru, whereuis odd and r≥1. (It is easy to compute randu
givenN. Also, restricting to r≥1 means that Nis odd, but testing primality
is easy when Nis even!) The algorithm shown previously tests only whether
aN−1=a2ru= 1 mod N. A more reﬁned algorithm looks at the sequence of
r+1 values au,a2u,...,a2ru(all modulo N). Each term in this sequence is
the square of the preceding term; thus, if some value is equal to ±1 then all
subsequent values will be equal to 1.
Say that a∈Z∗
Nis astrong witness that Nis composite (or simply a
strong witness ) if (1)au/negationslash=±1 modNand (2) a2iu/negationslash=−1 modNfor all
i∈ {1,...,r−1}. Note that when an element aisnota strong witness
then the sequence ( au,a2u,...,a2ru) (all taken modulo N) takes one of the
following forms:
(±1,1,...,1) or ( ⋆,...,⋆,−1,1,...,1),
where⋆is an arbitrary term. If aisnota strong witness then we have
a2r−1u=±1 modNand
aN−1=a2ru=/parenleftBig
a2r−1u/parenrightBig2
= 1 mod N,
and soais not a witness that Nis composite, either. Put diﬀerently, if ais
a witness then it is also a strong witness and so there can only possibly be
morestrong witnesses than witnesses.
We ﬁrst show that if Nis prime then there does not exist a strong witness
thatNis composite. In doing so, we rely on the following easy lemma (which
is a special case of Proposition 13.16 proved subsequently in Chapter 13):
LEMMA 8.39 Sayx∈Z∗
Nis asquarerootof1modulo Nifx2= 1 mod N.
IfNis an odd prime then the only square roots of 1moduloNare[±1 modN].
PROOF Sayx2= 1 mod Nwithx∈{1,...,N−1}. Then 0 = x2−1 =
(x+1)(x−1) modN, implying that N|(x+ 1) orN|(x−1) by Proposi-
tion 8.3. This can only possibly occur if x= [±1 modN].
LetNbe an odd prime and ﬁx arbitrary a∈Z∗
N.Leti≥0 be the minimum
value for which a2iu= 1 mod N; sincea2ru=aN−1= 1 mod Nwe know thatNumber Theory and Cryptographic Hardness Assumptions 309
some such i≤rexists. If i= 0 then au= 1 mod Nandais not a strong
witness. Otherwise,
/parenleftBig
a2i−1u/parenrightBig2
=a2iu= 1 mod N
anda2i−1uis a square root of 1. If Nis an odd prime, the only square roots of
1 are±1; by choice of i, however, a2i−1u/negationslash= 1 mod N. Soa2i−1u=−1 modN,
andais not a strong witness. We conclude that when Nis an odd prime
there is no strong witness that Nis composite.
A composite integer Nis aprime power ifN=prfor some prime pand
integerr≥1. We now show that every odd, composite Nthat is not a prime
power has many strong witnesses.
THEOREM 8.40 LetNbe an odd number that is not a prime power.
Then at least half the elements of Z∗
Nare strong witnesses that Nis composite.
PROOF LetBad⊆Z∗
Ndenote the set of elements that are not strong
witnesses. We deﬁne a set Bad/primeand show that: (1) Badis a subset of Bad/prime,
and (2)Bad/primeis a strict subgroup of Z∗
N. This suﬃces because by combining
(2) and Lemma 8.37 we have that |Bad/prime|≤|Z∗
N|/2. Furthermore, by (1) it
holds that Bad⊆Bad/prime, and so|Bad|≤|Bad/prime|≤|Z∗
N|/2 as in Theorem 8.38.
Thus, at least half the elements of Z∗
Nare strong witnesses. (We stress that
we do not claim that Badis a subgroup of Z∗
N.)
Note ﬁrst that−1∈Badsince (−1)u=−1 modN(recalluis odd). Let
i∈{0,...,r−1}be the largest integer for which there exists an a∈Badwith
a2iu=−1 modN; alternatively, iis the largest integer for which there exists
ana∈Badwith
(au,a2u,...,a2ru) = (⋆,...,⋆,−1/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright
i+1terms,1,...,1).
Since−1∈Badand (−1)20u=−1 modN, some such iexists.
Fixias above, and deﬁne
Bad/primedef={a|a2iu=±1 modN}.
We now prove what we claimed above.
CLAIM 8.41 Bad⊆Bad/prime.
Leta∈Bad. Then either au= 1 mod Nora2ju=−1 modNfor some
j∈{0,...,r−1}. In the ﬁrst case, a2iu= (au)2i= 1 mod Nand soa∈Bad/prime.
In the second case, we have j≤iby choice of i. Ifj=ithen clearly a∈Bad/prime.310 Introduction to Modern Cryptography
Ifj < ithena2iu= (a2ju)2i−j= 1 mod Nanda∈Bad/prime. Since awas
arbitrary, this shows Bad⊆Bad/prime.
CLAIM 8.42 Bad/primeis a subgroup of Z∗
N.
Clearly 1∈Bad/prime. Furthermore, if a,b∈Bad/primethen
(ab)2iu=a2iub2iu= (±1)(±1) =±1 modN
and soab∈Bad/prime. By Lemma 8.36, Bad/primeis a subgroup.
CLAIM 8.43 Bad/primeis a strict subgroup of Z∗
N.
IfNis an odd, composite integer that is not a prime power, then Ncan be
written as N=N1N2withN1,N2>1 odd and gcd( N1,N2) = 1. Appealing
to the Chinese remainder theorem, let a↔(a1,a2) denote the representation
ofa∈Z∗
Nas an element of Z∗
N1×Z∗
N2; that is, a1= [amodN1] anda2=
[amodN2]. Takea∈Bad/primesuch that a2iu=−1 modN(such an amust exist
by the way we deﬁned i), and say a↔(a1,a2). Since−1↔(−1,−1) we have
(a1,a2)2iu= (a2iu
1, a2iu
2) = (−1,−1),
and so
a2iu
1=−1 modN1anda2iu
2=−1 modN2.
Consider the element b∈Z∗
Nwithb↔(a1,1). Then
b2iu↔(a1,1)2iu= ([a2iu
1modN1],1) = (−1,1)/negationslash↔±1.
That is, b2iu/negationslash=±1 modNand so we have found an element b/negationslash∈Bad/prime. This
proves that Bad/primeis astrictsubgroup of Z∗
Nand so, by Lemma 8.37, the size
ofBad/prime(and thus the size of Bad) is at most half the size of Z∗
N.
An integer Nisaperfect power ifN=ˆNefor integers ˆNande≥2 (here
it is not required for ˆNto be prime, although of course any prime power is
also a perfect power). Algorithm 8.44 gives the Miller–Rabin primality test.
Exercises 8.12 and 8.13 ask you to show that testing whether Nis a perfect
power, and testing whether a particular ais a strong witness, can be done
in polynomial time. Given these results, the algorithm clearly runs in time
polynomial in/bardblN/bardblandt. We can now complete the proof of Theorem 8.33:
PROOF IfNis an odd prime, there are no strong witnesses and so the
Miller–Rabin algorithm always outputs “prime.” If Nis even or a prime
power, the algorithm always outputs “composite.” The interesting case is
whenNis an odd, composite integer that is not a prime power. Consider anyNumber Theory and Cryptographic Hardness Assumptions 311
ALGORITHM 8.44
The Miller–Rabin primality test
Input:IntegerN >2 and parameter 1t
Output: A decision as to whether Nis prime or composite
ifNis even,return“composite”
ifNis a perfect power, return“composite”
compute r≥1 anduodd such that N−1 = 2ru
forj= 1 tot:
a←{1,...,N−1}
ifau/negationslash=±1 modNanda2iu/negationslash=−1 modNfori∈{1,...,r−1}
return“composite”
return“prime”
iteration of the inner loop. Note ﬁrst that if a/negationslash∈Z∗
Nthenau/negationslash=±1 modNand
a2iu/negationslash=−1 modNfori∈{1,...,r−1}. The probability of ﬁnding either a
strongwitnessoranelementnotin Z∗
Nisatleast1 /2(invokingTheorem8.40).
Thus, the probability that the algorithm never outputs “composite” in any of
thetiterations is at most 2−t.
8.2.3 The Factoring Assumption
LetGenModulus be a polynomial-time algorithm that, on input 1n, outputs
(N,p,q) whereN=pq, andpandqaren-bit primes except with probability
negligible in n. (The natural way to do this is to generate two uniform n-bit
primes, as discussed previously, and then multiply them to obtain N.) Then
consider the following experiment for a given algorithm Aand parameter n:
The factoring experiment FactorA,GenModulus (n):
1. RunGenModulus (1n)to obtain (N,p,q).
2.Ais givenN, and outputs p/prime,q/prime>1.
3. The output of the experiment is deﬁned to be 1ifp/prime·q/prime=N,
and0otherwise.
Note that if the output of the experiment is 1 then {p/prime,q/prime}={p,q}, unlessp
orqare composite (which happens with only negligible probability).
We now formally deﬁne the factoring assumption:
DEFINITION 8.45 Factoring is hard relative to GenModulus if for all
probabilistic polynomial-time algorithms Athere exists a negligible function
neglsuch that
Pr[FactorA,GenModulus (n) = 1]≤negl(n).
Thefactoring assumption is the assumption that there exists a GenModulus
relative to which factoring is hard.312 Introduction to Modern Cryptography
8.2.4 The RSA Assumption
The factoring problem has been studied for hundreds of years without an
eﬃcient algorithm being found. Although the factoring assumption does give
a one-way function (see Section 8.4.1), it unfortunately does not directlyyield
practical cryptosystems. (In Section 13.5.2, however, we show how to con-
struct eﬃcient cryptosystemsbased on aproblem whosehardnessis equivalent
to that of factoring.) This has motivated a search for other problems whose
diﬃculty is related to the hardness of factoring. The best known of these is a
problem introduced in 1978 by Rivest, Shamir, and Adleman and now called
theRSA problem in their honor.
Given a modulus Nand an integer e >2 relatively prime to φ(N), Corol-
lary 8.22 shows that exponentiation to the eth power modulo Nis apermu-
tation. We can therefore deﬁne [ y1/emodN] (for any y∈Z∗
N) as the unique
element of Z∗
Nwhich yields ywhen raised to the eth power modulo N; that is,
x=y1/emodNif and only if xe=ymodN. The RSA problem, informally,
is to compute [ y1/emodN] for a modulus Nof unknown factorization.
Formally, let GenRSA be a probabilistic polynomial-time algorithm that, on
input 1n, outputs a modulus Nthat is the product of two n-bit primes, as
well as integers e,d >0 with gcd( e,φ(N)) = 1 and ed= 1 mod φ(N). (Such a
dexists since eis invertible modulo φ(N). The purpose of dwill become clear
later.) The algorithm may fail with probability negligible in n. Consider the
following experiment for a given algorithm Aand parameter n:
The RSA experiment RSA-invA,GenRSA(n):
1. RunGenRSA(1n)to obtain (N,e,d).
2. Choose a uniform y∈Z∗
N.
3.Ais givenN,e,y, and outputs x∈Z∗
N.
4. The outputof the experiment is deﬁned tobe 1ifxe=ymodN,
and0otherwise.
DEFINITION 8.46 The RSA problem is hard relative to GenRSA if for all
probabilistic polynomial-time algorithms Athere exists a negligible function
neglsuch that Pr[RSA-invA,GenRSA(n) = 1]≤negl(n).
TheRSA assumption is that there exists a GenRSA algorithm relative to
which the RSA problem is hard. A suitable GenRSA algorithm can be con-
structed from any algorithm GenModulus that generates a composite modulus
alongwithitsfactorization. Ahigh-leveloutlineisprovidedasAlgorithm8.47,
where the only thing left unspeciﬁed is how exactly eis chosen. In fact, the
RSA problem is believed to be hard for anyethat is relatively prime to φ(N).
We discuss some typical choices of ebelow.Number Theory and Cryptographic Hardness Assumptions 313
ALGORITHM 8.47
GenRSA– high-level outline
Input:Security parameter 1n
Output: N,e,das described in the text
(N,p,q)←GenModulus (1n)
φ(N) := (p−1)(q−1)
choosee >1 such that gcd( e,φ(N)) = 1
compute d:= [e−1modφ(N)]
returnN,e,d
Example 8.48
SayGenModulus outputs ( N,p,q) = (143 ,11,13). Then φ(N) = 120. Next,
we need to choose an ethat is relatively prime to φ(N); say we take e= 7.
The next step is to compute dsuch that d= [e−1modφ(N)]. This can be
done as shown in Appendix B.2.2 to obtain d= 103. (One can check that
7·103 = 721 = 1 mod 120.) Our GenRSA algorithm thus outputs (143 ,7,103).
AsanexampleoftheRSAproblemrelativetotheseparameters,take y= 64
and so the problem is to compute the 7th root of 64 modulo 143 without
knowledge of dor the factorization of N. ♦
Computing ethrootsmodulo Nbecomeseasyif d,φ(N), orthefactorization
ofNis known. (As we show in the next section, any of these can be used to
eﬃciently compute the others.) This follows from Corollary8.22, which shows
that [ydmodN] is theeth root of ymoduloN. This asymmetry—namely,
that the RSA problem appears to be hard when dor the factorization of
Nis unknown, but becomes easy when disknown—serves as the basis for
applications of the RSA problem to public-key cryptography.
Example 8.49
Continuing the previous example, we can compute the 7th root of 64 mod-
ulo 143 using the value d= 103; the answer is 25 = 64d= 64103mod 143. We
can verify that this is the correct solution since 25e= 257= 64 mod 143.♦
On the choice of e.There does not appear to be any diﬀerence in the
hardness of the RSA problem for diﬀerent exponents eand, as such, diﬀerent
methods have been suggested for selecting it. One popular choice is to set
e= 3, since then computing eth powers modulo Nrequires only two multi-
plications (see Appendix B.2.3). If eis to be set equal to 3, then pandq
must be chosen with p,q/negationslash= 1 mod 3 so that gcd( e,φ(N)) = 1. For similar
reasons, another popular choice is e= 216+1 = 65537, a prime number with
low Hamming weight (in Appendix B.2.3, we explain why such exponents
are preferable). As compared to choosing e= 3, this makes exponentiation314 Introduction to Modern Cryptography
slightly more expensive but reduces the constraints on pandq, and avoids
some “low-exponent attacks”(described at the end of Section 11.5.1) that can
result from poorly implemented cryptosystems based on the RSA problem.
Note that choosing dsmall (that is, changing GenRSA to choose small d
and then compute e:= [d−1modφ(N)]) is a bad idea. If dlies in a very
small range then a brute-force search for dcan be carried out (and, as noted,
oncedis known the RSA problem can be solved easily). Even if dis chosen
so thatd≈N1/4, and so brute-force attacks are ruled out, there are known
algorithms that can be used to recover dfromNandein this case.
8.2.5 *Relating the RSA and Factoring Assumptions
SayGenRSA is constructed as in Algorithm 8.47. If Ncan be factored, then
we can compute φ(N) and use this to compute d:= [e−1modφ(N)] for any
givene(using Algorithm B.11). So for the RSA problem to be hard relative
toGenRSA, the factoring problem must be hard relative to GenModulus . Put
diﬀerently, the RSA problem cannot be morediﬃcult than factoring; hard-
ness of factoring (relative to GenModulus ) can only potentially be a weaker
assumption than hardness of the RSA problem (relative to GenRSA).
What about the other direction? That is, is hardness of the RSA problem
implied by hardness of factoring? This remains an open question. The best
we can show is that computing dfromNandeis as hard as factoring .
THEOREM 8.50 There is a probabilistic polynomial-time algorithm that,
given as input a composite integer Nand integers e,dwithed= 1 mod φ(N),
outputs a factor of Nexcept with probability negligible in /bardblN/bardbl.
PROOF The theorem holds for any N, but for simplicity—and because it
is the case most relevant to cryptography—we focus here on the case where
Nis a product of two distinct (odd) primes. We rely on Proposition 8.36 and
Lemma 8.37 as well as the following facts (which follow from more general
results proved in Sections 13.4.2 and 13.5.2):
•IfNis a product of two distinct, odd primes, then 1 has exactly four
square roots modulo N. Two of these are the “trivial” square roots ±1,
and two of these are “nontrivial” square roots.
•Any nontrivial square root of 1 can be used to (eﬃciently) compute a
factor of N. This is by virtue of the fact that y2= 1 mod Nimplies
0 =y2−1 = (y−1)(y+1) mod N,
and soN|(y−1)(y+1). However, N/negationslash|(y−1) andN/negationslash|(y+1) because
y/negationslash=±1 modN. So it must be the case that gcd( y−1,N) is equal to
one of the prime factors of N.
Letk=ed−1 and note that φ(N)|k. Using Corollary 8.21, we have
xk= 1 mod Nfor allx∈Z∗
N. Letk= 2ruforuan odd integer; note thatNumber Theory and Cryptographic Hardness Assumptions 315
r≥1 sinceφ(N) (and hence k) is even. Our strategy for factoring Nwill be
to repeatedly choose a uniform x∈Z∗
Nand compute the sequence
xu, x2u, ..., x2ru,
all modulo N. Each term in this sequence is the square of the preceding term
and, as we have just noted, the ﬁnal term in the sequence is 1. Take the
largesti(if any) for which ydef= [x2iumodN]/negationslash= 1. By our choice of i, we have
y2= 1 mod N. Ify/negationslash=−1 we have found a nontrivial square root of N, and
can then factor Nas discussed above.
Alltheabovestepscanbedoneinpolynomialtime, andsotheonlyquestion
is to determine the probability, over choice of x, thatyis a nontrivial square
root ofN. Leti∈{0,...,r−1}be the largest value of ifor which there
exists an x∈Z∗
Nsuch that x2iu/negationslash= 1 mod N. (Since uis odd (−1)u=−1/negationslash=
1 modN, and so the deﬁnition is not vacuous.) Then for all x∈Z∗
N, we have
x2i+1u= 1 mod Nand so [x2iumodN] is a square root of 1. Deﬁne
Baddef={x|x2iu=±1 modN}
and observe that if our algorithm chooses x/negationslash∈Badthen it ﬁnds a nontrivial
squarerootof1. Weshowthat Badisastrictsubgroupof Z∗
N; byLemma8.37,
this implies that |Bad|≤|Z∗
N|/2. This means that x/negationslash∈Bad(and the algo-
rithm ﬁnds a nontrivial square root of 1) with probability at least 1 /2 in each
iteration. Using suﬃciently many iterations gives the result of the theorem.
We now prove that Badis a strict subgroup of Z∗
N. First note that Badis
not empty, since 1 ∈Bad. Furthermore, if x,x/prime∈Badthen
(xx/prime)2iu=x2iu(x/prime)2iu= (±1)·(±1) =±1 modN,
and soxx/prime∈BadandBadis a subgroup. To see that Badis astrictsubgroup,
letx∈Z∗
Nbe such that x2iu/negationslash= 1 mod N(such an xmust exist by our deﬁ-
nition of i). Ifx2iu/negationslash=−1 modN, thenx/negationslash∈Badand we are done. Otherwise,
letN=pqwithp,qprime, and let x↔(xp,xq) be the Chinese remaindering
representation of x. Sincex2iu=−1 modN, we know that
(xp,xq)2iu= (x2iu
p,x2iu
q) = (−1,−1)↔−1.
But then ( xp,1) (or rather, the element corresponding to it) is not in Bad
since
(xp,1)2iu= ([x2iu
pmodp],1) = (−1,1)/negationslash↔±1.
This completes the proof.
Assuming factoring is hard, the above result rules out the possibility of
eﬃciently solving the RSA problem by ﬁrst computing dfromNande. How-
ever, it does not rule out the possibility that there might be some completely316 Introduction to Modern Cryptography
diﬀerent way of attacking the RSA problem that does not involve (or im-
ply) factoring N. Thus, based on our current knowledge, the RSA assump-
tion is stronger than the factoring assumption—that is, it may be that the
RSA problem can be solved in polynomial time even though factoring cannot.
Nevertheless, when GenRSA is constructed based on GenModulus as in Algo-
rithm 8.47, the prevailing conjecture is that the RSA problem is hard relative
toGenRSA whenever factoring is hard relative to GenModulus .
8.3 Cryptographic Assumptions in Cyclic Groups
Inthis section we introduce a class of cryptographic hardness assumptions
incyclic groups . We begin with a general discussion of cyclic groups, followed
by abstract deﬁnitions of the relevant assumptions. We then look at two
concreteandwidelyusedexamplesofcyclicgroupsinwhichtheseassumptions
are believed to hold.
8.3.1 Cyclic Groups and Generators
LetGbe a ﬁnite group of order m. For arbitrary g∈G, consider the set
/angbracketleftg/angbracketrightdef=/braceleftbig
g0,g1,.../bracerightbig
.
(We warn the reader that if Gis an inﬁnite group, /angbracketleftg/angbracketrightis deﬁned diﬀerently.)
By Theorem 8.14, we have gm= 1. Let i≤mbe the smallest positive integer
for which gi= 1. Then the above sequence repeats after iterms (i.e., gi=g0,
gi+1=g1, etc.), and so
/angbracketleftg/angbracketright=/braceleftbig
g0,...,gi−1/bracerightbig
.
We see that/angbracketleftg/angbracketrightcontains at most ielements. In fact, it contains exactly i
elements since if gj=gkwith 0≤j < k < i thengk−j= 1 and 0 < k−j < i,
contradicting our choice of ias the smallest positive integer for which gi= 1.
Itisnothardtoverifythat /angbracketleftg/angbracketrightisasubgroupof Gforanyg(seeExercise8.3);
we call/angbracketleftg/angbracketrightthesubgroup generated by g. If the order of the subgroup /angbracketleftg/angbracketrightisi,
theniis called the order of g; that is:
DEFINITION 8.51 LetGbe a ﬁnite group and g∈G. Theorder ofgis
the smallest positive integer iwithgi= 1.
The following is a useful analogue of Corollary 8.15 (the proof is identical):
PROPOSITION 8.52 LetGbe a ﬁnite group, and g∈Gan element of
orderi. Then for any integer x, we have gx=g[xmodi].Number Theory and Cryptographic Hardness Assumptions 317
We can prove something stronger:
PROPOSITION 8.53 LetGbe a ﬁnite group, and g∈Gan element of
orderi. Thengx=gyif and only if x=ymodi.
PROOF Ifx=ymodithen [xmodi] = [ymodi]and the previouspropo-
sition says that
gx=g[xmodi]=g[ymodi]=gy.
For the more interesting direction, say gx=gy. Then 1 = gx−y=g[x−ymodi]
(using the previous proposition). Since [ x−ymodi]< i, butiis the smallest
positive integer with gi= 1, we must have [ x−ymodi] = 0.
The identity element of any group Gisthe only element of order 1, and
generates the group /angbracketleft1/angbracketright={1}. At the other extreme, if there is an element
g∈Gthat has order m(wheremis the order of G), then/angbracketleftg/angbracketright=G. In this
case, we call Gacyclic group and say that gis agenerator ofG. (A cyclic
groupmayhavemultiple generators,andsowecannotspeakof thegenerator.)
Ifgis a generator of Gthen, by deﬁnition, every element h∈Gis equal to
gxfor some x∈{0,...,m−1}, a point we will return to in the next section.
Diﬀerent elements of the same group Gmay have diﬀerent orders. We can,
however, place some restrictions on what these possible orders might be.
PROPOSITION 8.54 LetGbe a ﬁnite group of order m, and say g∈G
has order i. Theni|m.
PROOF By Theorem 8.14 we know that gm= 1 =g0. Proposition 8.53
implies that m= 0 mod i.
The next corollary illustrates the power of this result:
COROLLARY 8.55 IfGis a group of prime order p, thenGis cyclic.
Furthermore, all elements of Gexcept the identity are generators of G.
PROOF By Proposition 8.54, the only possible orders of elements in G
are 1 and p. Only the identity has order 1, and so all other elements have
orderpand generate G.
Groups of prime order form one class of cyclic groups. The additive group
ZN,forN >1, gives another example of a cyclic group (the element 1 is
always a generator). The next theorem—a special case of Theorem A.21—318 Introduction to Modern Cryptography
gives an important additional class of cyclic groups; a proof is outside the
scope of this book, but can be found in any standard abstract algebra text.
THEOREM 8.56 Ifpis prime then Z∗
pis a cyclic group of order p−1.
Forp >3 prime, Z∗
pdoes not have prime order and so the above does not
follow from the preceding corollary.
Example 8.57
Consider the (additive) group Z15. As we have noted, Z15is cyclic and the
element 1 is a generator since 15 ·1 = 0 mod 15 and i·1 =i/negationslash= 0 mod 15 for
any 0< i <15 (recall that in this group the identity is 0).
Z15has other generators. For example, /angbracketleft2/angbracketright={0,2,4,..., 14,1,3, ..., 13}
and so 2 is also a generator.
Not every element generates Z15. For example, the element 3 has order 5
since 5·3 = 0 mod 15, and so 3 does not generate Z15. The subgroup /angbracketleft3/angbracketright
consists of the 5 elements {0,3,6,9,12}, and this is indeed a subgroup under
addition modulo 15. The element 10 has order 3 since 3 ·10 = 0 mod 15,
and the subgroup /angbracketleft10/angbracketrightconsists of the 3 elements {0,5,10}. The orders of the
subgroups (i.e., 5 and 3) divide |Z15|= 15 as required by Proposition 8.54. ♦
Example 8.58
Consider the (multiplicative) group Z∗
15of order (5−1)(3−1) = 8. We have
/angbracketleft2/angbracketright={1,2,4,8}, and so the order of 2 is 4. As required by Proposition 8.54,
4 divides 8. ♦
Example 8.59
Consider the (additive) group Zpof prime order p. We know this group is
cyclic, but Corollary 8.55 tells us more: namely, everyelement except 0 is
a generator. Indeed, for any h∈{1,...,p−1}and integer i >0 we have
ih= 0 mod pif and only if p|ih. But then Proposition 8.3 says that either
p|horp|i. The former cannot occur (since h < p), and the smallest positive
integer for which the latter can occur is i=p. We have thus shown that
every nonzero element hhas order p(and so generates Zp), in accordance
with Corollary 8.55. ♦
Example 8.60
Consider the (multiplicative) group Z∗
7, which is cyclic by Theorem 8.56. We
have/angbracketleft2/angbracketright={1,2,4}, and so 2 is nota generator. However,
/angbracketleft3/angbracketright={1,3,2,6,4,5}=Z∗
7,
and so 3 is a generator of Z∗
7. ♦Number Theory and Cryptographic Hardness Assumptions 319
The following example relies on the material of Section 8.1.5.
Example 8.61
LetGbe a cyclic group of order n, and let gbe a generator of G. Then
the mapping f:Zn→Ggiven by f(a) =gais an isomorphism between Zn
andG. Indeed, for a,a/prime∈Znwe have
f(a+a/prime) =g[a+a/primemodn]=ga+a/prime=ga·ga/prime=f(a)·f(a/prime).
Bijectivity of fcan be proved using the fact that nis the order of g.♦
The previous example shows that all cyclic groups of the same order are
isomorphic and thus the same from an algebraic point of view. We stress that
this is not true in a computational sense, and in particular an isomorphism
f−1:G→Zn(which we know must exist) need not be eﬃciently computable.
This point should become clearer from the discussion in the sections below as
well as Chapter 9.
8.3.2 The Discrete-Logarithm/Diﬃe–Hellman Assumptions
We now introduce several computational problems that can be deﬁned for
any class of cyclic groups. We will keep the discussion in this section abstract,
and consider speciﬁc examples of groups in which these problems are believed
to be hard in Sections 8.3.3 and 8.3.4.
We letGdenote a generic, polynomial-time, group-generation algorithm .
This is an algorithm that, on input 1n, outputs a description of a cyclic
groupG, its order q(with/bardblq/bardbl=n), and a generator g∈G. The description
of a cyclic group speciﬁes how elements of the group are represented as bit-
strings; we assume that each group element is represented by a unique bit-
string. We require that there are eﬃcient algorithms (namely, algorithms
running in time polynomial in n) for computing the group operation in G,
as well as for testing whether a given bit-string represents an element of G.
Eﬃcient computation of the group operation implies eﬃcient algorithms for
exponentiation in G(see Appendix B.2.3) and for sampling a uniform element
h∈G(simply choose uniform x∈Zqand seth:=gx).
As discussed at the end of the previous section, although all cyclic groups
of a given order are isomorphic, the representation of the group determines
the computational complexity of mathematical operations in that group.
IfGis a cyclic group of order qwith generator g, then{g0,g1,...,gq−1}
is all ofG. Equivalently, for every h∈Gthere is a uniquex∈Zqsuch that
gx=h. When the underlying group Gis understood from the context, we
call this xthediscrete logarithm of hwith respect to gand write x= loggh.
(Logarithms in this case are called “discrete” since they take values in a ﬁnite
range, as opposed to “standard” logarithms from calculus whose values range
over the inﬁnite set of real numbers.) Note that if gx/prime=hfor some arbitrary
integerx/prime, then [x/primemodq] = loggh.320 Introduction to Modern Cryptography
Discrete logarithms obey many of the same rules as “standard” logarithms.
For example, logg1 = 0 (where 1 is the identity of G); for any integer r, we
have logghr= [r·logghmodq]; and logg(h1h2) = [(loggh1+loggh2) modq].
Thediscrete-logarithm problem in a cyclic group Gwith generator gis to
compute logghfor a uniform element h∈G. Consider the following experi-
ment for a group-generation algorithm G, algorithmA, and parameter n:
The discrete-logarithm experiment DLogA,G(n):
1. RunG(1n)to obtain (G,q,g), whereGis a cyclic group of
orderq(with/bardblq/bardbl=n), andgis a generator of G.
2. Choose a uniform h∈G.
3.Ais givenG,q,g,h, and outputs x∈Zq.
4. The output of the experiment is deﬁned to be 1ifgx=h,
and0otherwise.
DEFINITION 8.62 We say that the discrete-logarithm problem is hard
relative toGif for all probabilistic polynomial-time algorithms Athere exists
a negligible function neglsuch that Pr[DLogA,G(n) = 1]≤negl(n).
The discrete-logarithm assumption is simply the assumption that there ex-
ists aGfor which the discrete-logarithm problem is hard. The following two
sections discuss some candidate group-generation algorithms Gfor which this
is believed to be the case.
The Diﬃe–Hellmanproblems. Theso-called Diﬃe–Hellman problemsare
related, but not known to be equivalent, to the problem of computing discrete
logarithms. There are two important variants: the computational Diﬃe–
Hellman (CDH) problem and the decisional Diﬃe–Hellman (DDH) problem.
Fix a cyclic group Gand a generator g∈G. Given elements h1,h2∈G,
deﬁneDHg(h1,h2)def=gloggh1·loggh2. That is, if h1=gx1andh2=gx2then
DHg(h1,h2) =gx1·x2=hx2
1=hx1
2.
TheCDH problem isto compute DHg(h1,h2) foruniform h1andh2. Hardness
of this problem can be formalized by the natural experiment; we leave the
details as an exercise.
If the discrete-logarithm problem relative to some Gis easy, then the CDH
problem is, too: given h1andh2, ﬁrst compute x1:= loggh1and then output
the answer hx1
2. In contrast, it is not clear whether hardness of the discrete-
logarithm problem implies that the CDH problem is hard as well.
TheDDH problem , roughly speaking, is to distinguish DHg(h1,h2) from
a uniform group element when h1,h2are uniform. That is, given uniform
h1,h2and a third group element h/prime, the problem is to decide whether h/prime=
DHg(h1,h2) or whether h/primewas chosen uniformly from G. Formally:Number Theory and Cryptographic Hardness Assumptions 321
DEFINITION 8.63 We say that the DDH problem is hard relative to Gif
for all probabilistic polynomial-time algorithms Athere is a negligible function
neglsuch that
/vextendsingle/vextendsingle/vextendsinglePr[A(G,q,g,gx,gy,gz) = 1]−Pr[A(G,q,g,gx,gy,gxy) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl(n),
where in each case the probabilities are taken over the experiment in which
G(1n)outputs(G,q,g), and then uniform x,y,z∈Zqare chosen. (Note that
whenzis uniform in Zq, thengzis uniformly distributed in G.)
We have already seen that if the discrete-logarithm problem is easy relative
to someG, then the CDH problem is too. Similarly, if the CDH problem is
easy relative toGthen so is the DDH problem; you are asked to show this in
Exercise 8.15. The converse, however, does not appear to be true, and there
areexamples ofgroupsin which the discrete-logarithmand CDH problemsare
believed to be hard even though the DDH problem is easy; see Exercise 13.15.
Using Prime-Order Groups
There are various (classes of) cyclic groups in which the discrete-logarithm
and Diﬃe–Hellman problems are believed to be hard. There is a preference,
however, for cyclic groups of prime order , for reasons we now explain.
One reason for preferring groups of prime order is because, in a certain
sense, the discrete-logarithm problem is hardest in such groups. This is a
consequence of the Pohlig–Hellman algorithm , described in Chapter 9, which
shows that the discrete-logarithm problem in a group of order qbecomes
easier if qhas (small) prime factors. This does not necessarily mean that
the discrete-logarithm problem is easyin groups of nonprime order; it merely
means that the problem becomes easier.
Related to the above is the fact that the DDH problem is easy if the group
orderqhas small prime factors. We refer to Exercise 13.15 for one example
of this phenomenon.
A second motivation for using prime-order groups is because ﬁnding a gen-
erator in such groups is trivial. This follows from Corollary 8.55, which says
thateveryelement of a prime-ordergroup (except the identity) is a generator.
In contrast, eﬃciently ﬁnding a generatorof an arbitrarycyclic group requires
the factorization of the group order to be known (see Appendix B.3).
Proofs of security for some cryptographic constructions require computing
multiplicative inverses of certain exponents (we will see an example in Sec-
tion 8.4.2). When the group order is prime, any nonzero exponent will be
invertible, making this computation possible.
A ﬁnal reason for working with prime-order groups applies in situations
when the decisional Diﬃe–Hellman problem should be hard. Fixing a group
Gwith generator g, the DDH problem boils down to distinguishing between322 Introduction to Modern Cryptography
tuples of the form ( h1,h2,DHg(h1,h2)) for uniform h1,h2, and tuples of the
form (h1,h2,y), for uniform h1,h2,y. A necessary condition for the DDH
problem to be hard is that DHg(h1,h2)by itself should be indistinguishable
from a uniform group element. One can show that DHg(h1,h2) is “close” to
uniform (in a sense we do not deﬁne here) when the group order qis prime,
something that is not true otherwise.
8.3.3 Working in (Subgroups of) Z∗
p
Groups of the form Z∗
p, forpprime, give one class of cyclic groups in which
the discrete-logarithm problem is believed to be hard. Concretely, let Gbe an
algorithm that, on input 1n, chooses a uniform n-bit prime p, and outputs p
and the group order q=p−1 along with a generator gofZ∗
p. (Section 8.2.1
discusses eﬃcient algorithms for choosing a random prime, and Appendix B.3
showshowtoeﬃciently ﬁnd ageneratorof Z∗
pgiventhefactorizationof p−1.)
The representationof Z∗
phere is the trivial onewhere elements arerepresented
as integers between 1 and p−1. It is conjectured that the discrete-logarithm
problem is hard relative to Gof this sort.
The cyclic group Z∗
p(forp >3 prime), however, does nothave prime order.
(The preference for groups of prime order was discussed in the previous sec-
tion.) More problematic, the decisional Diﬃe–Hellman problem is, in general,
not hard in such groups (see Exercise 13.15), and they are therefore unaccept-
able for the cryptographic applications based on the DDH assumption that
we will explore in later chapters.
These issues can be addressed by using a prime-order subgroup ofZ∗
p. Let
p=rq+1 where both pandqare prime. We prove that Z∗
phas a subgroup G
of order qgiven by the set of rth residues modulo p, i.e., the set of elements
{[hrmodp]|h∈Z∗
p}that are equal to the rth power of some h∈Z∗
p.
THEOREM 8.64 Letp=rq+1withp,qprime. Then
Gdef=/braceleftbig
[hrmodp]|h∈Z∗
p/bracerightbig
is a subgroup of Z∗
pof order q.
PROOF The proof that Gis a subgroup is straightforward and is omitted.
We prove that Ghas order qby showing that the function fr:Z∗
p→G
deﬁned by fr(g) = [grmodp] is anr-to-1 function. (Since |Z∗
p|=p−1, this
shows that|G|= (p−1)/r=q.) To see this, let gbe a generator of Z∗
p
so thatg0,...,gp−2are all the elements of Z∗
p. By Proposition 8.53 we have/parenleftbig
gi/parenrightbigr=/parenleftbig
gj/parenrightbigrif and only if ir=jrmod (p−1) or, equivalently, p−1|(i−j)r.
Sincep−1 =rq, this is equivalentto q|(i−j). For anyﬁxed j∈{0,...,p−2},
this means that the set of values i∈{0,...,p−2}for which/parenleftbig
gi/parenrightbigr=/parenleftbig
gj/parenrightbigrisNumber Theory and Cryptographic Hardness Assumptions 323
exactly the set of rdistinct values
{j, j+q, j+2q, ..., j+(r−1)q},
all reduced modulo p−1. (Note that j+rq=jmod (p−1).) This proves
thatfris anr-to-1 function.
Besides showing existence of an appropriate subgroup, the theorem also
implies that it is easy to generate a uniform element of Gand to test whether
a given element of Z∗
plies inG. Speciﬁcally, choosing a uniform element of G
can be done by choosing uniform h∈Z∗
pand computing [ hrmodp]. SinceG
has prime order, every element in Gexcept the identity is a generator of G.
Finally, it is possible to determine whether any h∈Z∗
pis alsoin Gby checking
whether hq?= 1 mod p. To see that this works, let h=giforga generator
ofZ∗
pandi∈{0,...,p−2}. Then
hq= 1 mod p⇐⇒giq= 1 mod p
⇐⇒iq= 0 mod ( p−1)⇐⇒rq|iq⇐⇒r|i,
using Proposition 8.53. So h=gi=gcr= (gc)rfor some c, andh∈G.
Algorithm 8.65 encapsulates the above discussion. In the algorithm, we let
ndenote the length of q, the order of the group, and let /lscriptdenote the length
ofp, the modulus being used. The relationship between these parameters is
discussed below.
Choosing /lscript.Letn=/bardblq/bardbland/lscript=/bardblp/bardbl. Two types of algorithms are
known for computing discrete logarithms in order- qsubgroups of Z∗
p(see Sec-
tion 9.2): those that run in time O(√q)=O(2n/2) and those that run in
time 2O((logp)1/3·(loglog p)2/3)= 2O(/lscript1/3·(log/lscript)2/3). Fixing some desired security
parameter n, the parameter /lscriptshould be chosen so as to balance these times.
(If/lscriptis any smaller, security is reduced; if /lscriptis any larger, operations in Gwill
be less eﬃcient without any gain in security.) See also Section 9.3.
ALGORITHM 8.65
Agroup-generation algorithm G
Input:Security parameter 1n, parameter /lscript=/lscript(n)
Output: Cyclic group G, its (prime) order q, and a generator g
generate a uniform n-bit prime q
generate an/lscript-bit prime psuch that q|(p−1)
//we omit the details of how this is done
choosea uniform h∈Z∗
pwithh/negationslash= 1
setg:= [h(p−1)/qmodp]
returnp,q,g //Gis the order- qsubgroup of Z∗
p324 Introduction to Modern Cryptography
Inpractice, standardizedvalues(e.g., recommendedbyNIST)for p,q, anda
generator gareused, andthereisnoneedtogenerateparametersofone’sown.
Example 8.66
Consider the group Z∗
11of order 10. Let us try to ﬁnd a generator of this
group. Consider trying 2:
Powers of 2: 20212223242526272829
Values:1 2 4 8 5 10 9 7 3 6
(All values above are computed modulo 11.) We got lucky the ﬁrst time—the
number 2 is a generator! Let’s try 3:
Powers of 3: 30313233343536373839
Values:1 3 9 5 4 1 3 9 5 4
We see that 3 is not a generator of the entire group. Rather, it generates a
subgroupG={1,3,4,5,9}of order 5. Now, let’s see what happens with 10:
Powers of 10: 100101102103104105106107108109
Values: 1 10 1 10 1 10 1 10 1 10
In this case we generate a subgroup of order 2.
For cryptographic purposes we want to work in a prime-order group. Since
11 = 2·5+1 we can apply Theorem 8.64 with q= 5 and r= 2, or with q= 2
andr= 5. In the ﬁrst case, the theorem tells us that the squaresof all the
elements of Z∗
11should give a subgroup of order 5. This can be easily veriﬁed:
Element: 123 4 5 6 7 8 9 10
Square: 1 4 9 5 3 3 5 9 4 1
We have seen above that 3 is a generator of this subgroup. (In fact, since the
subgroup is prime, every element of the subgroup besides 1 is a generator of
the subgroup.) Taking q= 2 and r= 5, Theorem 8.64 tells us that taking
5th powers will give a subgroup of order 2. One can check that this gives the
order-2 subgroup generated by 10 that we encountered earlier. ♦
Subgroups of ﬁnite ﬁelds. The discrete-logarithm problem is also believed
to be hard in the multiplicative group of a ﬁnite ﬁeld of large characteristic
when the polynomial representation is used. (Appendix A.5 provides a brief
background on ﬁnite ﬁelds.) Recall that for any prime pand integer k≥1
there is a (unique) ﬁeld Fpkof order pk; the multiplicative group F∗
pkof that
ﬁeld is a cyclic group of order pk−1 (cf. Theorem A.21). If qis a large prime
factor of pk−1, then Theorem 8.64 shows that F∗
pkhas a cyclic subgroup of
orderq. (The only property of Z∗
pwe used in the proof of that theorem was
thatZ∗
pis cyclic.) This oﬀers another choice of prime-order groups in which
the discrete-logarithm and Diﬃe–Hellman problems are believed to be hard.
Our treatment of Z∗
pin this section corresponds to the special case k= 1.Number Theory and Cryptographic Hardness Assumptions 325
8.3.4 Elliptic Curves
The groups we have concentrated on thus far have all been based directly
on modular arithmetic. Another class of groups important for cryptography
is given by groups consisting of points on elliptic curves . Such groups are
especially interesting from a cryptographic perspective since, in contrast to
Z∗
por the multiplicative group of a ﬁnite ﬁeld, there are currently no known
sub-exponential time algorithms for solving the discrete-logarithm problem
in elliptic-curve groups when chosen appropriately. (See Section 9.3 for fur-
ther discussion.) For cryptosystems based on the discrete-logarithm or Diﬃe–
Hellmanassumptions,thismeansthatimplementationsbasedonelliptic-curve
groups will be more eﬃcient than implementations based on prime-order sub-
groups of Z∗
pat any given level of security. In this section we provide only a
brief introduction to this area. A deeper understanding of the issues discussed
here requires more sophisticated mathematics than we are willing to assume
on the part of the reader. Those interested in further exploring this topic are
advised to consult the references at the end of this chapter.
Letp≥5 be a prime.3Consider an equation Ein the variables xandyof
the form:
y2=x3+Ax+Bmodp, (8.1)
whereA,B∈Zpare constants with 4 A3+ 27B2/negationslash= 0 mod p. (This ensures
that the equation x3+Ax+B= 0 mod phas no repeated roots.) Let E(Zp)
denote the set of pairs ( x,y)∈Zp×Zpsatisfying the above equation along
with a special value Owhose purpose we will discuss shortly; that is,
E(Zp)def=/braceleftbig
(x,y)|x,y∈Zpandy2=x3+Ax+Bmodp/bracerightbig
∪{O}.
The elements E(Zp) are called the pointson theelliptic curve Edeﬁned by
Equation (8.1), and Ois called the point at inﬁnity .
Example 8.67
An element y∈Z∗
pis aquadratic residue modulo pif there is an x∈Z∗
psuch
thatx2=ymodp; in that case, we say xis asquare root of y. Forp >2
prime, half the elements in Z∗
pare quadratic residues, and every quadratic
residue has exactly two square roots. (See Section 13.4.1.)
Letf(x)def=x3+3x+3 and consider the curve E:y2=f(x) mod 7. Each
value of xfor which f(x) is a quadratic residue modulo 7 yields two points
on the curve; values xfor which f(x) is a non-quadratic residue are not on
3The theory can be adapted to deal with the case of p= 2 or 3 but this introduces additional
complications. Elliptic curves can, in fact, be deﬁned over arbitrary ﬁnite or inﬁnite ﬁelds
(cf. Section A.5), and our discussion largely carries over to ﬁelds of characteristic not equal
to 2or3. Binary curves (i.e.,curves overﬁeldsofcharacteristic 2)areparticularlyimportant
in cryptography, but we will not discuss them here.326 Introduction to Modern Cryptography
the curve; values of xfor which f(x) = 0 mod 7 give one point on the curve.
This allows us to determine the points on the curve:
•f(0) = 3 mod 7, a quadratic non-residue modulo 7.
•f(1) = 0 mod 7, so we obtain the point (1 ,0)∈E(Z7).
•f(2) = 3 mod 7, a quadratic non-residue modulo 7.
•f(3) = 4 mod 7, a quadraticresidue modulo 7 with squareroots2 and 5.
This yields the points (3 ,2),(3,5)∈E(Z7).
•f(4) = 2 mod 7, a quadraticresidue modulo 7 with squareroots3 and 4.
This yields the points (4 ,3),(4,4)∈E(Z7).
•f(5) = 3 mod 7, a quadratic non-residue modulo 7.
•f(6) = 6 mod 7, a quadratic non-residue modulo 7.
Including the point at inﬁnity, there are 6 points in E(Z7). ♦
A useful way to think about E(Zp) is to look at the graph of Equation (8.1)
overthereals(i.e., theequation y2=x3+Ax+Bwithout reductionmodulo p)
as in Figure 8.2. This ﬁgure does not correspond exactly to E(Zp) because,
for example, E(Zp) has a ﬁnite number of points ( Zpis, after all, a ﬁnite
set) while there are an inﬁnite number of solutions to the same equation if
we allow xandyto range over all real numbers. Nevertheless, the picture
provides useful intuition. In such a ﬁgure, one can think of the “point at
inﬁnity”Oas sitting at the top of the y-axis and lying on every vertical line.
It can be shown that every line intersecting E(Zp) intersects it in exactly
3 points, where(1) a point Pis counted twiceif the line is tangentto the curve
atP, and (2) the point at inﬁnity is also counted when the line is vertical.
This fact is used to deﬁne a binary operation, called “addition” and denoted
by +, on points of E(Zp) in the following way:
•The pointOis deﬁned to be an (additive) identity; that is, for all
P∈E(Zp) we deﬁne P+O=O+P=P.
•For two points P1,P2/negationslash=OonE, we evaluate their sum P1+P2by
drawing the line through P1,P2(ifP1=P2then draw the line tangent
to the curve at P1) and ﬁnding the third point of intersection P3of this
line with E(Zp); the third point of intersection may be P3=Oif the
line is vertical. If P3= (x,y)/negationslash=Othen we deﬁne P1+P2def= (x,−y).
(Graphically, this corresponds to reﬂecting P3in thex-axis.) If P3=O
thenP1+P2def=O.
IfP= (x,y)/negationslash=Ois a point of E(Zp), then−Pdef= (x,−y) (which is
clearly also a point of E(Zp)) is the unique inverse of P. Indeed, the lineNumber Theory and Cryptographic Hardness Assumptions 327
/MT80/MT49/MT80/MT50/MT80/MT51
/MT45/MT80/MT51/MT32/MT61/MT32/MT80 /MT49/MT32/MT43/MT32/MT80 /MT50
/MT121/MT50/MT32/MT61/MT32/MT120/MT51/MT32/MT45/MT32/MT120/MT32/MT43/MT32/MT49
FIGURE 8.2 : Anelliptic curve over the reals.
through ( x,y) and (x,−y) is vertical, and so the addition rule implies that
P+ (−P) =O. (Ify= 0 then P= (x,y) = (x,−y) =−Pbut then the
tangent line at Pwill be vertical and so P+ (−P) =Ohere as well.) Of
course,−O=O.
It is straightforward, but tedious, to work out the addition law concretely.
LetP1= (x1,y1) andP2= (x2,y2) be two points in E(Zp), withP1,P2/negationslash=O
andEas in Equation (8.1). To keep matters simple, suppose x1/negationslash=x2(dealing
with the case x1=x2is still straightforward but even more tedious). The
slope of the line through these points is
mdef=/bracketleftbiggy2−y1
x2−x1modp/bracketrightbigg
;
our assumption that x1/negationslash=x2means that the inverse of ( x2−x1) modulo p
exists. The line passing through P1andP2has the equation
y=m·(x−x1)+y1modp. (8.2)
To ﬁnd the third point of intersection of this line with E, substitute the above
into the equation for Eto obtain
/parenleftBig
m·(x−x1)+y1/parenrightBig2
=x3+Ax+Bmodp.
The values of xthat satisfy this equation are x1,x2, and
x3def= [m2−x1−x2modp].
The ﬁrst two solutions correspond to the original points P1andP2, while
the third is the x-coordinate of the third point of intersection P3. Plugging
x3into Equation (8.2) we ﬁnd that the y-coordinate corresponding to x3is328 Introduction to Modern Cryptography
y3= [m·(x3−x1)+y1modp]. To obtain the desired answer P1+P2, we ﬂip
the sign of yto obtain:
(x1,y1)+(x2,y2) =/parenleftbig
[m2−x1−x2modp],[m·(x1−x3)−y1modp]/parenrightbig
.
We summarize and extend this in the following proposition.
PROPOSITION 8.68 Letp≥5be prime and let Ebe the elliptic curve
given byy2=x3+Ax+Bmodpwhere4A3+27B2/negationslash= 0 mod p. LetP1,P2/negationslash=O
be points on E, withP1= (x1,y1)andP2= (x2,y2).
1. Ifx1/negationslash=x2, thenP1+P2= (x3,y3)with
x3= [m2−x1−x2modp]andy3= [m·(x1−x3)−y1modp],
wherem=/bracketleftBig
y2−y1
x2−x1modp/bracketrightBig
.
2. Ifx1=x2buty1/negationslash=y2thenP1=−P2and soP1+P2=O.
3. IfP1=P2andy1= 0thenP1+P2= 2P1=O.
4. IfP1=P2andy1/negationslash= 0thenP1+P2= 2P1= (x3,y3)with
x3= [m2−2x1modp]andy3= [m·(x1−x3)−y1modp],
wherem=/bracketleftBig
3x2
1+A
2y1modp/bracketrightBig
.
Somewhat amazingly, the set of points E(Zp) along with the addition rule
deﬁned above form an abelian group, called the elliptic-curve group of E.
Commutativityfollowsfromthewayadditionisdeﬁned, Oactsastheidentity,
and we have already seen that each point on E(Zp) has an inverse in E(Zp).
The diﬃcult property to verify is associativity, which the disbelieving reader
can check through tedious calculation. A more illuminating proof that does
not involve explicit calculation relies on algebraic geometry.
Example 8.69
Consider the curve from Example 8.67. We show associativity for three
speciﬁc points. Let P1= (1,0),P2=Q2= (4,3). When computing P1+P2
we getm= [(3−0)·(4−1)−1mod 7] = 1 and [12−1−4 mod 7] = 3. Thus,
P3def=P1+P2= (3,[1·(1−3)−0 mod 7]) = (3 ,5);
note that this is indeed a point on E(Z7). If we then compute P3+Q2we get
m= [(3−5)·(4−3)−1mod 7] = 5 and [52−3−4 mod 7] = 4. Thus,
(P1+P2)+Q2=P3+Q2= (4,[5·(3−4)−5 mod 7]) = (4 ,4).Number Theory and Cryptographic Hardness Assumptions 329
If we compute P2+Q2= 2P2we obtain m= [(3·42+3)·(2·3)−1mod 7] = 5
and [52−2·4 mod 7] = 3. Thus,
P/prime
3def=P2+Q2= (3,[5·(4−3)−3 mod 7]) = (3 ,2).
If we then compute P1+P/prime
3we ﬁnd m= [2·(3−1)−1mod 7] = 1 and
[12−1−3 mod 7] = 4. So
P1+(P2+Q2) =P1+P/prime
3= (4,[1·(1−4)−0 mod 7]) = (4 ,4),
andP1+(P2+Q2) = (P1+P2)+Q2. ♦
Recall that when a group is written additively, “exponentiation” corre-
sponds to repeated addition. Thus, if we ﬁx some point Pin an elliptic-curve
group, the discrete-logarithm problem becomes (informally) the problem of
computing the integer xfromxP, while the decisional Diﬃe–Hellman prob-
lem becomes (informally) the problem of distinguishing tuples of the form
(aP,bP,abP ) from those of the form ( aP,bP,cP ). These problems are be-
lieved to be hard in elliptic-curve groups (or subgroups thereof) of large prime
order, subject to a few technical conditions we will mention in passing below.
If we want an elliptic-curve group (or subgroup) of large prime order, the
ﬁrst question we must address is: how large are elliptic-curve groups? As
noted in Example 8.67, the equation y2=f(x) modphas two solutions
whenever f(x) is a quadratic residue, and one solution when f(x) = 0. Since
half the elements in Z∗
pare quadratic residues, we heuristically expect to ﬁnd
2·(p−1)/2+1 =ppoints on the curve. Including the point at inﬁnity, this
means there should be about p+1 points in an elliptic-curve group over Zp.
TheHasse bound says this heuristic estimate is accurate, in the sense that
every elliptic-curve group has “almost” this many points.
THEOREM 8.70 (Hasse bound) Letpbe prime, and let Ebe an
elliptic curve over Zp. Thenp+1−2√p≤|E(Zp)|≤p+1+2√p.
This bound implies that it is always easy to ﬁnda point on a given elliptic
curvey2=f(x) modp: simply choose uniform x∈Zp, check whether f(x)
is 0 or a quadratic residue, and—if so—let ybe a square root of f(x). (Algo-
rithms for deciding quadratic residuosity and computing square roots modulo
a prime are discussed in Chapter 13.) Since points on the elliptic curve are
plentiful, we will not have to try very many values of xbefore ﬁnding a point.
The Hasse bound only gives a range for the size of an elliptic-curve group.
For a ﬁxed prime p, however, the order of a random elliptic curve over Zp
(namely, a curve deﬁned by Equation (8.1) in which A,Bare chosen uni-
formly in Zpsubject to the constraint 4 A3+27B2/negationslash= 0 mod p) is heuristically
found to be “close” to uniformly distributed in the Hasse interval. There
also exist eﬃcient algorithms—whose description and analysis are well be-
yond the scope of this book—for counting the number of points on an elliptic330 Introduction to Modern Cryptography
curve. This suggests an approach to elliptic-curve parameter generation as in
Algorithm 8.71.
ALGORITHM 8.71
Elliptic-curve group-generation algorithm G
Input:Security parameter 1n
Output: Cyclic group G, its (prime) order q, and a generator g
generate a uniform n-bit prime p
untilqis ann-bit prime do:
chooseA,B←Zpwith 4A3+27B2/negationslash= 0 mod p,
deﬁning elliptic curve Eas in Equation (8.1)
letqbe the number of points on E(Zp)
chooseg∈E(Zp)\{O}
return(A,B,p),q,g//Gis the elliptic-curve group of E
Certain classes of curves are considered cryptographically weak and should
beavoided. These include elliptic-curve groups over Zpwhose order is equal
top(anomalous curves ) orp+1(supersingular curves ), orwhoseorderdivides
pk−1 for “small” k. A full discussion is beyond the scope of this book. In
practice, standardized curves (such as those recommended by NIST) are used,
and generating a curve of one’s own is not advised.
Eﬃciency Considerations
We conclude this section with a very brief discussion of some standard
eﬃciency improvements when using elliptic curves.
Point compression. A useful observation is that the number of bits needed
to represent a point on an elliptic curve can be reduced almost by half. To see
this, note that for any point ( x,y) on an elliptic curve E:y2=f(x) modp
there are at most two points on the curve that have x-coordinate x: namely,
(x,y) and (x,−y). (It is possible that y= 0 in which case these are the same
point.) Thus, we can specify any point P= (x,y) by itsx-coordinate and a
bitbthat distinguishes between the (at most) two possibilities for the value
of itsy-coordinate. One convenient way to do this is to set b= 0 ify < p/2
andb= 1 otherwise. Given xandbwe can recover Pby computing the two
square roots y1,y2of the equation y2=f(x) modp; sincey1=−y2modp
and soy1=p−y2, exactly one of y1,y2will be less than p/2.
Projective coordinates. Representing elliptic-curve points as we have been
doing until now—in which a point Pon an elliptic curve is described by a pair
of ﬁeld elements ( x,y)—is called using aﬃne coordinates . There are alternate
ways to represent points, using projective coordinates , that can oﬀer eﬃciencyNumber Theory and Cryptographic Hardness Assumptions 331
improvements. While these alternate representations can be motivated math-
ematically, we treat them simply as useful computational aids.
Points in projective coordinates are represented using threeelements of Zp.
An interesting feature is that a point has multiple representations. When
using standard projective coordinates, a point P/negationslash=Owith representation
(x,y) in aﬃne coordinates is represented by any tuple ( X,Y,Z)∈Z3
pfor
whichX/Z=xmodpandY/Z=ymodp. The pointOis represented
by any tuple (0 ,Y,0) withY/negationslash= 0, and these are the only points ( X,Y,Z)
withZ= 0. We can easily translate between coordinate systems: ( x,y) in
aﬃne coordinates can be mapped to ( x,y,1) in projective coordinates, and
(X,Y,Z) (withZ/negationslash= 0) in projective coordinates is mapped to the representa-
tion ([X/Zmodp],[Y/Zmodp]) in aﬃne coordinates.
The main advantage of using projective coordinates is that we can add
points without having to compute inverses modulo p. (Adding points in aﬃne
coordinates requires computing inverses; see Proposition 8.68.) We accom-
plish this by exploiting the fact that points have multiple representations. To
see this, let us work out the addition law for two points P1= (X1,Y1,Z1)
andP2= (X2,Y2,Z2) withP1,P2/negationslash=O(soZ1,Z2/negationslash= 0) and P1/negationslash=±P2(so
X1/Z1/negationslash=X2/Z2modp). (If either P1orP2are equal toO, addition is triv-
ial. The case of P1=±P2can be handled as well, but we omit details here.)
We can express P1andP2as (X1/Z1,Y1/Z1) and (X2/Z2,Y2/Z2) in aﬃne
coordinates, so
P3def=P1+P2=/parenleftbig
m2−X1/Z1−X2/Z2,
m·(X1/Z1−m2+X1/Z1+X2/Z2)−Y1/Z1,1/parenrightbig
,
where
m= (Y2/Z2−Y1/Z1)(X2/Z2−X1/Z1)−1= (Y2Z1−Y1Z2)(X2Z1−X1Z2)−1
and all computations are done modulo p. Note we are using projective coor-
dinates to represent P3, setting Z3= 1 above. But using projective coordi-
nates means we are not limited to Z3= 1. Multiplying each coordinate by
Z1Z2(X2Z1−X1Z2)3/negationslash= 0 mod p, we ﬁnd that P3can also be represented as
P3=/parenleftBig
vw, u(v2X1Z2−w)−v3Y1Z2, Z1Z2v3/parenrightBig
(8.3)
where
u=Y2Z1−Y1Z2, v=X2Z1−X1Z2,
w=u2Z1Z2−v3−2v2X1Z2. (8.4)
The point to notice is that the computations in Equations (8.3) and (8.4) can
be carried out without having to perform any modular inversions.
Precisely because points have multiple representations in projective coor-
dinates, some subtleties can arise when projective coordinates are used. (We332 Introduction to Modern Cryptography
have explicitly assumed until now that group elements have unique represen-
tations asbit-strings.) Speciﬁcally, apoint expressedin projectivecoordinates
may reveal some information about how that point was obtained, which may
depend on some secret information. To address this—as well as for reasons
of eﬃciency—aﬃne coordinates should be used for transmitting and storing
points, with projective coordinates used only as an intermediate represen-
tation during the course of a computation (with points converted to/from
projective coordinates at the beginning/end of the computation).
8.4 *Cryptographic Applications
Wehave spent a fair bit of time discussingnumber theory and grouptheory,
and introducing computational hardnessassumptions that are widely believed
to hold. Applications of these assumptions will occupy us for the rest of the
book, but we provide some brief examples here.
8.4.1 One-Way Functions and Permutations
One-way functions are the minimal cryptographic primitive, and they are
both necessary and suﬃcient for private-key encryption and message authen-
tication codes. A more complete discussion of the role of one-way functions in
cryptography appears in Chapter 7; here we only provide a deﬁnition of one-
way functions and demonstrate that their existence follows from the number-
theoretic hardness assumptions we have seen in this chapter.
Informally, a function fisone-way if it is easy to compute but hard to in-
vert. The following experiment and deﬁnition, a restatement ofDeﬁnition 7.1,
formalizes this.
The inverting experiment InvertA,f(n):
1. Choose uniform x∈{0,1}nand compute y:=f(x).
2.Ais given1nandyas input, and outputs x/prime.
3. The output of the experiment is 1if and only if f(x/prime) =y.
DEFINITION 8.72 A function f:{0,1}∗→{0,1}∗isone-way if the
following two conditions hold:
1.(Easy to compute:) There is a polynomial-time algorithm that on
inputxoutputsf(x).
2.(Hard to invert:) For allpptalgorithmsAthere is a negligible func-
tionneglsuch that Pr[InvertA,f(n) = 1]≤negl(n).Number Theory and Cryptographic Hardness Assumptions 333
We now show formally that the factoring assumption implies the existence
of a one-way function. Let Genbe a polynomial-time algorithm that, on
input 1n, outputs ( N,p,q) whereN=pqandpandqaren-bit primes except
with probability negligible in n. (We use Genrather than GenModulus here
purely for notational convenience.) Since Genruns in polynomial time, there
is a polynomial upper bound on the number of random bits the algorithm
uses. For simplicity, and in order to get the main ideas across, we assume Gen
always uses at most nrandom bits on input 1n. In Algorithm 8.73 we deﬁne
a function fGenthat uses its input as the random bits for running Gen. Thus,
fGenis adeterministic function as required.
ALGORITHM 8.73
Algorithm computing fGen
Input:Stringxof length n
Output: IntegerN
compute (N,p,q) :=Gen(1n;x)
//i.e., run Gen(1n) usingxas the random tape
returnN
If the factoring problem is hard relative to Genthen, intuitively, fGenis a
one-way function. Certainly fGenis easy to compute. As for the hardness of
inverting this function, note that the following distributions are identical:
1. Themodulus Noutputby fGen(x), whenx∈{0,1}nischosenuniformly.
2. The modulus Noutput by (the randomized algorithm) Gen(1n).
If moduli Ngenerated according to the second distribution are hard to factor,
then thesameholdsformoduli Ngeneratedaccordingtotheﬁrstdistribution.
Moreover,givenanypreimage x/primeofNwithrespectto fGen(i.e., anx/primeforwhich
fGen(x/prime) =N; note that we do not require x/prime=x), it is easyto recovera factor
ofNby running Gen(1n;x/prime) to obtain ( N,p,q) and outputting the factors p
andq. Thus, ﬁnding a preimage of Nwith respect to fGenis as hard as
factoring N. One can easily turn this into a formal proof of the following:
THEOREM 8.74 If the factoring problem is hard relative to Gen, then
fGenis a one-way function.
One-Way Permutations
We can also use number-theoretic assumptions to construct a family of one-
waypermutations . We begin with a restatement of Deﬁnitions 7.2 and 7.3,
specialized to the case of permutations:334 Introduction to Modern Cryptography
DEFINITION 8.75 A tripleΠ = (Gen,Samp,f)of probabilistic polynomial-
time algorithms is a family of permutations if the following hold:
1. Theparameter-generationalgorithmGen , on input 1n, outputsparameters
Iwith|I|≥n. Each value of Ideﬁnes a setDIthat constitutes the
domain and range of a permutation (i.e., bijection) fI:DI→DI.
2. ThesamplingalgorithmSamp , on input I, outputsa uniformly distributed
element ofDI.
3. The deterministic evaluationalgorithm f, on input Iandx∈DI, outputs
an element y∈DI. We write this as y:=fI(x).
Given a family of functions Π, consider the following experiment for any
algorithmAand parameter n:
The inverting experiment InvertA,Π(n):
1.Gen(1n)is run to obtain I, and then Samp(I)is run to choose
a uniform x∈DI. Finally, y:=fI(x)is computed.
2.Ais givenIandyas input, and outputs x/prime.
3. The output of the experiment is 1if and only if fI(x/prime) =y.
DEFINITION 8.76 The family of permutations Π = (Gen,Samp,f)is
one-way if for all probabilistic polynomial-time algorithms Athere exists a
negligible function neglsuch that
Pr[InvertA,Π(n) = 1]≤negl(n).
GivenGenRSA as in Section 8.2.4, Construction 8.77 deﬁnes a family of
permutations. It is immediate that if the RSA problem is hard relative to
GenRSA then this family is one-way. It can similarly be shown that hardness
of the discrete-logarithm problem in Z∗
p, withpprime, implies the existence
of a one-way family of permutations; see Section 7.1.2.
CONSTRUCTION 8.77
LetGenRSAbe as before. Deﬁne a family of permutations as follows:
•Gen: on input 1n, runGenRSA(1n) to obtain ( N,e,d) and output
I=/angbracketleftN,e/angbracketright. SetDI=Z∗
N.
•Samp: on input I=/angbracketleftN,e/angbracketright, choose a uniform element of Z∗
N.
•f: on input I=/angbracketleftN,e/angbracketrightandx∈Z∗
N, output [ xemodN].
A family of permutations based on the RSA problem.Number Theory and Cryptographic Hardness Assumptions 335
8.4.2 Constructing Collision-Resistant Hash Functions
Collision-resistant hash functions were introduced in Section 5.1. Although
we have discussed constructions of collision-resistant hash functions used in
practice in Section 6.3, we have not yet seen constructions that can be rig-
orously based on simpler assumptions. We show here a construction based
on the discrete-logarithm assumption in prime-order groups. (A construction
based on the RSA problem is described in Exercise8.20.) Although these con-
structions are less eﬃcient than the hash functions used in practice, they are
important since they illustrate the feasibility of achieving collision resistance
based on standard and well-studied number-theoretic assumptions.
LetGbe a polynomial-time algorithmthat, on input 1n, outputs a (descrip-
tion of a) cyclic group G, its order q(with/bardblq/bardbl=n), and a generator g. Here
we also require that qisprimeexcept possibly with negligible probability. A
ﬁxed-length hash function based on Gis given in Construction 8.78.
CONSTRUCTION 8.78
LetGbe as described in the text. Deﬁne a ﬁxed-length hash function
(Gen,H) as follows:
•Gen: on input 1n, runG(1n) to obtain ( G,q,g) and then select a
uniform h∈G. Output s:=/angbracketleftG,q,g,h/angbracketrightas the key.
•H: given a key s=/angbracketleftG,q,g,h/angbracketrightand input( x1,x2)∈Zq×Zq, output
Hs(x1,x2) :=gx1hx2∈G.
A ﬁxed-length hash function.
Note thatGenandHcan be computed in polynomial time. Before contin-
uing with an analysis of the construction, we make some technical remarks:
•For a given s=/angbracketleftG,q,g,h/angbracketrightwithn=/bardblq/bardbl, the function Hsis described
as taking elements of Zq×Zqas input. However, Hscan be viewed
as taking bit-strings of length 2 ·(n−1) as input if we parse an input
x∈{0,1}2(n−1)as two strings x1,x2, each of length n−1, and then
viewx1,x2as elements of Zqin the natural way.
•The output of Hsis similarly speciﬁed as being an element of G, but
we can view this as a bit-string if we ﬁx some representation of G. To
satisfy the requirements of Deﬁnition 5.2 (which requires the output
length to be ﬁxed as a function of n) we can pad the output as needed.
•Giventhe above,theconstructiononlycompressesitsinputforgroups G
in which elements of Gcan be represented using fewer than 2 n−2 bits.
This holds both for the groups output by Algorithm 8.65 (assuming
n/lessmuch/lscript, which is usually the case), as well as for elliptic-curve groups
when point compression is used. A generalization of Construction 8.78336 Introduction to Modern Cryptography
can be used to obtain compression from anyGfor which the discrete-
logarithm problem is hard, regardless of the number of bits required to
represent group elements; see Exercise 8.21.
THEOREM 8.79 If the discrete-logarithm problem is hard relative to G,
then Construction 8.78 is a ﬁxed-length collision-resistant hash function (sub-
ject to the discussion regarding compression, above).
PROOF Let Π = ( Gen,H) be as in Construction 8.78, and let Abe a
probabilistic polynomial-time algorithm with
ε(n)def= Pr[Hash-collA,Π(n) = 1]
(cf. Deﬁnition 5.2). We show how Acan be used by an algorithm A/primeto solve
the discrete-logarithm problem with success probability ε(n):
AlgorithmA/prime:
The algorithm is given G,q,g,has input.
1. Lets:=/angbracketleftG,q,g,h/angbracketright. RunA(s) and obtain output xandx/prime.
2. Ifx/negationslash=x/primeandHs(x) =Hs(x/prime) then:
(a) Ifh= 1 return 0.
(b) Otherwise ( h/negationslash= 1), parse xas (x1,x2) and parse x/primeas
(x/prime
1,x/prime
2), where x1,x2,x/prime
1,x/prime
2∈Zq, and return the result/bracketleftbig
(x1−x/prime
1)·(x/prime
2−x2)−1modq/bracketrightbig
.
Clearly,A/primerunsinpolynomialtime. Furthermore,theinput sgiventoAwhen
run as a subroutine by A/primeis distributed exactly as in experiment Hash-collA,Π
for the same value of the security parameter n. (The input toA/primeis generated
by runningG(1n) to obtain G,q,gand then choosing h∈Guniformly at
random. This is exactly how sis generated by Gen(1n).) So, with probability
exactlyε(n) there is a collision; i.e.,x/negationslash=x/primeandHs(x) =Hs(x/prime).
We claim that whenever there is a collision, A/primereturns the correct answer
loggh. Ifh= 1 then this is clearly true (since loggh= 0 in this case).
Assuming h/negationslash= 1, the existence of a collision means that
Hs(x1,x2) =Hs(x/prime
1,x/prime
2)⇒gx1hx2=gx/prime
1hx/prime
2
⇒gx1−x/prime
1=hx/prime
2−x2. (8.5)
Note that x/prime
2−x2/negationslash= 0 mod q; otherwise, we would have x1=x/prime
1modqbut
thenx=x/primeand we would not have a collision. Since qis prime, the inverse
∆def= [(x/prime
2−x2)−1modq] exists. Raising each side of Equation (8.5) to this
power gives:
g(x1−x/prime
1)·∆=/parenleftBig
hx/prime
2−x2/parenrightBig∆
=h1=h,Number Theory and Cryptographic Hardness Assumptions 337
and so the output returned by A/primeis
loggh= [(x1−x/prime
1)·∆ modq] =/bracketleftbig
(x1−x/prime
1)·(x/prime
2−x2)−1modq/bracketrightbig
.
We see thatA/primecorrectly solves the discrete-logarithm problem with proba-
bility exactly ε(n). Since, by assumption, the discrete-logarithm problem is
hard relative toG, we conclude that ε(n) is negligible.
Using Exercise 8.21 in combination with the Merkle–Damg˚ ard transform
(see Section 5.2) we obtain:
THEOREM 8.80 If the discrete-logarithm problem is hard, then collision-
resistant hash functions exist.
References and Additional Reading
ThebookbyChilds[44]hasexcellentcoverageofthegrouptheorydiscussed
inthischapter(andmore),ingreaterdepth butatasimilarlevelofexposition.
Shoup [159] gives a more advanced, yet still accessible, treatment of much of
this material also, with special focus on algorithmic aspects. (Our statement
of Bertrand’s postulate is taken from [159, Theorem 5.8].) Relatively gentle
introductions to abstract algebra and group theory that go well beyond what
we have space for here are available in the books by Fraleigh [67] and Her-
stein [89]; the interested reader will have no trouble ﬁnding more advanced
algebra texts if they are so inclined.
The ﬁrst eﬃcient primality test was by Solovay and Strassen [164]. The
Miller–Rabin test is due to Miller [127] and Rabin [146]. A deterministic
primality test was discovered by Agrawal et al. [5]. See Dietzfelbinger [57] for
a comprehensive survey of this area.
The RSA problem was publicly introduced by Rivest, Shamir, and Adle-
man [148], although it was revealedin 1997that Ellis, Cocks, and Williamson,
three members of GCHQ (a British intelligence agency), had explored similar
ideas—without fully recognizing their importance—in a classiﬁed setting sev-
eral years earlier. The discrete-logarithm and Diﬃe–Hellman problems were
ﬁrst considered, at least implicitly, by Diﬃe and Hellman [58].
Most treatments of elliptic curves require advanced mathematical back-
ground on the part of the reader. The book by Silverman and Tate [160] is
perhaps an exception. As with many books on the subject written for mathe-
maticians, however, that book has little coverage of elliptic curves over ﬁnite
ﬁelds, which is the case most relevant to cryptography. The text by Washing-
ton [176], although a bit more advanced, deals heavily (but not exclusively)338 Introduction to Modern Cryptography
with the ﬁnite-ﬁeld case. Implementation issues related to elliptic-curve cryp-
tography are covered by Hankerson et al. [83]. Recommended parameters for
elliptic curves, as well as subgroups modulo a prime, are given by NIST [132].
Theconstructionofacollision-resistanthashfunction basedonthe discrete-
logarithm problem is due to [43], and an earlier construction based on the
hardness of factoring is given in [81] (see also Exercise 8.20).
Exercises
8.1LetGbe an abelian group. Prove that there is a uniqueidentity in G,
and that every element g∈Ghas auniqueinverse.
8.2 Show that Proposition 8.36 does not necessarily hold when Gis inﬁnite.
Hint:Consider the set {1} ∪{2,4,6,8,...} ⊂R.
8.3 LetGbe a ﬁnite group, and g∈G. Show that/angbracketleftg/angbracketrightis a subgroup of G.
Is the set{g0,g1,...}necessarily a subgroup of GwhenGis inﬁnite?
8.4 This question concerns the Euler phi function.
(a) Letpbeprimeand e≥1aninteger. Showthat φ(pe) =pe−1(p−1).
(b) Letp,qbe relatively prime. Show that φ(pq) =φ(p)·φ(q). (You
may use the Chinese remainder theorem.)
(c) Prove Theorem 8.19.
8.5 Compute the ﬁnal two (decimal) digits of 31000(by hand).
Hint:The answer is [31000mod 100].
8.6 Compute [1014,800,000,002mod 35] (by hand).
8.7 Compute[4651mod 55](byhand)usingthe Chineseremaindertheorem.
8.8 Prove that if G,Hare groups, then G×His a group.
8.9 Letp,Nbe integers with p|N. Prove that for any integer X,
[[XmodN] modp] = [Xmodp].
Show that, in contrast, [[ Xmodp] modN] need not equal [ XmodN].
8.10 Corollary 8.21 shows that if N=pqanded= 1 mod φ(N) then for
allx∈Z∗
Nwe have ( xe)d=xmodN. Show that this holds for all
x∈{0,...,N−1}.
Hint:Use the Chinese remainder theorem.Number Theory and Cryptographic Hardness Assumptions 339
8.11 Complete the details of the proof of the Chinese remainder theorem,
showing that Z∗
Nis isomorphic to Z∗
p×Z∗
q.
8.12 This exercise develops an eﬃcient algorithm for testing whether an in-
teger is a perfect power.
(a) Show that if N=ˆNefor some integers ˆN,e >1 thene≤/bardblN/bardbl.
(b) Given Nandewith 2≤e≤/bardblN/bardbl+1, show how to determine in
poly(/bardblN/bardbl) time whether there exists an integer ˆNwithˆNe=N.
Hint:Use binary search.
(c) Given N, show how to test in poly(/bardblN/bardbl) time whether Nis a
perfect power.
8.13 Given Nanda∈Z∗
N, show how to test in polynomial time whether a
is a strong witness that Nis composite.
8.14 Fix N,ewith gcd( e,φ(N)) = 1, and assume there is an adversary A
running in time tfor which
Pr[A([xemodN]) =x] = 0.01,
where the probability is taken over uniform choice of x∈Z∗
N. Show
that it is possible to construct an adversary A/primefor which
Pr[A/prime([xemodN]) =x] = 0.99
forallx. The running time t/primeofA/primeshould be polynomial in tand/bardblN/bardbl.
Hint:Use the fact that y1/e·r= (y·re)1/emodN.
8.15 Formally deﬁne the CDH assumption. Prove that hardness of the CDH
problemrelativeto Gimplies hardnessofthe discrete-logarithmproblem
relativetoG, andthathardnessoftheDDHproblemrelativeto Gimplies
hardness of the CDH problem relative to G.
8.16 Determine the points on the elliptic curve E:y2=x3+2x+1 over Z11.
How many points are on this curve?
8.17 Consider the elliptic-curve group from Example 8.67. (See also Exam-
ple 8.69.) Compute (1 ,0)+(4,3)+(4,3)in this groupby ﬁrst converting
to projective coordinates and then using Equations (8.3) and (8.4).
8.18 Prove the fourth statement in Proposition 8.68.
8.19 Can the following problem be solved in polynomial time? Given a prime
p, a value x∈Z∗
p−1, andy:= [gxmodp] (where gis a uniform value
inZ∗
p), ﬁndg, i.e., compute y1/xmodp. If your answer is “yes,” give a
polynomial-time algorithm. If your answer is “no,” show a reduction to
one of the assumptions introduced in this chapter.340 Introduction to Modern Cryptography
8.20 Let GenRSAbeasinSection8.2.4. ProvethatiftheRSAproblemishard
relative to GenRSA then Construction 8.81 is a ﬁxed-length collision-
resistant hash function.
CONSTRUCTION 8.81
Deﬁne (Gen,H) as follows:
•Gen: on input 1n, runGenRSA(1n) to obtain N,e,d, and select
y←Z∗
N. The key is s:=/angbracketleftN,e,y/angbracketright.
•H: ifs=/angbracketleftN,e,y/angbracketright, thenHsmaps inputs in{0,1}3nto outputs
inZ∗
N. Letfs
0(x)def= [xemodN] andfs
1(x)def= [y·xemodN].
For a 3n-bit long string x=x1···x3n, deﬁne
Hs(x)def=fs
x1/parenleftBig
fs
x2/parenleftBig
···/parenleftBig
1/parenrightBig
···/parenrightBig/parenrightBig
.
8.21 Consider the following generalization of Construction 8.78:
CONSTRUCTION 8.82
Deﬁne a ﬁxed-length hash function ( Gen,H) as follows:
(a)Gen: oninput1n, runG(1n)to obtain ( G,q,h1)andthenselect
h2,...,h t←G. Output s:=/angbracketleftG,q,(h1,...,h t)/angbracketrightas the key.
(b)H: given a key s=/angbracketleftG,q,(h1,...,h t)/angbracketrightand input ( x1,...,x t)
withxi∈Zq, output Hs(x1,...,x t) :=/producttext
ihxi
i.
(a) Prove that if the discrete-logarithm problem is hard relative to G
andqis prime, then for any t=poly(n) this construction is a
ﬁxed-length collision-resistant hash function.
(b) Discuss how this construction can be used to obtain compression
regardless of the number of bits needed to represent elements of G
(as long as it is polynomial in n).Chapter 9
*Algorithms for Factoring and
Computing Discrete Logarithms
In the last chapter, we introduced several number-theoretic problems—most
prominently, factoring the product of two large primes and computing dis-
crete logarithms in certain groups—that are widely believed to be hard. As
deﬁned there, this means there are presumed to be no polynomial-time algo-
rithms for these problems. This asymptotic notion of hardness, however, tells
us little about how to set the security parameter—sometimes called the key
length, although the terms are not interchangeable—to achieve some desired,
concrete level of security in practice. A proper understanding of this issue is
extremely important for the real-worlddeployment of cryptosystems based on
these problems. Setting the security parameter too low means a cryptosystem
maybevulnerabletoattacksmoreeﬃcientthananticipated; beingoverlycon-
servative and setting the security parameter too high will give good security,
but at the expense of eﬃciency for the honest users. The relative diﬃculty of
diﬀerent number-theoretic problems can also play a role in determining which
problems to use as the basis for building cryptosystems in the ﬁrst place.
Thefundamentalissue, ofcourse,isthatabrute-forcesearchmaynotbethe
best algorithm for solving a given problem; thus, using key length ndoes not,
in general, give security against attackers running for 2ntime. This is in con-
trasttotheprivate-keysettingwherethebestattacksonexistingblockciphers
have roughlythe complexity ofbrute-forcesearch(ignoring pre-computation).
As a consequence, the key lengths used in the public-key setting tend to be
signiﬁcantly larger than those used in the private-key setting.
To gain a better appreciation of this point, we explore in this chapter sev-
eral nonpolynomial-time algorithms for factoring and computing discrete log-
arithms that are far better than brute-force search. The goal is merely to give
atasteofexistingalgorithmsfortheseproblems, aswellastoprovidesomeba-
sic guidance for setting parameters in practice. Our focus is on the high-level
ideas, and we consciously do not address many important implementation-
level details that would be critical to deal with if these algorithms were to
be used in practice. We also concentrate exclusively on classical algorithms,
and refer the reader elsewhere for a discussion of known quantum polynomial-
time(!) algorithms for factoring and computing discrete logarithms. (This
was another conscious decision, both because we did not want to assume a
background in quantum mechanics on the part of the reader, and because
quantum computers seem unlikely in the near future.)
341342 Introduction to Modern Cryptography
The reader may also notice that we only describe algorithms for factoring
and computing discrete logarithms, and not algorithms for, say, solving the
RSA or decisional Diﬃe–Hellman problems. Our choice is justiﬁed by the
facts that the best known algorithms for solving RSA require factoring the
modulus, and (in the groups discussed in Sections 8.3.3 and 8.3.4) the best
known approaches for solving the decisional Diﬃe–Hellman problem involve
computing discrete logarithms.
9.1 Algorithms for Factoring
Throughout, we assume that N=pqis a product of two distinct primes
withp < q. We will be most interested in the case when pandqeach has the
same (known) length n, and so n= Θ(logN).
We will frequently use the Chinese remainder theorem along with the nota-
tion developed in Section 8.1.5. The Chinese remainder theorem states that
ZN/similarequalZp×ZqandZ∗
N/similarequalZ∗
p×Z∗
q,
with isomorphism given by f(x)def= ([xmodp],[xmodq]). The fact that
fis an isomorphism means, in particular, that it gives a bijection between
elements x∈ZNand pairs ( xp, xq)∈Zp×Zq. We write x↔(xp, xq), with
xp= [xmodp] andxq= [xmodq], to denote this bijection.
Recall from Section 8.2 that trial division —a trivial, brute-force factoring
method—ﬁnds a factor of a given number Nin timeO(N1/2·polylog(N)).
(This is an exponential-time algorithm, since the size of the input is the length
of the binary representation of N, i.e.,/bardblN/bardbl=O(logN).1) We cover three
factoring algorithms with better performance:
•Pollard’s p−1methodis eﬀective if p−1 has only “small” prime factors.
•Pollard’s rho method applies to arbitrary N. (As such, it is called a
general-purpose factoring algorithm.) Its running time for Nof the
form discussed at the beginning of this section is O(N1/4·polylog(N)).
Note this is still exponential inn, the length of N.
•Thequadratic sieve algorithm is a general-purpose factoring algorithm
that runs in time sub-exponential in the length of N. We give a high-
leveloverviewofhowthis algorithmworks,but the details aresomewhat
complex and are beyond the scope of this book.
1Thus, a running time of NO(1)= 2O(/bardblN/bardbl)is exponential, a running time of 2o(logN)=
2o(/bardblN/bardbl)is sub-exponential, and a running time of logO(1)N=/bardblN/bardblO(1)is polynomial.*Algorithms for Factoring and Computing Discrete Logarithms 343
The fastest known general-purpose factoring algorithm is the general num-
ber ﬁeld sieve . Heuristically, this algorithm factors its input Nin expected
time 2O((logN)1/3·(loglog N)2/3), which is sub-exponential in the length of N.
9.1.1 Pollard’s p−1Algorithm
IfN=pqandp−1hasonly“small”prime factors, Pollard’s p−1algorithm
can be used to eﬃciently factor N. The basic idea is simple. Let Bbe an
integer for which ( p−1)|Band (q−1)/negationslash|B; we defer to below the details of
how such a Bis found. Say B=γ·(p−1) for some integer γ. Choose a
uniform x∈Z∗
Nand compute y:= [xB−1 modN]. (Note that ycan be
computed using the eﬃcient exponentiation algorithm from Appendix B.2.3.)
Since 1↔(1,1), we have
y= [xB−1 modN]↔(xp,xq)B−(1,1)
= (xB
p−1 modp, xB
q−1 modq)
= ((xp−1
p)γ−1 modp, xB
q−1 modq)
= (0,[xB
q−1 modq])
using Theorem 8.14 and the fact that the order of Z∗
pisp−1. We show below
that, with high probability, xB
q/negationslash= 1 mod q. Assuming this is the case, we have
obtained an integer yfor which
y= 0 mod pbuty/negationslash= 0 mod q;
that is,p|ybutq/negationslash|y. This, in turn, implies that gcd( y,N) =p. Thus, a
simple gcd computation (which can be done eﬃciently as described in Ap-
pendix B.1.2) yields a prime factor of N.
ALGORITHM 9.1
Pollard’sp−1algorithm for factoring
Input:IntegerN
Output: A non-trivial factor of N
x←Z∗
N
y:= [xB−1 modN]
//Bis as in the text
p:= gcd(y,N)
ifp/negationslash∈{1,N}returnp
Let us ﬁrst argue that the algorithm works(with high probability). Assume
(p−1)|Bbut (q−1)/negationslash|B. In that case, as long as xqdef= [xmodq] is a
generator of Z∗
q, we have xB
q/negationslash= 1 mod q. (This follows from Proposition 8.52.)
It remains to analyze the probability that xqis a generator. Here we rely on344 Introduction to Modern Cryptography
some results proved in Appendix B.3.1. Since qis prime, Z∗
qis a cyclic group
of orderq−1 that has exactly φ(q−1) generators (cf. Theorem B.16). If xis
chosen uniformly from Z∗
N, thenxqis uniformly distributed in Z∗
q. (This is a
consequence of the fact that the Chinese remainder theorem gives a bijection
between Z∗
NandZ∗
p×Z∗
q.) Thus, the probability that xqis a generator is
φ(q−1)
q−1=Ω(1/logq) = Ω(1/n) (cf. Theorem B.15). Multiple values of xcan
be chosen to boost the probability of success.
Weareleftwith the problemofﬁnding Bsuchthat( p−1)|Bbut (q−1)/negationslash|B.
One possibility is to choose B=/producttextk
i=1p⌊n/logpi⌋
i for some k, wherepidenotes
theithprime (i.e., p1= 2,p2= 3,p3= 5,...) andnis the length of p. (Note
thatp⌊n/logpi⌋
i is the largest power of pithat can possibly divide p−1.) If
p−1 can be written as/producttextk
i=1pei
iwithei≥0 (that is, if the largest prime
factor of p−1 is less than pk), we will have ( p−1)|B. In contrast, if q−1
hasanyprime factor larger than pk, then (q−1)/negationslash|B.
Choosing a larger value for kincreases Band so increases the running time
of the algorithm (which performs a modular exponentiation to the power B).
A larger value of kalso makes it more likely that ( p−1)|B, but at the same
time makes it less likely that ( q−1)/negationslash|B. It is, of course, possible to run the
algorithm repeatedly using multiple choices for k.
Pollard’s p−1 algorithm is thwarted if both p−1 andq−1 have any large
prime factors. (More precisely, the algorithm still works but only for Bso
large that the algorithm becomes impractical.) If pandqare uniform n-bit
primes, then it is unlikely that either p−1 orq−1 will have only small prime
factors. Nevertheless, when generating a modulus N=pqfor cryptographic
applications, pandqare sometimes chosen to be strongprimes. (Recall that
pis a strong prime if ( p−1)/2 is also prime.) Selecting pandqin this way
is markedly less eﬃcient than simply choosing pandqasarbitrary (random)
primes. Because better factoring algorithms are available anyway (as we will
see below), and due to the observation above, the current consensus is that
the added computational cost of generating pandqas strong primes does not
yield any appreciable security gains.
9.1.2 Pollard’s Rho Algorithm
Pollard’s rho algorithm can be used to factor an arbitrary integer N=pq;
in that sense, it is a general-purpose factoring algorithm. Heuristically, the
algorithm factors Nwith constant probability in O/parenleftbig
N1/4·polylog(N)/parenrightbig
time;
this is still exponential, but is a vast improvement over trial division.
The core idea of the approach is to ﬁnd distinct values x,x/prime∈Z∗
Nthat are
equivalent modulo p(i.e., for which x=x/primemodp); call such a pair good. Note
thatforagoodpair x,x/primeitholdsthatgcd( x−x/prime,N) =p(sincex/negationslash=x/primemodN),
so computing the gcd gives a non-trivial factor of N.
How can we ﬁnd a good pair? Say we choose values x(1),...,x(k)uni-
formly from Z∗
N, wherek= 2n/2=O(√p). Viewing these in their Chinese-*Algorithms for Factoring and Computing Discrete Logarithms 345
ALGORITHM 9.2
Pollard’s rho algorithm for factoring
Input:IntegerN, a product of two n-bit primes
Output: A non-trivial factor of N
x(0)←Z∗
N,x/prime:=x:=x(0)
fori= 1 to 2n/2:
x:=F(x)
x/prime:=F(F(x/prime))
p:= gcd(x−x/prime,N)
ifp/negationslash∈{1,N}returnpandstop
remaindering representation as ( x(1)
p,x(1)
q),...,(x(k)
p,x(k)
q), we have that each
x(i)
pdef= [x(i)modp] is uniform in Z∗
p. (This follows from bijectivity between
Z∗
NandZ∗
p×Z∗
q.) Thus, using the birthdaybound of LemmaA.16, we see that
with high probability there exist distinct i,jwithx(i)
p=x(j)
por, equivalently,
x(i)=x(j)modp. Moreover, Lemma A.15 shows that x(i)/negationslash=x(j)except
with negligible probability. Thus, with high probability we obtain a good pair
x(i),x(j)that can be used to ﬁnd a non-trivialfactorof N, asdiscussed earlier.
We can generate k=O(√p)uniform elements of Z∗
NinO(√p)=O(N1/4)
time.Testingall pairs of elements in order to identify a good pair, however,
would require/parenleftbigk
2/parenrightbig
=O(k2) =O(p) =O/parenleftbig
N1/2/parenrightbig
time! (Note that since pis
unknown we cannot simply compute x(1)
p,...,x(k)
pexplicitly and then sort the
x(i)
pto ﬁnd a good pair. Instead, for all distinct pairs i,jwe must compute
gcd(x(i)−x(j),N)toseewhetherthisgivesanon-trivialfactorof N.) Without
further optimizations, this will be no better than trial division.
Pollard’s idea was to use a technique we have seen in Section 5.4.2 in the
contextofsmall-spacebirthdayattacks. Speciﬁcally, wecomputethesequence
x(1),x(2),...by letting each value be a function of the one before it; i.e., we
ﬁx some function F:Z∗
N→Z∗
N, choose a uniform x(0)∈Z∗
N, and then set
x(i):=F(x(i−1)) fori= 1,...,k. We require Fto have the property that if
x=x/primemodp, thenF(x) =F(x/prime) modp; this ensures that once equivalence
modulopoccurs, it persists. (A standardchoiceis F(x) = [x2+1 mod N], but
anypolynomial Fwillhavethisproperty.) Ifwemodel Fasarandomfunction
(which works heuristically), then with high probability there is a good pair in
the ﬁrst kelements of this sequence. Proceeding roughly as in Algorithm 5.9
from Section 5.4.2, we can detect a good pair (if there is one) using only O(k)
gcd computations; see Algorithm 9.2. In addition to improving the running
time, Pollard’s idea also drastically reduces the amount of memory needed.
9.1.3 The Quadratic Sieve Algorithm
Pollard’s rho algorithm is better than trial division, but still runs in expo-
nential time. The quadratic sieve algorithm runs in sub-exponential time. It346 Introduction to Modern Cryptography
was the fastest known factoring algorithm until the early 1990s and remains
the factoring algorithm of choice for numbers up to about 300 bits long. We
describe the general principles of the algorithm but caution the reader that
several important details are omitted.
An element z∈Z∗
Nis aquadratic residue modulo Nif there is an x∈Z∗
N
such that x2=zmodN; in this case, we say that xis asquare root of z. The
following observations serve as our starting point:
•IfNis a product of two distinct, odd primes, then every quadratic
residue modulo Nhas exactly four square roots. (See Section 13.4.2.)
•Givenx,ywithx2=y2modNandx/negationslash=±ymodN, it is possible to
compute a nontrivial factor of Nin polynomial time. This is by virtue
of the fact that x2=y2modNimplies
0 =x2−y2= (x−y)(x+y) modN,
and soN|(x−y)(x+y). However, N/negationslash|(x−y) andN/negationslash|(x+y) because
x/negationslash=±ymodN. So it must be the case that gcd( x−y,N) is equal to
one of the prime factors of N. (See also Lemma 13.35.)
The quadratic sieve algorithm tries to generate x,ywithx2=y2modN
andx/negationslash=±ymodN. A naive way of doing this—which forms the basis of an
older factoring algorithm due to Fermat—is to choose an x∈Z∗
N, compute
q:= [x2modN], and then check whether qis a square over the integers (i.e.,
without reduction modulo N). If so, then q=y2for some integer yand so
x2=y2modN. Unfortunately, the probability that [ x2modN] is a square
is so low that this process must be repeated exponentially many times.
A signiﬁcant improvement is obtained by generating a sequence of values
q1:= [x2
1modN],...and identifying a subset of those values whose prod-
uctis a square over the integers. In the quadratic sieve algorithm this is
accomplished using the following two steps:
Step 1. Fix some bound B. Say an integer is B-smooth if all its prime
factors are less than or equal to B. In the ﬁrst phase of the algorithm, we
search for integers of the form qi= [x2
imodN] that are B-smooth and factor
them. (Although factoring is hard, ﬁnding and factoring B-smooth numbers
is feasible when Bis small enough.) These {xi}are chosen by trying x=√
N+1,√
N+2,... ; this ensures a nontrivial reduction modulo N(since
x >√
N)and has the advantage that qdef= [x2modN] =x2−Nis “small”
so thatqis more likely to be B-smooth.
Let{p1,...,p k}be the set of prime numbers less than or equal to B. Once
we have found and factored the B-smooth{qi}as described above, we have a*Algorithms for Factoring and Computing Discrete Logarithms 347
set of equations of the form:
q1= [x2
1modN] =k/productdisplay
i=1pe1,i
i
... (9.1)
q/lscript= [x2
/lscriptmodN] =k/productdisplay
i=1pe/lscript,i
i.
(Note that the above equations are over the integers.)
Step 2. We next want to ﬁnd some subset of the {qi}whose product is a
square. If we multiply some subset Sof the{qi}, we see that the result
z=/productdisplay
j∈Sqj=k/productdisplay
i=1p/summationtext
j∈Sej,i
i
is a square if and only if the exponent of each prime piis even. This suggests
that we care about the exponents {ej,i}in Equation (9.1) only modulo 2;
moreover, we can use linear algebra to ﬁnd a subset of the {qi}whose “expo-
nent vectors” sum to the 0-vector modulo 2.
In more detail: if we reduce the exponents in Equation (9.1) modulo 2, we
obtain the 0/1-matrix Γ given by

γ1,1γ1,2···γ1,k
............
γ/lscript,1γ/lscript,2···γ/lscript,k
def=
[e1,1mod 2] [ e1,2mod 2]···[e1,kmod 2]
............
[e/lscript,1mod 2] [ e/lscript,2mod 2]···[e/lscript,kmod 2]
.
If/lscript=k+ 1, then Γ has more rows than columns and there must be some
nonempty subset Sof the rows that sum to the 0-vector modulo 2. Such a
subset can be found eﬃciently using linear algebra. Then:
zdef=/productdisplay
j∈Sqj=k/productdisplay
i=1p/summationtext
j∈Sej,i
i =/parenleftBiggk/productdisplay
i=1p(/summationtext
j∈Sej,i)/2
i/parenrightBigg2
,
using the fact that all the/braceleftBig/summationtext
j∈Sej,i/bracerightBig
are even. Since
z=/productdisplay
j∈Sqj=/productdisplay
j∈Sx2
j=
/productdisplay
j∈Sxj
2
modN,
we have obtained two square roots (modulo N) ofz. Although there is no
guarantee that these square roots will enable factorization of N(for reasons348 Introduction to Modern Cryptography
discussed at the beginning of this section), heuristically they do with constant
probability. By taking /lscript > k+1 we can obtain multiple subsets Swith the
desired property and try to factor Nusing each possibility.
Example 9.3
TakeN= 377753. We have 6647 = [6202modN], and we can factor 6647
(over the integers, without any modular reduction) as
/bracketleftbig
6202modN/bracketrightbig
= 6647 = 172·23.
Similarly,
/bracketleftbig
6212modN/bracketrightbig
= 24·17·29
/bracketleftbig
6452modN/bracketrightbig
= 27·13·23
/bracketleftbig
6552modN/bracketrightbig
= 23·13·17·29.
Letting our subset Sinclude all four of the above equations, we see that
6202·6212·6452·6552= 214·132·174·232·292modN
⇒[620·621·645·655 mod N]2=/bracketleftbig
27·13·172·23·29 modN/bracketrightbig2modN
⇒1271942= 453352modN,
with 127194/negationslash=±45335mod N. Computing gcd(127194 −45335,377753) =
751 yields a non-trivial factor of N. ♦
Running time. Choosing a larger value of Bmakes it more likely that a
uniform value q= [x2modN] isB-smooth; on the other hand, it means we
have to work harder to identify and factor B-smooth numbers, and we will
have to ﬁnd more of them (since we require /lscript > k, wherekis the number
of primes less than or equal to B). It also means that the matrix Γ will be
larger, and so the linear-algebraic step will be slower. Choosing the optimal
value of Bgives an algorithm that (heuristically, at least) factors Nin time
2O(√logNloglogN).(In fact, the constant term in the exponent can be deter-
mined quite precisely.) The important point for our purposes is that this is
sub-exponential in the length of N.
9.2 Algorithms for Computing Discrete Logarithms
LetGbe a group of known order q. An instance of the discrete-logarithm
problem in Gspeciﬁes a baseg∈G(which need not be a generator of G)
and an element h∈/angbracketleftg/angbracketright, the subgroup generated by h; the goal is to ﬁnd x*Algorithms for Factoring and Computing Discrete Logarithms 349
such that gx=h. (See Section 8.3.2.) The solution xis called the discrete
logarithm of hwith respect to g. A trivial brute-force search for xcan be done
in time|/angbracketleftg/angbracketright|≤q(by simply trying all possible values), and so we will only be
interested in algorithms whose running time is better than this.
Algorithms for solving the discrete-logarithm problem fall into two cate-
gories: those that are genericand apply to arbitrary groups, and those that
are tailored to work for some speciﬁcclass of groups. We begin by discussing
three generic algorithms:
•When the group order qis not prime and the factorizationof qis known,
oreasytodetermine, the Pohlig–Hellman algorithm reducestheproblem
of ﬁnding discrete logarithms in Gto that of ﬁnding discrete logarithms
in prime-order subgroups ofG. Roughly speaking, the eﬀect is that the
complexity of solving the discrete logarithm in a group of order qis no
greater than the complexity of solving the discrete logarithm in a group
of order q/prime, whereq/primeis the largest prime dividing q. This explains the
preference for using prime-order groups (cf. Section 8.3.2).
•Thebaby-step/giant-step method, due to Shanks, computes the discrete
logarithm in a group of order qin timeO(√q·polylog(q)) and storing
O(√q)group elements.
•Pollard’s rho algorithm also enables computation of discrete logarithms
in timeO(√q·polylog(q)), but using constant memory. It can be viewed
asexploitingtheconnectionbetweenthediscrete-logarithmproblemand
collision-resistant hashing that we have seen in Section 8.4.2. We de-
scribe a diﬀerent algorithm that more clearly illustrates this connection.
It can be shown that the time complexity of the latter two algorithms is
optimalas far as generic algorithms are concerned. Thus, to have any hope
of doing better we must look at algorithms for speciﬁc groups that exploit the
representation of group elements in those groups, where by “representation”
we mean the way group elements are encoded as bit-strings.
This point bears some discussion. From a mathematical point of view,
any two cyclic groups of the same order are isomorphic, meaning that the
groups are identical up to a “renaming” of the group elements. From a com-
putational/algorithmic point of view, however, this “renaming” can have a
signiﬁcant impact. For example, consider the cyclic group Zqof integers
{0,...,q−1}underaddition moduloq. Computing discrete logarithms in
this group is trivial. Say we are given g,h∈Zqwithga generator (so g/negationslash= 0),
and we want to ﬁnd xsuch that x·g=hmodq. Since g/negationslash= 0 we have
gcd(g,q) = 1 and so ghas a multiplicative inverse g−1moduloq. Moreover,
g−1can be computed eﬃciently, as described in Appendix B.2.2. But then
x=h·g−1modqis the desired solution. Note that, formally, xhere de-
notes an integer and not a group element—after all, the group operation is
addition, not multiplication. Nevertheless, in solving the discrete-logarithm350 Introduction to Modern Cryptography
problem in Zqwe can make use of the fact that another operation (namely,
multiplication) can be deﬁned on the elements of that group.
Turning to groups with cryptographic signiﬁcance, we focus our attention
on (subgroups of) Z∗
pforpprime. (See Section 8.3.3.) We give a high-level
overview of the index calculus algorithm for solving the discrete-logarithm
problem in such groups in sub-exponential time. Currently, the best known
algorithm for this class of groups is the number ﬁeld sieve ,2which heuris-
tically runs in time 2O((logp)1/3·(loglog p)2/3). Sub-exponential algorithms for
computing discrete logarithms in multiplicative subgroups of ﬁnite ﬁelds of
large characteristic are also known. In early 2013, signiﬁcant advances were
made in algorithms for computing discrete logarithms in multiplicative sub-
groups of ﬁnite ﬁelds of smallcharacteristic; it seems prudent to avoid using
such groups for cryptographic applications.
Importantly, no sub-exponential algorithms are known for computing dis-
crete logarithms in certain elliptic-curve groups. This means that for a given
security level, we can use groups of smaller order when working in elliptic-
curve groups as compared to, say, working in Z∗
p, resulting in cryptographic
schemes with better asymptotic eﬃciency.
9.2.1 The Pohlig–Hellman Algorithm
The Pohlig–Hellman algorithm can be used to speed up the computation
of discrete logarithms in a group Gwhen any non-trivial factors of the group
orderqare known. Recall that the order of an element g, which we denote
here byord(g), is the smallest positive integer ifor which gi= 1. We will
need the following lemma:
LEMMA 9.4 Letord(g) =q, and say p|q. Thenord(gp) =q/p.
PROOF Since (gp)q/p=gq= 1, the order of gpis at most q/p. Leti >0
be such that ( gp)i= 1. Then gpi= 1 and, since qis the order of g, we must
havepi≥qor equivalently i≥q/p. The order of gpis thus exactly q/p.
We will also use a generalization of the Chinese remainder theorem: if
q=/producttextk
i=1qiand gcd(qi,qj) = 1 for all i/negationslash=jthen
Zq/similarequalZq1×···×ZqkandZ∗
q/similarequalZ∗
q1×···×Z∗
qk.
(This can be provedby induction on k, using the basic Chinese remainder the-
orem for k= 2.) Moreover, by an extension of the algorithm in Section 8.1.5
2Itis no accident that the algorithm’s name and its running time are similar to those of
the general number ﬁeld sieve for factoring, since the algorithms share many of the same
underlying steps.*Algorithms for Factoring and Computing Discrete Logarithms 351
it is possible to convert eﬃciently between the representation of an element
as an element of Zqand its representation as an element of Zq1×···×Zqk.
We now describe the Pohlig–Hellmanalgorithm. We are givena generator g
and an element hand wish to ﬁnd an xsuch that gx=h. Say a factorization
q=/producttextk
i=1qiis known with the {qi}pairwise relatively prime. (This need not
be the complete prime factorization of q.) We know that
/parenleftBig
gq/qi/parenrightBigx
= (gx)q/qi=hq/qifori= 1,...,k. (9.2)
Lettinggidef=gq/qiandhidef=hq/qi, we thus have kinstances of a discrete-
logarithm problem in ksmallergroups. Speciﬁcally, each problem gx
i=hi
is in a subgroup of size ord(gi) =qi(by Lemma 9.4). (Note that each such
problem only determines [ xmodqi]; this follows from Proposition 8.53.)
We can solve each of the kresulting instances using any algorithm for
solving the discrete-logarithm problem. Solving these instances gives a set of
answers{xi}k
i=1, withxi∈Zqi, for which gxi
i=hi=gx
i. Proposition 8.53
implies that x=ximodqifor alli. By the generalized Chinese remainder
theorem discussed earlier, the constraints
x=x1modq1
...
x=xkmodqk
uniquely determine xmoduloq, and the desired solution xcan be eﬃciently
reconstructed from the {xi}.
Example 9.5
Consider the problem of computing discrete logarithms in Z∗
31, a group of
orderq= 30 = 5·3·2. Sayg= 3 andh= 26 =gxwithxunknown. We have:
(g30/5)x=h30/5⇒(36)x= 266⇒16x= 1
(g30/3)x=h30/3⇒(310)x= 2610⇒25x= 5
(g30/2)x=h30/2⇒(315)x= 2615⇒30x= 30.
(All the above equations are modulo 31.) We have ord(16) = 5, ord(25) = 3,
andord(30) = 2. Solving each equation, we obtain
x= 0 mod 5 , x= 2 mod 3 ,andx= 1 mod 2 ,
and sox= 5 mod 30. Indeed, 35= 26 mod 31. ♦
Ifqhas(known)primefactorization q=/producttextk
i=1pei
ithen, byusingthe Pohlig–
Hellman algorithm, the time to compute discrete logarithms in a group of
orderqis dominated by the computation ofa discrete logarithmin a subgroup
of size max i{pei
i}. This can be further reduced to computation of a discrete
logarithm in a subgroup of size max i{pi}; see Exercise 9.5.352 Introduction to Modern Cryptography
9.2.2 The Baby-Step/Giant-Step Algorithm
Thebaby-step/giant-stepalgorithmcomputesdiscretelogarithmsinagroup
of order qusingO(√q)group operations. The idea is simple. Given a gener-
atorg∈G, we can imagine the powers of gas forming a cycle
1 =g0, g1, g2, ..., gq−2, gq−1, gq= 1.
We know that hmust lie somewhere in this cycle. Computing all the points in
this cycle would take Ω( q) time. Instead, we “mark oﬀ” the cycle at intervals
ofsizetdef=⌊√q⌋;moreprecisely, wecomputeandstorethe ⌊q/t⌋+1 =O(√q)
elements
g0,gt,g2t,...,g⌊q/t⌋·t.
(These are the “giant steps.”) Note that the gap between any consecutive
“marks” is at most t. Furthermore, we know that h=gxlies in one of these
gaps. Thus, if we next take “baby steps” and compute the telements
h·g1, ..., h·gt,
each of which corresponds to a “shift” of h, we know that one of these values
will be equal to one of the points we have marked oﬀ. Say we ﬁnd h·gi=gk·t.
We can then easily compute loggh:= [(kt−i) modq]. Pseudocode for this
algorithm follows.
ALGORITHM 9.6
The baby-step/giant-step algorithm
Input:Elements g,h∈G; the order qofG
Output: loggh
t:=⌊√q⌋
fori=0 to⌊q/t⌋:
compute gi:=gi·t
sortthe pairs ( i,gi) by their second component
fori= 1 tot:
compute hi:=h·gi
ifhi=gkfor some k,return[kt−imodq]
The algorithm requires O(√q)exponentiations/multiplications in G.(In
fact, other than the ﬁrst value g1=gt, each value gican be computed using
a single multiplication as gi:=gi−1·g1. Similarly, each hican be computed
ashi:=hi−1·g.) Sorting theO(√q)pairs{(i,gi)}takes timeO(√q·logq),
and we can then use binary search to check if each hiis equal to some gkin
timeO(logq). The overall algorithm thus runs in time O(√q·polylog(q)).*Algorithms for Factoring and Computing Discrete Logarithms 353
Example 9.7
We show an application of the algorithm in the cyclic group Z∗
29of order
q= 29−1 = 28. Take g= 2 and h= 17. We set t= 5 and compute:
20= 1,25= 3,210= 9,215= 27,220= 23,225= 11.
(It should be understood that all operations are in Z∗
29.) Then compute:
17·21= 5,17·22= 10,17·23= 20,17·24= 11,
and notice that 17 ·24= 11 = 225. We thus have log217 = 25−4 = 21.♦
9.2.3 Discrete Logarithms from Collisions
A drawback of the baby-step/giant-step algorithm is that it uses a large
amount of memory, as it requires storage of O(√q)points. We can obtain an
algorithm that uses constant memory—and has the same asymptotic running
time—by exploiting the connection between the discrete-logarithm problem
and collision-resistant hashing shown in Section 8.4.2, and recalling the small-
space birthday attack for ﬁnding collisions from Section 5.4.2.
We describethe high-levelidea. Fix a base g∈Gand someelement h∈/angbracketleftg/angbracketright.
Recall from the results of Section 8.4.2 that if we deﬁne the hash function
Hg,h:Zq×Zq→GbyHg,h(x1,x2) =gx1hx2, then ﬁnding a collision in Hg,h
implies the ability to compute loggh. (See the proof of Theorem 8.79.) We
havethusreducedtheproblemofcomputinglogghtothatofﬁndingacollision
in a hash function, something we know how to do in time O(/radicalbig
|G|)=O(√q)
using a birthday attack! Moreover, a small-space birthday attack will give a
collision in the same time and constant space.
It only remains to address a few technical details. One is that the small-
space birthday attack described in Section 5.4.2 assumes that the range of
the hash function is a subset of its domain; that is not the case here, and in
fact (depending on the representation being used for elements of G) it could
even be that Hg,his not compressing. A second issue is that the analysis in
Section 5.4.2 treated the hash function as a random function, whereas Hg,h
has a signiﬁcant amount of algebraic structure.
Pollard’s rho algorithm provides one way to deal with the above issues. We
describe a diﬀerent algorithm that can be viewed as a more direct implemen-
tation of the above ideas. (In practice, Pollard’s algorithm would be more
eﬃcient, although both algorithms use only O(√q)group operations.) Let
F:G→Zq×Zqdenote a cryptographic hash function obtained by, e.g., a
suitable modiﬁcation of SHA-1. Deﬁne H:G→GbyH(k)def=Hg,h(F(k)).
We can use Algorithm 5.9, with natural modiﬁcations, to ﬁnd a collision in H
usingO(/radicalbig
|G|)=O(√q)evaluations of Hinexpectation (and constant mem-
ory). With overwhelming probability, this yields a collision in Hg,h. You are
asked to ﬂesh out the details in Exercise 9.6.354 Introduction to Modern Cryptography
It is interesting to observe here that a security proof based on the hardness
ofthe discrete-logarithmproblem—namely, that it implies acollision-resistant
hash function—leads to a better algorithm for solving that same problem! A
little reﬂectionshouldconvinceusthat thisisnotsurprising: aproofbyreduc-
tion demonstrates that an attack on some construction (in this case, ﬁnding
collisions in the hash function) directly yields an attack on the underlying
assumption (here, the hardness of the discrete-logarithm problem), which is
exactly the property the above algorithm exploits.
9.2.4 The Index Calculus Algorithm
We conclude with a brief look at the (non-generic) index calculus algorithm
for computing discrete logarithmsin the cyclic group Z∗
p(forpprime). In con-
trast to the preceding (generic) algorithms, this approach has sub-exponential
running time. The algorithm bears some resemblance to the quadratic sieve
algorithmintroducedinSection 9.1.3,and weassumereadersarefamiliarwith
the discussion there. As in that case, we discuss the main ideas of the index
calculus method but leave a detailed analysis outside the scope of our treat-
ment. Also, some simpliﬁcations are introduced to clarify the presentation.
The index calculus method uses a two-step process. Importantly, the ﬁrst
step requires knowledge only of the modulus pand the base gand so it can be
run as a preprocessing step before h—the value whose discrete logarithm we
wish to compute—is known. For the same reason, it suﬃces to run the ﬁrst
step only once in order to solve multiple instances of the discrete-logarithm
problem (as long as all those instances share the same pandg).
Step 1. Fix some bound B, and let{p1,...,p k}be the set of prime num-
bers less than or equal to B. In this step, we ﬁnd /lscript≥kdistinct values
x1,...,x /lscript∈Zp−1for which gidef= [gximodp] isB-smooth. This is done by
simply choosing uniform {xi}until suitable values are found.
Factoring the resulting B-smooth numbers, we have the /lscriptequations:
gx1=k/productdisplay
i=1pe1,i
imodp
...
gx/lscript=k/productdisplay
i=1pe/lscript,i
imodp.*Algorithms for Factoring and Computing Discrete Logarithms 355
Taking discrete logarithms, we can transform these into the linear equations
x1=k/summationdisplay
i=1e1,i·loggpimod (p−1) (9.3)
...
x/lscript=k/summationdisplay
i=1e/lscript,i·loggpimod (p−1). (9.4)
Note that the{xi}and the{ei,j}are known, while the {loggpi}are unknown.
Step 2. Now we are given an element hand want to compute loggh. Here,
we ﬁnd a value x∈Zp−1for which [ gx·hmodp] isB-smooth. (Once again,
this is done simply by choosing xuniformly.) Say
gx·h=k/productdisplay
i=1pei
imodp
⇒x+loggh=k/summationdisplay
i=1ei·loggpimod (p−1),
wherexand the{ei}are known. Combined with Equations (9.3)–(9.4), we
have/lscript+1≥k+1 linear equations in the k+1 unknowns{loggpi}k
i=1and
loggh. Usinglinear-algebraic3methods(andassumingthesystemofequations
is not under-deﬁned), we can solve for each of the unknowns and in particular
obtain the desired solution loggh.
Example 9.8
Letp= 101,g= 3, and h= 87. We have [310mod 101] = 65 = 5 ·13.
Similarly, [312mod 101] = 80 = 24·5 and [314mod 101] = 13. We thus have
the linear equations
10 = log35+log313 mod 100
12 = 4·log32+log35 mod 100
14 = log313 mod 100 .
We also have 35·87 = 32 = 25mod 101, or
5+log387 = 5·log32 mod 100 . (9.5)
Adding the second and third equations and subtracting the ﬁrst, we derive
4·log32 = 16 mod 100. This doesn’t determine log32 uniquely (since 4 is
3Technically, things are slightly more complicated since the linear equations are all modulo
p−1, which is not prime. Nevertheless, there exist techniques for dealing with this.356 Introduction to Modern Cryptography
not invertible modulo 100), but it does tell us that log32 = 4,29,54, or 79
(cf. Exercise 9.3). Trying all possibilities gives log32 = 29. Plugging this into
Equation (9.5) gives log387 = 40. ♦
Running time. Choosing a largervalue of Bmakes it more likely that a uni-
form value in Z∗
pisB-smooth; however, it means we will have to work harder
to identify and factor B-smooth numbers, and we will have to ﬁnd more of
them. Because the system of equations will be larger, solving the system will
take longer. Choosing the optimal value of Bgives an algorithm that (heuris-
tically, at least) computes discrete logarithms in Z∗
pin time 2O(√logploglogp).
(In fact, the constantterm in the exponent can be determined quite precisely.)
The important point for our purposes is that this is sub-exponential in the
length of p.
9.3 Recommended Key Lengths
Knowledgeofthebestavailablealgorithmsforsolvingvariouscryptographic
problems is essential for determining an appropriate key length to achieve
some desired level of security. The following table summarizes the key lengths
currently recommended by the US National Institute of Standards and Tech-
nology4(NIST) [13]:
RSA Discrete Logarithm
Eﬀective
Key Length Modulus LengthOrder-q
Subgroup of Z∗
pElliptic-Curve
Group Order q
112 2048 p:2048,q:224 224
128 3072 p:3072,q:256 256
192 7680 p:7680,q:384 384
256 15360 p:15360,q:512 512
All ﬁgures in the table are measured in bits. The “eﬀective key length” is
avaluensuch that the best known algorithm for solving a problem takes
time roughly 2n; i.e., the computational diﬃculty of solving a problem is
approximately equivalent to that of performing a brute-force search against
a symmetric-key scheme with an n-bit key, or the time to ﬁnd collisions in a
hash function with a 2 n-bit output length. NIST deems a 112-bit eﬀective key
length acceptable for security until the year 2030, but recommends 128-bit or
higher key lengths for applications where security is required beyond then.
4Other groups have made their own recommendations; see http://keylength.com .*Algorithms for Factoring and Computing Discrete Logarithms 357
Given what we have learned in this chapter, it is instructive to look more
closely at some of the numbers in the table. The ﬁrst thing we may notice is
that elliptic-curvegroupscanbe usedtorealizeanygivenlevelofsecuritywith
smaller parameters than for RSA or subgroups of Z∗
p. This is simply because
no sub-exponential algorithms are known for solving the discrete-logarithm
probleminsuchgroups(whenchosenappropriately). Achieving n-bitsecurity,
however, requires an elliptic-curve group whose order qis 2n-bits long. This
is a consequence of the generic algorithms we have seen in this chapter, which
solve the discrete-logarithm problem (in any group) in time O(√q)≈2n.
Turning to the case of Z∗
pwe see that here, too, a 2 n-bit value of qis needed
forn-bit security. The length of p, however, must be signiﬁcantly larger,
because the number ﬁeld sieve can be used to compute discrete logarithms in
Z∗
pin time sub-exponential in the length of p. (That is, pandqare chosen
such that the running time of the number ﬁeld sieve, which depends on the
length of p, and the runningtime ofagenericalgorithm, which depends onthe
length of q, will be approximately equal.) The practical ramiﬁcations of this
are that, for any desired security level, elliptic-curve cryptosystems can use
signiﬁcantly smaller parameters, with asymptotically faster group operations
for the honest parties, than cryptosystems based on subgroups of Z∗
p.
References and Additional Reading
Pollard’sp−1algorithmwaspublishedin 1974[139], andhisrhomethodfor
factoringwasdescribedthefollowingyear[140]. Thequadraticsievealgorithm
is due to Pomerance [142], based on earlier ideas of Dixon [60].
The baby-step/giant-step algorithm is due to Shanks [153]. The Pohlig–
Hellman algorithmwaspublished in 1978[138], as wasPollard’srhoalgorithm
for computing discrete logarithms [141]. The index calculus algorithm as we
have described it is by Adleman [4].
The texts by Wagstaﬀ [173], Shoup [159], Crandall and Pomerance [51],
Joux[96],andGalbraith[69]providefurtherinformationonalgorithmsforfac-
toring and computing discrete logarithms, including descriptions of the (gen-
eral)numberﬁeldsieve. Veryrecently, animprovedalgorithmforthe discrete-
logarithm problem in ﬁnite ﬁelds of small characteristic was announced [11].
Lower bounds on the running time of generic algorithms for computing
discrete logarithms, which asymptotically match the running times of the
algorithms described here, were given by Nechaev [133] and Shoup [155].
Lenstraand Verheul[113] provideacomprehensivediscussionofhowknown
algorithms for factoring and computing discrete logarithms aﬀect the choice
of cryptographic parameters in practice.358 Introduction to Modern Cryptography
Exercises
9.1In order to speed up the key-generation algorithm for RSA, it has been
suggestedto generatea prime by generatingmany small randomprimes,
multiplying them together, and adding one (of course, then checking
that the result is prime). Ignoring the question of the probability that
such a value really is prime, what do you think of this method?
9.2 In an execution of Algorithm 9.2, deﬁne x(i)def=F(i)(x(0)). Show that if,
in a given execution of the algorithm, there exist i,j≤2n/2such that
x(i)/negationslash=x(j)butx(i)=x(j)modp, then that execution of the algorithm
outputsp. (The analysis is a little diﬀerent from the analysis of Algo-
rithm 5.9, since the algorithms—and their goals—are slightly diﬀerent.)
9.3 (a) Show that if ab=cmodNand gcd( b,N) =d, then:
i.d|c;
ii.a·(b/d) = (c/d) mod (N/d); and
iii. gcd(b/d,N/d ) = 1.
(b) Describe how to use the above to compute discrete logarithms in
ZNeﬃciently even when the base gis not a generator of ZN.
9.4 Here we show how to solve the discrete-logarithm problem in a cyclic
group of order q=pein timeO(polylog(q)·√p). Given as input a gen-
eratorgof order q=peand a value h, we want to compute x= loggh.
(a) Show how to compute [ xmodp] in timeO(polylog(q)·√p).
Hint:Solve the equation
/parenleftBig
gpe−1/parenrightBigx0=hpe−1
and use the same ideas as in the Pohlig–Hellman algorithm.
(b) Sayx=x0+x1·p+···+xe−1·pe−1with 0≤xi< p. Inthe previous
step we determined x0. Show how to compute in polylog(q) time a
valueh1such that ( gp)x1+x2·p+···+xe−1·pe−2=h1.
(c) Use recursion to obtain the claimed running time for the original
problem. (Note that e=O(logq).)
9.5 Letqhave prime factorization q=/producttextk
i=1pei
i. Using the result from the
previous problem, show a modiﬁcation of the Pohlig–Hellman algorithm
that solves the discrete-logarithm problem in a group of order qin time
O/parenleftBig
polylog(q)·/summationtextk
i=1ei√pi/parenrightBig
=O/parenleftbig
polylog(q)·maxi{√pi}/parenrightbig
.
9.6Give pseudocode for the small-space algorithm for computing discrete
logarithms described in Section 9.2.3, and give a heuristic analysis of
the probability with which it succeeds.Chapter 10
Key Management and the
Public-Key Revolution
10.1 Key Distribution and Key Management
InChapters 1–7 we have seen how private-key cryptography can be used to
ensure secrecy and integrity for two parties communicating over an insecure
channel, assuming the two parties are in possession of a shared, secret key.
The question we have deferred since Chapter 1, however, is:
How can the parties share a secret key in the ﬁrst place?
Clearly, the key cannot simply be sent over the public communication channel
because an eavesdroppingadversarywould then be able to observeit en route.
Some other mechanism must be used instead.
In some situations, the parties may have access to a secure channel that
they can use to reliably share a secret key. One common example is when
the two parties are co-located at some time, at which point they can share a
key. Alternatively, the parties might be able to use a trusted courier service
as a secure channel. We stress that the fact that the parties can share a
key—and thus must have access to a secure channel at some point—does
notmake private-key cryptography useless: in the ﬁrst example, the parties
have a secure channel at one point in time but not indeﬁnitely; in the second
example, utilizing the secure channel might be slower and more costly than
communicating over an insecure channel.
The above approaches have been used to share keys in government, diplo-
matic, and military contexts. For example, the “red phone” connecting
Moscow and Washington in the 1960s was encrypted using a one-time pad,
with keys shared by couriers who ﬂew from one country to the other carrying
briefcases full of print-outs. Such approachescan alsobe used in corporations,
e.g., to set up a shared key between a central database and a new employee
on his/her ﬁrst day of work. (We return to this example in the next section.)
Relying on a secure channel to distribute keys, however, does not work well
in many other situations. For example, consider a large, multinational corpo-
rationin which every pair ofemployeesmight need the abilitytocommunicate
securely, with their communication protected from other employees as well.
359360 Introduction to Modern Cryptography
It will be inconvenient, to say the least, for each pair of employees to meet so
they can securely share a key; for employees working in diﬀerent cities, this
may even be impossible. Even if the current set of employees could somehow
share keys with each other, it would be impractical for them to share keys
with new employees who join after this initial sharing is done.
Assuming these Nemployees are somehow able to securely share keys with
each other, another signiﬁcant drawback is that each employee will have to
manage and store N−1 secret keys (one for each other employee). In fact,
this may signiﬁcantly under-count the number of keys stored by each user,
because employees may also need keys to communicate securely with remote
resources such as databases, servers, printers, and so on. The proliferation of
somanysecretkeysis asigniﬁcantlogisticalproblem. Moreover,allthese keys
must be stored securely. The more keys there are, the harder it is to protect
them, and the higher the chance of some keys being stolen by an attacker.
Computer systems are often infected by viruses, worms, and other forms of
malicious software which can steal secret keys and send them quietly over the
network to an attacker. Thus, storing keys on employees’ personal computers
is not always a safe solution.
To be clear, potential compromise of secret keys is always a concern, irre-
spective of the number of keys each party holds. When only a few keys need
to be stored, however, there are good solutions available for dealing with this
threat. A typical solution today is to store keys on secure hardware such as a
smartcard. A smartcard can carry out cryptographic computations using the
stored secret keys, ensuring that these keys never make their way onto users’
personal computers. If designed properly, the smartcard can be much more
resilient to attack than a personal computer—for example, it typically cannot
be infected by malware—andso oﬀersa good meansof protectingusers’ secret
keys. Unfortunately, smartcards are typically quite limited in memory and so
cannot store hundreds (or thousands) of keys.
The concerns outlined above can all be addressed—in principle, even if not
in practice—in “closed” organizations consisting of a well-deﬁned population
of users, all of whom are willing to follow the same policies for distributing
and storing keys. They break down, however, in “open systems” where users
have transient interactions, cannot arrange a physical meeting, and may not
even be aware of each other’s existence until the time they want to commu-
nicate. This is, in fact, a more common situation than one might at ﬁrst
realize: consider using encryption to send credit-card information to an In-
ternet merchant from whom you have not previously purchased anything, or
sending email to someone whom you have never met in person. In such cases,
private-key cryptography alone simply does not provide a solution, and we
must look further for adequate solutions.
To summarize, there are at least three distinct problems related to the use
of private-key cryptography. The ﬁrst is that of key distribution ; the second
is that of storing and managing large numbers of secret keys ; the third is the
inapplicability of private-key cryptography to open systems .Key Management and the Public-Key Revolution 361
10.2 A Partial Solution: Key-Distribution Centers
One way to address some of the concerns from the previous section is to
use akey-distribution center (KDC) to establish shared keys. Consider again
the case of a large corporation where all pairs of employees must be able to
communicate securely. In such a setting, we can leverage the fact that all
employees may trustsome entity—say, the system administrator—at least
with respect to the security of work-related information. This trusted entity
can then act as a KDC and help all the employees share pairwise keys.
When a new employee joins, the KDC can share a key with that employee
(in person, in a secure location) as part of that employee’s ﬁrst day of work.
At the same time, the KDC could also distribute shared keys between that
employeeandall existingemployees. That is, when the ith employeejoins, the
KDC could(in additiontosharingakeybetweenitselfand thisnew employee)
generate i−1 keysk1,...,k i−1, give these keys to the new employee, and then
send key kjto thejth existing employee by encrypting it using the key that
employee already shares with the KDC. Following this, the new employee
shares a key with every other employee (as well as with the KDC).
A better approach, which avoids requiring employees to store and manage
multiple keys, is to utilize the KDC in an onlinefashion to generate keys “on
demand” whenever two employees wish to communicate securely. As before,
the KDC will share a (diﬀerent) key with each employee, something that can
be done securely on an employee’s ﬁrst day of work. Say the KDC shares
keykAwith employee Alice, and kBwith employee Bob. At some later time,
when Alice wishes to communicate securely with Bob, she can simply send the
message‘‘I, Alice, want to talk to Bob’’ to the KDC. (If desired, this
message can be authenticated using the key shared by Alice and the KDC.)
The KDC then chooses a new, random key—called a session key —and sends
this key kto Alice encrypted using kA, and to Bob encrypted using kB.
(This protocol is too simplistic to be used in practice; see further discussion
below.) Once Alice and Bob both recover this session key, they can use it to
communicate securely. When they are done with their conversation, they can
(and should) erase the session key because they can always contact the KDC
again if they wish to communicate at some later time.
Consider the advantages of this approach:
1. Each employee needs to store only onelong-term secret key (namely,
the one they share with the KDC). Employees still need to manage and
store session keys, but these are short-term keys that are erased once a
communication session concludes.
The KDC needs to store many long-term keys. However, the KDC can
be kept in a secure location and be given the highest possible protection
against network attacks.362 Introduction to Modern Cryptography
2. When an employee joins the organization, all that must be done is to
set up a key between this employee and the KDC. No other employees
need to update the set of keys they hold.
Thus, KDCs can alleviate two of the problems we have seen with regard to
private-key cryptography: they can simplify key distribution (since only one
newkeymustbesharedwhenanemployeejoins, anditisreasonabletoassume
a secure channel between the KDC and that employee on their ﬁrst day of
work), and canreduce the complexity ofkey storage(since eachemployeeonly
needs to store a single key). KDCs go a long way toward making private-key
cryptography practical in large organizations where there is a single entity
who is trusted by everyone.
There are, however, some drawbacks to relying on KDCs:
1. A successful attack on the KDC will result in a complete break of the
system: anattackercancompromiseallkeysandsubsequentlyeavesdrop
on all network traﬃc. This makes the KDC a high-value target. Note
that even if the KDC is well-protected against external attacks, there is
always the possibility of insider attacks by employees who have access
to the KDC (for example, the IT manager).
2. The KDC is a single point of failure: if the KDC is down, secure com-
munication is temporarily impossible. If employees are constantly con-
tacting the KDC and asking for session keys to be established, the load
on the KDC can be very high, thereby increasing the chances that it
may fail or be slow to respond.
A simple solution to the second problem is to replicate the KDC. This works
(and is done in practice), but also means that there are now more points of
attack on the system. Adding more KDCs also makes it more diﬃcult to add
new employees, since updates must be securely propagated to every KDC.
Protocols for key distribution using a KDC. There are a number of pro-
tocols in the literature for secure key distribution using a KDC. We mention
in particular the Needham–Schroeder protocol , which forms the core of Ker-
beros, animportant andwidely used servicefor performingauthenticationand
supporting secure communication. (Kerberos is used in many universities and
corporations, and is the default mechanism for supporting secure networked
authentication and communication in Windows and many UNIX systems.)
We only highlight one feature of this protocol. When Alice contacts the KDC
and asks to communicate with Bob, the KDC does not send the encrypted
session key to both Alice and Bob as we have described earlier. Instead, the
KDC sends to Alice the session key encrypted under Alice’s key in addition
tothe session key encrypted under Bob’s key. Alice then forwards the sec-
ond ciphertext to Bob as in Figure 10.1. The second ciphertext is sometimes
called a ticket, and can be viewed as a credential that allows Alice to talk
to Bob (and allows Bob to be assured that he is talking to Alice). Indeed,Key Management and the Public-Key Revolution 363
/MT65/MT108/MT105/MT99/MT101/MT75/MT68/MT67
/MT66/MT111/MT98/MT69/MT110/MT99/MT107/MT66/MT40/MT107/MT41 /MT76/MT101/MT116/MT146/MT115/MT32/MT116/MT97/MT108/MT107/MT44/MT73/MT32/MT119/MT97/MT110/MT116/MT32/MT116/MT111/MT32/MT116/MT97/MT108/MT107/MT32/MT116/MT111/MT32/MT66/MT111/MT98 /MT69/MT110/MT99/MT107/MT65/MT40/MT107/MT41
/MT69/MT110/MT99/MT107/MT66/MT40/MT107/MT41
FIGURE 10.1 :Ageneral template for key-distribution protocols.
although we have not stressed this point in our discussion, a KDC-based ap-
proach can provide a useful means of performing authentication as well. Note
also that Alice and Bob need not both be users; Alice might be a user and
Bob a resource such as a server, a remote disk, or a printer.
The protocol was designed in this way to reduce the load on the KDC.
In the protocol as described, the KDC does not need to initiate a second
connection to Bob, and need not worry whether Bob is on-line when Alice
initiates the protocol. Moreover, if Alice retains the ticket (and her copy of
the session key), then she can re-initiate secure communication with Bob by
simply re-sending the ticket to Bob, without the involvement of the KDC at
all. (In practice, tickets expire and eventually need to be renewed. But a
session could be re-established within some acceptable time period.)
We conclude by noting that in practice the key that Alice shares with
the KDC might be a short, easy-to-memorize password. In this case, many
additional security problems arise that must be dealt with. We have also
been implicitly assuming an attacker who only passively eavesdrops, rather
than one who might actively try to interfere with the protocol. We refer
the interested reader to the references at the end of this chapter for more
information about how such issues can be addressed.
10.3 Key Exchange and the Diﬃe–Hellman Protocol
KDCs and protocols like Kerberos are commonly used in practice. But
these approaches to the key-distribution problem still require, at some point,
aprivateandauthenticated channel that can be used to share keys. (In
particular, we assumed the existence of such a channel between the KDC and
the employees on their ﬁrst day.) Thus, they still cannot solve the problem364 Introduction to Modern Cryptography
of key distribution in open systems like the Internet, where there may be no
private channel available between two users who wish to communicate.
To achieve private communication without ever communicating over a pri-
vate channel, a radically diﬀerent approach is needed. In 1976, Whitﬁeld
Diﬃe and Martin Hellman published a paper with the innocent-looking title
“New Directions in Cryptography.” In that work they observed that there
is oftenasymmetry in the world; in particular, there are certain actions that
can be easily performed but not easily reversed. For example, padlocks can
be locked without a key (i.e., easily), but then cannot be reopened. More
strikingly, it is easy to shatter a glass vase but extremely diﬃcult to put it
back together again. Algorithmically (and more germane for our purposes), it
is easy to multiply two large primes but diﬃcult to recover those primes from
their product. (This is exactly the factoring problem discussed in previous
chapters.) Diﬃe and Hellman realized that such phenomena could be used to
derive interactive protocols for secure key exchange that allow two parties to
share a secret key, via communication over a public channel, by having the
parties perform operations that they can reverse but that an eavesdropper
cannot.
The existence of secure key-exchange protocols is quite amazing. It means
that youand afriend could agreeon a secretby simply shouting acrossa room
(and performing some local computation); the secret would be unknown to
anyone else, even if they had listened to everything that was said. Indeed,
until 1976 it was generally believed that secure communication could not be
achievedwithout ﬁrstsharingsomesecretinformationusingaprivatechannel.
The inﬂuence of Diﬃe and Hellman’s paper was enormous. In addition to
introducing a fundamentally new way of looking at cryptography, it was one
of the ﬁrst steps toward moving cryptography out of the private domain and
into the public one. We quote the ﬁrst two paragraphs of their paper:
We stand today on the brink of a revolution in cryptography. The
development of cheap digital hardware has freed it from the design
limitations of mechanical computing and brought the cost of high
grade cryptographic devices down to where they can be used in such
commercial applications as remote cash dispensers and computer
terminals.
In turn, such applications create a need for new types of crypto-
graphic systems which minimize the necessity of secure key distri-
bution channels. ...At the same time, theoretical developments in
information theory and computer science show promise of provid-
ing provably secure cryptosystems, changing this ancient art into
a science.
Diﬃe and Hellman were not exaggerating, and the revolution they spoke of
was due in great part to their work.
In this section we present the Diﬃe–Hellman key-exchange protocol. We
prove its security against eavesdropping adversaries or, equivalently, underKey Management and the Public-Key Revolution 365
the assumption that the parties communicate over a public but authenticated
channel (so an attacker cannot interfere with their communication). Secu-
rity against an eavesdropping adversary is a relatively weak guarantee, and
in practice key-exchange protocols must satisfy stronger notions of security
that are beyond our present scope. (Moreover, we are interested here in the
setting where the communicating parties have noprior shared information,
in which case there is nothing that can be done to prevent an adversary from
impersonating one of the parties. We return to this point later.)
The setting and deﬁnition of security. We consider a setting with two
parties—traditionally called Alice and Bob—who run a probabilistic protocol
Π in order to generate a shared, secret key; Π can be viewed as the set of
instructionsfor Alice andBobin the protocol. Aliceand Bobbegin byholding
the security parameter 1n; they then run Π using (independent) random bits.
At the end of the protocol, Alice and Bob output keys kA,kB∈ {0,1}n,
respectively. The basic correctness requirement is that kA=kB. Since we
willonlydealwithprotocolsthatsatisfythisrequirement,wewillspeaksimply
ofthekeyk=kA=kBgenerated by an honest execution of Π.
We now turn to deﬁning security. Intuitively, a key-exchange protocol is
secure if the key output by Alice and Bob is completely unguessable by an
eavesdropping adversary. This is formally deﬁned by requiring that an ad-
versary who has eavesdropped on an execution of the protocol should be
unable to distinguish the key kgenerated by that execution (and now shared
by Alice and Bob) from a uniform key of length n. This is much stronger
than simply requiring that the adversary be unable to compute kexactly, and
this strongernotion is necessaryif the parties will subsequently use kfor some
cryptographic application (e.g., as a key for a private-key encryption scheme).
Formalizing the above, let Π be a key-exchange protocol, Aan adversary,
andnthe security parameter. We have the following experiment:
The key-exchange experiment KEeav
A,Π(n):
1. Two parties holding 1nexecute protocol Π. This results in a
transcript transcontaining all the messages sent by the par-
ties, and a key koutput by each of the parties.
2. A uniform bit b∈{0,1}is chosen. If b= 0setˆk:=k, and
ifb= 1then choose ˆk∈{0,1}nuniformly at random.
3.Ais giventransandˆk, and outputs a bit b/prime.
4. The output of the experiment is deﬁned to be 1ifb/prime=b, and
0otherwise. (In caseKEeav
A,Π(n) = 1, we say thatAsucceeds.)
Ais giventransto capture the fact that Aeavesdrops on the entire execution
oftheprotocolandthus seesallmessagesexchangedbythe parties. Inthe real
world,Awould not be given any key; in the experiment the adversaryis given
ˆkonly asa means ofdeﬁning what it means for Ato “break”the securityofΠ.366 Introduction to Modern Cryptography
That is, the adversary succeeds in “breaking” Π if it can correctly determine
whether the key ˆkis the real key corresponding to the given execution of the
protocol, or whether ˆkis a uniform key that is independent of the transcript.
As expected, we say Π is secure if the adversary succeeds with probability
that is at most negligibly greater than 1 /2. That is:
DEFINITION 10.1 A key-exchange protocol Πissecure in the presence
of an eavesdropper if for all probabilistic polynomial-time adversaries Athere
is a negligible function neglsuch that
Pr/bracketleftbig
KEeav
A,Π(n) = 1/bracketrightbig
≤1
2+negl(n).
The aim of a key-exchange protocol is almost always to generate a shared
keykthat will be used by the parties for some further cryptographic purpose,
e.g., to encrypt and authenticate their subsequent communication using, say,
an authenticated encryption scheme. Intuitively, using a sharedkey generated
by a secure key-exchange protocol should be “as good as” using a key shared
over a private channel. It is possible to prove this formally; see Exercise 10.1.
The Diﬃe–Hellman key-exchange protocol. We now describe the key-
exchange protocol that appeared in the original paper by Diﬃe and Hellman
(although they were less formal than we will be here). Let Gbe a probabilis-
tic polynomial-time algorithm that, on input 1n, outputs a description of a
cyclic group G, its order q(with/bardblq/bardbl=n), and a generator g∈G. (See Sec-
tion 8.3.2.) The Diﬃe–Hellman key-exchange protocol is described formally
as Construction 10.2 and illustrated in Figure 10.2.
CONSTRUCTION 10.2
•Common input: The security parameter 1n
•The protocol:
1. Alice runsG(1n) to obtain ( G,q,g).
2. Alice chooses a uniform x∈Zq, and computes hA:=gx.
3. Alice sends ( G,q,g,h A) to Bob.
4. Bob receives ( G,q,g,h A). He chooses a uniform y∈Zq, and
computes hB:=gy. Bob sends hBto Alice and outputs the
keykB:=hy
A.
5. Alice receives hBand outputs the key kA:=hx
B.
The Diﬃe–Hellman key-exchange protocol.Key Management and the Public-Key Revolution 367
/MT65/MT108/MT105/MT99/MT101 /MT66/MT111/MT98
/MT120
/MT104/MT65/MT58/MT61/MT103/MT120
/MT104/MT66
/MT107/MT65/MT104/MT120
/MT66/MT113
/MT44/MT32/MT113/MT44/MT32/MT103/MT44/MT32/MT104/MT65
/MT58/MT61 /MT58/MT61 /MT107/MT66/MT104/MT121
/MT65/MT104/MT66/MT58/MT61/MT103/MT121/MT121 /MT113
FIGURE 10.2 :The Diﬃe–Hellman key-exchange protocol.
In our description, we haveassumed that Alice generates( G,q,g) and sends
these parameters to Bob as part of her ﬁrst message. In practice, these pa-
rameters are standardized and are ﬁxed and known to both parties before the
protocol begins. In that case Alice need only send hA, and Bob need not wait
to receive Alice’s message before computing and sending hB.
It is not hard to see that the protocol is correct: Bob computes the key
kB=hy
A= (gx)y=gxy
and Alice computes the key
kA=hx
B= (gy)x=gxy,
and sokA=kB. (The observant reader will note that the shared key is a
group element, not a bit-string. We will return to this point later.)
Diﬃe and Hellman did not prove security of their protocol; indeed, the
appropriate notions (both the deﬁnitional framework as well as the idea of
formulating precise assumptions) were not yet in place. Let us see what
sort of assumption will be needed in order for the protocol to be secure. A
ﬁrst observation, made by Diﬃe and Hellman, is that a minimal require-
ment for security here is that the discrete-logarithm problem be hard relative
toG. If not, then an adversary given the transcript (which, in particular,
includes hA) can compute the secret value of one of the parties (i.e., x) and
then easily compute the shared key using that value. So, hardness of the
discrete-logarithm problem is necessary for the protocol to be secure. It is
not, however, suﬃcient, as it is possible that there are other ways of comput-
ing the key kA=kBwithout explicitly computing xory. Thecomputational
Diﬃe–Hellman assumption—which would only guarantee that the key gxyis368 Introduction to Modern Cryptography
hard to compute in its entirety from the transcript—does not suﬃce either.
What is required by Deﬁnition 10.1 is that the shared key gxyshould be in-
distinguishable from uniform for any adversary given g,gx, andgy. This is
exactly the decisional Diﬃe–Hellman assumption introduced in Section 8.3.2.
As we will see, a proof of security for the protocol follows almost immedi-
ately from the decisional Diﬃe–Hellman assumption. This should not be sur-
prising, as the Diﬃe–Hellman assumptions were introduced—well after Diﬃe
and Hellman published their paper—as a way of abstracting the properties
underlying the (conjectured) security of the Diﬃe–Hellman protocol. Given
this, it is fair to ask whether anything is gained by deﬁning and proving secu-
rity here. By this point in the book, hopefully you are convinced the answer
isyes. Precisely deﬁning secure key exchange forces us to think about exactly
what security properties we require; specifying a precise assumption (namely,
the decisional Diﬃe–Hellman assumption) means we can study this assump-
tion independently of any particular application and—once we are convinced
of its plausibility—construct other protocols based on it; ﬁnally, proving secu-
rity shows that the assumption does, indeed, suﬃce for the protocol to meet
our desired notion of security.
Inourproofofsecurity, weuseamodiﬁed versionofDeﬁnition 10.1in which
it is required that the shared key be indistinguishable from a uniform element
ofGrather than from a uniform n-bit string . This discrepancy will need
to be addressed before the protocol can be used in practice—after all, group
elements arenot typicallyuseful ascryptographickeys, and the representation
of a uniform group element will not, in general, be a uniform bit-string—and
we brieﬂy discuss one standard way to do so following the proof. For now, we
let/hatwiderKEeav
A,Π(n) denote a modiﬁed experiment where if b= 1 the adversary is
givenˆkchosen uniformly from Ginstead of a uniform n-bit string.
THEOREM 10.3 If the decisional Diﬃe–Hellman problem is hard rela-
tive toG, then the Diﬃe–Hellman key-exchange protocol Πis secure in the
presence of an eavesdropper (with respect to the modiﬁed experiment /hatwiderKEeav
A,Π).
PROOF LetAbe apptadversary. Since Pr[ b= 0] = Pr[ b= 1] = 1/2, we
have
Pr/bracketleftBig
/hatwiderKEeav
A,Π(n) = 1/bracketrightBig
=1
2·Pr/bracketleftBig
/hatwiderKEeav
A,Π(n) = 1|b= 0/bracketrightBig
+1
2·Pr/bracketleftBig
/hatwiderKEeav
A,Π(n) = 1|b= 1/bracketrightBig
.
In experiment /hatwiderKEeav
A,Π(n) the adversaryAreceives ( G,q,g,h A,hB,ˆk), where
(G,q,g,h A,hB) represents the transcript of the protocol execution, and ˆk
is either the actual key computed by the parties (if b= 0) or a uniform
group element (if b= 1). Distinguishing between these two cases is exactlyKey Management and the Public-Key Revolution 369
equivalent to solving the decisional Diﬃe–Hellman problem. That is
Pr/bracketleftBig
/hatwiderKEeav
A,Π(n) = 1/bracketrightBig
=1
2·Pr/bracketleftBig
/hatwiderKEeav
A,Π(n) = 1|b= 0/bracketrightBig
+1
2·Pr/bracketleftBig
/hatwiderKEeav
A,Π(n) = 1|b= 1/bracketrightBig
=1
2·Pr[A(G,g,q,gx,gy,gxy) = 0]+1
2·Pr[A(G,q,g,gx,gy,gz) = 1]
=1
2·/parenleftBig
1−Pr[A(G,g,q,gx,gy,gxy) = 1]/parenrightBig
+1
2·Pr[A(G,q,g,gx,gy,gz) = 1]
=1
2+1
2·/parenleftBig
Pr[A(G,g,q,gx,gy,gz) = 1]−Pr[A(G,q,g,gx,gy,gxy) = 1]/parenrightBig
≤1
2+1
2·/vextendsingle/vextendsingle/vextendsinglePr[A(G,g,q,gx,gy,gz) = 1]−Pr[A(G,q,g,gx,gy,gxy) = 1]/vextendsingle/vextendsingle/vextendsingle,
where the probabilities are all taken over ( G,q,g) output byG(1n), and uni-
form choice of x,y,z∈Zq. (Note that since gis a generator, gzis a uniform
element of Gwhenzis uniformly distributed in Zq.) If the decisional Diﬃe–
Hellman assumption is hard relative to G, that exactly means that there is a
negligible function neglfor which
/vextendsingle/vextendsinglePr[A(G,g,q,gx,gy,gz) = 1]−Pr[A(G,q,g,gx,gy,gxy) = 1]/vextendsingle/vextendsingle≤negl(n).
We conclude that
Pr/bracketleftBig
/hatwiderKEeav
A,Π(n) = 1/bracketrightBig
≤1
2+1
2·negl(n),
completing the proof.
Uniform group elements vs. uniform bit-strings. The previoustheorem
shows that the key output by Alice and Bob in the Diﬃe–Hellman protocol is
indistinguishable (for a polynomial-time eavesdropper) from a uniform group
element. Inordertousethekeyforsubsequentcryptographicapplications—as
well as to meet Deﬁnition 10.1—the key output by the parties should instead
be indistinguishable from a uniform bit-string of the appropriate length. The
Diﬃe–Hellman protocol can be modiﬁed to achieve this by having the parties
apply an appropriate key-derivation function (cf. Section 5.6.4) to the shared
group element gxythey each compute.
Active adversaries. So far we have considered only an eavesdropping ad-
versary. Although eavesdropping attacks are by far the most common (as
they are the easiest to carry out), they are by no means the only possible at-
tack.Activeattacks, in which the adversary sends messages of its own to one
or both of the parties, are also a concern, and any protocol used in practice
must be resilient to such attacks as well. When considering active attacks,
it is useful to distinguish, informally, between impersonation attacks where370 Introduction to Modern Cryptography
the adversary impersonates one party while interacting with the other party,
andman-in-the-middle attacks where both honest parties are executing the
protocol and the adversary is intercepting and modifying messages being sent
from one party to the other. We will not formally deﬁne security against
either class of attacks, as such deﬁnitions are rather involved and cannot be
achieved without the parties sharing someinformation in advance. Never-
theless, it is worth remarking that the Diﬃe–Hellman protocol is completely
insecure against man-in-the-middle attacks. In fact, a man-in-the-middle ad-
versary can act in such a way that Alice and Bob terminate the protocol with
diﬀerent keys kAandkBthat are both known to the adversary, yet neither
Alice nor Bob can detect that any attack was carriedout. We leave the details
of this attack as an exercise.
Diﬃe–Hellman key exchange in practice. The Diﬃe–Hellman protocol
in its basic form is typically not used in practice due to its insecurity against
man-in-the-middle attacks, as discussed above. This does not detract in any
way from its importance. The Diﬃe–Hellman protocol served as the ﬁrst
demonstration that asymmetric techniques (and number-theoretic problems)
could be used to alleviate the problems of key distribution in cryptography.
Furthermore, the Diﬃe–Hellman protocol is at the core of standardized key-
exchange protocols that are resilient to man-in-the-middle attacks and are in
wide use today. One notable example is TLS; see Section 12.8.
10.4 The Public-Key Revolution
Inaddition to key exchange, Diﬃe and Hellman also introduced in their
ground-breaking work the notion of public-key (orasymmetric ) cryptography.
Inthepublic-keysetting(incontrasttotheprivate-keysettingwehavestudied
in Chapters 1–7), a party who wishes to communicate securely generates a
pairof keys: a public key that is widely disseminated, and a private key
that it keeps secret. (The fact that there are now two diﬀerent keys is what
makes the scheme asymmetric.) Having generated these keys, a party can use
them to ensure secrecy for messages it receives using a public-key encryption
scheme, or integrity for messages it sends using a digital signature scheme .
(See Figure 10.3.) We provide a brief taste of these primitives here, and
discuss them in extensive detail in Chapters 11 and 12, respectively.
In a public-key encryption scheme, the public key generated by some party
serves as an encryption key ; anyone who knows that public key can use it
to encrypt messages and generate corresponding ciphertexts. The private
key serves as a decryption key and is used by the party who knows it to
recovertheoriginalmessagefromanyciphertextgeneratedusingthematching
public key. Furthermore—and it is amazing that something like this exists!—Key Management and the Public-Key Revolution 371
Private-Key Setting Public-Key Setting
Secrecy Private-key encryption Public-key encryption
Integrity Message authentication codes Digital signature schemes
FIGURE 10.3 :Cryptographic primitives in the private-key and the
public-key settings.
the secrecy of encrypted messages is preserved even against an adversary
who knows the encryption key (but not the decryption key). In other words,
the (public) encryption key is of no use for an attacker trying to decrypt
ciphertexts encrypted using that key. To enable secret communication, then,
areceivercansimply sendherpublic keytoapotentialsender(without having
to worry about an eavesdropping adversary who observes her public key), or
publicize herpublickeyonherwebpageorin somecentraldatabase. A public-
key encryption scheme thus enables private communication without relying
on a private channel for key distribution.1
A digital signature scheme is a public-key analogue of message authentica-
tion codes (MACs). Here, the private key serves as an “authentication key”
(more typically called a signing key ) that enables the party who knows this
key to generate “authentication tags” (i.e., signatures ) for messages it sends.
The public key acts as a veriﬁcation key , allowing anyone who knows it to
verify signatures issued by the sender. As with MACs, a digital signature
scheme can be used to prevent undetected tampering of a message. The fact
that veriﬁcation can be done by anyone who knows the public key of the
sender, however, turns out to have far-reaching ramiﬁcations. Speciﬁcally, it
makes it possible to take a document that was signed by Alice and present
it to a third party (say, a judge) as proof that Alice indeed signed the docu-
ment. This property is called non-repudiation and has extensive applications
in electronic commerce. For example, it is possible to digitally sign contracts,
send signed electronic purchase orders or promises of payments, and so on.
Digital signatures are also used for the secure distribution of public keys as
part of a public-key infrastructure , as discussed in more detail in Section 12.7.
In their paper, Diﬃe and Hellman set forth the notion of public-key cryp-
tography but did not give any candidate constructions, A year later, Ron
Rivest, Adi Shamir, and Len Adleman proposed the RSA problem and pre-
sented the ﬁrst public-key encryption and digital signature schemes based on
the hardness of this problem. Variants of their schemes are now among the
most widely used cryptographic primitives today. In 1985, Taher El Gamal
presented an encryption scheme that is essentially a slight twist on the Diﬃe–
Hellman key-exchange protocol, and is now also widely used. Thus, although
1For now, however, we do assume an authenticated channel that allows the sender to obtain
a legitimate copy of the receiver’s public key. In Section 12.7 we show how public-key
cryptography can be used to reduce this assumption as well.372 Introduction to Modern Cryptography
Diﬃe and Hellman did not succeed in constructing a (non-interactive) public-
key encryption scheme, they came very close.
We close by summarizing how public-key cryptography addresses the limi-
tations of the private-key setting discussed in Section 10.1:
1. Public-key encryption allows key distribution to be done over public
(but authenticated) channels. This can simplify the distribution and
updating of key material.
2. Public-key cryptographyreduces the need for users to store many secret
keys. Consideragainthesettingofalargecorporationwhereeachpairof
employees needs the ability to communicate securely. Using public-key
cryptography, it suﬃces for each employee to store just a singleprivate
key (their own) and the public keys of all other employees. Importantly,
these latter keys do notneed to be stored in secret; they could even be
stored in some central (public) repository.
3. Finally, public-key cryptography is (more) suitable for open environ-
ments where parties who have never previouslyinteracted want the abil-
ity to communicate securely. As one commonplace example, an Internet
merchant can post their public key on-line; a user making a purchase
can then obtain the merchant’s public key, as needed, when they need
to encrypt their credit card information.
The invention of public-key encryption was a revolution in cryptography.
It is no coincidence that until the late 1970s and early 1980s, encryption and
cryptography in general belonged to the domain of intelligence and military
organizations, and only with the advent of public-key techniques did the use
of cryptography spread to the masses.
References and Additional Reading
Wehave only brieﬂy discussed the problems of key distribution and key
management. For more information, we recommend looking at textbooks on
network security. Kaufman et al. [102] provide a good treatment of protocols
for secure key distribution, what they aim to achieve, and how they work.
We have not made any attempt to capture the full history of the devel-
opment of public-key cryptography. Others besides Diﬃe and Hellman were
working on similar ideas in the 1970s. One researcher in particular doing
similar and independent work was Ralph Merkle, considered by many to be a
co-inventorofpublic-key cryptography(although he published after Diﬃe and
Hellman). We also mention Michael Rabin, who developed constructions of
signatureschemesandpublic-keyencryptionschemesbasedonthehardnessof
factoring about one yearafter the work of Rivest, Shamir, and Adleman [148].Key Management and the Public-Key Revolution 373
We highly recommend reading the original paper by Diﬃe and Hellman [58],
and refer the reader to the book by Levy [114] for more on the political and
historical aspects of the public-key revolution.
Interestingly, aspects of public-key cryptography were discovered in the in-
telligence community before being published in the open scientiﬁc literature.
In the early 1970s, James Ellis, Cliﬀord Cocks, and Malcolm Williamson of
the British intelligence agency GCHQ invented the notion of public-key cryp-
tography, a variant of RSA encryption, and a variant of the Diﬃe–Hellman
key-exchange protocol. Their work was not declassiﬁed until 1997. Although
the underlying mathematics of public-key cryptography may have been dis-
covered before 1976, it is fair to say that the widespread ramiﬁcations of this
new technology were not appreciated until Diﬃe and Hellman came along.
Exercises
10.1 Let Π be a key-exchange protocol, and ( Enc,Dec) be a private-key en-
cryption scheme. Consider the following interactive protocol Π/primefor en-
crypting a message: ﬁrst, the sender and receiver run Π to generate a
shared key k. Next, the sender computes c←Enck(m) and sends cto
the other party, who decrypts and recovers musingk.
(a) Formulate a deﬁnition of indistinguishable encryptions in the pres-
ence of an eavesdropper (cf. Deﬁnition 3.8) appropriate for this
interactive setting.
(b) Prove that if Π is secure in the presence of an eavesdropper and
(Enc,Dec) has indistinguishable encryptions in the presence of an
eavesdropper, then Π/primesatisﬁes your deﬁnition.
10.2 Show that, for either of the groups considered in Sections 8.3.3 or 8.3.4,
a uniform group element (expressed using the natural representation) is
easily distinguishable from a uniform bit-string of the same length.
10.3 Describe a man-in-the-middle attack on the Diﬃe–Hellman protocol
where the adversary shares a key kAwith Alice and a (diﬀerent) key
kBwith Bob, and Alice and Bob cannot detect that anything is wrong.
10.4 Consider the following key-exchange protocol:
(a) Alice chooses uniform k,r∈{0,1}n, and sends s:=k⊕rto Bob.
(b) Bob chooses uniform t∈{0,1}n, and sends u:=s⊕tto Alice.
(c) Alice computes w:=u⊕rand sends wto Bob.
(d) Alice outputs kand Bob outputs w⊕t.
Show that Alice and Bob output the same key. Analyze the security of
the scheme (i.e., either prove its security or show a concrete attack).Chapter 11
Public-Key Encryption
11.1 Public-Key Encryption – An Overview
Theintroductionofpublic-keyencryptionmarkedarevolutionincryptogra-
phy. Until that time, cryptographers had relied exclusively on shared, secret
keys to achieve private communication. Public-key techniques, in contrast,
enable parties to communicate privately without having agreed on anysecret
information in advance. As we have already noted, it is quite amazing and
counterintuitive that this is possible: it means that two people on opposite
sides of a room who can only communicate by shouting to each other, and
have no initial secret, can talk in such a way that no one else in the room
learns anything about what they are saying!
In the setting of private-key encryption, two parties agree on a secret key
that can be used, by either party, for both encryption and decryption. Public-
key encryption is asymmetric in both these respects. One party (the receiver)
generates a pairof keys ( pk,sk), called the public key and the private key ,
respectively. The public key is used by a senderto encrypt a message; the
receiver uses the private key to decrypt the resulting ciphertext.
Since the goal is to avoid the need for two parties to meet in advance to
agree on any information, how does the sender learn pk? At an abstract level,
there are two ways this can occur. Call the receiver Alice and the sender
Bob. In the ﬁrst approach, when Alice learns that Bob wants to communicate
with her, she can at that point generate ( pk,sk) (assuming she hasn’t done so
already) and then send pkto Bobin the clear ; Bob can then use pkto encrypt
his message. We emphasize that the channel between Alice and Bob may be
public, butisassumedtobeauthenticated, meaningthattheadversarycannot
modify the public key sent by Alice to Bob (and, in particular, cannot replace
it with its own key). See Section 12.7 for a discussion of how public keys can
be distributed over unauthenticated channels.
AnalternativeapproachisforAlicetogenerateherkeys( pk,sk)inadvance,
independently of any particular sender. (In fact, at the time of key generation
Alice need not even be aware that Bob wants to talk to her, or even that Bob
exists.) Alice can widely disseminate her public key pkby, say, publishing
it on her webpage, putting it on her business cards, or placing it in a public
directory. Now, anyonewho wishes to communicate privately with Alice can
375376 Introduction to Modern Cryptography
look up her public key and proceed as above. Note that multiple senders
can communicate multiple times with Alice using the same public key pkfor
encrypting all their communication.
Note that pkis inherently public—and can thus be learned easily by an
attacker—in either of the above scenarios. In the ﬁrst case, an adversary
eavesdropping on the communication between Alice and Bob obtains pkdi-
rectly; inthesecondcase,anadversarycouldjustaswelllookupAlice’spublic
key on its own. We see that the security of public-key encryption cannot rely
on secrecy of pk, but must instead rely on secrecy of sk. It is therefore crucial
that Alice not reveal her private key to anyone, including the sender Bob.
Comparison to Private-Key Encryption
Perhaps the most obvious diﬀerence between private- and public-key en-
cryption is that the former assumes complete secrecy of all cryptographic
keys, whereas the latter requires secrecy for only the private key sk. Al-
though this may seem like a minor distinction, the ramiﬁcations are huge: in
the private-key setting the communicating parties must somehow be able to
share the secret key without allowing any third party to learn it, whereas in
the public-key setting the public key can be sent from one party to the other
over a public channel without compromising security. For parties shouting
across a room or, more realistically, communicating over a public network like
a phone line or the Internet, public-key encryption is the only option.
Another important distinction is that private-key encryption schemes use
the same key for both encryption and decryption, whereas public-key encryp-
tion schemes use diﬀerent keys for each operation. That is, public-key en-
cryption is inherently asymmetric . This asymmetry in the public-key setting
means that the roles of sender and receiver are notinterchangeable as they
are in the private-key setting: a single key-pair allows communication in one
direction only. (Bidirectional communication can be achieved in a number of
ways; the point is that a single invocation of a public-key encryption scheme
forces a distinction between one user who acts as a receiver and other users
who act as senders.) In addition, a single instance of a public-key encryption
scheme enables multiple senders to communicate privately with a single re-
ceiver, in contrast to the private-key case where a secret key shared between
two parties enables private communication only between those two parties.
Summarizing and elaborating the preceding discussion, we see that public-
keyencryptionhasthefollowingadvantagesrelativetoprivate-keyencryption:
•Public-key encryption addresses (to some extent) the key-distribution
problem, since communicating parties do not need to secretly share a
key in advance of their communication. Two parties can communicate
secretly even if allcommunication between them is monitored.
•When asinglereceiveriscommunicatingwith Nsenders(e.g., anon-line
merchant processing credit card orders from multiple purchasers), it isPublic-Key Encryption 377
much more convenient for the receiver to store a singleprivate key sk
rather than to share, store, and manage Ndiﬀerent secret keys (i.e., one
for each sender). In fact, when using public-key encryption the number
and identities of potential senders need not be known at the time of key
generation. This allows enormous ﬂexibility in “open systems.”
The fact that public-key encryption schemesallow anyoneto act as a sender
can be a drawback when a receiver only wants to receive messages from one
speciﬁc individual. In that case, an authenticated (private-key) encryption
scheme would be a better choice than public-key encryption.
The main disadvantage of public-key encryption is that it is roughly 2 to 3
orders of magnitude slowerthanprivate-keyencryption.1Itcanbeachallenge
to implement public-key encryption in severely resource-constrained devices
like smartcards or radio-frequency identiﬁcation (RFID) tags. Even when a
desktop computer is performing cryptographic operations, carrying out thou-
sands of such operations per second (as in the case of an on-line merchant
processing credit card transactions) may be prohibitive. Thus, when private-
key encryption is an option (i.e., if two parties cansecurely share a key in
advance), then it typically should be used.
In fact, as we will see in Section 11.3, private-key encryption is used in the
public-key setting to improve eﬃciency for the (public-key) encryption of long
messages. A thorough understanding of private-key encryption is therefore
crucial to appreciate how public-key encryption is implemented in practice.
Secure Distribution of Public Keys
In our entire discussion thus far, we have implicitly assumed that the ad-
versary is passive; that is, the adversary only eavesdrops on communication
between the sender and receiver but does not activelyinterfere with the com-
munication. Iftheadversaryhastheabilitytotamperwith allcommunication
between the honest parties, and these honest parties share no keys in advance,
then privacy simply cannot be achieved. For example, if a receiver Alice sends
her public key pkto Bob but the adversary replaces it with a key pk/primeof his
own (for which it knows the matching private key sk/prime), then even though Bob
encrypts his message using pk/primethe adversary will easily be able to recover the
message (using sk/prime). A similar attack works if an adversary is able to change
the value of Alice’s public key that is stored in some public directory, or if
the adversary can tamper with the public key as it is transmitted from the
public directory to Bob. If Alice and Bob do not share any information in
advance, and are not willing to rely on some mutually trusted third party,
there is nothing Alice or Bob can do to prevent active attacks of this sort, or
1Itis diﬃcult to give an exact comparison since the relative eﬃciency depends on the exact
schemes under consideration as well as various implementation details.378 Introduction to Modern Cryptography
even to tell that such an attack is taking place.2
Importantly, ourtreatmentofpublic-keyencryptionin thischapter assumes
that senders are able to obtain a legitimate copy of the receiver’s public key .
(This will be implicit in the security deﬁnitions we provide.) That is, we
assumesecure key distribution . This assumption is made not because active
attacks of the type discussed above are of no concern—in fact, they repre-
sent a serious threat that must be dealt with in any real-world system that
uses public-key encryption. Rather, this assumption is made because there
exist other mechanisms for preventing active attacks (see, for example, Sec-
tion 12.7), and it is therefore convenient (and useful) to decouple the study of
secure public-key encryption from the study of secure public-key distribution.
11.2 Deﬁnitions
Webegin by deﬁning the syntax of public-key encryption. The deﬁnition
is very similar to Deﬁnition 3.7, with the exception that instead of working
with just one key, we now have distinct encryption and decryption keys.
DEFINITION 11.1 Apublic-key encryption scheme is a triple of proba-
bilistic polynomial-time algorithms (Gen,Enc,Dec)such that:
1. Thekey-generation algorithm Gen takes as input the security parameter
1nand outputs a pair of keys (pk,sk). We refer to the ﬁrst of these
as thepublic key and the second as the private key . We assume for
convenience that pkandskeach has length at least n, and that ncan
be determined from pk,sk.
2. Theencryption algorithm Enc takes as input a public key pkand a mes-
sagemfrom some message space (that may depend on pk). It outputs a
ciphertext c, and we write this as c←Encpk(m). (Looking ahead, Enc
will need to be probabilistic to achieve meaningful security.)
3. The deterministic decryption algorithm Dec takes as input a private key
skand a ciphertext c, and outputs a message mor a special symbol ⊥
denoting failure. We write this as m:=Decsk(c).
It is required that, except possibly with negligible probability over (pk,sk)out-
put byGen(1n), we have Decsk(Encpk(m)) =mfor any (legal) message m.
The important diﬀerence from the private-key setting is that the key-
generation algorithm Gennow outputs twokeys instead of one. The public
2Inour “shouting-across-a-room” scenario, Alice and Bob can detect when an adversary in-
terferes with the communication. But this is only because: (1) the adversary cannot prevent
Alice’s messages from reaching Bob, and (2) Alice and Bob “share” in advance information
(e.g., the sound of their voices) that allows them to “authenticate” their communication.Public-Key Encryption 379
keypkis used for encryption, while the private key skis used for decryption.
Reiterating our earlier discussion, pkis assumed to be widely distributed so
that anyone can encrypt messages for the party who generated this key, but
skmust be kept private by the receiver in order for security to possibly hold.
Weallowforanegligibleprobabilityofdecryptionerrorand, indeed, someof
the schemes we present will have a negligible error probability (e.g., if a prime
needs to be chosen but with negligible probability a composite is obtained
instead). Despite this, we will generally ignore the issue from here on.
Forpracticalusageofpublic-keyencryption, wewillwantthe messagespace
to be{0,1}nor{0,1}∗(and, in particular, to be independent of the public
key). Although we will sometimes describe encryption schemes using some
message spaceMthat does not contain all bit-strings of some ﬁxed length
(and that may also depend on the public key), we will in such cases also
specify how to encode bit-strings as elements of M. This encoding must
be both eﬃciently computable and eﬃciently reversible, so the receiver can
recover the bit-string that was encrypted.
11.2.1 Security against Chosen-Plaintext Attacks
We initiate our treatment of security by introducing the “natural” coun-
terpart of Deﬁnition 3.8 in the public-key setting. Since extensive motivation
for this deﬁnition (as well as the others we will see) has already been given in
Chapter 3, the discussion here will be relatively brief and will focus primarily
on the diﬀerences between the private-key and the public-key settings.
Givenapublic-keyencryptionschemeΠ = ( Gen,Enc,Dec) andanadversary
A, consider the following experiment:
The eavesdropping indistinguishabilityexperiment PubKeav
A,Π(n):
1.Gen(1n)is run to obtain keys (pk,sk).
2. AdversaryAis given pk, and outputs a pair of equal-length
messages m0,m1in the message space.
3. A uniform bit b∈ {0,1}is chosen, and then a ciphertext
c←Encpk(mb)is computed and given to A. We call cthe
challenge ciphertext .
4.Aoutputs a bit b/prime. The output of the experiment is 1ifb/prime=b,
and0otherwise. If b/prime=bwe say thatAsucceeds.
DEFINITION 11.2 A public-key encryption scheme Π = (Gen,Enc,Dec)
hasindistinguishable encryptions in the presence of an eavesdropper if for all
probabilistic polynomial-time adversaries Athere is a negligible function negl
such that
Pr[PubKeav
A,Π(n) = 1]≤1
2+negl(n).380 Introduction to Modern Cryptography
The main diﬀerence between the above deﬁnition and Deﬁnition 3.8 is that
hereAis given the public key pk. Furthermore, we allow Ato choose its
messages m0andm1based on this public key. This is essential when deﬁning
security of public-key encryption since, as discussed previously, we assume
that the adversary knows the public key of the recipient.
The seemingly “minor” modiﬁcation of giving the adversary Athe public
keypkbeing used to encrypt the message has a tremendous impact: it ef-
fectively givesAaccess to an encryption oracle for free. (The concept of an
encryption oracle is explained in Section 3.4.2.) This is true because the ad-
versary, given pk, can encrypt any message mon its own by simply computing
Encpk(m). (As always,Ais assumed to know the algorithm Enc.) The up-
shot is that Deﬁnition 11.2 is equivalent to CPA-security (i.e., security against
chosen-plaintext attacks), deﬁned in a manner analogous to Deﬁnition 3.22,
with the only diﬀerence being that the attacker is given the public key in the
corresponding experiment. We thus have:
PROPOSITION 11.3 If a public-key encryption scheme has indistin-
guishable encryptions in the presence of an eavesdropper, it is CPA-secure.
This is in contrast to the private-key setting, where there exist schemes
that haveindistinguishable encryptionsin the presenceofaneavesdropperbut
are insecure under a chosen-plaintext attack (see Proposition 3.20). Further
diﬀerences from the private-key setting that follow almost immediately as
consequences of the above are discussed next.
Impossibility of perfectly secret public-key encryption. Perfectly se-
cretpublic-key encryption could be deﬁned analogously to Deﬁnition 2.3 by
conditioning on the entire view of an eavesdropper (i.e., including the public
key). Equivalently, it could be deﬁned by extending Deﬁnition 11.2 to require
that foralladversariesA(not only eﬃcient ones), we have:
Pr[PubKeav
A,Π(n) = 1] =1
2.
Incontrast to the private-key setting, however, perfectly secret public-key
encryption is impossible , regardless of how long the keys are or how small the
messagespace is. In fact, an unbounded adversarygiven pkand a ciphertext c
computed via c←Encpk(m) can determine mwith probability 1. A proof of
this is left as Exercise 11.1.
Insecurity of deterministic public-key encryption. As noted in the
context of private-key encryption, no deterministic encryption scheme can be
CPA-secure. The same is true here:
THEOREM 11.4 No deterministic public-key encryption scheme is CPA-
secure.Public-Key Encryption 381
Because Theorem 11.4 is so important, it merits a bit more discussion. The
theorem is notan “artifact” of our security deﬁnition, or an indication that
our deﬁnition is too strong. Deterministic public-key encryption schemes are
vulnerable to practical attacks in realisticscenarios and should never be used.
The reason is that a deterministic scheme not only allows the adversary to
determine when the same message is sent twice (as in the private-key setting),
but also allows the adversary to recover the message, with probability 1, if
the set of possible messages being encrypted is small. For example, consider
a professor encrypting students’ grades. Here, an eavesdropper knows that
each student’s grade must be one of {A,B,C,D,F}. If the professor uses
a deterministic public-key encryption scheme, an eavesdropper can quickly
determine any student’s actual grade by encrypting all possible grades and
comparing the result to the given ciphertext.
Althoughthe abovetheoremseems deceptivelysimple, for alongtime many
real-world systems were designed using deterministic public-key encryption .
When public-key encryption was introduced, it is fair to say that the impor-
tance of probabilistic encryption was not yet fully realized. The seminal work
of Goldwasser and Micali, in which (something equivalent to) Deﬁnition 11.2
was proposed and Theorem 11.4 was stated, marked a turning point in the
ﬁeld of cryptography. The importance of pinning down one’s intuition in a
formal deﬁnition and looking at things the right way for the ﬁrst time—even
if seemingly simple in retrospect—should not be underestimated.
11.2.2 Multiple Encryptions
As in Chapter 3, it is important to understand the eﬀect of using the same
key (in this case, the same public key) for encrypting multiple messages. We
could formulate security in such a setting by having an adversary output
twolistsof plaintexts, as in Deﬁnition 3.19. For the reasons discussed in
Section 3.4.2, however, we choose instead to use a deﬁnition in which the
attacker is given access to a “left-or-right” oracle LRpk,bthat, on input a pair
of equal-length messages m0,m1, computes the ciphertext c←Encpk(mb) and
returnsc. The attacker is allowed to query this oracle as many times as it
likes, and the deﬁnition therefore models security when multiple (unknown)
messages are encrypted using the same public key.
Formally, considerthe followingexperiment deﬁned fora public-keyencryp-
tion scheme Π = ( Gen,Enc,Dec) and adversaryA:
The LR-oracle experiment PubKLR-cpa
A,Π(n):
1.Gen(1n)is run to obtain keys (pk,sk).
2. A uniform bit b∈{0,1}is chosen.
3. The adversary Ais given input pkandoracle access to LRpk,b(·,·).
4. The adversary Aoutputs a bit b/prime.
5. The output of the experiment is deﬁned to be 1ifb/prime=b, and
0otherwise. If PubKLR-cpa
A,Π(n) = 1, we say thatAsucceeds.382 Introduction to Modern Cryptography
DEFINITION 11.5 A public-key encryption scheme Π = (Gen,Enc,Dec)
hasindistinguishablemultiple encryptions if for all probabilistic polynomial-time
adversariesAthere exists a negligible function neglsuch that:
Pr[PubKLR-cpa
A,Π(n) = 1]≤1
2+negl(n).
We will show that any CPA-secure scheme automatically has indistinguish-
able multiple encryptions; that is, in the public-key setting, security for en-
cryption of a single message implies security for encryption of multiple mes-
sages. This means we can prove security of some scheme with respect to
Deﬁnition 11.2, which is simpler and easier to work with, and conclude that
the scheme satisﬁes Deﬁnition 11.5, a seemingly stronger deﬁnition that more
accurately models real-world usage of public-key encryption. A proof of the
following theorem is given below.
THEOREM 11.6 If public-key encryption scheme Πis CPA-secure, then
it also has indistinguishable multipleencryptions.
An analogous result in the private-key setting was stated, but not proved,
as Theorem 3.24.
Encrypting arbitrary-length messages. An immediate consequence of
Theorem 11.6 is that a CPA-secure public-key encryption scheme for ﬁxed-
lengthmessages implies a public-key encryption scheme for arbitrary-length
messages satisfying the same notion of security. We illustrate this in the
extreme case when the original scheme encrypts only 1-bit messages. Say
Π = (Gen,Enc,Dec) is an encryption scheme for single-bit messages. We can
construct a new scheme Π/prime= (Gen,Enc/prime,Dec/prime) that has message space {0,1}∗
by deﬁning Enc/primeas follows:
Enc/prime
pk(m) =Encpk(m1),...,Encpk(m/lscript), (11.1)
wherem=m1···m/lscript. (The decryption algorithm Dec/primeis constructed in the
obvious way.) We have:
CLAIM 11.7 LetΠandΠ/primebe as above. If Πis CPA-secure, then so is Π/prime.
The claim follows since we can view encryption of the message musing Π/prime
as encryption of tmessages ( m1,...,m t) using scheme Π.
A note on terminology. We have introduced three deﬁnitions of secu-
rity for public-key encryption schemes—indistinguishable encryptions in the
presence of an eavesdropper, CPA-security, and indistinguishable multiple
encryptions—that are all equivalent. Following the usual convention in the
cryptographic literature, we will simply use the term “CPA-security” to refer
to schemes meeting these notions of security.Public-Key Encryption 383
*Proof of Theorem 11.6
The proof of Theorem 11.6 is rather involved. We therefore provide some
intuition before turning to the details. For this intuitive discussion we assume
for simplicity that Amakes only twocalls to the LRoracle in experiment
PubKLR-cpa
A,Π(n). (In the full proof, the number of calls is arbitrary.)
Fix an arbitrary pptadversaryAand a CPA-secure public-key encryption
scheme Π, and consider an experiment PubKLR-cpa2
A,Π(n) whereAcan make
onlytwoqueries to the LRoracle. Denote the queries made by Ato the
oracle by ( m1,0,m1,1) and (m2,0,m2,1); note that the second pair of messages
may depend on the ﬁrst ciphertext obtained by Afrom the oracle. In the
experiment,Areceives either a pair of ciphertexts ( Encpk(m1,0),Encpk(m2,0))
(ifb= 0), or a pair of ciphertexts ( Encpk(m1,1),Encpk(m2,1)) (ifb= 1). We
writeA(pk,Encpk(m1,0),Encpk(m2,0)) to denote the output of Ain the ﬁrst
case, and analogously for the second.
Let/vectorC0denote the distribution of ciphertext pairs in the ﬁrst case, and /vectorC1
the distribution of ciphertext pairs in the second case. To show that Deﬁni-
tion 11.5 holds (for PubKLR-cpa2
A,Π), we need to prove that Acannot distinguish
between being given a pair of ciphertexts distributed according to /vectorC0, or a
pair of ciphertexts distributed according to /vectorC1. That is, we need to prove
that there is a negligible function neglsuch that
/vextendsingle/vextendsinglePr[A(pk,Encpk(m1,0),Encpk(m2,0)) = 1]
−Pr[A(pk,Encpk(m1,1),Encpk(m2,1)) = 1]/vextendsingle/vextendsingle≤negl(n).(11.2)
(This is equivalent to Deﬁnition 11.5 for the same reason that Deﬁnition 3.9
is equivalent to Deﬁnition 3.8.) To prove this, we will show that
1. CPA-security of Π implies that Acannot distinguish between the case
when it is given a pair of ciphertexts distributed according to /vectorC0, or
a pair of ciphertexts ( Encpk(m1,0),Encpk(m2,1)), which corresponds to
encrypting the ﬁrstmessage inA’s ﬁrst oracle query and the second
message inA’s second oracle query. (Although this cannot occur in
PubKLR-cpa2
A,Π(n), we can still ask what A’s behavior would be if given
such a ciphertext pair.) Let /vectorC01denote the distribution of ciphertext
pairs in this latter case.
2. Similarly, CPA-security of Π implies that Acannot distinguish between
the case when it is given a pair of ciphertexts distributed according to
/vectorC01, or a pair of ciphertexts distributed according to /vectorC1.
The above says that Acannot distinguish between distributions /vectorC0and/vectorC01,
nor between distributions /vectorC01and/vectorC1. We conclude (using simple algebra)
thatAcannot distinguish between distributions /vectorC0and/vectorC1.
The crux of the proof, then, is showing that Acannot distinguish between
being given a pair of ciphertexts distributed according to /vectorC0, or a pair of384 Introduction to Modern Cryptography
ciphertexts distributed according to /vectorC01. (The other case follows similarly.)
That is, we want to show that there is a negligible function neglfor which
/vextendsingle/vextendsinglePr[A(pk,Encpk(m1,0),Encpk(m2,0)) = 1]
−Pr[A(pk,Encpk(m1,0),Encpk(m2,1)) = 1]/vextendsingle/vextendsingle≤negl(n).(11.3)
Note that the only diﬀerence between the input of the adversary Ain each
case is in the second element. Intuitively, indistinguishability follows from
the single-message case since Acan generate Encpk(m1,0) by itself. Formally,
consider the following pptadversaryA/primerunning in experiment PubKeav
A/prime,Π(n):
AdversaryA/prime:
1. On input pk, adversaryA/primerunsA(pk) as a subroutine.
2. WhenAmakes its ﬁrst query ( m1,0,m1,1) to the LRoracle,
A/primecomputes c1←Encpk(m1,0) and returns c1toAas the
response from the oracle.
3. WhenAmakes its second query ( m2,0,m2,1) to the LRor-
acle,A/primeoutputs ( m2,0,m2,1) and receives back a challenge
ciphertext c2. This is returned to Aas the response from the
LRoracle.
4.A/primeoutputs the bit b/primeoutput byA.
Looking at experiment PubKeav
A/prime,Π(n), we see that when b= 0 then the chal-
lenge ciphertext c2is computed as Encpk(m2,0). Thus,
Pr[A/prime(Encpk(m2,0)) = 1] = Pr[A(Encpk(m1,0),Encpk(m2,0)) = 1].(11.4)
(We suppress explicit mention of pkto save space.) In contrast, when b= 1
in experiment PubKeav
A/prime,Π(n), thenc2is computed as Encpk(m2,1) and so
Pr[A/prime(Encpk(m2,1)) = 1] = Pr[A(Encpk(m1,0),Encpk(m2,1)) = 1].(11.5)
CPA-security of Π implies that there is a negligible function neglsuch that
|Pr[A/prime(Encpk(m2,0)) = 1]−Pr[A/prime(Encpk(m2,1)) = 1]|≤negl(n).
This, together with Equations (11.4) and (11.5), yields Equation (11.3).
In almost exactly the same way, we can prove that:
/vextendsingle/vextendsinglePr[A(pk,Encpk(m1,0),Encpk(m2,1)) = 1]
−Pr[A(pk,Encpk(m1,1),Encpk(m2,1)) = 1]/vextendsingle/vextendsingle≤negl(n).(11.6)
Equation (11.2) follows by combining Equations (11.3) and (11.6).
The main complication that arises in the general case is that the number
of queries to the LRoracle is no longer ﬁxed but may instead be an arbitraryPublic-Key Encryption 385
polynomial of n. In the formal proof this is handled using a hybrid argument .
(Hybrid arguments were used also in Chapter 7.)
PROOF (of Theorem 11.6) Let Π be a CPA-secure public-key encryp-
tion scheme andAan arbitrary pptadversary in experiment PubKLR-cpa
A,Π(n).
Lett=t(n)beapolynomialupperboundonthenumberofqueriesmadeby A
to theLRoracle, and assume without loss of generality that Aalways queries
the oracle exactlythis many times. For a given public key pkand 0≤i≤t,
letLRi
pkdenote the oracle that on input ( m0,m1) returns Encpk(m0) for the
ﬁrstiqueries it receives, and returns Encpk(m1) for the next t−iqueries it
receives. (That is, for the ﬁrst iqueries the ﬁrst message in the input pair
is encrypted, and in response to the remaining queries the second message
in the input pair is encrypted.) We stress that each encryption is computed
using uniform, independent randomness. Using this notation, we have
Pr/bracketleftBig
PubKLR-cpa
A,Π(n) = 1/bracketrightBig
=1
2·Pr[ALRt
pk(pk) = 0]+1
2·Pr[ALR0
pk(pk) = 1]
because, from the point of view of A(who makes exactly tqueries), oracle
LRt
pkis equivalent to LRpk,0, and oracle LR0
pkis equivalent to LRpk,1. To prove
that Π satisﬁes Deﬁnition 11.5, we will show that for any pptAthere is a
negligible function negl/primesuch that
/vextendsingle/vextendsingle/vextendsinglePr[ALRt
pk(pk) = 1]−Pr[ALR0
pk(pk) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl/prime(n).(11.7)
(As before, this is equivalent to Deﬁnition 11.5 for the same reason that Def-
inition 3.9 is equivalent to Deﬁnition 3.8.)
Consider the following pptadversaryA/primethat eavesdrops on the encryption
of asinglemessage:
AdversaryA/prime:
1.A/prime, givenpk, chooses a uniform index i←{1,...,t}.
2.A/primerunsA(pk), answering its jth oracle query ( mj,0,mj,1) as
follows:
(a) Forj < i, adversaryA/primecomputes cj←Encpk(mj,0) and
returnscjtoAas the response from its oracle.
(b) Forj=i, adversaryA/primeoutputs ( mj,0,mj,1) and receives
back a challenge ciphertext cj. This is returned to Aas
the response from its oracle.
(c) Forj > i, adversaryA/primecomputes cj←Encpk(mj,1) and
returnscjtoAas the response from its oracle.
3.A/primeoutputs the bit b/primethat is output by A.386 Introduction to Modern Cryptography
Consider experiment PubKeav
A/prime,Π(n). Fixing some choice of i=i∗, note that
ifci∗is an encryption of mi∗,0then the interaction of Awith its oracle is
identical to an interaction with oracle LRi∗
pk. Thus,
Pr[A/primeoutputs 1|b= 0] =t/summationdisplay
i∗=1Pr[i=i∗]·Pr[A/primeoutputs 1|b= 0∧i=i∗]
=t/summationdisplay
i∗=11
t·Pr/bracketleftBig
ALRi∗
pk(pk) = 1/bracketrightBig
.
On the other hand, if ci∗is an encryption of mi∗,1then the interaction of A
with its oracle is identical to an interaction with oracle LRi∗−1
pk, and so
Pr[A/primeoutputs 1|b= 1] =t/summationdisplay
i∗=1Pr[i=i∗]·Pr[A/primeoutputs 1|b= 1∧i=i∗]
=t/summationdisplay
i∗=11
t·Pr/bracketleftBig
ALRi∗−1
pk(pk) = 1/bracketrightBig
=t−1/summationdisplay
i∗=01
t·Pr/bracketleftBig
ALRi∗
pk(pk) = 1/bracketrightBig
,
where the third equality is obtained just by shifting the indices of summation.
SinceA/primeruns in polynomial time, the assumption that Π is CPA-secure
means that there exists a negligible function neglsuch that
/vextendsingle/vextendsinglePr[A/primeoutputs 1|b= 0]−Pr[A/primeoutputs 1|b= 1]/vextendsingle/vextendsingle≤negl(n).
But this means that
negl(n)≥/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglet/summationdisplay
i∗=11
t·Pr/bracketleftBig
ALRi∗
pk(pk) = 1/bracketrightBig
−t−1/summationdisplay
i∗=01
t·Pr/bracketleftBig
ALRi∗
pk(pk) = 1/bracketrightBig/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle
=1
t·/vextendsingle/vextendsingle/vextendsinglePr/bracketleftBig
ALRt
pk(pk) = 1/bracketrightBig
−Pr/bracketleftBig
ALR0
pk(pk) = 1/bracketrightBig/vextendsingle/vextendsingle/vextendsingle,
since all but one of the terms in each summation cancel. We conclude that
/vextendsingle/vextendsingle/vextendsinglePr/bracketleftBig
ALRt
pk(pk) = 1/bracketrightBig
−Pr/bracketleftBig
ALR0
pk(pk) = 1/bracketrightBig/vextendsingle/vextendsingle/vextendsingle≤t(n)·negl(n).
Because tis polynomial, the function t·negl(n) is negligible. Since Awas
an arbitrary pptadversary, this shows that Equation (11.7) holds and so
completes the proof that Π has indistinguishable multiple encryptions.Public-Key Encryption 387
11.2.3 Security against Chosen-Ciphertext Attacks
Chosen-ciphertext attacks , in which an adversary is able to obtain the de-
cryption of arbitrary ciphertexts of its choice (with one technical restriction
described below), are a concern in the public-key setting just as they are in
the private-key setting. In fact, they are arguably moreof a concern in the
public-key setting since there a receiver expects to receive ciphertexts from
multiple senders who are possibly unknown in advance, whereas a receiver
in the private-key setting intends to communicate only with a single, known
sender using any particular secret key.
Assume an eavesdropper Aobserves a ciphertext csent by a senderSto a
receiverR. Broadly speaking, in the public-key setting there are two classes
of chosen-ciphertext attacks:
• Amight sendamodiﬁedciphertext c/primetoRon behalf ofS. (Forexample,
in the context of encrypted e-mail, Amight construct an encrypted e-
mailc/primeandforgethe “ From”ﬁeld sothatit appearsthe e-mailoriginated
fromS.) In this case, although it is unlikely that Awould be able to
obtain the entire decryption m/primeofc/prime, it might be possible for Ato infer
some information about m/primebased on the subsequent behavior of R.
Based on this information, Amight be able to learn something about
the original message m.
• Amight send a modiﬁed ciphertext c/primetoRin its own name . In this
case,Amightobtainthe entiredecryption m/primeofc/primeifRrespondsdirectly
toA. Even ifAlearns nothing about m/prime, this modiﬁed message may
have a known relationto the original message mthat can be exploited
byA; see the third scenario below for an example.
The second class of attacks is speciﬁc to the context of public-key encryption,
and has no analogue in the private-key setting.
It is not hard to identify a number of realistic scenarios illustrating the
above types of attacks:
Scenario 1. Say a userSlogs in to her bank account by sending to her bank
an encryption of her password pwconcatenated with a timestamp. Assume
further that there are two types of error messages the bank sends: it returns
“password incorrect” if the encrypted password does not match the stored
password ofS, and “timestamp incorrect” if the password is correct but the
timestamp is not.
If an adversary obtains a ciphertext csent bySto the bank, the adversary
can now mount a chosen-ciphertext attack by sending ciphertexts c/primeto the
bank on behalf of Sand observing the error messages that result. (This is
similar to the padding-oracle attack that we saw in Section 3.7.2.) In some
cases, this information may be enough to allow the adversary to determine
the user’s entire password.388 Introduction to Modern Cryptography
Scenario 2. SaySsends an encrypted e-mail ctoR, and this e-mail is
observed byA. IfAsends, in its own name, an encrypted e-mail c/primetoR, then
Rmight reply to this e-mail and quote the decrypted text m/primecorresponding
toc/prime. In this case,Ris essentially acting as a decryption oracle for Aand
might potentially decrypt any ciphertext that Asends it.
Scenario 3. An issue that is closely related to that of chosen-ciphertextsecu-
rity is potential malleability of ciphertexts. Since a formal deﬁnition is quite
involved, we do not provide one here but instead only give the intuitive idea.
A scheme is malleable if it has the following property: given an encryption c
of some unknown message m, it is possible to come up with a ciphertext c/prime
that is an encryption of a message m/primethat is related in some known way to m.
For example, perhaps given an encryption of m, it is possible to construct an
encryption of 2 m. (We will see natural examples of CPA-secure schemes with
this and similar properties later; see Section 13.2.3.)
Now imagine that Ris running an auction, where two parties SandA
submit their bids by encrypting them using the public keyof R. If a malleable
encryption scheme is used, it may be possible for an adversary Ato always
place the highest bid (without bidding the maximum) by carrying out the
following attack: wait until Ssends a ciphertext ccorresponding to its bid m
(that is unknown to A); then send a ciphertext c/primecorresponding to the bid
m/prime= 2m. Note that m(andm/prime, for that matter) remain unknown to Auntil
Rannounces the results, and so the possibility of such an attack does not
contradict the fact that the encryption scheme is CPA-secure. CCA-secure
schemes, on the other hand, can be shown to be non-malleable, meaning they
are not vulnerable to such attacks.
The deﬁnition. Security against chosen-ciphertext attacks is deﬁned by
suitable modiﬁcation of the analogous deﬁnition from the private-key setting
(Deﬁnition 3.33). Given a public-key encryption scheme Π and an adversary
A, consider the following experiment:
The CCA indistinguishability experiment PubKcca
A,Π(n):
1.Gen(1n)is run to obtain keys (pk,sk).
2. The adversary Ais given pkand access to a decryption or-
acleDecsk(·). It outputs a pair of messages m0,m1of the
same length. (These messages must be in the message space
associated with pk.)
3. A uniform bit b∈ {0,1}is chosen, and then a ciphertext
c←Encpk(mb)is computed and given to A.
4.Acontinues to interact with the decryption oracle, but may
not request a decryption of citself. Finally,Aoutputs a bit b/prime.
5. The output of the experiment is deﬁned to be 1ifb/prime=b, and
0otherwise.Public-Key Encryption 389
DEFINITION 11.8 A public-key encryption scheme Π = (Gen,Enc,Dec)
hasindistinguishable encryptions under a chosen-ciphertext attack (or isCCA-
secure)if for all probabilistic polynomial-time adversaries Athere exists a
negligible function neglsuch that
Pr[PubKcca
A,Π(n) = 1]≤1
2+negl(n).
The naturalanalogueofTheorem11.6holds forCCA-securityaswell. That
is, if a scheme has indistinguishable encryptions under a chosen-ciphertext
attack then it has indistinguishable multiple encryptions under a chosen-
ciphertext attack, where this is deﬁned appropriately. Interestingly, however,
the analogue of Claim 11.7 does nothold for CCA-security.
As in Deﬁnition 3.33, we must prevent the attacker from submitting the
challenge ciphertext cto the decryption oracle for the deﬁnition to be achiev-
able. But this restriction does not make the deﬁnition meaningless and, in
particular, for each of the three motivating scenarios given earlier one can
argue that setting c/prime=cis of no beneﬁt to the attacker:
•In the ﬁrst scenario involving password-based login, the attacker learns
nothing aboutS’s password by replaying cto the bank since in this case
it already knows that no error message will be generated.
•In the second scenario involving encrypted email, sending c/prime=cto the
receiver would likely make the receiver suspicious and so it would refuse
to respond at all.
•In the ﬁnal scenario involving an auction, Rcould easily detect cheat-
ing if the adversary’s encrypted bid is identical to the other party’s
encrypted bid. Anyway, in that case all the attacker achieves by replay-
ingcis that it submits the samebid as the honest party.
11.3 Hybrid Encryption and the KEM/DEM Paradigm
Claim 11.7 shows that any CPA-secure public-key encryption scheme for /lscript/prime-
bitmessagescanbeusedtoobtainaCPA-securepublic-keyencryptionscheme
for messages of arbitrary length. Encrypting an /lscript-bit message using this
approach requires γdef=⌈/lscript//lscript/prime⌉invocations of the original encryption scheme,
meaning that both the computation and the ciphertext length are increased
by a multiplicative factor of γrelative to the underlying scheme.
It is possible to do better by using private-key encryption in tandem with
public-key encryption. This improves eﬃciency because private-key encryp-
tion is signiﬁcantly faster than public-key encryption, and improves band-
width because private-key schemes have lower ciphertext expansion. The
resulting combination is called hybrid encryption and is used extensively in390 Introduction to Modern Cryptography
practice. The basic idea is to use public-key encryption to obtain a shared
keyk, and then encrypt the message musing a private-key encryption scheme
and key k. The receiver uses its long-term (asymmetric) private key to de-
rivek,andthenusesprivate-keydecryption(withkey k)torecovertheoriginal
message. We stress that although private-key encryption is used as a compo-
nent, this is a full-ﬂedged public-key encryption scheme by virtue of the fact
that the sender and receiver do not share any secret key in advance .
/MT107
/MT112/MT107
/MT99/MT109
/MT99/MT146/MT69/MT110/MT99/MT146 /MT69/MT110/MT99
FIGURE 11.1 :Hybrid encryption. Encdenotes a public-key encryption
scheme, while Enc/primeis a private-key encryption scheme.
In a direct implementation of this idea (see Figure 11.1), the sender would
sharekby (1) choosing a uniform value kand then (2) encrypting kusing a
public-key encryption scheme. A more direct approach is to use a public-key
primitive called a key-encapsulation mechanism (KEM) to accomplish both
of these “in one shot.” This is advantageous both from a conceptual point of
view and in terms of eﬃciency, as we will see later.
A KEM has three algorithms similar in spirit to those of a public-key en-
cryption scheme. As before, the key-generation algorithm Genis used to
generate a pair of public and private keys. In place of encryption, we now
have anencapsulation algorithm Encapsthat takes only a public key as input
(and no message), and outputs a ciphertext calong with a key k. A corre-
sponding decapsulation algorithm Decapsis run by the receiver to recover k
from the ciphertext cusing the private key. Formally:
DEFINITION 11.9 Akey-encapsulation mechanism (KEM) is a tuple of
probabilistic polynomial-time algorithms (Gen,Encaps,Decaps)such that:
1. Thekey-generation algorithm Gen takes as input the security parame-
ter1nand outputs a public-/private-key pair (pk,sk). We assume pk
andskeach has length at least n, and that ncan be determined from pk.
2. TheencapsulationalgorithmEncaps takes as input a public key pkand the
security parameter 1n. It outputs a ciphertext cand a key k∈{0,1}/lscript(n)
where/lscriptis thekey length . We write this as (c,k)←Encapspk(1n).Public-Key Encryption 391
3. The deterministic decapsulationalgorithmDecaps takes as input a private
keyskand a ciphertext c, and outputs a key kor a special symbol ⊥
denoting failure. We write this as k:=Decapssk(c).
It is required that with all but negligible probability over (sk,pk)output by
Gen(1n), ifEncapspk(1n)outputs(c,k)thenDecapssk(c)outputsk.
In the deﬁnition we assume for simplicity that Encapsalways outputs (a
ciphertext cand) a key of some ﬁxed length /lscript(n). One could also consider a
more general deﬁnition in which Encapstakes 1/lscriptas an additional input and
outputs a key of length /lscript.
Any public-key encryption scheme trivially gives a KEM by choosing a ran-
dom key kand encrypting it. As we will see, however, dedicated constructions
of KEMs can be more eﬃcient.
/MT107/MT112/MT107
/MT99/MT109
/MT99/MT146/MT69/MT110/MT99/MT146 /MT69/MT110/MT99/MT97/MT112/MT115
FIGURE 11.2 :Hybrid encryption using the KEM/DEM approach.
Using a KEM (with key length n), we can implement hybrid encryption as
in Figure 11.2. The sender runs Encapspk(1n) to obtain calong with a key k;
it then uses a private-key encryption scheme to encrypt its message m, using
kas the key. In this context, the private-key encryption scheme is called a
data-encapsulation mechanism (DEM) for obvious reasons. The ciphertext
sent to the receiver includes both cand the ciphertext c/primefrom the private-key
scheme. Construction 11.10 gives a formal speciﬁcation.
What is the eﬃciency of the resulting hybrid encryption scheme Πhy? For
some ﬁxed value of n, letαdenote the cost of encapsulating an n-bit key
usingEncaps, and let βdenote the cost (per bit of plaintext) of encryption
usingEnc/prime. Assume|m|> n, which is the interesting case. Then the cost, per
bit of plaintext, of encrypting a message musing Πhyis
α+β·|m|
|m|=α
|m|+β, (11.8)
which approaches βfor suﬃciently long m. In the limit of very long messages,
then, the cost per bit incurred by the public-key encryption scheme Πhyis the392 Introduction to Modern Cryptography
CONSTRUCTION 11.10
LetΠ = (Gen,Encaps,Decaps) be a KEM with key length n, and let
Π/prime= (Gen/prime,Enc/prime,Dec/prime) be a private-key encryption scheme. Construct a
public-key encryption scheme Πhy= (Genhy,Enchy,Dechy) as follows:
•Genhy: on input 1nrunGen(1n) and use the public and private
keys (pk,sk) that are output.
•Enchy: on input a public key pkand a message m∈{0,1}∗do:
1. Compute ( c,k)←Encapspk(1n).
2. Compute c/prime←Enc/prime
k(m).
3. Output the ciphertext /angbracketleftc,c/prime/angbracketright.
•Dechy: on input a private key skand a ciphertext /angbracketleftc,c/prime/angbracketrightdo:
1. Compute k:=Decapssk(c).
2. Output the message m:=Dec/prime
k(c/prime).
Hybrid encryption using the KEM/DEM paradigm.
same as the cost per bit of the private-key scheme Π/prime. Hybrid encryption thus
allowsusto achievethe functionality ofpublic-keyencryption atthe eﬃciency
of private-key encryption, at least for suﬃciently long messages.
A similar calculation can be used to measure the eﬀect of hybrid encryption
on the ciphertext length. For some ﬁxed value of n, letLdenote the length
of the ciphertext output by Encaps, and say the private-key encryption of
a message musingEnc/primeresults in a ciphertext of length n+|m|(this can
be achieved using one of the modes of encryption discussed in Section 3.6;
actually, even ciphertext length |m|is possible since, as we will see, Π/primeneed
not be CPA-secure). Then the total length of a ciphertext in scheme Πhyis
L+n+|m|. (11.9)
In contrast, when using block-by-block encryption as in Equation (11.1), and
assuming that public-key encryption ofan n-bit messageusing Encresults in a
ciphertext of length L, encryption of a message mwould result in a ciphertext
of length L·⌈|m|/n⌉. The ciphertext length reported in Equation (11.9) is a
signiﬁcant improvement for suﬃciently long m.
We can use some rough estimates to get a sense for what the above results
mean in practice. (We stress that these numbers are only meant to give the
reader a feel for the improvement; realistic values would depend on a variety
of factors.) A typical value for the length of the key kmight be n= 128.
Furthermore, a “native” public-key encryption scheme might yield 256-bit
ciphertexts when encrypting 128-bitmessages; assume a KEM has ciphertexts
of the same length when encapsulating a 128-bit key. Letting α, as before,
denote the computational cost of public-key encryption/encapsulation of a
128-bitkey, wesee that block-by-blockencryptionasin Equation(11.1)wouldPublic-Key Encryption 393
encrypt a 1 MB (= 106-bit) message with computational cost α·⌈106/128⌉≈
7800·αandthe ciphertext wouldbe 2 MB long. Comparethis to the eﬃciency
of hybrid encryption. Letting β, as before, denote the per-bit computational
cost of private-key encryption, a reasonable approximation is β≈α/105.
Using Equation (11.8), we see that the overall computational cost for hybrid
encryption for a 1 Mb message is
α+106·α
105=11·α,
and the ciphertext would be only slightly longer than 1 MB. Thus, hybrid en-
cryption improves the computational eﬃciency in this case by a factor of 700,
and the ciphertext length by a factor of 2.
It remains to analyze the security of Πhy. This, of course, depends on the
security of its underlying components Π and Π/prime. In the following sections we
deﬁne notions of CPA-security and CCA-security for KEMs, and show:
•If Π is a CPA-secure KEM and the private-key scheme Π/primehas indis-
tinguishable encryptions in the presence of an eavesdropper, then Πhy
is a CPA-secure public-key encryption scheme. Notice that it suﬃces
for Π/primeto satisfy a weaker deﬁnition of security—which, recall, does not
imply CPA-security in the private-key setting—in order for the hybrid
scheme Πhyto be CPA-secure. Intuitively, the reason is that a fresh,
uniform key kis chosen each time a new message is encrypted. Since
each key kis used only once, indistinguishability of a single encryption
of Π/primesuﬃces for security of the hybrid scheme Πhy. This means that ba-
sic private-key encryption using a pseudorandom generator (or stream
cipher), as in Construction 3.17, suﬃces.
•If Π is a CCA-secure KEM and Π/primeis a CCA-secure private-key encryp-
tion scheme, then Πhyis a CCA-secure public-key encryption scheme.
11.3.1 CPA-Security
For simplicity, we assume in this and the next section a KEM with key
lengthn. We deﬁne a notion of CPA-security for KEMs by analogy with Def-
inition 11.2. As there, the adversary here eavesdrops on a single ciphertext c.
Deﬁnition 11.2 requires that the attacker is unable to distinguish whether cis
an encryption of some message m0or some other message m1. With a KEM
there is no message, and we require instead that the encapsulated key kis
indistinguishable from a uniform key that is independent of the ciphertext c.394 Introduction to Modern Cryptography
Let Π = ( Gen,Encaps,Decaps) be a KEM and Aan arbitrary adversary.
The CPA indistinguishability experiment KEMcpa
A,Π(n):
1.Gen(1n)is run to obtain keys (pk,sk). ThenEncapspk(1n)is
run to generate (c,k)withk∈{0,1}n.
2. A uniform bit b∈{0,1}is chosen. If b= 0setˆk:=k. If
b= 1then choose a uniform ˆk∈{0,1}n.
3. Give(pk,c,ˆk)toA, who outputs a bit b/prime. The output of the
experiment is deﬁned to be 1ifb/prime=b, and0otherwise.
In the experiment, Ais given the ciphertext cand either the actual key k
corresponding to c, or an independent, uniform key. The KEM is CPA-secure
if no eﬃcient adversary can distinguish between these possibilities.
DEFINITION 11.11 A key-encapsulation mechanism ΠisCPA-secure
if for all probabilistic polynomial-time adversaries Athere exists a negligible
function neglsuch that
Pr[KEMcpa
A,Π(n) = 1]≤1
2+negl(n).
In the remainder of this section we prove the following theorem:
THEOREM 11.12 IfΠis a CPA-secure KEM and Π/primeis a private-key
encryption scheme that has indistinguishable encryptions in the presence of an
eavesdropper, then Πhyas in Construction 11.10 is a CPA-secure public-key
encryption scheme.
Before proving the theorem formally, we give some intuition. Let the no-
tation “Xc≡Y” denote the event that no polynomial-time adversary can
distinguish between two distributions XandY. (This concept is treated
more formally in Section 7.8, although we do not rely on that section here.)
For example, let Encaps(1)
pk(1n) (resp., Encaps(2)
pk(1n)) denote the ciphertext
(resp., key) output by Encaps. The fact that Π is CPA-secure means that
/parenleftBig
pk,Encaps(1)
pk(1n),Encaps(2)
pk(1n)/parenrightBigc≡/parenleftBig
pk,Encaps(1)
pk(1n),k/prime/parenrightBig
,
wherepkis generated by Gen(1n) andk/primeis chosen independently and uni-
formly from{0,1}n. Similarly, the fact that Π/primehas indistinguishable encryp-
tions in the presence of an eavesdropper means that for any m0,m1output
byAwe have Enc/prime
k(m0)c≡Enc/prime
k(m1) ifkis chosen uniformly at random.
In order to prove CPA-security of Πhywe need to show that
/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k(m0)/parenrightBigc≡/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k(m1)/parenrightBig
(11.10)Public-Key Encryption 395
/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k(m0)/parenrightBig
?6
(by security of Π)
/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m0)/parenrightBig
-  -(by “transitivity”)
(by security of Π/prime)/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m1)/parenrightBig/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k(m1)/parenrightBig
?6
(by security of Π)
FIGURE 11.3 : High-level structure of the proof of Theorem 11.12 (the
arrows represent indistinguishability).
form0,m1output by a pptadversaryA. (Equation (11.10) suﬃces to show
that Πhyhas indistinguishable encryptions in the presence of an eavesdropper,
and by Proposition 11.3 this implies that Πhyis CPA-secure.)
The proof proceeds in three steps. (See Figure 11.3.) First we prove that
/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k(m0)/parenrightBigc≡/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m0)/parenrightBig
,(11.11)
where on the left kis output by Encaps(2)
pk(1n), and on the right k/primeis an inde-
pendent, uniformkey. Thisfollowsviaafairlystraightforwardreduction,since
CPA-security of Π means exactly that Encaps(2)
pk(1n) cannot be distinguished
from a uniform key k/primeeven given pkandEncaps(1)
pk(1n).
Next, we prove that
/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m0)/parenrightBigc≡/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m1)/parenrightBig
.(11.12)
Here the diﬀerence is between encrypting m0orm1using Π/primeand a uniform,
independent key k/prime. Equation (11.12) thus follows using the fact that Π/primehas
indistinguishable encryptions in the presence of an eavesdropper.
Exactly as in the case of Equation (11.11), we can also show that
/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k(m1)/parenrightBigc≡/parenleftBig
pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m1)/parenrightBig
,(11.13)
by relying again on the CPA-security of Π. Equations (11.11)–(11.13) imply,
by transitivity, the desired result of Equation (11.10). (Transitivity will be
implicit in the proof we give below.)
We now present the full proof.
PROOF (of Theorem 11.12) We prove that Πhyhas indistinguishable
encryptions in the presence of an eavesdropper; by Proposition 11.3, this
implies it is CPA-secure.396 Introduction to Modern Cryptography
Fixanarbitrary pptadversaryAhy,andconsiderexperiment PubKeav
Ahy,Πhy(n).
Our goal is to prove that there is a negligible function neglsuch that
Pr[PubKeav
Ahy,Πhy(n) = 1]≤1
2+negl(n).
By deﬁnition of the experiment, we have
Pr[PubKeav
Ahy,Πhy(n) = 1] (11.14)
=1
2·Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k(m0)) = 0]
+1
2·Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k(m1)) = 1],
where in each case kequalsEncaps(2)
pk(1n). Consider the following pptadver-
saryA1attacking Π.
AdversaryA1:
1.A1is given ( pk,c,ˆk).
2.A1runsAhy(pk) to obtain two messages m0,m1. ThenA1
computes c/prime←Enc/prime
ˆk(m0), gives ciphertext /angbracketleftc,c/prime/angbracketrighttoAhy, and
outputs the bit b/primethatAhyoutputs.
Consider the behavior of A1when attacking Π in experiment KEMcpa
A1,Π(n).
Whenb= 0 in that experiment, then A1is given ( pk,c,ˆk) wherecandˆkwere
both output by Encapspk(1n). This means that Ahyis given a ciphertext of
the form/angbracketleftc,c/prime/angbracketright=/angbracketleftc,Enc/prime
k(m0)/angbracketright, wherekis the key encapsulated by c. So,
Pr[A1outputs 0|b= 0] = Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k(m0)) = 0].
On the other hand, when b= 1 in experiment KEMcpa
A1,Π(n) thenA1is given
(pk,c,ˆk) withˆkuniform and independent of c. If we denote such a key by k/prime,
this meansAhyis given a ciphertext of the form /angbracketleftc,Enc/prime
k/prime(m0)/angbracketright, and
Pr[A1outputs 1|b= 1] = Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m0)) = 1].
Since Π is a CPA-secure KEM, there is a negligible function negl1such that
1
2+negl1(n)≥Pr[KEMcpa
A1,Π(n) = 1] (11.15)
=1
2·Pr[A1outputs 0|b= 0]+1
2·Pr[A1outputs 1|b= 1]
=1
2·Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k(m0)) = 0]
+1
2·Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m0)) = 1]Public-Key Encryption 397
wherekis equal to Encaps(2)
pk(1n) andk/primeis a uniform and independent key.
Next, considerthe following pptadversaryA/primethat eavesdropson amessage
encrypted using the private-key scheme Π/prime.
AdversaryA/prime:
1.A/prime(1n) runsGen(1n) on its own to generate keys ( pk,sk). It
also computes c←Encaps(1)
pk(1n).
2.A/primerunsAhy(pk) to obtain two messages m0,m1. These are
output byA/prime, and it is given in return a ciphertext c/prime.
3.A/primegives the ciphertext /angbracketleftc,c/prime/angbracketrighttoAhy, and outputs the bit b/prime
thatAhyoutputs.
Whenb= 0 in experiment PrivKeav
A/prime,Π/prime(n), adversaryA/primeis given a cipher-
textc/primewhichisanencryptionof m0usingakey k/primethatisuniformandindepen-
dent of anything else. So Ahyis given a ciphertext of the form /angbracketleftc,Enc/prime
k/prime(m0)/angbracketright
wherek/primeis uniform and independent of c, and
Pr[A/primeoutputs 0|b= 0] = Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m0)) = 0].
On the other hand, when b= 1 in experiment PrivKeav
A/prime,Π/prime(n), thenA/primeis given
an encryption of m1using a uniform, independent key k/prime. This meansAhyis
given a ciphertext of the form /angbracketleftc,Enc/prime
k/prime(m1)/angbracketrightand so
Pr[A/primeoutputs 1|b= 1] = Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m1)) = 1].
Since Π/primehas indistinguishable encryptions in the presence of an eavesdrop-
per, there is a negligible function negl/primesuch that
1
2+negl/prime(n)≥Pr[PrivKeav
A/prime,Π/prime(n) = 1] (11.16)
=1
2·Pr[A/primeoutputs 0|b= 0]+1
2·Pr[A/primeoutputs 1|b= 1]
=1
2·Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m0)) = 0]
+1
2·Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m1)) = 1].
Proceeding exactly as we did to prove Equation (11.15), we can show that
there is a negligible function negl2such that
1
2+negl2(n)≥Pr[KEMcpa
A2,Π(n) = 1] (11.17)
=1
2·Pr[A2outputs 0|b= 0]+1
2·Pr[A2outputs 1|b= 1]
=1
2·Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k(m1)) = 1]
+1
2·Pr[Ahy(pk,Encaps(1)
pk(1n),Enc/prime
k/prime(m1)) = 0].398 Introduction to Modern Cryptography
SummingEquations(11.15)–(11.17)andusingthefactthatthesumofthree
negligible functions is negligible, we see there exists a negligible function negl
such that
3
2+negl(n)≥
1
2·/parenleftBig
Pr[Ahy(pk,c,Enc/prime
k(m0)) = 0] +Pr[Ahy(pk,c,Enc/prime
k/prime(m0)) = 1]
+Pr[Ahy(pk,c,Enc/prime
k/prime(m0)) = 0]+Pr[Ahy(pk,c,Enc/prime
k/prime(m1)) = 1]
+ Pr[Ahy(pk,c,Enc/prime
k(m1)) = 1]+Pr[Ahy(pk,c,Enc/prime
k/prime(m1)) = 0]/parenrightBig
,
wherec=Encaps(1)
pk(1n) in all the above. Note that
Pr[Ahy(pk,c,Enc/prime
k/prime(m0)) = 1]+Pr[Ahy(pk,c,Enc/prime
k/prime(m0)) = 0] = 1 ,
since the probabilities of complementary events always sum to 1. Similarly,
Pr[Ahy(pk,c,Enc/prime
k/prime(m1)) = 1]+Pr[Ahy(pk,c,Enc/prime
k/prime(m1)) = 0] = 1 .
Therefore,
1
2+negl(n)
≥1
2·/parenleftBig
Pr[Ahy(pk,c,Enc/prime
k(m0)) = 0]+Pr[Ahy(pk,c,Enc/prime
k(m1)) = 1]/parenrightBig
= Pr[PubKeav
Ahy,Πhy(n) = 1]
(using Equation (11.14) for the last equality), proving the theorem.
11.3.2 CCA-Security
Ifthe private-key encryption scheme Π/primeis not itself secure against chosen-
ciphertext attacks, then (regardless of the KEM used) neither is the resulting
hybrid encryption scheme Πhy. As a simple, illustrative example, say we take
Construction 3.17 as our private-key encryption scheme. Then, leaving the
KEM unspeciﬁed, encryption of a message mby Πhyis done by computing
(c,k)←Encapspk(1n) and then outputting the ciphertext
/angbracketleftc,G(k)⊕m/angbracketright,
whereGis a pseudorandom generator. Given a ciphertext /angbracketleftc,c/prime/angbracketright, an attacker
can simply ﬂip the last bit of c/primeto obtain a modiﬁed ciphertext that is a valid
encryption of mwith its last bit ﬂipped.
The natural way to ﬁx this is to use a CCA-secure private-key encryption
scheme. But this is clearly not enough if the KEM is susceptible to chosen-
ciphertext attacks. Since we have not yet deﬁned this notion, we do so now.Public-Key Encryption 399
As in Deﬁnition 11.11, we require that an adversary given a ciphertext c
cannot distinguish the key kencapsulated by that ciphertext from a uniform
and independent key k/prime. Now, however, we additionally allow the attacker to
requestdecapsulation of ciphertexts of its choice (as long as they are diﬀerent
from the challenge ciphertext).
Formally, let Π = ( Gen,Encaps,Decaps) be a KEM with key length nand
Aan adversary, and consider the following experiment:
The CCA indistinguishability experiment KEMcca
A,Π(n):
1.Gen(1n)is run to obtain keys (pk,sk). ThenEncapspk(1n)is
run to generate (c,k)withk∈{0,1}n.
2. A uniform bit b∈{0,1}is chosen. If b= 0setˆk:=k. If
b= 1then choose a uniform ˆk∈{0,1}n.
3.Ais given(pk,c,ˆk)and access to an oracle Decapssk(·), but
may not request decapsulation of citself.
4.Aoutputs a bit b/prime. The output of the experiment is deﬁned
to be1ifb/prime=b, and0otherwise.
DEFINITION 11.13 A key-encapsulation mechanism ΠisCCA-secure if
for all probabilistic polynomial-time adversaries Athere is a negligible function
neglsuch that
Pr[KEMcca
A,Π(n) = 1]≤1
2+negl(n).
Fortunately, we can show that using a CCA-secure KEM in combination
with a CCA-secure private-key encryption scheme results in a public-key en-
cryption scheme secure against chosen-ciphertext attacks.
THEOREM 11.14 IfΠis a CCA-secure KEM and Π/primeis a CCA-secure
private-key encryption scheme, then Πhyas in Construction 11.10 is a CCA-
secure public-key encryption scheme.
A proof is obtained by suitable modiﬁcation of the proof of Theorem 11.12.
11.4 CDH/DDH-Based Encryption
Sofar we have discussed public-key encryption abstractly, but have not
yet seen any concrete examples of public-key encryption schemes (or KEMs).
Here we explore some constructions based on the Diﬃe–Hellman problems .
(The Diﬃe–Hellman problems are introduced in Section 8.3.2.)400 Introduction to Modern Cryptography
11.4.1 El Gamal Encryption
In 1985, Taher El Gamal observed that the Diﬃe–Hellman key-exchange
protocol (cf. Section 10.3) could be adapted to give a public-key encryption
scheme. Recall that in the Diﬃe–Hellman protocol, Alice sends a message to
Bob and then Bob responds with a message to Alice; based on these messages,
Alice and Bob can derive a shared value kwhich is indistinguishable (to an
eavesdropper) from a uniform element of some group G. We could imagine
Bob using that shared value to encrypt a message m∈Gby simply sending
k·mto Alice; Alice can clearly recover musing her knowledge of k, and we
will argue below that an eavesdropper learns nothing about m.
In theEl Gamal encryption scheme we simply change our perspective on
the above interaction. We view Alice’s initial message as her public key, and
Bob’s reply (both his initial response and k·m) as a ciphertext. CPA-security
based on the decisional Diﬃe–Hellman (DDH) assumption follows fairly easily
from security of the Diﬃe–Hellman key-exchange protocol (Theorem 10.3).
In our formal treatment, we begin by stating and proving a simple lemma
that underlies the El Gamal encryption scheme. Let Gbe a ﬁnite group, and
letm∈Gbe an arbitrary element. The lemma states that multiplying mby
a uniform group element kyields a uniformly distributed group element k/prime.
Importantly, the distribution of k/primeis independent of m; this means that k/prime
contains no information about m.
LEMMA 11.15 LetGbe a ﬁnite group, and let m∈Gbe arbitrary. Then
choosing uniform k∈Gand setting k/prime:=k·mgives the same distribution for
k/primeas choosing uniform k/prime∈G. Put diﬀerently, for any ˆg∈Gwe have
Pr[k·m= ˆg] = 1/|G|,
where the probability is taken over uniform choice of k∈G.
PROOF Let ˆg∈Gbe arbitrary. Then
Pr[k·m= ˆg] = Pr[k= ˆg·m−1].
Sincekis uniform, the probability that kis equal to the ﬁxed element ˆ g·m−1
is exactly 1 /|G|.
The above lemma suggests a way to construct a perfectly secret private-key
encryption scheme with message space G. The sender and receiver share as
their secret key a uniform element k∈G. To encrypt the message m∈G,
the sender computes the ciphertext k/prime:=k·m. The receiver can recover
the message from the ciphertext k/primeby computing m:=k/prime/k. Perfect secrecy
follows immediately from the lemma above. In fact, we have already seen
this scheme in a diﬀerent guise—the one-time pad encryption scheme is anPublic-Key Encryption 401
instantiation of this approach, with the underlying group being the set of
strings of some ﬁxed length under the operation of bit-wise XOR.
We can adapt the above ideas to the public-key setting by providing the
parties with a way to generate a shared, “random-looking” value kby inter-
acting over a public channel. This should sound familiar since it is exactly
what the Diﬃe–Hellman protocol provides. We proceed with the details.
As in Section 8.3.2, let Gbe a polynomial-time algorithm that takes as in-
put 1nand (except possibly with negligible probability) outputs a description
of a cyclic group G, its order q(with/bardblq/bardbl=n), and a generator g. The El
Gamal encryption scheme is described in Construction 11.16.
CONSTRUCTION 11.16
LetGbe as in thetext. Deﬁnea public-keyencryption scheme as follows:
•Gen: on input 1nrunG(1n) to obtain ( G,q,g). Then choose a
uniform x∈Zqand compute h:=gx. The public keyis /angbracketleftG,q,g,h/angbracketright
and the private key is /angbracketleftG,q,g,x/angbracketright. The message space is G.
•Enc: on input a public key pk=/angbracketleftG,q,g,h/angbracketrightand a message m∈G,
choose a uniform y∈Zqand output the ciphertext
/angbracketleftgy, hy·m/angbracketright.
•Dec: on input a private key sk=/angbracketleftG,q,g,x/angbracketrightand a ciphertext
/angbracketleftc1,c2/angbracketright, output
ˆm:=c2/cx
1.
The El Gamal encryption scheme.
Toseethatdecryptionsucceeds,let /angbracketleftc1,c2/angbracketright=/angbracketleftgy, hy·m/angbracketrightwithh=gx.Then
ˆm=c2
cx
1=hy·m
(gy)x=(gx)y·m
gxy=gxy·m
gxy=m.
Example 11.17
Letq= 83 and p= 2q+ 1 = 167, and let Gdenote the group of quadratic
residues (i.e., squares) modulo p. (Since pandqare prime, Gis a subgroup
ofZ∗
pwith order q. See Section 8.3.3.) Since the order of Gis prime, any
element of Gexcept 1 is a generator; take g= 22= 4 mod 167. Say the
receiver chooses secret key 37 ∈Z83and so the public key is
pk=/angbracketleftp,q,g,h/angbracketright=/angbracketleft167,83,4,[437mod 167]/angbracketright=/angbracketleft167,83,4,76/angbracketright,
where we use pto represent G(it is assumed that the receiver knows that the
group is the set of quadratic residues modulo p).402 Introduction to Modern Cryptography
Say a sender encrypts the message m= 65∈G(note 65 = 302mod 167
and so 65 is an element in the subgroup). If y= 71, the ciphertext is
/angbracketleft[471mod 167] ,[7671·65 mod 167]/angbracketright=/angbracketleft132,44/angbracketright.
To decrypt, the receiver ﬁrst computes 124 = [13237mod 167]; then, since
66 = [124−1mod 167], the receiver recovers m= 65 = [44·66 mod 167].♦
We now prove security of the scheme. (The reader may want to compare
the proof of the following to the proofs of Theorems 3.18 and 10.3.)
THEOREM 11.18 If the DDH problem is hard relative to G, then the
El Gamal encryption scheme is CPA-secure.
PROOF Let Π denote the El Gamal encryption scheme. We prove that
Π has indistinguishable encryptions in the presence of an eavesdropper; by
Proposition 11.3, this implies it is CPA-secure.
LetAbe a probabilistic polynomial-time adversary. We want to show that
there is a negligible function neglsuch that
Pr[PubKeav
A,Π(n) = 1]≤1
2+negl(n).
Consider the modiﬁed “encryption scheme” /tildewideΠ where Genis the same as in Π,
but encryption of a message mwith respect to the public key /angbracketleftG,q,g,h/angbracketrightis
done by choosing uniform y,z∈Zqand outputting the ciphertext
/angbracketleftgy, gz·m/angbracketright.
Although/tildewideΠ is not actually an encryption scheme (as there is no way for the
receiverto decrypt), theexperiment PubKeav
A,/tildewideΠ(n) isstill well-deﬁnedsince that
experiment depends only on the key-generation and encryption algorithms.
Lemma 11.15 and the discussion that immediately follows it imply that the
second component of the ciphertext in scheme /tildewideΠ is a uniformly distributed
group element and, in particular, is independent of the message mbeing en-
crypted. (Remember that gzis a uniform element of Gwhenzis chosen
uniformly from Zq.) The ﬁrst component of the ciphertext is trivially inde-
pendent of m. Taken together, this means that the entire ciphertext contains
no information about m. It follows that
Pr[PubKeav
A,/tildewideΠ(n) = 1] =1
2.
Now consider the following pptalgorithm Dthat attempts to solve the
DDH problem relative to G. Recall that Dreceives ( G,q,g,h 1,h2,h3) where
h1=gx,h2=gy, andh3is either gxyorgz(for uniform x,y,z); the goal of
Dis to determine which is the case.Public-Key Encryption 403
Algorithm D:
The algorithm is given ( G,q,g,h 1,h2,h3) as input.
•Setpk=/angbracketleftG,q,g,h 1/angbracketrightand runA(pk) to obtain two messages
m0,m1∈G.
•Choose a uniform bit b, and set c1:=h2andc2:=h3·mb.
•Give the ciphertext /angbracketleftc1,c2/angbracketrighttoAand obtain an output bit b/prime.
Ifb/prime=b, output 1; otherwise, output 0.
Let us analyze the behavior of D. There are two cases to consider:
Case 1: Say the input to Dis generated by running G(1n) to obtain ( G,q,g),
then choosing uniform x,y,z∈Zq, and ﬁnally setting h1:=gx,h2:=gy, and
h3:=gz. ThenDrunsAon a public key constructed as
pk=/angbracketleftG,q,g,gx/angbracketright
and a ciphertext constructed as
/angbracketleftc1,c2/angbracketright=/angbracketleftgy, gz·mb/angbracketright.
We see that in this case the view of Awhen run as a subroutine by Dis dis-
tributed identically to A’s view in experiment PubKeav
A,/tildewideΠ(n). SinceDoutputs 1
exactly when the output b/primeofAis equal to b, we have that
Pr[D(G,q,g,gx,gy,gz) = 1] = Pr[ PubKeav
A,/tildewideΠ(n) = 1] =1
2.
Case 2:Say the input to Dis generated by running G(1n) to obtain ( G,q,g),
then choosing uniform x,y∈Zq, and ﬁnally setting h1:=gx,h2:=gy, and
h3:=gxy. ThenDrunsAon a public key constructed as
pk=/angbracketleftG,q,g,gx/angbracketright
and a ciphertext constructed as
/angbracketleftc1,c2/angbracketright=/angbracketleftgy, gxy·mb/angbracketright=/angbracketleftgy,(gx)y·mb/angbracketright.
We see that in this case the view of Awhen run as a subroutine by Dis dis-
tributed identically to A’s view in experiment PubKeav
A,Π(n). SinceDoutputs 1
exactly when the output b/primeofAis equal to b, we have that
Pr[D(G,q,g,gx,gy,gxy) = 1] = Pr[ PubKeav
A,Π(n) = 1].
Under the assumption that the DDH problem is hard relative to G, there
is a negligible function neglsuch that
negl(n)≥/vextendsingle/vextendsingle/vextendsinglePr[D(G,q,g,gx,gy,gz) = 1]−Pr[D(G,q,g,gx,gy,gxy) = 1]/vextendsingle/vextendsingle/vextendsingle
=/vextendsingle/vextendsingle/vextendsingle/vextendsingle1
2−Pr[PubKeav
A,Π(n) = 1]/vextendsingle/vextendsingle/vextendsingle/vextendsingle.
This implies Pr[ PubKeav
A,Π(n) = 1]≤1
2+negl(n), completing the proof.404 Introduction to Modern Cryptography
El Gamal Implementation Issues
We brieﬂy discuss some practical issues related to El Gamal encryption.
Sharing public parameters. Our description of the El Gamal encryption
scheme in Construction11.16requiresthe receivertorun Gto generate G,q,g.
Inpractice,itiscommonfortheseparameterstobegeneratedandﬁxed“once-
and-for-all,” and then shared by multiple receivers. (Of course, each receiver
mustchoosetheirownsecretvalue xandpublishtheirownpublickey h=gx.)
For example, NIST has published a set of recommended parameters suitable
for use in the El Gamal encryption scheme. Sharing parameters in this way
does not impact security (assuming the parameters were generated correctly
and honestly in the ﬁrst place). Looking ahead, we remark that this is in
contrast to the case of RSA, where parameters cannot safely be shared (see
Section 11.5.1).
Choice of group. AsdiscussedinSection8.3.2,thegrouporder qisgenerally
chosen to be prime. As far as speciﬁc groups are concerned, elliptic curves
are one increasingly popular choice; an alternative is to let Gbe a prime-
order subgroup of Z∗
p, forpprime. We refer to Section 9.3 for a tabulation of
recommended key lengths for achieving diﬀerent levels of security.
The message space. An inconvenient aspect of the El Gamal encryption
scheme is that the message space is a group Grather than bit-strings of
some speciﬁed length. For some choices of the group, it is possible to address
this by deﬁning a reversible encoding of bit-strings as group elements. In
such cases, the sender can ﬁrst encode their message m∈{0,1}/lscriptas a group
element ˆm∈Gand then apply El Gamal encryption to ˆ m. The receiver can
decrypt as in Construction 11.16 to obtain the encoded message ˆ m, and then
reverse the encoding to recover the original message m.
A simpler approach is to use (a variant of) El Gamal encryption as part of
a hybrid encryption scheme. For example, the sender could choose a uniform
group element m∈G, encrypt this using the El Gamal encryption scheme,
and then encrypt their actual message using a private-key encryption scheme
and key H(m), where H:G→ {0,1}nis an appropriate key-derivation
function (see the following section). In this case, it would be more eﬃcient to
use the DDH-based KEM that we describe next.
11.4.2 DDH-Based Key Encapsulation
At the end of the previous section we noted that El Gamal encryption
can be used as part of a hybrid encryption scheme by simply encrypting a
uniform group element mand using a hash of that element as a key. But
this is wasteful! The proof of security for El Gamal encryption shows that cx
1
(wherec1is the ﬁrst component of the ciphertext, and xis the private key of
the receiver) is alreadyindistinguishable from a uniform groupelement, so the
sender/receiver may as well use that. Construction 11.19 illustrates the KEMPublic-Key Encryption 405
that follows this approach. Note that the resulting encapsulation consists of
just asinglegroupelement. In contrast, ifweweretouseElGamalencryption
of a uniform group element, the ciphertext would contain two group elements.
CONSTRUCTION 11.19
LetGbe as in the previous section. Deﬁne a KEM as follows:
•Gen: on input 1nrunG(1n) to obtain ( G,q,g). choose a uniform
x∈Zqand seth:=gx. Also specify a function H:G→{0,1}/lscript(n)
for some function /lscript(see text). The public key is /angbracketleftG,q,g,h,H/angbracketrightand
the private key is /angbracketleftG,q,g,x/angbracketright.
•Encaps: on inputa public key pk=/angbracketleftG,q,g,h,H/angbracketrightchoose a uniform
y∈Zqand output the ciphertext gyand the key H(hy).
•Decaps: on input a private key sk=/angbracketleftG,q,g,x/angbracketrightand a ciphertext
c∈G, output the key H(cx).
An “El Gamal-like” KEM.
Asdescribed, the construction leavesthe key-derivation function Hunspec-
iﬁed, and there are several options for it. (See Section 5.6.4 for more on key
derivation in general.) One possibility is to choose a function H:G→{0,1}/lscript
that is (close to) regular, meaning that for each possible key k∈{0,1}/lscriptthe
number of group elements that map to kis approximately the same. (For-
mally, we need a negligible function neglsuch that for each k∈{0,1}/lscript
2/lscript·/vextendsingle/vextendsinglePr[H(g) =k]−2−/lscript/vextendsingle/vextendsingle≤negl(n),
where the probability is taken over uniform choice of g∈G. This ensures
that the distribution on the key kis statistically close to uniform.) Both the
complexity of H, as well as the achievable key length /lscript, will depend on the
speciﬁc group Gbeing used.
A second possibility is to let Hbe akeyedfunction, where the (uniform)
key forHis included as part of the receiver’s public key. This works if His
a strong extractor, as mentioned brieﬂy in Section 5.6.4. Appropriate choice
of/lscripthere (to ensure that the resulting key is statistically close to uniform) will
depend on the size of G.
In either of the above cases, a proof of CPA-security based on the decisional
Diﬃe–Hellman (DDH) assumption follows easily by adapting the proof of
security for the Diﬃe–Hellman key-exchange protocol (Theorem 10.3).
THEOREM 11.20 If the DDH problem is hard relative to G, andHis
chosen as described, then Construction 11.19 is a CPA-secure KEM.
Ifoneis willingtomodel Hasarandom oracle , then Construction11.19can
be proven CPA-secure based on the (weaker) computational Diﬃe–Hellman
(CDH) assumption. We discuss this in the following section.406 Introduction to Modern Cryptography
11.4.3 *A CDH-Based KEM in the Random-Oracle Model
In this section, we show that if one is willing to model Has arandom
oracle, then Construction 11.19 can be proven CPA-secure based on the CDH
assumption. (Readers may want to review Section 5.5 to remind themselves
of the random-oracle model.) Intuitively, the CDH assumption implies that
an attacker observing h=gx(from the public key) and the ciphertext c=gy
cannot compute DHg(h,c) =hy. In particular, then, anattackercannot query
hyto the random oracle. But this means that the encapsulated key H(hy) is
completely random from the attacker’s point of view. This intuition is turned
into a formal proof below.
As indicated by the intuition above, the proof inherently relies on modeling
Has a random oracle.3Speciﬁcally, the proof relies on the facts that (1) the
only way to learn H(hy) is to explicitly query hytoH, which would mean
that the attacker has solved a CDH instance (this is called “extractability” in
Section 5.5.1), and (2) if an attacker does notqueryhytoH, then the value
H(hy) is uniform from the attacker’s point of view. These properties only
hold—indeed, they only make sense—if His modeled as a random oracle.
THEOREM 11.21 If the CDH problem is hard relative to G, andHis
modeled as a random oracle, then Construction 11.19 is CPA-secure.
PROOF Let Π denote Construction 11.19, and let Abe apptadversary.
We want to show that there is a negligible function neglsuch that
Pr[KEMcpa
A,Π(n) = 1]≤1
2+negl(n).
The above probability is also taken over uniform choice of the function H, to
whichAis given oracle access.
Consider an execution of experiment KEMcpa
A,Π(n) in which the public key
is/angbracketleftG,q,g,h/angbracketrightand the ciphertext is c=gy, and let Querybe the event that A
queriesDHg(h,c) =hytoH. We have
Pr[KEMcpa
A,Π(n) = 1] = Pr[ KEMcpa
A,Π(n) = 1∧Query]
+Pr[KEMcpa
A,Π(n) = 1∧Query]
≤Pr[KEMcpa
A,Π(n) = 1∧Query]+Pr[Query].(11.18)
If Pr[Query]= 0 then Pr[ KEMcpa
A,Π(n) = 1∧Query]= 0. Otherwise,
Pr[KEMcpa
A,Π(n) = 1∧Query]= Pr[KEMcpa
A,Π(n) = 1|Query]·Pr[Query]
≤Pr[KEMcpa
A,Π(n) = 1|Query].
3This is true as long as we wish to rely only on the CDH assumption. As noted earlier, a
proof without random oracles is possible if we rely on the stronger DDH assumption.Public-Key Encryption 407
In experiment KEMcpa
A,Π(n), the adversaryAis given the public key and the
ciphertext, plus either the encapsulated key kdef=H(hy) or a uniform key. If
Querydoes not occur, then kis uniformly distributed from the perspective of
the adversary, and so there is no way Acan distinguish between these two
possibilities. This means that
Pr[KEMcpa
A,Π(n) = 1|Query]=1
2.
Returning to Equation (11.18), we thus have
Pr[KEMcpa
A,Π(n) = 1]≤1
2+Pr[Query].
We next show that Pr[ Query] is negligible, completing the proof.
Lett=t(n) be a (polynomial) upper bound on the number of queries that
Amakes to the random oracle H. Deﬁne the following pptalgorithmA/primefor
the CDH problem relative to G:
Algorithm A/prime:
The algorithm is given G,q,g,h,c as input.
•Setpk=/angbracketleftG,q,g,h/angbracketrightand choose a uniform k∈{0,1}/lscript.
•RunA(pk,c,k). WhenAmakes a query to H, answer it by
choosing a fresh, uniform /lscript-bit string.
•At theend ofA’sexecution, let y1,...,y tbethe listofqueries
thatAhas made to H. Choose a uniform index i∈{1,...,t}
and output yi.
We are interested in the probability with which A/primesolves the CDH problem,
i.e., Pr[A/prime(G,q,g,h,c ) =DHg(h,c)], wherethe probabilityistakenover G,q,g
output byG(1n), uniform h,c∈G, and the randomness of A/prime. To analyze
this probability, note ﬁrst that event Queryis still well-deﬁned in the execu-
tion ofA/prime, even thoughA/primecannot detect whether it occurs. Moreover, the
probability of event QuerywhenAis run as a sub-routine by A/primeis identical
to the probability of event Queryin experiment KEMcpa
A,Π(n). This follows be-
cause the view of Ais identical in both cases until event Queryoccurs: in each
case,G,q,gare output byG(1n); in each case, handcare uniform elements
ofGandkis a uniform, /lscript-bit string; and in each case, queries to Hother
thanH(DHg(h,c)) are answered with a uniform /lscript-bit string. (In KEMcpa
A,Π(n),
the query H(DHg(h,c)) is answered with the actual encapsulated key, which
is equal to kwith probability 1 /2, whereas when Ais run as a subroutine
byA/primethe query H(DHg(h,c)) is answered with a uniform /lscript-bit string that is
independent of k. But when this query is made, event Queryoccurs.)
Finally, observe that when Queryoccurs then DHg(h,c)∈{y1,...,y t}by
deﬁnition, and so A/primeoutputs the correct result DHg(h,c) with probability at408 Introduction to Modern Cryptography
least 1/t. We therefore conclude that
Pr[A/prime(G,q,g,h,c ) =DHg(h,c)]≥Pr[Query]/t,
or Pr[Query]≤t·Pr[A/prime(G,q,g,h,c ) =DHg(h,c)]. Since the CDH problem
is hard forG, this latter probability is negligible; since tis polynomial, this
implies that Pr[ Query] is negligible as well. This completes the proof.
In the next section we will see that Construction 11.19 can be shown to be
CCA-secure under a stronger variant of the CDH assumption (if we continue
to model Has a random oracle).
11.4.4 Chosen-Ciphertext Security and DHIES/ECIES
TheElGamalencryptionschemeisvulnerabletochosen-ciphertextattacks.
This follows from the fact that it is malleable . Recall that an encryption
scheme is malleable, informally, if given a ciphertext cthat is an encryption
of some unknown message m, it is possible to generate a modiﬁed ciphertext
c/primethat is an encryption of a message m/primehaving some known relation to m.
In the case of El Gamal encryption, consider an adversary Awho intercepts
a ciphertext c=/angbracketleftc1,c2/angbracketrightencrypted using the public key pk=/angbracketleftG,q,g,h/angbracketright, and
who then constructs the modiﬁed ciphertext c/prime=/angbracketleftc1,c/prime
2/angbracketrightwherec/prime
s=c2·α
for some α∈G. Ifcis an encryption of a message m∈G(which may be
unknown toA), we have c1=gyandc2=hy·mfor some y∈Zq. But then
c1=gyandc/prime
2=hy·(α·m),
and soc/primeis a valid encryption of the message α·m. In other words, Acan
transform an encryption of the (unknown) message minto an encryption of
the (unknown) message α·m. As discussed in Scenario 3 in Section 11.2.3,
this sort of attack can have serious consequences.
The KEMdiscussed in the previoussection might alsobe malleable depend-
ing on the speciﬁc key-derivation function Hbeing used. If His modeled as
a random oracle, however, then such attacks no longer seem possible. In fact,
one can prove in this case that Construction 11.19 is CCA-secure based on
the so-called gap-CDH assumption . Recall that the CDH assumption says
that given group elements gxandgy(for some generator g), it is infeasible to
compute gxy. The gap-CDH assumption saysthat this remainsinfeasible even
given accessto an oracle Osuch thatO(U,V) returns 1 exactly when V=Uy.
Stated diﬀerently, the CDH problem remains hard even given an oracle that
solves the DDH problem. (We do not give a formal deﬁnition since we will
not use this assumption in the rest of the book.) This assumption is believed
to hold for the classes of groups we have discussed in this book. A proof of
the following is very similar to the proof of Theorem 11.38.Public-Key Encryption 409
THEOREM 11.22 If the gap-CDH problem is hard relative to G, andHis
modeled as a random oracle, then Construction 11.19 is a CCA-secure KEM.
It is interesting to observe that the same construction (namely, Construc-
tion 11.19) can be analyzed under diﬀerent assumptions and in diﬀerent mod-
els, yielding diﬀerent results. Assuming only that the DDH problem is hard
(and for Hchosen appropriately), the scheme is CPA-secure. If we model H
as a random oracle (which imposes more stringent requirements on H), then
under the weaker CDH assumption we obtain CPA-security, and under the
stronger gap-CDH assumption we obtain CCA-security.
CONSTRUCTION 11.23
LetGbe as in the text. Let Π E= (Enc/prime,Dec/prime) be a private-key en-
cryption scheme, and let Π M= (Mac,Vrfy) be a message authentication
code. Deﬁne a public-key encryption scheme as follows:
•Gen: On input 1nrunG(1n) to obtain ( G,q,g). choose a uniform
x∈Zq, seth:=gx, and specify a function H:G→{0,1}2n. The
public key is/angbracketleftG,q,g,h,H/angbracketrightand the private key is /angbracketleftG,q,g,x,H/angbracketright.
•Enc: On input a public key pk=/angbracketleftG,q,g,h,H/angbracketright, choose a uniform
y∈Zqand setkE/bardblkM:=H(hy). Compute c/prime←Enc/prime
kE(m), and
output the ciphertext /angbracketleftgy,c/prime,MackM(c/prime)/angbracketright.
•Dec: On input a private key sk=/angbracketleftG,q,g,x,H/angbracketrightand a ciphertext
/angbracketleftc,c/prime,t/angbracketright, output⊥ifc/negationslash∈G. Else, compute kE/bardblkM:=H(cx). If
VrfykM(c/prime,t)/negationslash= 1 then output⊥; otherwise, output Dec/prime
kE(c/prime).
DHIES/ECIES.
CCA-secure encryption with Construction 11.19. CombiningtheKEM
in Construction 11.19 with any CCA-secure private-key encryption scheme
yields a CCA-secure public-key encryption scheme. (See Theorem 11.14.)
Instantiating this approach using Construction 4.18 for the private-key com-
ponentmatcheswhatisdonein DHIES/ECIES,variantsofwhichareincluded
in the ISO/IEC 18033-2 standard for public-key encryption. (See Construc-
tion 11.23.) Encryption of a message min these schemes takes the form
/angbracketleftgy,Enc/prime
kE(m),MackM(c/prime)/angbracketright,
whereEnc/primedenotes a CPA-secure private-key encryption scheme and c/primede-
notesEnc/prime
kE(m). DHIES, the Diﬃe–Hellman Integrated Encryption Scheme ,
can be used generically to refer to any scheme of this form, or to refer specif-
ically to the case when the group Gis a cyclic subgroup of a ﬁnite ﬁeld.
ECIES, the Elliptic Curve Integrated Encryption Scheme , refers to the case
whenGis an elliptic-curve group. We remark that, in Construction 11.23, it
is critical to check during decryption that c, the ﬁrst component of the cipher-
text, is in G. Otherwise, an attacker might request decryption of a malformed410 Introduction to Modern Cryptography
ciphertext/angbracketleftc,c/prime,t/angbracketrightin which c/negationslash∈G; decrypting such a ciphertext (i.e., without
returning⊥) might leak information about the private key.
By Theorem 4.19, encrypting a message and then applying a (strong) mes-
sage authentication code yields a CCA-secure private-key encryption scheme.
Combining this with Theorem 11.14, we conclude:
COROLLARY 11.24 LetΠEbe a CPA-secure private-key encryption
scheme, and let ΠMbe a strongly secure message authentication code. If the
gap-CDH problem is hard relative to G, andHis modeled as a random oracle,
then Construction 11.23 is a CCA-secure public-key encryption scheme.
11.5 RSA Encryption
Inthis section we turn our attention to encryption schemes based on the
RSA assumption deﬁned in Section 8.2.4. We remark that although RSA-
based encryption is in widespread use today, there is also currently a gradual
shift away from using RSA—and toward using CDH/DDH-based cryptosys-
tems relying on elliptic-curve groups—because of the longer key lengths re-
quired for RSA-based schemes. We refer to Section 9.3 for further discussion.
11.5.1 Plain RSA
We begin by describing a simple encryption scheme based on the RSA
problem. Although the scheme is insecure, it provides a useful starting point
for the secure schemes that follow.
LetGenRSA be apptalgorithm that, on input 1n, outputs a modulus N
that is the product of two n-bit primes, along with integers e,dsatisfying
ed= 1 mod φ(N). (As usual, the algorithm may fail with negligible probabil-
ity but we ignore that here.) Recall from Section 8.2.4 that such an algorithm
can be easily constructed from any algorithm GenModulus that outputs a
composite modulus Nalong with its factorization; see Algorithm 11.25.
ALGORITHM 11.25
RSA key generation GenRSA
Input:Security parameter 1n
Output: N,e,das described in the text
(N,p,q)←GenModulus (1n)
φ(N) := (p−1)(q−1)
choosee >1 such that gcd( e,φ(N)) = 1
compute d:= [e−1modφ(N)]
returnN,e,dPublic-Key Encryption 411
LetN,e,dbe as above, and let c=memodN. RSA encryption relies
on the fact that someone who knows dcan recover mfromcby computing
[cdmodN]; this works because
cd= (me)d=med=mmodN,
as discussed in Section 8.2.4. On the other hand, withoutknowledge of d
(even ifNandeare known) the RSA assumption (cf. Deﬁnition 8.46) implies
that it is diﬃcult to recover mfromc, at least if mis chosen uniformly
fromZ∗
N. This naturally suggests the public-key encryption scheme shown as
Construction 11.26: The receiver runs GenRSA to obtain N,e,d; it publishes
Nandeasitspublic key, andkeeps dinits privatekey. Toencryptamessage4
m∈Z∗
N, a sender computes the ciphertext c:= [memodN]. As we have just
noted, the receiver—who knows d—can decrypt cand recover m.
CONSTRUCTION 11.26
LetGenRSAbe as in the text. Deﬁne a public-key encryption scheme as
follows:
•Gen: on input 1nrunGenRSA(1n) to obtain N,e, andd. The
public key is/angbracketleftN,e/angbracketrightand the private key is /angbracketleftN,d/angbracketright.
•Enc: on input a public key pk=/angbracketleftN,e/angbracketrightand a message m∈Z∗
N,
compute the ciphertext
c:= [memodN].
•Dec: on input a private key sk=/angbracketleftN,d/angbracketrightand a ciphertext c∈Z∗
N,
compute the message
m:= [cdmodN].
The plain RSA encryption scheme.
The following gives a worked example of the above (see also Example 8.49).
Example 11.27
SayGenRSA outputs ( N,e,d) = (391,3,235). (Note that 391 = 17 ·23 and so
φ(391) = 16·22 = 352. Moreover, 3 ·235 = 1 mod 352.) So the public key is
(391,3) and the private key is (391 ,235).
To encrypt the message m= 158∈Z∗
391using the public key (391 ,3), we
simply compute c:= [1583mod 391] = 295; this is the ciphertext. To decrypt,
the receiver computes [295235mod 391] = 158. ♦
Is the plain RSA encryption scheme secure? The factoring assumption im-
plies that it is computationally infeasible for an attacker who is given the
4Weassume that m∈Z∗
N. If factoring Nis hard, it is computationally diﬃcult to ﬁnd an
m∈ {1,...,N−1}withm/negationslash∈Z∗
N(since then gcd( m,N) is a nontrivial factor of N).412 Introduction to Modern Cryptography
public key to derive the corresponding private key; see Section 8.2.5. This is
necessary—but not suﬃcient—for a public-key encryption scheme to be se-
cure. The RSA assumption implies that if the message mischosen uniformly
fromZ∗
Nthen an eavesdropper given N,e, andc(namely, the public key and
the ciphertext) cannot recover m. But these are weak guarantees, and fall
far short of the level of security we want! In particular, they leave open the
possibility that an attacker can recover the message when it is notchosen
uniformly from Z∗
N(indeed, when mis chosen from a small range it is easy to
see that an attacker can compute mfrom the public key and ciphertext). In
addition, it does not rule out the possibility that an attacker can learn partial
information about the message, even when it is uniform (in fact, this is known
to be possible). Moreover, plain RSA encryption is deterministic and so must
be insecure, as we have already discussed in Section 11.2.1.
More Attacks on Plain RSA
We have already noted that plain RSA encryption is not CPA-secure. Nev-
ertheless, theremaybe atemptation touse plainRSA forencrypting“random
messages” and/or in situations where leaking a few bits of information about
the message is acceptable. We warn against this in general, and provide here
just a few examples of what can go wrong.
(Some of the attacks that follow assume e= 3. In some cases the attacks
can be extended, at least partially, to larger e; in any case, as noted in Sec-
tion 8.2.4, setting e= 3 is often done in practice. The attacks should be taken
asdemonstratingthat Construction11.26isinadequate, notasindicatingthat
settinge= 3 is necessarily a bad choice.)
A quadratic improvement in recovering m.Since plain RSA encryption
is deterministic, we know that if m < B then an attacker can determine
mfrom the ciphertext c= [memodN] in timeO(B) using the brute-force
attack discussed in Section 11.2.1. One might hope, however, that plain RSA
encryption can be used if Bis large, i.e., if the message is chosen from a
reasonably large set of values. One possible scenario where this might occur
is in the context of hybrid encryption (see Section 11.3), where the “message”
is a random n-bit key and so B= 2n. Unfortunately, there is a clever attack
that recovers m, with high probability, in time roughly O(√
B). This can
make a signiﬁcant diﬀerence in practice: a 280-time attack (say) is infeasible,
but an attack running in time 240is relatively easy to carry out.
A description of the attack is given as Algorithm 11.28. In our description,
we assume B= 2nand letα∈(1
2,1)denote some ﬁxed constant (see below).
The time complexity of the algorithm is dominated by the time required
to sort the 2αnpairs (r,xr); this can be done in time O(n·2αn). Binary
search is used in the second-to-last line to check whether there exists an r
withxr= [semodN].
We now sketch why the attack recovers mwith high probability. Let c=Public-Key Encryption 413
ALGORITHM 11.28
Anattack on plain RSA encryption
Input:Public key/angbracketleftN,e/angbracketright; ciphertext c
Output: m <2nsuch that me=cmodN
setT:= 2αn
forr= 1 toT:
xr:= [c/remodN]
sortthe pairs{(r,xr)}T
r=1by their second component
fors= 1 toT:
ifxr?= [semodN] for some r
return[r·smodN]
memodN.For appropriate choice of α >1
2,itcan be shown that if m
is a uniform n-bit integer then with high probability there exist r,swith
1< r≤s≤2αnfor which m=r·s. (For example, if n= 64 and so mis a
random 64-bit string, then with probability 0 .35 there exist r,sof length at
most 34 bits such that m=r·s. See the references at the end of the chapter
for details.) Assuming this to be the case, the above algorithm ﬁnds msince
c=me= (r·s)e=re·semodN,
and soxr=c/re=semodNwithr,s < T.
Encrypting short messages using small e.The previous attack shows
how to recover a message mknown to be smaller than some bound Bin time
roughlyO(√
B). Here we show how to do the same thing in time poly(/bardblN/bardbl)
ifB≤N1/e(where this means the eth root of Nas a real number).
The attack relies on the observation that when m < N1/e, raising mto the
eth power modulo Ninvolves no modular reduction; i.e., [ memodN] is equal
to the integer me. This means that given the ciphertext c= [memodN], an
attacker can determine mby computing m:=c1/eover the integers (i.e., not
moduloN); thiscanbedoneeasilyintime poly(/bardblc/bardbl) =poly(/bardblN/bardbl)sinceﬁnding
eth roots is easy over the integers and hard only when working mod N.
For small ethis represents a serious weakness of plain RSA encryption. For
example, if we take e= 3 and assume/bardblN/bardbl≈1024 bits, then the attack works
even when mis a uniform 300-bit integer; this once again rules out security
of plain RSA even when used as part of a hybrid encryption scheme.
Encrypting a partially known message. This attack can be viewed as
a generalization of the previous one. It assumes a sender who encrypts a
message, part of which is known (something that should not result in an
attack when using a secure encryption scheme). Here we rely on a powerful
result of Coppersmith that we state without proof:
THEOREM 11.29 Letp(x)be a polynomial of degree e. Then in time
poly(/bardblN/bardbl,e)one can ﬁnd all msuch that p(m) = 0 mod Nand|m|≤N1/e.414 Introduction to Modern Cryptography
Due to the dependence of the running time on e, the attack is only practical
for small e. In what follows we assume e= 3 for concreteness.
Assume a sender encrypts a message m=m1/bardblm2to a receiver with public
key/angbracketleftN,3/angbracketright, where the ﬁrst portion m1of the message is known but the second
portionm2is not. For concreteness, say m2iskbits long, so m=B·m1+m2
where we let B= 2k. Given the resulting ciphertext c= [(m1/bardblm2)3modN],
an eavesdroppercan deﬁne p(x)def= (2k·m1+x)3−c, a cubic polynomial. This
polynomial has m2as a root (modulo N), and|m2|< B. Theorem 11.29 thus
implies that the attacker can compute m2eﬃciently as long as B≤N1/3.
A similar attack works when m2is known but m1is not.
Encrypting related messages.5Thisattackassumesasenderwhoencrypts
two related messages to the same receiver (something that should not result
in an attack when using a secure encryption scheme). Assume the sender
encrypts both mandm+δto a receiver with public key /angbracketleftN,e/angbracketright, where the
oﬀsetδis known but mis not. Given the two ciphertexts c1= [memodN]
andc2= [(m+δ)emodN], an eavesdropper can deﬁne the two polynomials
f1(x)def=xe−c1andf2(x)def= (x+δ)e−c2(modulo N), each of degree e.
Note that x=mis a root (modulo N) of both polynomials, and so the linear
term (x−m) is a factor of both. Thus, if the greatest common divisor of f1(x)
andf2(x) (as polynomials over Z∗
N) is linear, it will reveal m. The greatest
common divisor can be computed in time poly(/bardblN/bardbl,e) using an algorithm
similar to the one in Appendix B.1.2; thus, this attack is feasible for small e.
Sending the same message to multiple receivers.6Our ﬁnal attack
assumes a sender who encrypts the same message to multiple receivers (some-
thing that, once again, should not result in an attack when using a secure
encryption scheme). Let e= 3, and say the same message mis encrypted to
three diﬀerent parties holding public keys pk1=/angbracketleftN1,3/angbracketright,pk2=/angbracketleftN2,3/angbracketright, and
pk3=/angbracketleftN3,3/angbracketright, respectively. Assume gcd( Ni,Nj) = 1 for distinct i,j; if not,
then at least one of the moduli can be factored immediately and the message
mcan be easily recovered. An eavesdropper sees
c1= [m3modN1], c2= [m3modN2],andc3= [m3modN3].
LetN∗=N1N2N3. An extended version of the Chinese remainder theorem
says that there exists a unique non-negative integer ˆ c < N∗such that
ˆc=c1modN1
ˆc=c2modN2
ˆc=c3modN3.
5This attack relies on some algebra slightly beyond what we have covered in this book.
6This attack relies on the Chinese remainder theorem presented in Section 8.1.5.Public-Key Encryption 415
Moreover, using techniques similar to those shown in Section 8.1.5 it is pos-
sible to compute ˆ ceﬃciently given the public keys and the above cipher-
texts. Note ﬁnally that m3satisﬁes the above equations, and m3< N∗since
m <min{N1,N2,N3}. As in the previous attack, this means that ˆ c=m3
over the integers (i.e., with no modular reduction taking place), and so the
message mcan be recovered by computing the integer cube root of ˆ c.
11.5.2 Padded RSA and PKCS #1 v1.5
Although plain RSA is insecure, it does suggest one general approach to
public-key encryption based on the RSA problem: to encrypt a message m
using public key/angbracketleftN,e/angbracketright, ﬁrst map mto an element ˆ m∈Z∗
N; then compute the
ciphertext c= [ˆmemodN]. To decrypt a ciphertext c, the receiver computes
ˆm= [cdmodN] and then recovers the original message m. For the receiver
to be able to recover the message, the mapping from messages to elements
ofZ∗
Nmust be (eﬃciently) reversible . For a scheme following this approach
to have a hope of being CPA-secure, the mapping must be randomized so
encryption is not deterministic. This is, of course, a necessary condition but
not a suﬃcient one, and security of the encryption scheme depends critically
on the speciﬁc mapping that is used.
One simple implementation of the above idea is to randomly pad the mes-
sage before encrypting. That is, to map a message m(viewed as a bit-string)
to an element of Z∗
N, the sender chooses a uniform bit-string r∈{0,1}/lscript(for
some appropriate /lscript) and sets ˆ m:=r/bardblm; the resulting value can naturally be
interpreted as an integer in Z∗
N, and this mapping is clearly reversible. See
Construction 11.30. (The bounds on /lscript(n) and the length of mensure that the
integer ˆmis smaller than N.)
The construction is parameterized by a value /lscriptthat determines the length
of the random padding used. Security of the scheme depends on /lscript. There is
an obvious brute-force attack on the scheme that runs in time 2/lscript, so if/lscriptis too
short (in particular, if /lscript(n) =O(logn)), the scheme is insecure. At the other
extreme, we show in the following section (essentially) that when the padding
is as large as possible, and mis just a single bit, then it is possible to prove
security based on the RSA assumption. In intermediate cases, the situation
is less clear: for certain ranges of /lscriptwe cannot prove security based on the
RSA assumption but no polynomial-time attacks are known either. We defer
further discussion until after our treatment of PKCS #1 v1.5 next.
RSA PKCS #1 v1.5. TheRSA Laboratories Public-Key Cryptography
Standard (PKCS) #1 version 1.5 , issued in 1993, utilizes a variant of padded
RSA encryption. For a public key pk=/angbracketleftN,e/angbracketrightof the usual form, let kdenote
the length of Nin bytes; i.e., kis the integer satisfying 28(k−1)≤N <28k.
Messages mto be encrypted are assumed to be a multiple of 8 bits long and
can have length anywhere from one to k−11 bytes. Encryption of a message416 Introduction to Modern Cryptography
CONSTRUCTION 11.30
LetGenRSAbe as before, and let /lscriptbe a function with /lscript(n)≤2n−4 for
alln. Deﬁne a public-key encryption scheme as follows:
•Gen: on input 1n, runGenRSA(1n) to obtain ( N,e,d). Output the
public key pk=/angbracketleftN,e/angbracketright, and the private key sk=/angbracketleftN,d/angbracketright.
•Enc: on input a public key pk=/angbracketleftN,e/angbracketrightand a message
m∈{0,1}/bardblN/bardbl−/lscript(n)−2, choose a uniform string r∈{0,1}/lscript(n)and
interpret ˆ m:=r/bardblmas an element of Z∗
N. Output the ciphertext
c:= [ˆmemodN].
•Dec: on input a private key sk=/angbracketleftN,d/angbracketrightand a ciphertext c∈Z∗
N,
compute
ˆm:= [cdmodN],
and output the/bardblN/bardbl−/lscript(n)−2 least-signiﬁcant bits of ˆ m.
The padded RSA encryption scheme.
mthat isD-bytes long is computed as
[(0x00/bardbl0x02/bardblr/bardbl0x00/bardblm)emodN],
whereris a randomly generated, ( k−D−3)-byte string with none of its bytes
equalto0x00. (Thislatterconditionenablesthemessagetobeunambiguously
recovered upon decryption.) Note that the maximum allowed length of m
ensures that the length of ris at least 8 bytes.
Unfortunately, PKCS #1 v1.5 as speciﬁed is not CPA-secure because it
allows using random padding that is too short. This is best illustrated by
showingthat an attackercan determine the initial portion ofa messageknown
to have many trailing 0s. For simplicity, say m=b/bardbl0···0/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright
Lwhereb∈{0,1}is
unknown and mis as long as possible (so L= 8·(k−11)−1). Encryption of
mgives a ciphertext cwith
c= (0x00/bardbl0x02/bardblr/bardbl0x00/bardblb/bardbl0···0)emodN.
An attacker can compute c/prime=c/(2L)emodN; note that
c/prime=/parenleftbigg0x00/bardbl0x02/bardblr/bardbl0x00/bardblb/bardbl0···0
10···0/parenrightbigge
=(0x00/bardbl0x02/bardblr/bardbl0x00/bardblb)emodN.
The integer 0x02/bardblr/bardbl0x00/bardblbis 75 bits long (note that 0x02= 00000010, and
all the high-order 0-bits don’t count), and so an attacker can now apply the
“short-message attack,” or the attack based on encrypting a partially known
message, from the previous section. To avoid these attacks we need to take
rof length at least /bardblN/bardbl/e. Even if eis large, however, the “quadratic-
improvement attack”from the previoussection showsthat rcan be recovered,
with high probability, in time roughly 2/bardblr/bardbl/2.Public-Key Encryption 417
If we force rto be roughly half the length of N, and correspondingly re-
duce the maximum message length, then it is reasonable to conjecture that
the encryption scheme in PKCS #1 v1.5 is CPA-secure. (We stress, however,
that no proof of security based on the RSA assumption is known.) Neverthe-
less, because of a serious chosen- ciphertext attack on the scheme, described
brieﬂy in Section 11.5.5, newer versions of the PKCS #1 standard have been
introduced and should be used instead.
11.5.3 *CPA-Secure Encryption without Random Oracles
In this section we show an encryption scheme that can be proven to be
CPA-secure based on the RSA assumption. We begin by describing a speciﬁc
hard-core predicate (see Section 7.1.3) for the RSA problem and then show
how to use that hard-core predicate to encrypt a single bit. We then extend
this scheme to give a KEM.
The schemes described in this section are mainly of theoretical interest and
are not used in practice. This is because they are less eﬃcient than alterna-
tive RSA-based constructions that can be proven secure in the random-oracle
model (cf. Section 5.5). We will see examples of such encryption schemes in
the sections that follow.
A hard-core predicate for the RSA problem. Loosely speaking, the
RSA assumption saysthat given N,e, and [xemodN] (forxchosenuniformly
fromZ∗
N), it is infeasible to recover x. By itself, this says nothing about the
computational diﬃculty of computing some speciﬁc information about x. Can
we isolate some particular bit of information about xthat is hard to compute
fromN,eand [xemodN]? The notion of a hard-core predicate captures ex-
actlythisrequirement. (Hard-corepredicateswereintroducedinSection7.1.3.
The fact that the RSA assumption gives a family of one-way permutations
is discussed in Section 8.4.1. Our treatment here is self-contained, however.)
It turns out that the least-signiﬁcant bit of x, denoted lsb(x), is a hard-core
predicate for the RSA problem.
Deﬁne the following experiment for a given algorithm GenRSA (with the
usual behavior) and algorithm A:
The RSA hard-core predicate experiment RSA-lsbA,GenRSA(1n):
1. RunGenRSA(1n)to obtain (N,e,d).
2. choose a uniform x∈Z∗
Nand compute y:= [xemodN].
3.Ais givenN,e,y, and outputs a bit b.
4. The output of the experiment is 1if and only if lsb(x) =b.
Observe that lsb(x) is a uniform bit when x∈Z∗
Nis uniform.Acan
guesslsb(x) with probability 1 /2 by simply outputting a uniform bit b. The
following theorem states that if the RSA problem is hard, then no eﬃcient418 Introduction to Modern Cryptography
algorithmAcan do signiﬁcantly better than this; i.e., the least-signiﬁcant bit
is a hard-core predicate of the RSA permutation.
THEOREM 11.31 If the RSA problem is hard relative to GenRSA then
for all probabilistic polynomial-time algorithms Athere is a negligible function
neglsuch that Pr[RSA-lsbA,GenRSA(n) = 1]≤1
2+negl(n).
A full proof of this theorem is beyond the scope of this book. However,
we provide some intuition for the theorem by sketching a proof of a weaker
result: that the RSA assumption implies Pr[ RSA-lsbA,GenRSA(n) = 1]<1 for
all probabilistic polynomial-time A. To prove this we show that an eﬃcient
algorithm that alwayscorrectly computes lsb(r) fromN,e, and [remodN]
can be used to eﬃciently recover x(in its entirety) from N,e, and [xemodN].
FixNande, and letAbe an algorithm such that A([remodN]) =lsb(r).
GivenN,e, andy= [xemodN], we will recoverthe bits of xone-by-one,from
least to most signiﬁcant. To determine lsb(x) we simply runA(y). There are
now two cases:
Case 1: lsb(x) = 0.Note that y/2e= (x/2)emodN, and because xis even
(i.e.,lsb(x) = 0), 2 divides the integer x. Sox/2 is just the right-wise bit-shift
ofx, andlsb(x/2) is equal to 2sb(x), the 2nd-least-signiﬁcant bit of x. So we
can obtain 2sb(x) by computing y/prime:= [y/2emodN] and then running A(y/prime).
Case 2: lsb(x) = 1.Here [x/2 modN] = (x+N)/2. Solsb([x/2 modN])
is equal to 2sb(x+N); the latter is equal to 1 ⊕2sb(N)⊕2sb(x) (we have
a carry bit in the second position because both xandNare odd). So if we
compute y/prime:= [y/2emodN], then2sb(x) =A(y/prime)⊕1⊕2sb(N).
Continuing in this way, we can recover all the bits of x.
Encrypting one bit. We can use the hard-core predicate identiﬁed above
to encrypt a single bit. The idea is straightforward: to encrypt the message
m∈{0,1}, the sender chooses uniform r∈Z∗
Nsubject to the constraint that
lsb(r) =m; the ciphertext is c:= [remodN]. See Construction 11.32.
THEOREM 11.33 If the RSA problem is hard relative to GenRSA then
Construction 11.32 is CPA-secure.
PROOF Let Π denote Construction 11.32. We prove that Π has indistin-
guishable encryptions in the presence of an eavesdropper; by Proposition11.3,
this implies it is CPA-secure.
LetAbe a probabilistic polynomial-time adversary. Without loss of gener-Public-Key Encryption 419
CONSTRUCTION 11.32
LetGenRSAbe as usual, and deﬁne a public-key encryption scheme as
follows:
•Gen: on input 1n, runGenRSA(1n) to obtain ( N,e,d). Output the
public key pk=/angbracketleftN,e/angbracketright, and the private key sk=/angbracketleftN,d/angbracketright.
•Enc: on input a public key pk=/angbracketleftN,e/angbracketrightand a message m∈{0,1},
choose a uniform r∈Z∗
Nsubject to theconstraint that lsb(r) =m.
Output the ciphertext c:= [remodN].
•Dec: on input a private key sk=/angbracketleftN,d/angbracketrightand a ciphertext c, com-
puter:= [cdmodN] and output lsb(r).
Single-bit encryption using a hard-core predicate for RSA.
ality, we may assume m0= 0 and m1= 1 in experiment PubKeav
A,Π(n). So
Pr[PubKeav
A,Π(n) = 1] =1
2·Pr[A(N,e,c) = 0|cis an encryption of 0]
+1
2·Pr[A(N,e,c) = 1|cis an encryption of 1] .
Consider running Ain experiment RSA-lsb. By deﬁnition,
Pr[RSA-lsbA,GenRSA(n) = 1] = Pr[A/parenleftbig
N,e,[remodN]/parenrightbig
=lsb(r)],
whereris uniform in Z∗
N. Since Pr[ lsb(r) = 1] = 1 /2, we have
Pr[RSA-lsbA,GenRSA(n) = 1] =1
2·Pr[A/parenleftbig
N,e,[remodN]/parenrightbig
= 0|lsb(r) = 0]
+1
2·Pr[A/parenleftbig
N,e,[remodN]/parenrightbig
= 1|lsb(r) = 1].
Noting that encrypting m∈{0,1}corresponds exactly to choosing uniform r
subject to the constraint that lsb(r) =m, we see that
Pr[PubKeav
A,Π(n) = 1] = Pr[ RSA-lsbA,GenRSA(n) = 1].
Theorem 11.31 thus implies that there is a negligible function neglsuch that
Pr[PubKeav
A,Π(n) = 1]≤1
2+negl(n),
as desired.
Constructing a KEM. Wenow show how to extend Construction 11.32 so
as to obtain a KEM with key length n. A naive way of doing this would be to
simply choosea uniform, n-bit keykand then encryptthe bits of kone-by-one420 Introduction to Modern Cryptography
usingninvocations of Construction 11.32. This would result in a rather long
ciphertext consisting of nelements of ZN.
A better approach is for the sender to apply the RSA permutation (namely,
raising to the eth power modulo N) repeatedly, starting from an initial, uni-
form value c1. That is, the sender will successively compute ce
1, followed by
(ce
1)e=ce2
1, and so on, up to cen
1(all modulo N). The ﬁnal value [ cen
1modN]
will be the ciphertext, and the sequence of bits lsb(c1),lsb(ce
1),...,lsb(cen−1
1)
is the key. To decrypt a ciphertext c, the receiver simply reverses this pro-
cess, successively computing cd,(cd)d=cd2up tocdn(again, all modulo N)
to recover the initial value c1=cdnused by the sender. Having recovered c1,
the receiver can then recompute ce
1,...,cen
1and obtain the key.
It is possible to implement decryption more eﬃciently using the fact that
the receiver knows the order of the group Z∗
N. At key-generation time, the
receiver can pre-compute d/prime:= [dnmodφ(N)] and store d/primeas part of its
private key. Then, rather than computing the nsuccessive modular expo-
nentiations cd,cd2,...to obtain c1, the receiver can instead directly compute
c1:= [cd/primemodN]. This works, of course, since
cdnmodN=c[dnmodφ(N)]=cd/primemodN.
The above is formally described as Construction 11.34.
CONSTRUCTION 11.34
LetGenRSAbe as usual, and deﬁne a KEM as follows:
•Gen: on input 1n, runGenRSA(1n) to obtain ( N,e,d). Then com-
puted/prime:= [dnmodφ(N)] (note that φ(N) can be computed from
(N,e,d) or obtained during the course of running GenRSA). Out-
putpk=/angbracketleftN,e/angbracketrightandsk=/angbracketleftN,d/prime/angbracketright.
•Encaps: on input pk=/angbracketleftN,e/angbracketrightand 1n, choose a uniform c1∈Z∗
N.
Then for i= 1,...,ndo:
1. Compute ki:=lsb(ci).
2. Compute ci+1:= [ce
imodN].
Output the ciphertext cn+1and the key k=k1···kn.
•Decaps: on input sk=/angbracketleftN,d/prime/angbracketrightand a ciphertext c, compute c1:=
[cd/primemodN]. Then for i= 1,...,ndo:
1. Compute ki:=lsb(ci).
2. Compute ci+1:= [ce
imodN].
Output the key k=k1···kn.
A KEM using a hard-core predicate for RSA.Public-Key Encryption 421
The construction is reminiscent of the approach used to construct a pseu-
dorandom generator from a one-way permutation toward the end of Sec-
tion 7.4.2. If we let fdenote the RSA permutation relative to some public key
/angbracketleftN,e/angbracketright(i.e.,f(x)def= [xemodN]), then CPA-security of Construction 11.34 is
equivalent to pseudorandomnessof lsb(fn−1(c1)),...,lsb(c1) even conditioned
on the value c=fn(c1). This, in turn, can be proven using Theorem 11.31
and the techniques from Section 7.4.2. (The only diﬀerence is that in Sec-
tion 7.4.2 the value fn(c1) was itself a uniform n-bit string, whereas here it
is a uniform element of Z∗
N. Pseudorandomness of the successive hard-core
predicates is independent of the domain of f.) Summarizing:
THEOREM 11.35 If the RSA problem is hard relative to GenRSA then
Construction 11.34 is a CPA-secure KEM.
Eﬃciency. Construction11.34isreasonablyeﬃcient. Tobeconcrete,assume
thatn= 128, the RSA modulus Nis 2048 bits long, and the public expo-
nenteis 3 so that exponentiation to the power emoduloNcan be computed
using two modular multiplications. (See Appendix B.2.3.) Encryption then
requires 2 n= 256 modular multiplications. Decryption can be done with one
full modular exponentiation (at the cost of approximately 1 .5·2048 = 3072
modular multiplications) plus an additional 256modular multiplications. The
cost of decryption is thus only about 8% less eﬃcient than for the plain RSA
encryption scheme. In contrast, encryption is signiﬁcantly more expensive
than in plain RSA, but in many applications decryption time is much more
crucial (since it may be implemented by a server that is performing thousands
of decryptions simultaneously).
11.5.4 OAEP and RSA PKCS #1 v2.0
WehavesofarnotconsideredRSA-basedencryptionschemesthatareCCA-
secure. We ﬁrst showthat all the RSA-based encryption schemeswehaveseen
so far are vulnerable to chosen-ciphertext attacks.
Plain RSA encryption. Plain RSA is not even CPA-secure. But it does
ensure that if m∈Z∗
Nis uniform then an attacker who eavesdrops on the
encryption c= [memodN] ofmwith respect to the public key /angbracketleftN,e/angbracketrightcannot
recoverm. Eventhisweakguaranteenolongerholdsinasettingwherechosen-
ciphertext attacks are possible. As in the case of El Gamal encryption, this is
a consequence of the fact that plain RSA is malleable : given the encryption
c= [memodN] of an unknown message m, it is easy to generate a ciphertext
c/primethat is an encryption of [2 mmodN] by setting
c/prime:= [2e·cmodN]
= 2e·me= (2m)emodN.422 Introduction to Modern Cryptography
RSA PKCS #1 v1.5. Padded RSA encryption, which is conjectured to be
CPA-secure for the right setting of the parameters, is vulnerable to essentially
the same attack as plain RSA encryption is. But there is also a more interest-
ing chosen-ciphertext attack on PKCS #1 v1.5 encryption that, in contrast to
the attack presented above, does notrequire full accessto a decryption oracle;
it only requires access to a “partial” decryption oracle that indicates whether
or not decryption of some ciphertext returns an error. This makes the attack
much more practical, as the attack can be carried out whenever an attacker
can distinguish the behavior of the receiver after a decryption success from its
behavior after a decryption failure, as in the case of the padding-oracle attack
shown in Section 3.7.2.
Recall that the public-key encryption scheme deﬁned in the PKCS #1 v1.5
standard uses a variant of padded RSA encryption where the padding is done
inaspeciﬁcway. Inparticular,thetwohigh-orderbytesofthepaddedmessage
are always 0x00/bardbl0x02. When decrypting, the receiver is supposed to check
that the two high-order bytes match these values, and return an error if this
is not the case. In 1998, Bleichenbacher developed a chosen-ciphertext attack
that exploits the fact that this check is done. Roughly, given a ciphertext c
that corresponds to an honest encryption of some unknown message mwith
respect to a public key /angbracketleftN,e/angbracketright, the attack repeatedly chooses uniform s∈Z∗
N
and submits the ciphertext c/prime:= [se·cmodN] to the receiver. Say c=
[ˆmemodN] where
ˆm=0x00/bardbl0x02/bardblr/bardbl0x00/bardblm,
asspeciﬁedbyPKCS#1v1.5. Thendecryptionof c/primewillgivetheintermediate
result ˆm/prime= [s·ˆmmodN], and the receiver will return an error unless the top
two bytes of ˆ m/primeare exactly 0x00/bardbl0x02. (Other checksare doneas well, but we
ignore those for simplicity.) Any time decryption succeeds, the attackerlearns
that the top two bytes of s·ˆmmodNare0x00/bardbl0x02, wheresis known. A
number ofequations ofthis type suﬃce for the attackerto learn ˆ mand recover
all of the original message m.
The CPA-secure KEM. In Section 11.5.3 we showed a construction of a
KEM that can be proven CPA-secure based on the RSA assumption. That
construction is also insecure against a chosen-ciphertext attack; we leave the
details as an exercise.
RSA-OAEP
In this section we explore a construction of RSA-based CCA-secure encryp-
tion using optimal asymmetric encryption padding (OAEP). The resulting
RSA-OAEP scheme follows the idea (used also in Section 11.5.2) of tak-
ing a message m, transforming it to an element ˆ m∈Z∗
N, and then letting
c= [ˆmemodN] be the ciphertext. The transformation here, however, isPublic-Key Encryption 423
/MT109/MT32/MT124/MT124/MT32/MT32/MT48/MT107/MT49
/MT71
/MT72/MT114
/MT115 /MT116
FIGURE 11.4 :The OAEP mechanism.
more complex than before. A version of RSA-OAEP has been standardized
as part of RSA PKCS #1 since version 2.0.
Let/lscript(n),k0(n),k1(n) be integer-valued functions with k0(n),k1(n) = Θ(n)
and such that /lscript(n) +k0(n) +k1(n) is less than the minimum bit-length of
moduli output by GenRSA(1n). Fixn, and let /lscript=/lscript(n),k0=k0(n), and
k1=k1(n). LetG:{0,1}k0→{0,1}/lscript+k1andH:{0,1}/lscript+k1→{0,1}k0be
two hash functions that will be modeled as independent random oracles. (Al-
though using more than one random oracle was not discussed in Section 5.5.1,
this is interpreted in the natural way.) The transformation deﬁned by OAEP
is a two-round Feistel network with GandHas round functions; see Fig-
ure 11.4. In detail, padding of a message m∈{0,1}/lscriptis done as follows: ﬁrst
setm/prime:=m/bardbl0k1and choose a uniform r∈{0,1}k0. Then compute
s:=m/prime⊕G(r)∈{0,1}/lscript+k1, t:=r⊕H(s)∈{0,1}k0,
and set ˆm:=s/bardblt.
To encrypt a message mwith respect to the public key /angbracketleftN,e/angbracketright, the sender
generates ˆ mas above and outputs the ciphertext c:= ˆmemodN. (Note
that ˆm, interpreted as an integer, is less than Nbecause of the constraints
on/lscript,k0,k1.) To decrypt, the receiver computes ˆ m:= [cdmodN] and lets
s/bardblt:= ˆmwithsandtof the appropriate lengths. It then inverts the Feistel
network by computing r:=H(s)⊕tandm/prime:=G(r)⊕s. Importantly,
the receiver then veriﬁes that the trailing k1bits ofm/primeare all 0; if not, the
ciphertext is rejected and an error message is returned. Otherwise, the k1
least-signiﬁcant 0s of m/primeare discarded, and the remaining /lscriptbits ofm/primeare
output as the message. This process is described in Construction 11.36.
The proof of CCA-security for RSA-OAEP is rather complicated, and we
do not give it here. Instead, we merely provide some intuition. First consider424 Introduction to Modern Cryptography
CONSTRUCTION 11.36
LetGenRSAbe as in the previous sections, and /lscript,k0,k1be as described
in the text. Let G:{0,1}k0→{0,1}/lscript+k1andH:{0,1}/lscript+k1→{0,1}k0
be functions. Construct a public-key encryption scheme as follows:
•Gen: on input 1n, runGenRSA(1n) to obtain ( N,e,d). The public
key is/angbracketleftN,e/angbracketrightand the private key is /angbracketleftN,d/angbracketright.
•Enc: on input a public key /angbracketleftN,e/angbracketrightand a message m∈{0,1}/lscript, set
m/prime:=m/bardbl0k1and choose a uniform r∈{0,1}k0. Then compute
s:=m/prime⊕G(r), t:=r⊕H(s)
and set ˆm:=s/bardblt. Output the ciphertext c:= [ˆmemodN].
•Dec: on input a private key /angbracketleftN,d/angbracketrightand a ciphertext c∈Z∗
N, com-
pute ˆm:= [cdmodN]. If/bardblˆm/bardbl> /lscript+k0+k1, output⊥. Otherwise,
parse ˆmass/bardbltwiths∈{0,1}/lscript+k1andt∈{0,1}k0. Compute
r:=H(s)⊕tandm/prime:=G(r)⊕s. If the least-signiﬁcant k1bits
ofm/primeare not all 0, output ⊥. Otherwise, output the /lscriptmost-
signiﬁcant bits of ˆ m.
The RSA-OAEP encryption scheme.
CPA-security. During encryption the sender computes
m/prime:=m/bardbl0k1, s:=m/prime⊕G(r), t:=r⊕H(s)
for uniform r; the ciphertext is [( s/bardblt)emodN]. If the attacker never queries r
toGthen, since we model Gas a random function, the value G(r) is uniform
from the attacker’s point of view and so mis masked with a uniform string
just as in the one-time pad encryption scheme. Thus, if the attacker never
queriesrtoGthen no information about the message is leaked.
Can the attacker query rtoG? Note that the value of ris itself masked
byH(s). So the attacker has no information about runless it ﬁrst queries s
toH. If the attacker does not query stoHthen the attacker may get lucky
and guess ranyway, but if we set the length of r(i.e.,k0) suﬃciently long
then the probability of this is negligible.
So, the only way for the attacker to learn anything about mis to ﬁrst
querystoH. This would require the attacker to compute sfrom the (uni-
form) ciphertext [( s/bardblt)emodN]. Note that computing sfrom [(s/bardblt)emodN]
is not the RSA problem, which instead involves computing bothsandt. Nev-
ertheless, for the right settings of the parameters we can use Theorem 11.29
to show that recovering senables recovery of tin polynomial time, and so
recovering sis computationally infeasible if the RSA problem is hard.
Arguing CCA-security involves additional complications, but the basic idea
is to show that every decryption-oraclequery cmade by the attackerfalls into
one of two categories: either the attacker obtained cby legally encrypting
some message m(in which case the attacker learns nothing from the decryp-
tion query), or else decryption of creturns an error. This is a consequence ofPublic-Key Encryption 425
the fact that the receiver checks that the k1low-order bits of ˆ mare 0 during
decryption; if the attacker did not construct some ciphertext cby legally en-
crypting some message, the probability that this condition holds is negligible.
The formal proof is complicated by the fact that the attacker’s decryption-
oracle queries must be answered correctly without knowledge of the private
key, which means there must be an eﬃcient way to determine whether to re-
turn an erroror not and, if not, what message to return. This is accomplished
by looking at the adversary’s queries to the random oracles G,H.
Manger’s chosen-ciphertext attack on PKCS #1 v2.0. In 2001, James
Manger showed a chosen-ciphertext attack against certain implementations of
the RSA encryption scheme speciﬁed in PKCS #1 v2.0—even though what
was speciﬁed was a variant of RSA-OAEP! Since Construction 11.36 is CCA-
secure (assuming the RSA problem is hard), how is this possible?
Examining the decryption algorithm in Construction 11.36, note that there
aretwowaysanerrorcanoccur: either ˆ m∈Z∗
Nistoolarge,or m/prime∈{0,1}/lscript+k1
does not have enough trailing 0s. In Construction 11.36, the receiver is sup-
posed to return the sameerror (denoted⊥) in either case. In some imple-
mentations, however, the receiver would output diﬀerent errors depending on
which step failed. This single bit of additionalinformation enables an attacker
to mount a chosen-ciphertext attack that recovers a message min its entirety
from an encryptionofthat message, using only about /bardblN/bardblqueriesto anoracle
that leaks the error message upon decryption. This shows the importance of
implementing cryptographic schemes exactly as speciﬁed, since the resulting
proof and analysis may no longer apply if aspects of the scheme are changed.
Even if the same error is returned in both cases, an attacker can deter-
mine where the error occurs if the timeto return the error is diﬀerent. (This
is a great example of how an attacker is not limited to examining the in-
puts/outputs of an algorithm, but can use side-channel information to attack
a scheme.) Implementations must be careful to ensure that the time to return
an error is identical regardless of where the error occurs.
11.5.5 *A CCA-Secure KEM in the Random-Oracle Model
We show here a construction of an RSA-based KEM that is CCA-secure in
therandom-oraclemodel. (RecallfromTheorem11.14thatanysuchconstruc-
tion can be used in conjunction with any CCA-secure private-key encryption
scheme to give a CCA-secure public-key encryption scheme.) As compared to
the RSA-OAEP scheme from the previous section, the main advantage is the
simplicity of both the construction and its proof of security. Its main disad-
vantage is that it results in longerciphertexts when encrypting short messages
since it requires the KEM/DEM paradigm whereas RSA-OAEP does not. For
encrypting long messages, however, RSA-OAEP would also be used as part of
a hybrid encryption scheme, and would result in an encryption scheme having
similar eﬃciency to what could be obtained using the KEM shown here.426 Introduction to Modern Cryptography
The KEM we describe is included as part of the ISO/IEC 18033-2 standard
for public-key encryption. In the scheme, the public key includes /angbracketleftN,e/angbracketrightas
usual, and a function H:Z∗
N→{0,1}nis speciﬁed that will be modeled
as a random oracle in the analysis. (This function can be based on some
underlying cryptographic hash function, as discussed in Section 5.5. We omit
the details.) To encapsulate a key, the sender chooses uniform r∈Z∗
Nand
then computes the ciphertext c:= [remodN] and the key k:=H(r). To
decrypt a ciphertext c, the receiver simply recovers rin the usual way and
then re-derives the same key k:=H(r). See Construction 11.37.
CONSTRUCTION 11.37
LetGenRSAbe as usual, and construct a KEM as follows:
•Gen: on input 1n, runGenRSA(1n) to compute ( N,e,d). The
public key is/angbracketleftN,e/angbracketright, and the private key is /angbracketleftN,d/angbracketright.
Aspartofkeygeneration, afunction H:Z∗
N→{0,1}nisspeciﬁed,
but we leave this implicit.
•Encaps: on input public key /angbracketleftN,e/angbracketrightand 1n, choose a uniform r∈
Z∗
N. Output the ciphertext c:= [remodN] and the key k:=
H(r).
•Decaps: on input private key /angbracketleftN,d/angbracketrightand a ciphertext c∈Z∗
N,
compute r:= [cdmodN] and output the key k:=H(r).
A CCA-secure KEM (in the random-oracle model).
CPA-security of the scheme is immediate. Indeed, the ciphertext cis equal
to [remodN] for uniform r∈Z∗
N, and so the RSA assumption implies that
an eavesdropper who observes cwill be unable to compute r. This means, in
turn, that the eavesdropper will not query rtoH, and thus the value of the
keykdef=H(r) remains uniform from the attacker’s point of view.
In fact, the above extends to show CCA-security as well. This is because
answering a decapsulation-oracle query for any ciphertext ˜ c/negationslash=conly in-
volves evaluating Hat some input [˜ cdmodN] = ˜r/negationslash=r. Thus, the attacker’s
decapsulation-oracle queries do not reveal any additional information about
the keyH(r) encapsulated by the challenge ciphertext. (A formal proof is
slightly more involved since we must show how it is possible to simulate the
answers to decapsulation-oracle queries without knowledge of the private key.
Nevertheless, this turns out not to be very diﬃcult.)
THEOREM 11.38 If the RSA problem is hard relative to GenRSA andH
is modeled as a random oracle, then Construction 11.37 is CCA-secure.Public-Key Encryption 427
PROOF Let Π denote Construction 11.37, and let Abe a probabilistic
polynomial-time adversary. For convenience, and because this is the ﬁrst
proof where we use the full power of the random-oracle model, we explicitly
describe the steps of experiment KEMcca
A,Π(n):
1.GenRSA(1n) is run to obtain ( N,e,d). In addition, a random function
H:Z∗
N→{0,1}nis chosen.
2. Uniform r∈Z∗
Nis chosen, and the ciphertext c:= [remodN] and key
k:=H(r) are computed.
3. A uniform bit b∈{0,1}is chosen. If b= 0 setˆk:=k. Ifb= 1 then
choose a uniform ˆk∈{0,1}n.
4.Ais givenpk=/angbracketleftN,e/angbracketright,c, andˆk, and may query H(·) (on any input)
and the decapsulation oracle Decaps/angbracketleftN,d/angbracketright(·) on any ciphertext ˆ c/negationslash=c.
5.Aoutputs a bit b/prime. The output of the experiment is deﬁned to be 1 if
b/prime=b, and 0 otherwise.
In an execution of experiment KEMcca
A,Π(n), letQuerybe the event that, at
any point during its execution, Aqueriesrto the random oracle H. We let
Successdenote the event that b/prime=b(i.e., the experiment outputs 1). Then
Pr[Success] = Pr/bracketleftbig
Success∧Query/bracketrightbig
+Pr[Success∧Query]
≤Pr/bracketleftbig
Success∧Query/bracketrightbig
+Pr[Query],
where all probabilities are taken over the randomness used in experiment
KEMcca
A,Π(n). We show that Pr/bracketleftbig
Success∧Query/bracketrightbig
≤1
2and that Pr[ Query] is
negligible. The theorem follows.
We ﬁrst argue that Pr/bracketleftbig
Success∧Query/bracketrightbig
≤1
2.IfPr[Query]= 0 this is im-
mediate. Otherwise, Pr/bracketleftbig
Success∧Query/bracketrightbig
≤Pr/bracketleftbig
Success|Query/bracketrightbig
.Now, con-
ditioned on Query,the value of the correct key k=H(r)is uniform because
His a random function. Consider A’s information about kin experiment
KEMcca
A,Π(n). The public key pkand ciphertext c, by themselves, do not con-
tain any information about k. (They do uniquely determine r, but since His
chosen independently of anything else, this gives no information about H(r).)
Queries thatAmakes to Halso do not reveal any information about r, unless
AqueriesrtoH(in which case Queryoccurs); this, again, relies on the fact
thatHis a random function. Finally, queries that Amakes to its decap-
sulation oracle only reveal H(˜r) for ˜r/negationslash=r. This follows from the fact that
Decaps/angbracketleftN,d/angbracketright(˜c) =H(˜r) where ˜r= [˜cdmodN], but ˜c/negationslash=cimplies ˜r/negationslash=r. Once
again, this and the fact that His a randomfunction mean that no information
aboutH(r) is revealed unless Queryoccurs.
The above shows that, as long as Querydoes not occur, the value of the
correct key kis uniform even given A’s view of the public key, ciphertext, and428 Introduction to Modern Cryptography
the answers to all its oracle queries. In that case, then, there is no way Acan
distinguish (any better than random guessing) whether ˆkis the correct key
or a uniform, independent key. Therefore, Pr/bracketleftbig
Success|Query/bracketrightbig
=1
2.
Wehighlight that nowhere in the above argument did we rely on the fact
thatAis computationally bounded, and in fact Pr/bracketleftbig
Success∧Query/bracketrightbig
≤1
2
even if no computational restrictions are placed on A. This indicates part of
the power of the random-oracle model.
To complete the proof of the theorem, we show
CLAIM 11.39 If the RSA problem is hard relative to GenRSA andHis
modeled as a random oracle, then Pr[Query]is negligible.
To prove this, we construct an algorithm A/primethat usesAas a subroutine.
A/primeis given an instance N,e,cof the RSA problem, and its goal is to compute
rfor which re=cmodN. To do so, it will run A, answering its queries
toHandDecaps. Handling queries to His simple, sinceA/primecan just return
a random value. Queries to Decapsare trickier, however, since A/primedoes not
know the private key associated with the eﬀective public key /angbracketleftN,e/angbracketright.
On further thought, however, decapsulation queries are also easy to answer
sinceA/primecan just return a random value here as well. That is, although the
queryDecaps(˜c) is supposed to be computed by ﬁrst computing ˜ rsuch that
˜re= ˜cmodNand then evaluating H(˜r), the result is just a uniform value.
Thus,A/primecan simply return a random value without performing the inter-
mediate computation. The only “catch” is that A/primemust ensure consistency
between its answers to H-queries and Decaps-queries; namely, it must ensure
that for any ˜ r,˜cwith ˜re= ˜cmodNit holds that H(˜r) =Decaps(˜c). This is
handled using simple bookkeeping and lists LHandLDecapsthat keep track
of the answersA/primehas given in response to the respective oracle queries. We
now give the details.
AlgorithmA/prime:
The algorithm is given ( N,e,c) as input.
1. Initializeemptylists LH,LDecaps. chooseauniform k∈{0,1}n
and store ( c,k) inLDecaps.
2. Choose a uniform bit b∈{0,1}. Ifb= 0 set ˆk:=k. If
b= 1 then choose a uniform ˆk∈{0,1}n. RunAon/angbracketleftN,e/angbracketright,c,
andˆk.
WhenAmakes a query H(˜r), answer it as follows:
•If there is an entry in LHof the form (˜ r,k) for some k,
returnk.
•Otherwise, let ˜ c:= [˜remodN]. If there is an entry in
LDecapsof the form (˜ c,k) for some k, returnkand store
(˜r,k) inLH.Public-Key Encryption 429
•Otherwise, choose a uniform k∈{0,1}n, return k, and
store (˜r,k) inLH.
WhenAmakes a query Decaps(˜c), answer it as follows:
•Ifthereisanentryin LDecapsofthe form(˜ c,k) forsome k,
returnk.
•Otherwise, for each entry (˜ r,k)∈LH, check if ˜ re=
˜cmodNand, if so, output k.
•Otherwise, choose a uniform k∈{0,1}n, return k, and
store (˜c,k) inLDecaps.
3. At the end ofA’s execution, if there is an entry ( r,k) inLH
for which re=cmodNthen return r.
ClearlyA/primeruns in polynomial time, and the view of Awhen run as a sub-
routine byA/primein experiment RSA-invA/prime,GenRSA(n) isidentical to the view ofA
in experiment KEMcca
A,Π(n): the inputs given to Aclearly have the right dis-
tribution, the answers to A’s oracle queries are consistent, and the responses
to allH-queries are uniform and independent. Finally, A/primeoutputs the correct
solution exactly when Queryoccurs. Hardness of the RSA problem relative to
GenRSA thus implies that Pr[ Query] is negligible, as required.
It is worth remarking on the various properties of the random-oracle model
(see Section 5.5.1) that are used in the above proof. First, we rely on the fact
that the value H(r) is uniform unless ris queried to H—even if His queried
on multiple other values ˜ r/negationslash=r. We also, implicitly, use extractability to argue
that the attacker cannot query rtoH; otherwise, we could use this attacker
to solve the RSA problem. Finally, the proof relies on programmability in
order to simulate the adversary’s decapsulation-oracle queries.
11.5.6 RSA Implementation Issues and Pitfalls
We close this section with a brief discussion of some issues related to the
implementation of RSA-based schemes, and some pitfalls to be aware of.
Using Chinese remaindering. In implementations of RSA-based encryp-
tion, the receiver can use the Chinese remainder theorem (Section 8.1.5) to
speed up computation of eth roots modulo Nduring decryption. Speciﬁcally,
letN=pqand say the receiver wishes to compute the eth root of some
valueyusingd= [e−1modφ(N)]. The receiver can use the correspondence
[ydmodN]↔([ydmodp],[ydmodq]) to compute the partial results
xp:= [ydmodp] =/bracketleftBig
y[dmod (p−1)]modp/bracketrightBig
(11.19)
and
xq:= [ydmodq] =/bracketleftBig
y[dmod (q−1)]modq/bracketrightBig
, (11.20)430 Introduction to Modern Cryptography
and then combine these to obtain x↔(xp,xq), as discussed in Section 8.1.5.
Note that [ dmod (p−1)] and [ dmod (q−1)] could be pre-computed since
they are independent of y.
Why is this better? Assume exponentiation modulo an /lscript-bit integer takes
γ·/lscript3operations for some constant γ. Ifp,qare each nbits long, then naively
computing [ ydmodN] takesγ·(2n)3= 8γ·n3steps (because/bardblN/bardbl= 2n).
Using Chinese remaindering reduces this to roughly 2 ·(γ·n3) steps (because
/bardblp/bardbl=/bardblq/bardbl=n), or roughly 1 /4 of the time.
Example 11.40
We revisit Example 8.49. Recall that N= 143 = 11·13 andd= 103, and
y= 64 there. To calculate [64103mod 143] we compute
/parenleftbig
[64 mod 11] ,[64 mod 13]/parenrightbig103=/parenleftbig
[(−2)103mod 11],[(−1)103mod 13]/parenrightbig
=/parenleftBig
[(−2)[103 mod 10]mod 11],−1/parenrightBig
=/parenleftbig
[−8 mod 11] ,−1/parenrightbig
= (3,−1).
We can compute 1 p= 78↔(1,0) and 1 q= 66↔(0,1), as discussed in Sec-
tion 8.1.5. (Note these values can be pre-computed, as they are independent
ofy.) Then (3 ,−1)↔3·1p−1q= 3·78−66 = 168 = 25 mod 143, in
agreement with the answer previously obtained. ♦
A fault attack when using Chinese remaindering. When using Chinese
remaindering as just described, one should be aware of a potential attack that
can be carried out if faultsoccur (or can be induced to occur by an attacker,
e.g., by hardware tampering) during the course of the computation.
Considerwhat happens if [ ydmodN] is computed twice: the ﬁrst time with
no error(givingthe correctresult x), but the second time with an errorduring
computation of Equation (11.20) but not Equation (11.19) (the same attack
applies in the opposite case). The second computation yields an incorrect
resultx/primeforwhich x/prime=xmodpbutx/prime/negationslash=xmodq. This meansthat p|(x/prime−x)
butq/negationslash|(x/prime−x). But then gcd( x/prime−x,N) =p, yielding the factorization of N.
One possible countermeasure is to verify correctness of the result before
using it, by checking that xe=ymodN. (Since/bardble/bardbl/lessmuch/bardbld/bardbl, using Chinese
remaindering still gives better eﬃciency.) This is recommended in hardware
implementations.
Dependent public keys I. When multiple receivers wish to utilize the same
encryption scheme, they should use independent public keys. This and the
following attack demonstrate what can go wrong when this is not done.
Imagine a company wants to use the same modulus Nfor each of its em-
ployees. Since it is not desirable for messages encrypted to one employee to
be read by any other employee, the company issues diﬀerent ( ei,di) pairs toPublic-Key Encryption 431
each employee. That is, the public key of the ith employee is pki=/angbracketleftN,ei/angbracketright
and their private key is sk=/angbracketleftN,di/angbracketright, whereei·di= 1 mod φ(N) for alli.
This approach is insecure and allows any employee to read messages en-
crypted to all other employees. The reason is that, as noted in Section 8.2.4,
givenNandei,diwithei·di= 1 mod φ(N), the factorization of Ncan be
eﬃciently computed. Given the factorization of N, of course, it is possible to
compute dj:=e−1
jmodφ(N) for any j.
Dependent public keys II. The attack just shown allows any employee to
decrypt messages sent to any other employee. This still leaves the possibility
that sharing the modulus Nis ﬁne as long as all employees trust each other
(or, alternatively, as long as conﬁdentiality need only be preserved against
outsiders but not against other members of the company). Here we show a
scenario indicating that sharing a modulus is still a bad idea, at least when
plain RSA encryption is used.
Say the same message mis encrypted and sent to two diﬀerent (known)
employeeswith public keys ( N,e1) and (N,e2) wheree1/negationslash=e2. Assume further
that gcd( e1,e2) = 1. Then an eavesdropper sees the two ciphertexts
c1=me1modNandc2=me2modN.
Since gcd( e1,e2) = 1, there exist integers X,Ysuch that Xe1+Ye2= 1 by
Proposition 8.2. Moreover, given the public exponents e1ande2it is possible
to eﬃciently compute XandYusing the extended Euclidean algorithm (see
Appendix B.1.2). We claim that m= [cX
1·cY
2modN], which can easily be
calculated. This is true because
cX
1·cY
2=mXe1mYe2=mXe1+Ye2=m1=mmodN.
A similar attack applies when using padded RSA or RSA-OAEP if the sender
uses the same transformed message ˆ mwhen encrypting to two users.
Randomness quality in RSA key generation. Throughout this book,
we always assume that honest parties have access to suﬃcient, high-quality
randomness. When this assumption is violated then security may fail to hold.
In particular, if an /lscript-bit string is chosen from some set S⊂{0,1}/lscriptrather than
uniformly from{0,1}/lscript, then an attacker can perform a brute-force search (in
timeO(|S|)) to attack the system.
In some cases the situation may be even worse. Consider in particular
the case of RSA key generation, where one sample of random bits rpis used
to choose the ﬁrst prime p, and a second sample rqis used to generate the
second prime q. Assume further that many public/private keys are generated
using the same source of poor-quality randomness, in which rp,rqare chosen
uniformly from some set Sof size 2s. After generating roughly 2s/2public
keys (see Appendix A.4), we expect to obtain two diﬀerent moduli N,N/primethat
were generated using identical randomness rp=r/prime
p. These two moduli share a
prime factor which can be easily found by computing gcd( N,N/prime). An attacker432 Introduction to Modern Cryptography
can thus scrape the Internet for a large set of RSA public keys, compute their
pairwise gcd’s, and hope to factor some subset of them. Although computing
pairwise gcd’s of 2s/2moduli would naively take time O(2s), it turns out that
this can be signiﬁcantlyimprovedusinga “divide-and-conquer”approachthat
is beyond the scope of this book. The upshot is that an attacker can perform
a brute-force search in time much less than 2s. Moreover, the attack works
even if the set Sis unknown to the attacker!
Theabovescenariowasveriﬁedexperimentallyby tworesearchteams work-
ing independently, who carried out exactly the above attack on public keys
scraped over the Internet and were able to successfully factor a signiﬁcant
fraction of the keys they found.
References and Additional Reading
The idea of public-key encryption was ﬁrst proposed in the open literature
by Diﬃe and Hellman [58]. Rivest, Shamir, and Adleman [148] introduced
the RSA assumption and proposed a public-key encryption scheme based on
this assumption. As pointed out in the previous chapter, other pioneers of
public-key cryptographyinclude Merkle and Rabin (in academic publications)
and Ellis, Cocks, and Williamson (in classiﬁed publications).
Deﬁnition 11.2 is rooted in the seminal work of Goldwasser and Micali [80],
who were also the ﬁrst to recognize the necessity of probabilistic encryption
for satisfying this deﬁnition. As noted in Chapter 4, chosen-ciphertext at-
tacks were ﬁrst formally deﬁned by Naor and Yung [129] and Rackoﬀ and
Simon [147]. The expository article by Shoup [156] discusses the importance
of security against chosen-ciphertext attacks. Bellare et al. give a uniﬁed,
modern treatment of various security notions for public-key encryption [16].
A proof of CPA-security for hybrid encryption was ﬁrst given by Blum and
Goldwasser [36]. The case of CCA-security was treated in [56].
Somewhat amazingly, the El Gamal encryption scheme [70] was not sug-
gested until 1984, even though it can be viewed as a direct transformation
of the Diﬃe–Hellman key-exchange protocol (see Exercise 11.4). DHIES was
introduced in [2]. The ISO/IEC 18033-2 standard for public-key encryption
can be found at http://www.shoup.net/iso .
Plain RSA encryption corresponds to the original scheme introduced by
Rivest, Shamir, and Adleman [148]. The attacks on plain RSA encryption de-
scribed in Section 11.5.1 are due to [161, 55, 84, 47, 40]; see [120, Chapter 8]
and [38] for additional attacks and further information. Proofs of Copper-
smith’s theorem can be found in the original work [46] or several subsequent
expositions (e.g., [119]).
ThePKCS #1 RSA Cryptography Standards (both previous and currentPublic-Key Encryption 433
versions) are available at http://www.emc.com/emc-plus/rsa-labs . The
chosen-plaintext attack on PKCS #1 v1.5 described here is due to [49]. A
descriptionofBleichenbacher’schosen-ciphertextattackonPKCS#1v1.5can
be found in the original paper [34]. See [12] for subsequent improvements.
Proofs of Theorem 11.31, and generalizations, can be found in [8, 86, 66, 7].
See Section 13.1.2 for a general treatment of schemes of this form. Construc-
tion 11.37 appears to have been introduced and ﬁrst analyzed by Shoup [157].
OAEP was introduced by Bellare and Rogaway [22]. The original proof
of OAEP was later found to be ﬂawed; the interested reader is referred to
[39, 158, 68]. For details of Manger’s chosen-ciphertext attack on implemen-
tations of PKCS #1 v2.0, see [117].
The pairwise-gcd attack described in Section 11.5.6 was carried out by
Lenstra et al. [112] and Heninger et al. [88].
When using any encryption scheme in practice, the question arises as to
what key length to use. This issue should not be taken lightly, and we refer
the reader to Section 9.3 and references therein for an in-depth treatment.
The ﬁrst eﬃcient CCA-secure public-key encryption scheme not relying
on the random-oracle model was shown by Cramer and Shoup [50] based
on the DDH assumption. Subsequently, Hoﬀheinz and Kiltz have shown an
eﬃcient CCA-secure scheme without random oracles based on the RSA as-
sumption [92].
Exercises
11.1 Assume a public-key encryption scheme for single-bit messages with no
decryption error. Show that, given pkand a ciphertext ccomputed via
c←Encpk(m), it is possible for an unbounded adversary to determine
mwith probability 1.
11.2 Show that for any CPA-secure public-key encryption scheme for single-
bit messages, the length of the ciphertext must be superlogarithmic in
the security parameter.
Hint:If not, the range of possible ciphertexts has polynomial size.
11.3 Say a public-key encryption scheme ( Gen,Enc,Dec) forn-bit messages
isone-way if anypptadversaryAhas negligible probability of success
in the following experiment:
•Gen(1n)is run to obtain keys (pk,sk).
•A message m∈{0,1}nis chosen uniformly at random,
and a ciphertext c←Encpk(m)is computed.
• Ais givenpkandc, and outputs a message m/prime. We say
Asucceeds if m/prime=m.434 Introduction to Modern Cryptography
(a) Give a construction of a CPA-secure KEM in the random-oracle
model based on any one-way public-key encryption scheme.
(b) Can a deterministic public-key encryption scheme be one-way? If
not, prove impossibility; if so, give a construction based on any of
the assumptions introduced in this book.
11.4 Show that any two-round key-exchange protocol (that is, where each
party sends a single message) satisfying Deﬁnition 10.1 can be converted
into a CPA-secure public-key encryption scheme.
11.5 Show that Claim 11.7 does not hold in the setting of CCA-security.
11.6 Consider the following public-key encryption scheme. The public key
is (G,q,g,h) and the private key is x, generated exactly as in the El
Gamal encryption scheme. In order to encrypt a bit b, the sender does
the following:
(a) Ifb= 0 then choose a uniform y∈Zqand compute c1:=gyand
c2:=hy. The ciphertext is /angbracketleftc1,c2/angbracketright.
(b) Ifb= 1 then choose independent uniform y,z∈Zq, compute
c1:=gyandc2:=gz, and set the ciphertext equal to /angbracketleftc1,c2/angbracketright.
Show that it is possible to decrypt eﬃciently given knowledge of x.
Provethat this encryption scheme is CPA-secure if the decisional Diﬃe–
Hellman problem is hard relative to G.
11.7 Consider the following variant of El Gamal encryption. Let p= 2q+1,
letGbe the group of squares modulo p(soGis a subgroup of Z∗
pof
orderq), and let gbe a generator of G. The private key is ( G,g,q,x)
and the public key is ( G,g,q,h), where h=gxandx∈Zqis chosen
uniformly. To encrypt a message m∈Zq, choose a uniform r∈Zq,
compute c1:=grmodpandc2:=hr+mmodp, and let the ciphertext
be/angbracketleftc1,c2/angbracketright. Is this scheme CPA-secure? Prove your answer.
11.8 Considerthe followingprotocolfortwoparties AandBto ﬂip afaircoin
(more complicated versionsof this might be used for Internet gambling):
(1) a trusted party Tpublishes her public key pk; (2) then Achooses a
uniform bit bA, encrypts it using pk, and announces the ciphertext cA
toBandT; (3) next, Bacts symmetrically and announces a ciphertext
cB/negationslash=cA; (4)Tdecrypts both cAandcB, and the parties XOR the
results to obtain the value of the coin.
(a) Argue that even if Ais dishonest (but Bis honest), the ﬁnal value
of the coin is uniformly distributed.
(b) Assume the parties use El Gamal encryption (where the bit bis
encoded asthe groupelement gbbefore beingencrypted—note that
eﬃcient decrypt is still possible). Show how a dishonest Bcan bias
the coin to any value he likes.Public-Key Encryption 435
(c) Suggest what type of encryption scheme would be appropriate to
use here. Can you deﬁne an appropriate notion of security and
prove that your suggestion achieves this deﬁnition?
11.9 Proveformally that the El Gamal encryption scheme is not CCA-secure.
11.10 In Section 11.4.4 we showed that El Gamal encryption is malleable, and
speciﬁcally that given a ciphertext /angbracketleftc1,c2/angbracketrightthat is the encryption ofsome
unknown message m, it is possible to produce a ciphertext /angbracketleftc1,c/prime
2/angbracketrightthat
is the encryption of α·m(for known α). A receiver who receives both
these ciphertexts might be suspicious since both ciphertexts share the
ﬁrst component. Show that it is possible to generate /angbracketleftc/prime
1,c/prime
2/angbracketrightthat is the
encryption of α·m, withc/prime
1/negationslash=c1andc/prime
2/negationslash=c2.
11.11 Prove Theorem 11.22.
11.12 One of the attacks on plain RSA discussed in Section 11.5.1 involves a
sender who encrypts two related messages using the same public key.
Formulate an appropriate deﬁnition of security ruling out such attacks,
and show that any CPA-secure public-key encryption scheme satisﬁes
your deﬁnition.
11.13 One of the attacks on plain RSA discussed in Section 11.5.1 involves
a sender who encrypts the same message to three diﬀerent receivers.
Formulate an appropriate deﬁnition of security ruling out such attacks,
and show that any CPA-secure public-key encryption scheme satisﬁes
your deﬁnition.
11.14 Consider the following modiﬁed version of padded RSA encryption: As-
sume messages to be encrypted have length exactly /bardblN/bardbl/2. To encrypt,
ﬁrstcompute ˆ m:=0x00/bardblr/bardbl0x00/bardblmwhererisauniformstringoflength
/bardblN/bardbl/2−16. Then compute the ciphertext c:= [ˆmemodN]. When de-
crypting a ciphertext c, the receiver computes ˆ m:= [cdmodN] and
returns an error if ˆ mdoes not consist of 0x00followed by/bardblN/bardbl/2−16
arbitrary bits followed by 0x00. Show that this scheme is not CCA-
secure. Why is it easier to construct a chosen-ciphertext attack on this
scheme than on PKCS #1 v1.5?
11.15 Consider the RSA-based encryption scheme in which a user encrypts a
message m∈{0,1}/lscriptwith respect to the public key /angbracketleftN,e/angbracketrightby computing
ˆm:=H(m)/bardblmand outputting the ciphertext [ˆ memodN]. (Here, let
H:{0,1}/lscript→{0,1}nand assume /lscript+n </bardblN/bardbl.) The receiver recovers
ˆmin the usual way and veriﬁes that it has the correct form before
outputting the /lscriptleast-signiﬁcant bits as m. Prove or disprove that this
scheme is CCA-secure if His modeled as a random oracle.
11.16 Show a chosen-ciphertext attack on Construction 11.34.436 Introduction to Modern Cryptography
11.17 Let Π = ( Gen,Enc,Dec) be a CPA-secure public-key encryption scheme,
and let Π/prime= (Gen/prime,Enc/prime,Dec/prime) be a CCA-secure private-key encryption
scheme. Consider the following construction:
CONSTRUCTION 11.41
LetH:{0,1}n→{0,1}nbe a function. Construct a public-key
encryption scheme as follows:
•Gen∗: on input 1n, runGen(1n) to obtain ( pk,sk). Output
these as the public and private keys, respectively.
•Enc∗: on input a public key pkand a message m∈{0,1}n,
choose a uniform r∈{0,1}nand output the ciphertext
/angbracketleftbig
Encpk(r),Enc/prime
H(r)(m)/angbracketrightbig
.
•Dec∗: on input a private key skand a ciphertext/angbracketleftc1,c2/angbracketright, com-
puter:=Decsk(c1) and set k:=H(r). Then output Dec/prime
k(c2).
Does the above construction have indistinguishable encryptions under
achosen-ciphertext attack, if His modeled as a random oracle? If
yes, provide a proof. If not, where does the approach used to prove
Theorem 11.38 break down?
11.18 Consider the following variant of Construction 11.32:
CONSTRUCTION 11.42
LetGenRSAbe as usual, and deﬁne a public-key encryption scheme
as follows:
•Gen: on input 1n, runGenRSA(1n) to obtain ( N,e,d). Output
the public key pk=/angbracketleftN,e/angbracketright, and the private key sk=/angbracketleftN,d/angbracketright.
•Enc: on input a public key pk=/angbracketleftN,e/angbracketrightand a message
m∈{0,1}, choose a uniform r∈Z∗
N. Output the ciphertext
/angbracketleft[remodN],lsb(r)⊕m/angbracketright.
•Dec: on input a private key sk=/angbracketleftN,d/angbracketrightand a ciphertext/angbracketleftc,b/angbracketright,
compute r:= [cdmodN] and output lsb(r)⊕b.
Prove that this scheme is CPA-secure. Discuss its advantages and dis-
advantages relative to Construction 11.32.
11.19 Say three users have RSA public keys /angbracketleftN1,3/angbracketright,/angbracketleftN2,3/angbracketright, and/angbracketleftN3,3/angbracketright(i.e.,
they all use e= 3), with N1< N2< N3. Consider the following method
forsendingthesamemessage m∈{0,1}/lscripttoeachoftheseparties: choose
a uniform r←Z∗
N1, and send to everyone the same ciphertext
/angbracketleftbig
[r3modN1],[r3modN2],[r3modN3],H(r)⊕m/angbracketrightbig
,
whereH:Z∗
N1→{0,1}/lscript. Assume /lscript/greatermuchn.Public-Key Encryption 437
(a) Show that this is not CPA-secure, and an adversary can recover m
from the ciphertext even when His modeled as a random oracle.
Hint:See Section 11.5.1.
(b) Show a simple way to ﬁx this and get a CPA-secure method that
transmits a ciphertext of length 3 /lscript+O(n).
(c) Show a better approach that is still CPA-secure but with a cipher-
text of length /lscript+O(n).
11.20 Fix an RSA public key /angbracketleftN,e/angbracketrightand assume we have an algorithm Athat
always correctly computes lsb(x) given [ xemodN]. Write full pseu-
docode for an algorithm A/primethat computes xfrom [xemodN].
11.21 Fix an RSA public key /angbracketleftN,e/angbracketrightand deﬁne
half(x) =/braceleftbigg0 if 0< x < N/ 2
1 ifN/2< x < N
Prove that halfis a hard-core predicate for the RSA problem.
Hint:Reduce to hardness of computing lsb.Chapter 12
Digital Signature Schemes
12.1 Digital Signatures – An Overview
Inthe previous chapter we explored how public-key encryption can be used
to achieve secrecyin the public-key setting. Integrity (orauthenticity ) in the
public-key setting is provided using digital signature schemes . These can be
viewed as the public-key analogue of message authentication codes, although,
aswewillsee, thereareseveralimportantdiﬀerencesbetweentheseprimitives.
Signature schemes allow a signerSwho has established a public key pkto
“sign”amessageusingtheassociatedprivatekey skinsuchawaythatanyone
whoknows pk(andknowsthatthis publickeywasestablishedby S)canverify
that the message originated from Sand was not modiﬁed in transit. (Note
that, in contrast to public-key encryption, in the context of digital signatures
the owner of the public key acts as the sender.) As a prototypical application,
consider a software company that wants to disseminate software updates in
an authenticated manner; that is, when the company releases an update it
should be possible for any of its clients to verify that the update is authentic,
and a malicious third party should never be able to fool a client into accepting
an update that was not actually released by the company. To do this, the
company can generate a public key pkalong with a private key sk, and then
distribute pkinsomereliablemannertoitsclientswhilekeeping sksecret. (As
in the case of public-key encryption, we assume that this initial distribution
of the public key is carried out correctly so that all clients have a correct copy
ofpk. In the current example, pkcould be bundled with the original software
purchased by a client.) When releasing a software update m, the company
computes a digital signature σonmusing its private key sk, and sends ( m,σ)
to every client. Each client can verify the authenticity of mby checking that
σis a correct signature on mwith respect to the public key pk.
A maliciouspartymighttry to issueafraudulent update by sending( m/prime,σ/prime)
to a client, where m/primerepresents an update that was never released by the
company. This m/primemight be a modiﬁed version of some previous update, or it
might be completely new and unrelated to any prior updates. If the signature
scheme is “secure” (in a sense we will deﬁne more carefully soon), however,
then when the client attempts to verify σ/primeit will ﬁnd that this is an invalid
signatureon m/primewithrespectto pk, andwilltherefore rejectthesignature. The
439440 Introduction to Modern Cryptography
client will reject even if m/primeis modiﬁed only slightly from a genuine update m.
The above is not just a theoretical application of digital signatures, but one
that is used extensively today for distributing software updates.
Comparison to Message Authentication Codes
Both message authentication codes and digital signature schemes are used
to ensure the integrity of transmitted messages. Although the discussion in
Chapter 10 comparing the public-key and private-key settings focused mainly
on encryption, that discussion applies also to message integrity. Using digital
signatures rather than message authentication codes simpliﬁes key distribu-
tion and management, especially when a sender needs to communicate with
multiple receiversas in the software-updateexample above. By using a digital
signature scheme the sender avoids having to establish a distinct secret key
with each potential receiver, and avoids having to compute a separate MAC
tag with respect to each such key. Instead, the sender need only compute a
single signature that can be veriﬁed by all recipients.
Aqualitative advantagethatdigitalsignatureshaveascomparedtomessage
authentication codesis that signaturesare publicly veriﬁable . This means that
if a receiver veriﬁes that a signature on a given message is legitimate, then all
other parties who receive this signed message will also verify it as legitimate.
This feature is not achieved by message authentication codes if the signer
shares a separate key with each receiver: in such a setting a malicious sender
might compute a correct MAC tag with respect to the key it shares with
receiverAbut an incorrect MAC tag with respect to the key it shares with a
diﬀerent user B. In this case, Aknows that he received an authentic message
from the sender but has no guarantee that Bwill agree.
Public veriﬁability implies that signatures are transferable : a signature σ
on a message mby a signer Scan be shown to a third party, who can then
verify herself that σis a legitimate signature on mwith respect to S’s public
key (here, we assume this third party alsoknows S’s public key). By making a
copy of the signature, this third party can then show the signature to another
party and convince themthatSauthenticated m, and so on. Public veriﬁabil-
ity and transferability are essential for the application of digital signatures to
certiﬁcates and public-key infrastructures, as we will discuss in Section 12.7.
Digital signature schemes also provide the very important property of non-
repudiation . This means that once Ssigns a message he cannot later deny
having done so (assuming the public key of Sis widely publicized and dis-
tributed). This aspect of digital signatures is crucial for legal applications
where a recipient may need to prove to a third party (say, a judge) that a
signer did indeed “certify” a particular message (e.g., a contract): assum-
ingS’s public key is known to the judge, or is otherwise publicly available,
a valid signature on a message serves as convincing evidence that Sindeed
signed this message. Message authentication codes simply cannot provide
non-repudiation. To see this, say users SandRshare a key kSR, andSDigital Signature Schemes 441
sends a message mtoRalong with a (valid) MAC tag tcomputed using this
key. Since the judge does notknowkSR(indeed, this key is kept secret by S
andR), there is no way for the judge to determine whether tis valid or not. If
Rwere to revealthe key kSRto the judge, there would be no wayfor the judge
to know whether this is the “actual” key that SandRshared, or whether it
is some “fake” key manufactured by R. Finally, even if we assume the judge
can somehow obtain the actual key kSRshared by the parties, there is no way
for the judge to distinguish whether Sgenerated tor whether Rdid—this
follows from the fact that message authentication codes are a symmetric -key
primitive; anything Scan do,Rcan do also.
As in the case of private-key vs. public-key encryption, message authenti-
cation codes have the advantage of being shorter and roughly 2–3 orders of
magnitude more eﬃcient to generate/verify than digital signatures. Thus, in
situations where public veriﬁability, transferability, and/or non-repudiation
are not needed, and the sender communicates primarily with a single recipi-
ent (with whom it is able to share a secret key), message authentication codes
should be used.
Relation to Public-Key Encryption
Digitalsignaturesareoften mistakenlyviewedasthe “inverse”ofpublic-key
encryption, with the roles of the sender and receiver interchanged. Histori-
cally,1in fact, it has been suggested that digital signatures can be obtained
by “reversing” public-key encryption, i.e., signing a message mby decrypting
it (using the private key) to obtain σ, and verifying a signature σby encrypt-
ing it (using the corresponding public key) and checking whether the result
ism. The suggestion to construct signature schemes in this way is completely
unfounded : in most cases, it is simply inapplicable, and in cases where it is
applicable it results in signature schemes that are not secure.
12.2 Deﬁnitions
Digital signatures are the public-key counterpart of message authentication
codes, and their syntax and security guaranteesare analogous. The algorithm
that the sender applies to a message is here denoted Sign(rather than Mac),
and the output of this algorithm is now called a signature (rather than a tag).
1This view no doubt arose because, as we will see in Section 12.4.1, plain RSA signatures
are the reverse of plain RSA encryption. However, neither plain RSA signatures nor plain
RSA encryption meet even minimal notions of security.442 Introduction to Modern Cryptography
The algorithm that the receiver applies to a message and a signature in order
to verify validity is still denoted Vrfy.
DEFINITION 12.1 A(digital) signature scheme consists of three proba-
bilistic polynomial-time algorithms (Gen,Sign,Vrfy)such that:
1. Thekey-generation algorithm Gen takes as input a security parameter 1n
and outputs a pair of keys (pk,sk). These are called the public key and
theprivate key , respectively. We assume that pkandskeach has length
at leastn, and that ncan be determined from pkorsk.
2. Thesigning algorithm Sign takes as input a private key skand a mes-
sagemfrom some message space (that may depend on pk). It outputs
a signature σ, and we write this as σ←Signsk(m).
3. The deterministic veriﬁcationalgorithmVrfy takes as input a public key pk,
a message m, and a signature σ. It outputs a bit b, withb= 1meaning
validandb= 0meaning invalid. We write this as b:=Vrfypk(m,σ).
It is required that except with negligible probability over (pk,sk)output by
Gen(1n), it holds that Vrfypk(m,Signsk(m)) = 1for every (legal) message m.
If there is a function /lscriptsuch that for every (pk,sk)output by Gen(1n)the
message space is {0,1}/lscript(n), then we say that (Gen,Sign,Vrfy)is asignature
scheme for messages of length /lscript(n).
We callσavalid signature on a message m(with respect to some public
keypkunderstood from the context) if Vrfypk(m,σ) = 1.
A signature scheme is used in the following way. One party S, who acts as
thesender, runsGen(1n) to obtain keys ( pk,sk). The public key pkis then
publicized as belonging to S; e.g.,Scan put the public key on its webpage or
place it in some public directory. As in the case of public-key encryption, we
assume that any other party is able to obtain a legitimate copy of S’s public
key (see discussion below). When Swants to authenticate a message m, it
computes the signature σ←Signsk(m) and sends ( m,σ). Upon receipt of
(m,σ), a receiver who knows pkcan verify the authenticity of mby checking
whether Vrfypk(m,σ)?= 1. This establishes both that Ssentm, and also that
mwasnot modiﬁed in transit. As in the caseofmessageauthentication codes,
however, it does not say anything about whenmwas sent, and replay attacks
are still possible (see Section 4.2).
The assumption that parties are able to obtain a legitimate copy of S’s
public key implies that Sis able to transmit at least one message (namely,
pkitself) in a reliable and authenticated manner. If we are able to transmit
messages reliably, however, then why do we need a signature scheme at all?
The answer is that reliable distribution of pkisa diﬃcult and expensive
task, but using a signature scheme means that this need only be carried outDigital Signature Schemes 443
once, after which an unlimited number of messages can subsequently be sent
reliably. Furthermore, as we will discuss in Section 12.7, signature schemes
themselves are used to ensure the reliable distribution of otherpublic keys.
They thus serve as a central tool for setting up a “public-key infrastructure”
to address the key-distribution problem.
Security of signature schemes. For a ﬁxed public key pkgenerated by
a signer S, aforgeryis a message malong with a valid signature σ, where
mwas not previously signed by S. Security of a signature scheme means
that an adversary should be unable to output a forgery even if it obtains
signatures on many other messages of its choice. This is the direct analogue
of the deﬁnition of security for message authentication codes, and we refer the
reader to Section 4.2 for motivation and further discussion.
We now present the formal deﬁnition of security, which is essentially the
same as Deﬁnition 4.2. Let Π = ( Gen,Sign,Vrfy) be a signature scheme, and
consider the following experiment for an adversary Aand parameter n:
The signature experiment Sig-forgeA,Π(n):
1.Gen(1n)is run to obtain keys (pk,sk).
2. AdversaryAis given pkand access to an oracle Signsk(·).
The adversary then outputs (m,σ). LetQdenote the set of
all queries thatAasked its oracle.
3.Asucceeds if and only if (1) Vrfypk(m,σ) = 1and (2)m/negationslash∈Q.
In this case the output of the experiment is deﬁned to be 1.
DEFINITION 12.2 A signature scheme Π = (Gen,Sign,Vrfy)isexisten-
tially unforgeable under an adaptive chosen-message attack , or justsecure, if for
all probabilistic polynomial-time adversaries A, there is a negligible function
neglsuch that:
Pr[Sig-forgeA,Π(n) = 1]≤negl(n).
12.3 The Hash-and-Sign Paradigm
Asin the case of public-key vs. private-key encryption, “native” signature
schemes are orders of magnitude less eﬃcient than message authentication
codes. Fortunately, as with hybrid encryption (see Section 11.3), it is possible
to obtain the functionality of digital signatures at the asymptotic cost of a
private-keyoperation, at least for suﬃciently long messages. This can be done
using the hash-and-sign approach, discussed next.444 Introduction to Modern Cryptography
Theintuition behind the hash-and-signapproachis straightforward. Saywe
have a signature scheme for messages of length /lscript, and wish to sign a (longer)
message m∈{0,1}∗. Rather than sign mitself, we can instead use a hash
function Htohashthe message down to a ﬁxed-length digestof length /lscript,
and then sign the resulting digest. This approach is exactly analogous to the
hash-and-MAC approach discussed in Section 5.3.1.
CONSTRUCTION 12.3
LetΠ = (Gen,Sign,Vrfy) be a signature scheme for messages of
length/lscript(n), and let Π H= (GenH,H) be a hash function with out-
put length /lscript(n). Construct signature scheme Π/prime= (Gen/prime,Sign/prime,Vrfy/prime) as
follows:
•Gen/prime: on input 1n, runGen(1n) to obtain ( pk,sk) and run
GenH(1n) to obtain s; the public key is /angbracketleftpk,s/angbracketrightand the private
key is/angbracketleftsk,s/angbracketright.
•Sign/prime: on input a private key /angbracketleftsk,s/angbracketrightand a message m∈{0,1}∗,
outputσ←Signsk(Hs(m)).
•Vrfy/prime: on input a public key /angbracketleftpk,s/angbracketright, a message m∈{0,1}∗, and a
signature σ, output 1 if and only if Vrfypk(Hs(m),σ)?= 1.
The hash-and-sign paradigm.
THEOREM 12.4 IfΠis a secure signature scheme for messages of
length/lscriptandΠHis collision resistant, then Construction 12.3 is a secure sig-
nature scheme (for arbitrary-length messages).
The proof of this theorem is almost identical to that of Theorem 5.6.
12.4 RSA Signatures
Webegin our consideration of concrete signature schemes with a discussion
of schemes based on the RSA assumption.
12.4.1 Plain RSA
We ﬁrst describe a simple, RSA-based signature scheme. Although the
scheme is insecure, it serves as a useful starting point.
As usual, let GenRSA be apptalgorithm that, on input 1n, outputs aDigital Signature Schemes 445
modulus Nthat is the product of two n-bit primes (except with negligible
probability), along with integers e,dsatisfying ed= 1 mod φ(N). Key gener-
ation in plain RSA involves simply running GenRSA, and outputting/angbracketleftN,e/angbracketrightas
the public key and /angbracketleftN,d/angbracketrightas the private key. To sign a message m∈Z∗
N, the
signer computes σ:= [mdmodN]. Veriﬁcation of a signature σon a message
mwith respect to the public key /angbracketleftN,e/angbracketrightis carried out by checking whether
m?=σemodN. See Construction 12.5.
CONSTRUCTION 12.5
LetGenRSAbe as in the text. Deﬁne a signature scheme as follows:
•Gen: on input 1nrunGenRSA(1n) to obtain ( N,e,d). The public
key is/angbracketleftN,e/angbracketrightand the private key is /angbracketleftN,d/angbracketright.
•Sign: on input a private key sk=/angbracketleftN,d/angbracketrightand a message m∈Z∗
N,
compute the signature
σ:= [mdmodN].
•Vrfy: on input a public key pk=/angbracketleftN,e/angbracketright, a message m∈Z∗
N, and
a signature σ∈Z∗
N, output 1 if and only if
m?= [σemodN].
The plain RSA signature scheme.
Itiseasy to see that veriﬁcation of a legitimately generated signature is
always successful since
σe= (md)e=m[edmodφ(N)]=m1=mmodN.
One might expect this scheme to be secure since, for an adversary knowing
only the public key /angbracketleftN,e/angbracketright, computing a valid signature on a message mseems
to requiresolvingthe RSA problem (since the signatureis exactlythe eth root
ofm). Unfortunately, this reasoning is incorrect. For one thing, the RSA as-
sumption only implies hardness of computing a signature (that is, computing
aneth root) of a uniform message m; it says nothing about hardness of com-
puting a signature on a nonuniform mor on some message mof the attacker’s
choice. Moreover, the RSA assumption says nothing about what an attacker
might be able to do once it learnssignatures on othermessages. The following
examples demonstrate that both of these observations lead to attacks on the
plain RSA signature scheme.
A no-message attack. Theﬁrstattackwedescribegeneratesaforgery using
the public key alone , without obtaining any signatures from the legitimate
signer. The attack works as follows: given a public key pk=/angbracketleftN,e/angbracketright, choose
a uniform σ∈Z∗
Nand compute m:= [σemodN]. Then output the forgery446 Introduction to Modern Cryptography
(m,σ). It is immediate that σis a valid signature on m, and this is a forgery
since no signatures at all were issued by the owner of the public key. We
conclude that the plain RSA signatureschemedoesnot satisfy Deﬁnition 12.2.
One might argue that this does not constitute a “realistic” attack since the
adversary has “no control” over the message mfor which it forges a valid sig-
nature. This is irrelevant as far as Deﬁnition 12.2 is concerned, and we have
already discussed (in Chapter 4) why it is dangerous to assume any seman-
tics for messages that are going to be authenticated using any cryptographic
scheme. Moreover, the adversary does have somecontrol over m: for exam-
ple, by choosing multiple, uniform values of σit can (with high probability)
obtain an mwith a few bits set in some desired way. By choosing σin some
speciﬁc manner, it may also be possible to inﬂuence the resulting message for
which a forgery is output.
Forging a signature on an arbitrary message. A more damaging attack
on the plain RSA signaturescheme requiresthe adversaryto obtain twosigna-
tures from the signer, but allowsthe adversaryto output a forgedsignatureon
any message of its choice. Say the adversary wants to forge a signature on the
message m∈Z∗
Nwith respect to the public key pk=/angbracketleftN,e/angbracketright. The adversary
choosesarbitrary m1,m2∈Z∗
Ndistinct from msuchthat m=m1·m2modN.
It then obtains signatures σ1,σ2onm1,m2, respectively. Finally, it outputs
σ:= [σ1·σ2modN] as a valid signature on m. This works because
σe= (σ1·σ2)e= (md
1·md
2)e=med
1·med
2=m1·m2=mmodN,
using the fact that σ1,σ2are valid signatures on m1,m2.
Beingable to forgea signatureon an arbitrarymessageis devastating. Nev-
ertheless, one might argue that this attack is unrealistic since an adversary
will not be able to convince a signer to sign the exact messages m1andm2.
Once again, this is irrelevant as far as Deﬁnition 12.2 is concerned. Further-
more, it is dangerous to make assumptions about what messages the signer
may or may not be willing to sign. For example, a client may use a signature
scheme to authenticate to a server by signing a random challenge sent by the
server. Here, a malicious server would be able to obtain a signature on any
message(s) of its choice. More generally, it may be possible for the adversary
to choose m1andm2as “legitimate” messages that the signer will agree to
sign. Finally, note that the attack can be generalized: if an adversary obtains
valid signatures on qarbitrary messages M={m1,...,m q}, then the adver-
sary can output a valid signature on any of 2q−qother messages obtained
by taking products of subsets of M(of size diﬀerent from 1).
12.4.2 RSA-FDH and PKCS #1 v2.1
One can attempt to prevent the attacks from the previous section by ap-
plying some transformation to messages before signing them. That is, the
signer will now specify as part of its public key a (deterministic) function HDigital Signature Schemes 447
with certain cryptographic properties (described below) mapping messages
toZ∗
N; the signature on a message mwill beσ:= [H(m)dmodN], and veriﬁ-
cation of the signature σon the message mwill be done by checking whether
σe?=H(m) modN. See Construction 12.6.
CONSTRUCTION 12.6
LetGenRSAbe as in the previous sections, and construct a signature
scheme as follows:
•Gen: on input 1n, runGenRSA(1n) to compute ( N,e,d). The
public key is/angbracketleftN,e/angbracketrightand the private key is /angbracketleftN,d/angbracketright.
Aspartofkeygeneration, afunction H:{0,1}∗→Z∗
Nis speciﬁed,
but we leave this implicit.
•Sign: on input a private key /angbracketleftN,d/angbracketrightand a message m∈{0,1}∗,
compute
σ:= [H(m)dmodN].
•Vrfy: on input a public key /angbracketleftN,e/angbracketright, a message m, and a signature σ,
output 1 if and only if σe?=H(m) modN.
The RSA-FDH signature scheme.
What properties does Hneed in order for this construction to be secure?
At a minimum, to prevent the no-message attack it should be infeasible for
an attacker to start with σ, compute ˆ m:= [σemodN], and then ﬁnd a
message msuch that H(m) = ˆm. This, in particular, means that Hshould
be hard to invert in some sense. To prevent the second attack, we need an H
that does not admit “multiplicative relations,” that is, for which it is hard to
ﬁnd three messages m,m1,m2withH(m) =H(m1)·H(m2) modN. Finally,
it must be hard to ﬁnd collisions in H: ifH(m1) =H(m2), thenm1andm2
have the same signature and forgery becomes trivial.
Thereisno knownwaytochoose Hsothat Construction12.6canbe proven
secure. However, it ispossible to prove security if His modeled as a random
oracle that maps its inputs uniformly onto Z∗
N; the scheme in this case is
called the RSA full-domain hash (RSA-FDH) signature scheme. One can
check that a random function of this sort satisﬁes the requirements discussed
in the previous paragraph: a random function (with large range) is hard to
invert, does not have any easy-to-ﬁnd multiplicative relations, and is collision
resistant. Of course, this informal reasoning does not rule out all possible
attacks, but the proof of security below does.
Before turning to the formal proof, we provide some intuition. Our goal is
to prove that if the RSA problem is hard relative to GenRSA, then RSA-FDH
is secure when His modeled as a random oracle. We consider ﬁrst security
against a no-message attack, i.e., when the adversary Acannot request any448 Introduction to Modern Cryptography
signatures. Here the adversary is limited to making queries to the random
oracle, and we assume without loss of generality that Aalways makes exactly
q(distinct) queries to Hand that if the adversary outputs a forgery ( m,σ)
then it had previously queried mtoH.
Say there is an eﬃcient adversary Athat carries out a no-message attack
and makesexactly qqueriesto H. We constructan eﬃcientalgorithm A/primesolv-
ing the RSA problem relative to GenRSA. Given input ( N,e,y), algorithmA/prime
runsAon the public key pk=/angbracketleftN,e/angbracketright. Letm1,...,m qdenote the q(distinct)
queries thatAmakes to H. Our algorithm A/primeanswers these random-oracle
queries ofAwith uniform elements of Z∗
Nexcept for one query—say, the ith
query, chosen uniformly from the oracle queries of A—that is answered with y
itself. Note that, from the point of view of A, all its random-oracle queries
are answered with uniform elements of Z∗
N(recall that yis uniform as well,
although it is not chosen by A/prime), and soAhas no information about i. More-
over, the view of Awhen run as a subroutine by A/primeis identically distributed
to the view ofAwhen attacking the original signature scheme.
IfAoutputs a forgery ( m,σ) then, because m∈{m1,...,m q}, with prob-
ability 1/qwe will have m=mi. In that case,
σe=H(m) =H(mi) =ymodN
andA/primecan output σas the solution to its given RSA instance ( N,e,y). We
conclude that ifAoutputs a forgery with probability ε, thenA/primesolves the
RSA problem with probability ε/q. Sinceqis polynomial, we conclude that
εmust be negligible if the RSA problem is hard relative to GenRSA.
Handling the case when the adversary is allowed to request signatures on
messages of its choice is more diﬃcult. The complication arises since our
algorithmA/primeabove does not know the decryption exponent d, yet now has to
compute valid signatures on messages queried by Ato its signing oracle. This
seems impossible (and possibly even contradictory!) until we realize that A/prime
cancorrectly compute a signature on a message mas long as it sets H(m) to
equal to [ σemodN] for aknownvalueσ. (Here we are using the fact that
the random oracle is “programmable.”) If σis uniform then [ σemodN] is
uniform as well, and so the random oracle is still emulated “properly” by A/prime.
The above intuition is formalized in the proof of the following:
THEOREM 12.7 If the RSA problem is hard relative to GenRSA andH
is modeled as a random oracle, then Construction 12.6 is secure.
PROOF Let Π = ( Gen,Sign,Vrfy) denoteConstruction12.6, andlet Abea
probabilisticpolynomial-timeadversary. We assumewithout lossofgenerality
that ifArequests a signature on a message m, or outputs a forgery ( m,σ),
then it previously queried mtoH. Letq(n) be a polynomial upper bound
on the number of queries Amakes to Hon security parameter n; we assume
without loss of generality that Amakes exactly q(n) distinct queries to H.Digital Signature Schemes 449
For convenience, we list the steps of experiment Sig-forgeA,Π(n):
1.GenRSA(1n)is run to obtain (N,e,d). A random function
H:{0,1}∗→Z∗
Nis chosen.
2. The adversary Ais given pk=/angbracketleftN,e/angbracketright, and may query H
as well as a signing oracle Sign/angbracketleftN,d/angbracketright(·)that, on input a mes-
sagem, returns σ:= [H(m)dmodN].
3.Aoutputs(m,σ), where it had not previously requested a sig-
nature on m. The output of the experiment is 1if and only
ifσe=H(m) modN.
We deﬁne a modiﬁed experiment Sig-forge/prime
A,Π(n) in which a guess is made at
the outset as to which message (from among the qmessages thatAqueries
toH) will correspond to the eventual forgery (if any) output by A:
1. Choose uniform j∈{1,...,q}.
2.GenRSA(1n)is run to obtain (N,e,d). A random function
H:{0,1}∗→Z∗
Nis chosen.
3. The adversary Ais given pk=/angbracketleftN,e/angbracketright, and may query H
as well as a signing oracle Sign/angbracketleftN,d/angbracketright(·)that, on input a mes-
sagem, returns σ:= [H(m)dmodN].
4.Aoutputs(m,σ), where it had not previously requested a sig-
nature on m. Letibe such that m=mi.2The output of the
experiment is 1if and only if σe=H(m) modNandj=i.
Sincejis uniform and independent of everything else, the probability that
j=i(even conditioned on the event that Aoutputs a forgery) is exactly 1 /q.
Therefore Pr[ Sig-forge/prime
A,Π(n) = 1] =1
q(n)·Pr[Sig-forgeA,Π(n) = 1].
Now consider the modiﬁed experiment Sig-forge/prime/prime
A,Π(n) in which the exper-
iment is aborted if Aever requests a signature on the message mj(where
mjdenotes the jth message queried to H, andjis the uniform value chosen
at the outset). This does not change the probability that the output of the
experiment is 1, since if Aever requests a signature on mjthen it cannot
possible output a forgery on mj. In words,
Pr[Sig-forge/prime/prime
A,Π(n) = 1] = Pr[ Sig-forge/prime
A,Π(n) = 1]
=Pr[Sig-forgeA,Π(n) = 1]
q(n).(12.1)
2Heremidenotes the ith query made to H. Recall, by assumption, that if Arequests a
signature on a message m, then it must have previously queried mtoH.450 Introduction to Modern Cryptography
Finally, consider the following algorithm A/primesolving the RSA problem:
AlgorithmA/prime:
The algorithm is given ( N,e,y) as input.
1. Choose uniform j∈{1,...,q}.
2. RunAon input the public key pk=/angbracketleftN,e/angbracketright. Store triples
(·,·,·) in a table, initially empty. An entry ( mi,σi,yi) indi-
cates thatA/primehas setH(mi) =yi, andσe
i=yimodN.
3. WhenAmakes its ith random-oracle query H(mi), answer
it as follows:
•Ifi=j, returnyas the answer to the query.
•Elsechooseuniform σi∈Z∗
N, compute yi:= [σe
imodN],
returnyiastheanswertothe query, andstore( mi,σi,yi)
in the table.
WhenArequests a signature on message m, letibe such
thatm=miand answer the query as follows3
•Ifi=jthenA/primeaborts.
•Ifi/negationslash=jthen there is an entry ( mi,σi,yi) in the table.
Returnσias the answer to the query.
4. At the end of A’s execution, it outputs ( m,σ). Ifm=mj
andσe=ymodN, then output σ.
Clearly,A/primeruns in probabilistic polynomial time. Say the input ( N,e,y) to
A/primeis generated by running GenRSA(1n) to obtain ( N,e,d), and then choosing
uniformy∈Z∗
N. The crucial observation is that the view of Awhen run as a
subroutine byA/primeis identical to the view of Ain experiment Sig-forge/prime/prime
A,Π(n).
In particular, all Sign-oracle queries are answered correctly, and each of the
random-oracle queries of Awhen run as a subroutine by A/primeis answered with
a uniform element of Z∗
N:
•The query H(mj) is answered with y, a uniform element of Z∗
N.
•QueriesH(mi) withi/negationslash=jare answered with yi= [σe
imodN], whereσi
is uniform in Z∗
N. Since exponentiation to the eth power is a one-to-one
function, yiis uniformly distributed as well.
Finally, observe that whenever experiment Sig-forge/prime/prime
A,Π(n) would output 1,
thenA/primeoutputsacorrectsolutiontoitsgivenRSAinstance. Thisfollowssince
Sig-forge/prime/prime
A,Π(n) = 1 implies that j=iandσe=H(mi) modN. Now, when
j=i, algorithmA/primedoes not abort and in addition H(mi) =y. Thus,σe=
3Heremidenotes the ith query made to H. Recall, by assumption, that if Arequests a
signature on a message m, then it must have previously queried mtoH.Digital Signature Schemes 451
H(mi) =ymodN, and so σis the desired inverse. Using Equation (12.1),
this means that
Pr[RSA-invA/prime,GenRSA(n) = 1] = Pr[ Sig-forge/prime/prime
A,Π(n) = 1]
=Pr[Sig-forgeA,Π(n) = 1]
q(n).(12.2)
If the RSA problem is hard relative to GenRSA, there is a negligible function
neglsuch that Pr[ RSA-invA/prime,GenRSA(n) = 1]≤negl(n). Since q(n) is poly-
nomial, we conclude from Equation (12.2) that Pr[ Sig-forgeA,Π(n) = 1] is
negligible as well. This completes the proof.
RSA PKCS #1 v2.1. The RSA PKCS #1 v2.1 standard includes a signa-
tureschemethatcanbeviewedasavariantofRSA-FDH. Abitmoreprecisely,
the standard deﬁnes a scheme in which the signature on a message depends
on asalt(i.e., a random value) chosen by the signer at the time of signature
generation. If this salt is ﬁxed to NULL by the signer—something that is
allowed by the standard—the resulting scheme is very similar to RSA-FDH.
It is critical for the range of Hto be (close to) allofZ∗
N; in particular
it does not suﬃce to simply let Hbe an “oﬀ-the-shelf” cryptographic hash
function such as SHA-1. (The output length of SHA-1 is much smaller than
the length of RSA moduli used in practice.) Indeed, practical attacks on
Construction 12.6 are known if the output length of His too small (e.g., if
the output length is 160 bits as would be the case if SHA-1 were used directly
asH). In the PKCS #1 v2.1 signature scheme, His constructed via repeated
application of an underlying cryptographic hash function.
12.5 Signatures from the Discrete-Logarithm Problem
Signature schemes can be based on the discrete-logarithm assumption as
well, although the assumption does not lend itself as readily to signatures as
the RSA assumption does. In Section 12.5.1 we describe a signature scheme
introduced by Claus Schnorr that can be proven secure in the random-oracle
model. In Section 12.5.2 we describe the DSA and ECDSA signature schemes
which are used widely.
12.5.1 The Schnorr Signature Scheme
The underlying intuition for the Schnorr signature scheme is best explained
by taking a slight detour to discuss (public-key) identiﬁcation schemes . We
then describe the Fiat–Shamir transform that can be used to convert iden-
tiﬁcation schemes to signature schemes in the random-oracle model. Finally,452 Introduction to Modern Cryptography
we present the Schnorr identiﬁcation scheme—and corresponding signature
scheme—based on the discrete-logarithm problem.
Identiﬁcation Schemes
An identiﬁcation scheme is an interactive protocol that allows one party to
proveits identity (i.e., to authenticate itself) toanother. Thisis averynatural
notion, and it is common nowadays to authenticate oneself when logging in to
a website. We call the party identifying herself (e.g., the user) the “prover,”
and the party verifying the identity (e.g., the web server) the “veriﬁer.” Here,
we are interested in the public-key setting where the prover and veriﬁer do
not share any secret information (such as a password) in advance; instead,
the veriﬁer only knows the public key of the prover. Successful execution of
the identiﬁcation protocolconvinces the veriﬁerthat it is communicating with
the intended prover rather than an imposter.
We will only consider three-round identiﬁcation protocols of a speciﬁc form,
where the prover is speciﬁed by two algorithms P1,P2and the veriﬁer’s side
of the protocol is speciﬁed by an algorithm V. The prover runs P1(sk) using
its private key skto obtain an initial message Ialong with some state st,
and initiates the protocol by sending Ito the veriﬁer. In response, the veriﬁer
sendsachallenge rchosenuniformlyfromsomesetΩ pkdeﬁned bytheprover’s
public key pk. Next, the prover runs P2(sk,st,r) to compute a response s
that it sends back to the veriﬁer. Finally, the veriﬁer computes V(pk,r,s) and
accepts if and only if this results in the initial message I; see Figure 12.1. Of
course, for correctness we require that if the legitimate prover executes the
protocol correctly then the veriﬁer should always accept.
Prover(sk) Veriﬁer(pk)
(I,st)←P1(sk)I-
r←Ωpk
r
s:=P2(sk,st,r)
s-V(pk,r,s)?=I
FIGURE 12.1 :Athree-round identiﬁcation scheme.
For technical reasons, we assume identiﬁcation schemes that are “non-
degenerate,” which intuitively means that there are many possible initial mes-
sagesI, and none has a high probability of being sent. Formally, a scheme is
non-degenerate if for every private key skand any ﬁxed initial message I, theDigital Signature Schemes 453
probability thatP1(sk) outputs Iis negligible. (Any identiﬁcation scheme
can be trivially modiﬁed to be non-degenerate by sending a uniform n-bit
string along with the initial message.)
The basic security requirement of an identiﬁcation scheme is that an ad-
versary who does not know the prover’s secret key should be unable to fool
the veriﬁer into accepting. This should hold even if the attacker is able to
passively eavesdrop on multiple (honest) executions of the protocol between
the proverand veriﬁer. We formalize such eavesdroppingvia an oracle Transsk
that, when called without any input, runs an honest execution of the protocol
and returns to the adversary the entire transcript ( I,r,s) of the interaction.
Let Π = ( Gen,P1,P2,V) be an identiﬁcation scheme, and consider the fol-
lowing experiment for an adversary Aand parameter n:
The identiﬁcation experiment IdentA,Π(n):
1.Gen(1n)is run to obtain keys (pk,sk).
2. AdversaryAis givenpkand access to an oracle Transskthat
it can query as often as it likes.
3. At any point during the experiment, Aoutputs a message I.
A uniform challenge r∈Ωpkis chosen and given to A, who
responds with some s. (Amay continue to query Transskeven
after receiving r.)
4. The experiment outputs 1if and only ifV(pk,r,s)?=I.
DEFINITION 12.8 An identiﬁcation scheme Π = (Gen,P1,P2,V)isse-
cure against a passive attack , or just secure, if for all probabilistic polynomial-
time adversaries A, there exists a negligible function neglsuch that:
Pr[IdentA,Π(n) = 1]≤negl(n).
It is also possible to consider stronger notions of security, for example,
where the adversary can also carry out activeattacks on the protocol by
impersonating a veriﬁer and possibly sending maliciously chosen values r. We
will not need this for our application to signature schemes.
From Identiﬁcation Schemes to Signatures
The Fiat–Shamir transform (Construction 12.9) provides a way to con-
vert any (interactive) identiﬁcation scheme into a (non-interactive) signature
scheme. The basic idea is for the signer to act as a prover, running the iden-
tiﬁcation protocol by itself. That is, to sign a message m, the signer ﬁrst
computes I, and next generates the challenge rby applying some function
HtoIandm. It then derives the correct response s. The signature on m
is (r,s), which can be veriﬁed by (1) recomputing I:=V(pk,r,s) and then
(2) checking that H(I,m)?=r.454 Introduction to Modern Cryptography
CONSTRUCTION 12.9
Let(Genid,P1,P2,V) be an identiﬁcation scheme, and construct a signa-
ture scheme as follows:
•Gen: on input 1n, simply run Genid(1n) to obtain keys pk,sk.
The public key pkspeciﬁes a set of challenges Ω pk. As part of key
generation, a function H:{0,1}∗→Ωpkis speciﬁed, but we leave
this implicit.
•Sign: on input a private key skand a message m∈{0,1}∗, do:
1. Compute ( I,st)←P1(sk).
2. Compute r:=H(I,m).
3. Compute s:=P2(sk,st,r).
Output the signature ( r,s).
•Vrfy: on input a public key pk, a message m, and a signature ( r,s),
compute I:=V(pk,r,s) and output 1 if and only if H(I,m)?=r.
The Fiat–Shamir transform.
Asignature ( r,s) is “bound” to a speciﬁc message mbecauseris a function
of bothIandm; changing mthus results in a completely diﬀerent r. IfH
is modeled as a random oracle mapping inputs uniformly onto Ω pk, then the
challenge ris uniform; intuitively, it will be just as diﬃcult for an adversary
(who does not know sk) to ﬁnd a valid signature ( r,s) on a message mas it
would be to impersonate the prover in an honest execution of the protocol.
This intuition is formalized in the proof of the following theorem.
THEOREM 12.10 LetΠbe an identiﬁcation scheme, and let Π/primebe the
signature scheme that results by applying the Fiat–Shamir transform to it. If
Πis secure and His modeled as a random oracle, then Π/primeis secure.
PROOF LetA/primebe a probabilistic polynomial-time adversary attacking
the signature scheme Π/prime, withq=q(n) an upper bound on the number of
queries thatA/primemakes to H. We make a number of simplifying assumptions
without loss of generality. First, we assume that A/primemakes any given query
toHonly once. We also assume that after being given a signature ( r,s) on a
message mwithV(pk,r,s) =I, the adversaryA/primenever queries H(I,m) (since
it knows the answer will be r). Finally, we assume that if A/primeoutputs a forged
signature ( r,s) on a message mwithV(pk,r,s) =I, thenA/primehad previously
queriedH(I,m).
We construct an eﬃcient adversary Athat usesA/primeas a subroutine and
attacks the identiﬁcation scheme Π:Digital Signature Schemes 455
AlgorithmA:
The algorithm is given pkand access to an oracle Transsk.
1. Choose uniform j∈{1,...,q}.
2. RunA/prime(pk). Answer its queries as follows:
WhenA/primemakes its ith random-oracle query H(Ii,mi), an-
swer it as follows:
•Ifi=j, output Ijand receive in return a challenge r.
ReturnrtoA/primeas the answer to its query.
•Ifi/negationslash=j, choose a uniform r∈Ωpkand return ras the
answer to the query.
WhenA/primerequests a signature on m, answer it as follows:
(a) Query Transskto obtain a transcript ( I,r,s) of an honest
execution of the protocol.
(b) Return the signature ( r,s).
3. IfA/primeoutputs a forged signature ( r,s) on a message m, com-
puteI:=V(pk,r,s) and check whether ( I,m)?= (Ij,mj). If
so, then output s. Otherwise, abort.
The view ofA/primewhen run as a subroutine by Ain experiment IdentA,Π(n) is
almostidentical to the view of A/primein experiment Sig-forgeA/prime,Π/prime(n). Indeed, all
theH-queriesthatA/primemakes areansweredwith a uniform value from Ω pk, and
allthesigningqueriesthat A/primemakesareansweredwithvalidsignatureshaving
the correct distribution. The only diﬀerence between the views is that when
A/primeis run as a subroutine by Ait is possible for there to be an inconsistency
in the answersA/primereceives from its queries to H: speciﬁcally, this happens if
Aever answers a signing query for a message musing a transcript ( I,r,s) for
whichH(I,m) is already deﬁned (that is, A/primehad previously queried ( I,m)
toH) andH(I,m)/negationslash=r. However, if Π is non-degenerate then this only ever
happens with negligible probability. Thus, the probability that A/primeoutputs a
forgery when run as a subroutine by AisSig-forgeA/prime,Π/prime(n)−negl(n) for some
negligible function negl.
Consider an execution of experiment IdentA,Π(n) in whichA/primeoutputs a
forged signature ( r,s) on a message m, and let I:=V(pk,r,s). Sincejis uni-
formandindependentofeverythingelse,theprobabilitythat( I,m) = (Ij,mj)
(even conditioned on the event that A/primeoutputs a forgery) is exactly 1 /q. (Re-
call we assume that if A/primeoutputs a forged signature ( r,s) on a message m
withV(pk,r,s) =I, thenA/primehad previously queried H(I,m).) When both
events happen,Asuccessfully impersonates the prover. Indeed, AsendsIj
as its initial message, receives in response a challenge r, and responds with s.
ButH(Ij,mj) =rand (since the forged signature is valid) V(pk,r,s) =I.
Putting everything together, we see that
Pr[IdentA,Π(n) = 1]≥1
q(n)·/parenleftbig
Pr[Sig-forgeA/prime,Π/prime(n) = 1]−negl(n)/parenrightbig456 Introduction to Modern Cryptography
or
Pr[Sig-forgeA/prime,Π/prime(n) = 1]≤q(n)·Pr[IdentA,Π(n) = 1]+negl(n).
If Π is secure then Pr[ IdentA,Π(n) = 1] is negligible; since q(n) is polynomial
this implies that Pr[ Sig-forgeA/prime,Π/prime(n) = 1] is also negligible. Because A/primewas
arbitrary, this means Π/primeis secure.
The Schnorr Identiﬁcation Scheme
The Schnorr identiﬁcation scheme is based on hardness of the discrete-
logarithm problem. Let Gbe a polynomial-time algorithm that takes as in-
put 1nand (except possibly with negligible probability) outputs a description
of a cyclic group G, its order q(with/bardblq/bardbl=n), and a generator g. To gen-
erate its keys, the prover runs G(1n) to obtain ( G,q,g), chooses a uniform
x∈Zq, and sets y:=gx; the public key is /angbracketleftG,q,g,y/angbracketrightand the private key
isx. To execute the protocol (see Figure 12.2), the prover begins by choosing
a uniform k∈Z∗
qand setting I:=gk; it sends Ias the initial message. The
veriﬁer chooses and sends a uniform challenge r∈Zq; in response, the prover
computes s:= [rx+kmodq]. The veriﬁer accepts if and only if gs·y−r?=I.
Correctness holds because
gs·y−r=grx+k·(gx)−r=gk=I.
Note that Iis uniform in G, and so the scheme is non-degenerate.
Before giving the proof, we provide some high-level intuition. A ﬁrst impor-
tant observation is that passive eavesdropping is of no help to the attacker.
The reason is that the attacker can simulate transcripts of honest executions
on its own, based only on the public key and withoutknowledge of the pri-
vate key. To do this, the attacker just reverses the order of the steps: it ﬁrst
chooses uniform and independent r,s∈Zqand then sets I:=gs·y−r. In an
honest transcript ( I,r,s), the initial message Iis a uniform element of G, the
challenge is an independent, uniform element of Zq, andsis then uniquely de-
termined as s= logg(I·yr). Simulated transcripts constructed by an attacker
Prover(x) Veriﬁer(G,q,g,y)
k←Zq
I:=gkI-
r←Zq
r
s:=[rx+kmodq]
s-check whether gs·y−r?=I
FIGURE 12.2 :An execution of the Schnorr identiﬁcation scheme.Digital Signature Schemes 457
have the same distribution: r∈Zqis uniform and, because sis uniform in
Zqand independent of r, we see that Iis uniform in Gand independent of r.
Finally,sis uniquely determined as satisfying the same constraint as before.
Due to this, we may eﬀectively assume that when attacking the identiﬁcation
scheme, an attacker does not eavesdrop on honest executions at all.
So, we have reduced to an attacker who gets a public key y, sends an initial
message I, is given in response a uniform challenge r, and then must send a
response sfor which gs·y−r=I. Informally, if an attacker is able to do this
with high probability then it must, in particular, be able to compute correct
responses s1,s2to at least two diﬀerent challenges r1,r2∈Zq. Note
gs1·y−r1=I=gs2·y−r2,
and sogs1−s2=yr1−r2. But this implies that the attacker (who, recall, is
able to generate s1in response to r1, ands2in response to r2) can implicitly
compute the discrete logarithm
loggy= [(s1−s2)·(r1−r2)−1modq],
contradicting the assumed hardness of the discrete-logarithm problem.
THEOREM 12.11 If the discrete-logarithm problem is hard relative to G,
then the Schnorr identiﬁcation scheme is secure.
PROOF Let Π denote the Schnorr identiﬁcation scheme, and let Abe a
pptadversary attacking the scheme. We construct the following pptalgo-
rithmA/primesolving the discrete-logarithm problem relative to G:
AlgorithmA/prime:
The algorithm is given G,q,g,yas input.
1. RunA(pk), answering all its queries to Transskas described
in the intuition given previously.
2. WhenAoutputsI, chooseauniform r1∈Zqasthechallenge.
Giver1toA, who responds with s1.
3. RunA(pk) a second time (from the beginning), using the
same randomness as before except for uniform and indepen-
dentr2∈Zq. Eventually,Aresponds with s2.
4. Ifgs1·h−r1=Iandgs2·h−r2=Iandr1/negationslash=r2then output
[(s1−s2)·(r1−r2)−1modq]. Else, output nothing.
Considering a single run of Aas a subroutine of A/prime, letωdenote the random-
ness used in that execution except forthe challenge itself. So, ωcomprises any
randomness used by G, the choice of (unknown) private key x, any random-
ness used byAitself, and the randomness used by A/primewhen answering queries458 Introduction to Modern Cryptography
toTranssk. Deﬁne V(ω,r) to be equal to 1 if and only if Acorrectly responds
to challenge rwhen randomness ωis used in the rest of the execution. For any
ﬁxedω, deﬁneδωdef= Prr[V(ω,r) = 1]; having ﬁxed ω, this is the probability
over choice of the challenge rthatAresponds correctly.
Deﬁneδ(n)def= Pr[IdentA,Π(n) = 1]. Since the simulation of the Transsk
oracle is perfect, we have
δ(n) = Pr ω,r[V(ω,r) = 1] =/summationtext
ωPr[ω]·δω.
Moreover, the intuition preceding the proof shows that A/primecorrectly computes
the discrete logarithm of ywheneverAsucceeds twice and r1/negationslash=r2. Thus:
Pr[DLogA/prime,G(n) = 1] = Pr ω,r1,r2[V(ω,r1)∧V(ω,r2)∧r1/negationslash=r2]
≥Prω,r1,r2[V(ω,r1)∧V(ω,r2)]−Prω,r1,r2[r1=r2]
=/summationtext
ωPr[ω]·(δω)2−1/q
≥/parenleftbig/summationtext
ωPr[ω]·δω/parenrightbig2−1/q
=δ(n)2−1/q,
using Jensen’s inequality4in the second-to-last step. If the discrete-logarithm
problem is hard relative to Gthen Pr[DLogA/prime,G(n) = 1] is negligible. Since
1/qis negligible (because /bardblq/bardbl=n), this implies that δ(n) is also negligible,
and so Π is a secure identiﬁcation scheme.
The Schnorr signature scheme is obtained by applying the Fiat–Shamir
transform to the Schnorr identiﬁcation scheme. See Construction 12.12.
CONSTRUCTION 12.12
LetGbe as described in the text.
•Gen: runG(1n) to obtain ( G,q,g). Choose a uniform x∈Zqand
sety:=gx. The private key is xand the public key is ( G,q,g,y).
As part of key generation, a function H:{0,1}∗→Zqis speciﬁed,
but we leave this implicit.
•Sign: on input a private key xand a message m∈{0,1}∗, choose
uniform k∈Zqand set I:=gk. Then compute r:=H(I,m),
followed by s:= [rx+kmodq]. Output the signature ( r,s).
•Vrfy: on input a public key ( G,q,g,y), a message m, and a signa-
ture (r,s), compute I:=gs·y−rand output 1 if H(I,m)?=r.
The Schnorr signature scheme.
4Jensen’s inequality says that/summationtext
iai·b2
i≥/parenleftbig/summationtext
iai/parenrightbig−1·/parenleftbig/summationtext
iai·bi/parenrightbig2for positive {ai}.Digital Signature Schemes 459
12.5.2 DSA and ECDSA
TheDigital Signature Algorithm (DSA)and Elliptic Curve Digital Signature
Algorithm (ECDSA) are based on the discrete-logarithm problem in diﬀerent
classes of groups. They have been around in some form since 1991, and are
bothincludedinthecurrent Digital Signature Standard (DSS)issuedbyNIST.
Both schemes follow a common template and can be viewed as being con-
structed from an underlying identiﬁcation scheme (see the previous section).
LetGbe a cyclic group of prime order qwith generator g. Consider the fol-
lowing identiﬁcation scheme in which the prover’s private key is xand public
key is (G,q,g,y) withy=gx:
1. The prover chooses uniform k∈Z∗
qand sends I:=gk.
2. The veriﬁer chooses and sends uniform α,r∈Zqas the challenge.
3. The prover sends s:= [k−1·(α+xr) modq] as the response.
4. The veriﬁer accepts if s/negationslash= 0 and gαs−1·yrs−1?=I.
Notes/negationslash= 0 unless α=−xrmodq, which occurs with negligible probability.
Assuming s/negationslash= 0, the inverse s−1modqexists and
gαs−1·yrs−1=gαs−1·gxrs−1=g(α+xr)·s−1=g(α+xr)·k·(α+xr)−1=I.
We thus see that correctness holds with all but negligible probability.
One can show that this identiﬁcation scheme is secure if the discrete-
logarithm problem is hard relative to G. We merely sketch the argument,
assuming familiarity with the results of the previous section. First of all,
transcripts of honest executions can be simulated: to do so, simply choose
uniformα,r∈Zqands∈Z∗
q, and then set I:=gαs−1·yrs−1. (This no longer
gives aperfectsimulation, but it is close enough.) Moreover, if an attacker
outputs an initial message Ifor which it can give correct responses s1,s2∈Z∗
q
to distinct challenges ( α,r1),(α,r2) then
gαs−1
1·yr1s−1
1=I=gαs−1
2·yr2s−1
2,
and sogα(s−1
1−s−1
2)=hr1s−1
1−r2s−1
2and logghcan be computed as in the
previous section. The same holds if the attacker gives correct responses to
distinct challenges ( α1,r),(α2,r).
The DSA/ECDSA signature schemes are constructed by “collapsing” the
aboveidentiﬁcation scheme into a non-interactivealgorithmrun by the signer.
In contrast to the Fiat–Shamir transform, however, the transformation here
is carried out as follows (see Construction 12.13):
•Setα:=H(m), where mis the message being signed and His a cryp-
tographic hash function.460 Introduction to Modern Cryptography
•Setr:=F(I) for a (speciﬁed) function F:G→Zq. Here, Fis a
“simple” function that is notintended to act like a random oracle.
The function Fdepends on the group Gm, which in turn depends on the
scheme. In DSA, Gis taken to be an order- qsubgroup of Z∗
p, forpprime
(cf. Section 8.3.3), and F(I)def= [Imodq]. In ECDSA, Gis an order- qsub-
groupof an elliptic-curvegroup E(Zp), forpprime.5Recall from Section 8.3.4
that any element of such a group can be represented as a pair ( x,y)∈Zp×Zp.
The function Fin this case is deﬁned as F((x,y))def= [xmodq].
CONSTRUCTION 12.13
LetGbe as in the text.
•Gen: on input 1n, runG(1n) to obtain ( G,q,g). Choose uniform
x∈Zqand set y:=gx. The public key is /angbracketleftG,q,g,y/angbracketrightand the
private key is x.
As part of key generation, two functions H:{0,1}∗→Zqand
F:G→Zqare speciﬁed, but we leave this implicit.
•Sign: on input the private key xand a message m∈ {0,1}∗,
choose uniform k∈Z∗
qand setr:=F(gk). Then compute s:=
[k−1·(H(m)+xr) modq]. (Ifr= 0 ors= 0 then start again with
a fresh choice of k.) Output the signature ( r,s).
•Vrfy: on input a public key /angbracketleftG,q,g,y/angbracketright, a message m∈{0,1}∗, and
a signature ( r,s) withr,s/negationslash= 0 mod q, output 1 if and only if
r?=F/parenleftBig
gH(m)·s−1yr·s−1/parenrightBig
.
DSA and ECDSA—abstractly.
Assuming hardness of the discrete-logarithm problem, DSA and ECDSA
can be proven secure if HandFare modeled as random oracles. As we have
discussed above, however, while the random-oracle model may be reasonable
forH, it isnotan appropriate model for F. No proofs of security are known
for the speciﬁc choices of Fin the standard. Nevertheless, DSA and ECDSA
have been used and studied for decades without any attacks being found.
Proper generation of k.The DSA/ECDSA schemes specify that the signer
should choose a uniform k∈Z∗
qwhen computing a signature. Failure to
choosekproperly (e.g., due to poor random-number generation) can lead to
catastrophic results. For starters, if an attacker can predict the value of k
used to compute a signature ( r,s) on a message m, then they can compute
5ECDSA also allows elliptic curves over other ﬁelds, but we have only covered the case of
prime ﬁelds in Section 8.3.4.Digital Signature Schemes 461
the signer’s private key. This is true because s=k−1·(H(m) +xr) modq,
and ifkis known then the only unknown is the private key x.
Evenifkis unpredictable, the attackercan compute the signer’s private key
if thesamekis ever used to generate two diﬀerent signatures. The attacker
can easily tell when this happens because then rrepeats as well. Say ( r,s1)
and (r,s2) are signatures on messages m1andm2, respectively. Then
s1=k−1·(H(m1)+xr) modq
s2=k−1·(H(m2)+xr) modq.
Subtracting gives s1−s2=k−1(H(m1)−H(m2)) modq, from which kcan
be computed; given k, the attacker can determine the private key xas in
the previous paragraph. This very attack was used by hackers to extract the
master private key from the Sony PlayStation (PS3) in 2010.
12.6 *Signatures from Hash Functions
Interestingly—and perhaps somewhat surprisingly—signature schemes can
be constructed based on cryptographic hash functions, without relying on
number-theoretic assumptions. (This is in contrast to public-key encryption,
which seems to require hard problems with some algebraic structure.) In
this section we explore such constructions. The schemes we will see are also
interesting in that they do not rely on random oracles, as opposed to all the
constructions we have described previously in this chapter.
12.6.1 Lamport’s Signature Scheme
We initiate our study of signature schemes based on hash functions by
considering the relatively weak notion of one-time-secure signature schemes .
Informally, such schemes are “secure” as long as a given private key is used to
sign only a singlemessage. Schemes satisfying this notion of security may be
appropriate for some applications, and also serve as useful “building blocks”
forachievingstrongernotionsofsecurity,aswewillseeinthefollowingsection.
Let Π = ( Gen,Sign,Vrfy) be a signature scheme, and consider the following
experiment for an adversary Aand parameter n:
The one-time signature experiment Sig-forge1-time
A,Π(n):
1.Gen(1n)is run to obtain keys (pk,sk).
2. AdversaryAis given pkand asks a singlequerym/primeto its
oracleSignsk(·).Athen outputs (m,σ)withm/negationslash=m/prime.
3. The output of the experiment is deﬁned to be 1if and only if
Vrfypk(m,σ) = 1.462 Introduction to Modern Cryptography
DEFINITION 12.14 Signature scheme Π = (Gen,Sign,Vrfy)isexisten-
tiallyunforgeableunderasingle-messageattack , or is aone-time-securesignature
scheme, if for all probabilistic polynomial-time adversaries A, there exists a
negligible function neglsuch that:
Pr/bracketleftBig
Sig-forge1-time
A,Π(n) = 1/bracketrightBig
≤negl(n).
LeslieLamportshowedaconstructionofaone-time-securesignaturescheme
in 1979. We illustrate the idea for the case of signing 3-bit messages. Let H
be a cryptographic hash function. A private key consists of six uniform values
x1,0,x1,1,x2,0,x2,1,x3,0,x3,1∈{0,1}n, and the corresponding public key
contains the results obtained by applying Hto each of these elements. These
keys can be visualized as two-dimensional arrays:
pk=/parenleftbigg
y1,0y2,0y3,0
y1,1y2,1y3,1/parenrightbigg
sk=/parenleftbigg
x1,0x2,0x3,0
x1,1x2,1x3,1/parenrightbigg
.
To sign a message m=m1m2m3(wheremi∈{0,1}), the signer releases
the appropriate preimage xi,mifor each bit of the message; the signature σ
consists of the three values ( x1,m1, x2,m2, x3,m3). Veriﬁcation is carried out
in the natural way: presented with the candidate signature ( x1,x2,x3) on the
message m=m1m2m3, accept if and only if H(xi)?=yi,mifor 1≤i≤3.
This is shown graphically in Figure 12.3, and the general case—for messages
of any length /lscript—is described formally in Construction 12.15.
Signing m=011:
sk=/parenleftBigg
x1,0x2,0x3,0
x1,1x2,1x3,1/parenrightBigg
⇒σ=(x1,0,x2,1, x3,1)
Verifying for m= 011 and σ= (x1,x2,x3):
pk=/parenleftBigg
y1,0y2,0y3,0
y1,1y2,1y3,1/parenrightBigg/bracerightBigg
⇒H(x1)?=y1,0
H(x2)?=y2,1
H(x3)?=y3,1
FIGURE 12.3 :The Lamport scheme used to sign the message m= 011.
After observing a signature on a message, an attacker who wishes to forge
a signature on any othermessage must ﬁnd a preimage of one of the three
“unused” elements in the public key. If Hisone-way (see Deﬁnition 8.72),
then ﬁnding any such preimage is computationally diﬃcult.
THEOREM 12.16 Let/lscriptbe any polynomial. If His a one-way function,
then Construction 12.15 is a one-time-secure signature scheme.Digital Signature Schemes 463
CONSTRUCTION 12.15
LetH:{0,1}∗→{0,1}∗be a function. Construct a signature scheme
for messages of length /lscript=/lscript(n) as follows:
•Gen: on input 1n, proceed as follows for i∈{1,...,/lscript}:
1. Choose uniform xi,0,xi,1∈{0,1}n.
2. Compute yi,0:=H(xi,0) andyi,1:=H(xi,1).
The public key pkand the private key skare
pk=/parenleftbiggy1,0y2,0···y/lscript,0
y1,1y2,1···y/lscript,1/parenrightbigg
sk=/parenleftbiggx1,0x2,0···x/lscript,0
x1,1x2,1···x/lscript,1/parenrightbigg
.
•Sign: on inputa private key skas above anda message m∈{0,1}/lscript
withm=m1···m/lscript, output the signature ( x1,m1, ..., x /lscript,m/lscript).
•Vrfy: on input a public key pkas above, a message m∈{0,1}/lscript
withm=m1···m/lscript, and a signature σ= (x1,...,x /lscript), output 1 if
and only if H(xi) =yi,mifor all 1≤i≤/lscript.
The Lamport signature scheme.
PROOF Let/lscript=/lscript(n) throughout. As noted a moment ago, the key ob-
servation is this: say an attacker Arequests a signature on a message m/prime,
and consider any other message m/negationslash=m/prime. There must be at least one position
i∗∈{1,...,/lscript}on which mandm/primediﬀer. Say mi∗=b/negationslash=m/prime
i∗. Then forging
a signature on mrequires, at least, ﬁnding a preimage (under H) of element
yi∗,b∗of the public key. Since His one-way, this should be infeasible. We now
formalize this intuition.
Let Π denote the Lamport scheme, and let Abe a probabilistic polynomial-
time adversary. In a particular execution of Sig-forge1-time
A,Π(n), letm/primedenote
the messagewhosesignatureisrequestedby A(weassumewithoutlossofgen-
erality thatAalwaysrequests a signature on a message), and let ( m,σ) be the
ﬁnal output ofA. We say thatAoutputs a forgery at (i,b) ifVrfypk(m,σ) = 1
and furthermore mi/negationslash=m/prime
i(i.e., messages mandm/primediﬀer on their ith posi-
tion) and mi=b/negationslash=m/prime
i. Note that whenever Aoutputs a forgery, it outputs
a forgery at some(i,b).
Consider the following pptalgorithmIattempting to invert H:
AlgorithmI:
The algorithm is given 1nandyas input.
1. Chooseuniform i∗∈{1,...,/lscript}andb∗∈{0,1}. Setyi∗,b∗:=y.
2. For all i∈{1,...,/lscript}andb∈{0,1}with (i,b)/negationslash= (i∗,b∗):
•Choose uniform xi,b∈{0,1}nand setyi,b:=H(xi,b).
3. RunAon input pk:=/parenleftbigg
y1,0y2,0···y/lscript,0
y1,1y2,1···y/lscript,1/parenrightbigg
.464 Introduction to Modern Cryptography
4. WhenArequests a signature on the message m/prime:
•Ifm/prime
i∗=b∗, thenIaborts the execution.
•Otherwise,Ireturnsthesignature σ= (x1,m/prime
1,...,x /lscript,m/prime
/lscript).
5. WhenAoutputs ( m,σ) withσ= (x1,...,x /lscript):
•IfAoutputs a forgery at ( i∗,b∗), then output xi∗.
WheneverAoutputs a forgery at ( i∗,b∗), algorithmIsucceeds in inverting
its given input y. We are interested in the probability that this occurs when
the input toIis generated by choosing uniform x∈ {0,1}nand setting
y:=H(x) (cf. Deﬁnition 8.72). Imagine a “mental experiment” in which Iis
givenxat the outset, sets xi∗,b∗:=x, and then always returns a signature to
Ain step 4 (i.e., even if m/prime
i∗=b∗). The view ofAwhen run as a subroutine
byIin this mental experiment is distributed identically to the view of Ain
experiment Sig-forge1-time
A,Π(n). Because ( i∗,b∗) was chosen uniformly at the
beginning of the experiment, and the view of Ais independent of this choice,
the probability that Aoutputs a forgery at ( i∗,b∗), conditioned on the fact
thatAoutputs a forgery at all, is at least 1 /2/lscript. (This is because a signature
forgery implies a forgery for at least one point ( i,b). Since there are 2 /lscript(n)
points, the probability of the forgery being at ( i∗,b∗) is at least 1 /2/lscript.) We
conclude that, in this mental experiment, the probability that Aoutputs a
forgery at ( i∗,b∗) is at least1
2/lscript·Pr[Sig-forge1-time
A,Π(n) = 1].
Returning to the real experiment involving Ias initially described, the
key observation is that the probability that Aoutputs a forgery at (i∗,b∗)is
unchanged . This is because the mental experiment and the real experiment
coincide ifAoutputs a forgery at ( i∗,b∗). That is, the experiments only diﬀer
ifm/prime
i∗=b∗, but if this happens then it is impossible (by deﬁnition) for Ato
subsequently output a forgery at ( i∗,b∗). So the probability that Aoutputs a
forgery at ( i∗,b∗) is still at least1
2/lscript·Pr[Sig-forge1-time
A,Π(n) = 1]. In other words,
Pr[InvertI,H(n) = 1]≥1
2/lscript·Pr[Sig-forge1-time
A,Π(n) = 1].
Because His a one-way function, there is a negligible function neglsuch that
negl(n)≥Pr[InvertI,H(n) = 1].
Since/lscriptis polynomial this implies that Pr[ Sig-forge1-time
A,Π(n) = 1] is negligible,
completing the proof.
COROLLARY 12.17 Ifone-way functions exist, then for any polyno-
mial/lscriptthere is a one-time-secure signature scheme for messages of length /lscript.Digital Signature Schemes 465
12.6.2 Chain-Based Signatures
Beingabletosignonlyasinglemessagewith agivenprivatekeyisobviously
a signiﬁcant drawback. We show here an approachbased on collision-resistant
hash functions that allows a signer to sign arbitrarily many messages, at the
expense ofmaintaining statethat must be updated after eachsignatureis gen-
erated. In Section 12.6.3 we discuss a more eﬃcient variant of this approach
(that still requires state), and then describe how this modiﬁed construction
can be made stateless. The result shows that signature schemes satisfying
Deﬁnition 12.2 can be constructed based on collision-resistant hash functions.
We ﬁrst deﬁne signature schemes that allow the signer to maintain state
that is updated after every signature is produced.
DEFINITION 12.18 Astateful signature scheme is a tuple of probabilistic
polynomial-time algorithms (Gen,Sign,Vrfy)satisfying the following:
1. Thekey-generation algorithm Gen takes as input a security parameter
1nand outputs (pk,sk,s 0). These are called the public key ,private key ,
andinitial state , respectively. We assume pkandskeach has length at
leastn, and that ncan be determined from pk,sk.
2. Thesigning algorithm Sign takes as input a private key sk, a value si−1,
and a message m∈{0,1}∗. It outputs a signature σand a value si.
3. The deterministic veriﬁcation algorithm Vrfy takes as input a public key
pk, a message m, and a signature σ. It outputs a bit b.
We require that for every n, every(pk,sk,s 0)output by Gen(1n), and any mes-
sagesm1,...,m t∈{0,1}∗, if we iteratively compute (σi,si)←Signsk,si−1(mi)
fori= 1,...,t, then for every i∈{1,...,t}, it holds that Vrfypk(mi,σi) = 1.
We emphasize that the veriﬁer does not need to know the signer’s state in
order to verify a signature; in fact, in some schemes the state must be kept
secret by the signer in order for security to hold. Signature schemes that do
not maintain state (as in Deﬁnition 12.1) are called stateless to distinguish
them from stateful schemes. Clearly, stateless schemes are preferable (al-
though stateful schemes can still potentially be useful). We introduce stateful
signatures as a stepping stone to an eventual stateless construction.
Security for stateful signatures schemes is exactly analogous to Deﬁni-
tion 12.2, with the only subtleties being that the signing oracle returns only
the signature (and notthe state), and that the signing oracle updates the
state each time it is invoked.
For any polynomial t=t(n), we can easily construct a stateful “ t-time-
secure” signature scheme. (The deﬁnition of security here would be the ob-
vious generalization of Deﬁnition 12.14.) We can do this by simply letting
the public key (resp., private key) consist of tindependently generated pub-
lic keys (resp., private keys) for any one-time-secure signature scheme; i.e.,466 Introduction to Modern Cryptography
setpk:=/angbracketleftpk1,...,pk t/angbracketrightandsk:=/angbracketleftsk1,...,sk t/angbracketrightwhere each ( pki,ski) is an
independently generated key-pair for some one-time-secure signature scheme.
The state is a counter iinitially set to 1. To sign a message musing the
private key skand current state i≤t, compute σ←Signski(m) (that is,
generate a signature on musing the private key ski) and output ( σ,i); the
state is updated to i:=i+1. Since the state starts at 1, this means the ith
message is signed using ski. Veriﬁcation of a signature ( σ,i) on a message m
is done by checking whether σis a valid signature on mwith respect to pki.
This scheme is secure if used to sign tmessages since each private key of the
underlying one-time-secure scheme is used to sign only a singlemessage.
As described, signatures have constant length (i.e., independent of t), but
the public key has length linearint. It is possible to trade oﬀ the length
of the public key and signature by having the signer compute a Merkle tree
h:=MTt(pk1,...,pk t) (see Section 5.6.2) over the tunderlying public keys
from the one-time-secure scheme. That is, the public key will now be /angbracketleftt,h/angbracketright,
and the signature on the ith message will include ( σ,i), as before, along with
theith value pkiand a proof πithat this is the correct value corresponding
toh. (Veriﬁcation is done in the natural way.) The public key now has
constant size, and the signature length grows only logarithmically with t.
Sincetcan be an arbitrary polynomial, why don’t the previous schemes
give us the solution we are looking for? The main drawback is that they
require the upper bound ton the number of messages that can be signed to
be ﬁxed in advance , at the time of key generation. This is a potentially severe
limitation since once the upper bound is reached a new public key would have
to be generated and distributed. We would prefer instead to have a single,
ﬁxed public key that can be used to sign an unbounded number of messages.
Let Π = ( Gen,Sign,Vrfy) be a one-time-secure signature scheme. In the
scheme we have just described (ignoring the Merkle-tree optimization), the
signerruns tinvocationsof Gentoobtainpublickeys pk1,...,pk t, andincludes
eachoftheseinitsactualpublickey pk. Thesigneristhenrestrictedtosigning
at most tmessages. We can do better by using a “chain-based” scheme in
which the signer generates additional public keys on-the-ﬂy , as needed.
In the chain-based scheme, the public key consists of just a single public
keypk1generated using Gen, and the private key is just the associated pri-
vate key sk1. To sign the ﬁrst message m1, the signer ﬁrst generates a new
key-pair ( pk2,sk2) usingGen, and then signs both m1andpk2usingsk1to
obtainσ1←Signsk1(m1/bardblpk2). The signature that is output includes both
pk2andσ1, and the signer adds ( m1,pk2,sk2,σ1) to its current state. In gen-
eral, when it comes time to sign the ith message the signer will have stored
{(mj,pkj+1,skj+1,σj)}i−1
j=1as part of its state. To sign the ith message mi,
the signer ﬁrst generates a new key-pair ( pki+1,ski+1) usingGen, and then
signsmiandpki+1usingskito obtain a signature σi←Signski(mi/bardblpki+1).
The actual signature that is output includes pki+1,σi, and also the values
{mj,pkj+1,σj}i−1
j=1. The signer then adds ( mi,pki+1,ski+1,σi) to its state.
See Figure 12.4 for a graphical depiction of this process.Digital Signature Schemes 467
/MT109 /MT49/MT112/MT107 /MT50
/MT109 /MT50/MT112/MT107 /MT51/MT109 /MT49/MT112/MT107 /MT50/MT115/MT49
/MT109 /MT50/MT112/MT107 /MT51/MT115/MT50/MT112/MT107 /MT49 /MT112/MT107 /MT49
/MT109 /MT51/MT112/MT107 /MT52/MT115/MT51/MT115/MT49
/MT115/MT50
FIGURE 12.4 :Chain-based signatures: the situation before and after
signing the third message m3.
To verify a signature ( pki+1,σi,{mj,pkj+1,σj}i−1
j=1) on a message m=mi
with respect to public key pk1, the receiver veriﬁes each link between a public
keypkjand the next public key pkj+1in the chain, as well as the link between
the last public key pkiandm. That is, veriﬁcation outputs 1 if and only if
Vrfypkj(mj/bardblpkj+1,σj)?= 1 for all j∈{1,...,i}. (Refer to Figure 12.4.)
It is not hard to be convinced—at least on an intuitive level—that this sig-
nature scheme is existentially unforgeable under an adaptive chosen-message
attack (regardless of how many messages are signed). Informally, this is once
again due to the fact that each key-pair ( pki,ski) is used to sign only a single
“message,” where in this case the “message” is actually a message/public-key
pairmi/bardblpki+1. Since we will prove security of a more eﬃcient scheme in the
next section, we do not prove security for the chain-based scheme here.
Inthechain-basedscheme,eachpublickey pkiisusedtosignbothamessage
and another public key. Thus, it is essential that the underlying one-time-
securesignatureschemeΠ is capable of signing messages longer than the public
key. The Lamport scheme presented in Section 12.6.1 does nothave this
property. However, if we apply the hash-and-sign paradigm from Section 12.3
to the Lamport scheme, we doobtain a one-time-secure signaturescheme that
can sign messages of arbitrary length. (Although Theorem 12.4 was stated
only with regard to signature schemes satisfying Deﬁnition 12.2, it is not hard
to see that an identical proof works for one-time-secure signature schemes.)
Because this result is crucial for the next section, we state it formally. (Note
that the existence of collision-resistant hash functions implies the existence of
one-way functions; see Exercise 7.4.)
LEMMA 12.19 If collision-resistant hash functions exist, then there exists
a one-time-secure signature scheme (for messages of arbitrary length ).468 Introduction to Modern Cryptography
The chain-based signature scheme is a stateful signature scheme that is
existentially unforgeable under an adaptive chosen-message attack. It has
a number of disadvantages, though. For one, there is no immediate way
to eliminate the state (recall that our ultimate goal is a stateless scheme
satisfying Deﬁnition 12.2). It is also not very eﬃcient, in that the signature
length, size of the state, and veriﬁcation time are all linear in the number of
messages that have been signed. Finally, each signature reveals all previously
signed messages, and this may be undesirable in some contexts.
12.6.3 Tree-Based Signatures
The signer in the chain-based scheme of the previous section can be viewed
as maintaining a treeof degree 1, rooted at the public key pk1, and with depth
equal to the number of messagessigned so far (cf. Figure 12.4). A natural way
to improve eﬃciency is to use a binarytree in which each node has degree 2.
As before, a signature will correspond to a “signed” path in the tree from
a leaf to the root; as long as the tree has polynomial depth (even if it has
exponential size!), veriﬁcation can be done in polynomial time.
Concretely, to sign messages of length nwe will work with a binary tree
of depth nhaving 2nleaves. As before, the signer will add nodes to the tree
“on-the-ﬂy,” as needed. In contrast to the chain-based scheme, however, only
leaves (and not internal nodes) will be used for signing messages. Each leaf
of the tree will correspond to one of the possible messages of length n.
In moredetail, we imagine abinary tree ofdepth nwhere the root is labeled
byε(i.e., theemptystring),andanodethatislabeledwiththebinarystring w
(of length less than n) has left-child labeled w0 and right-child labeled w1.
This tree is never constructed in its entirety (note that it has exponential
size), but is instead built up by the signer as needed.
For every node w, we associate a pair of keys pkw,skwfor a one-time-secure
signature scheme Π. The public key of the root, pkε, is the actual public key
of the signer. To sign a message m∈{0,1}n, the signer does the following:
1. It ﬁrst generates keys (as needed) for all nodes on the path from the
root to the leaf labeled m. (Some of these public keys may have been
generated in the process of signing previous messages, and in that case
are not generated again.)
2. Next, it “certiﬁes” the path from the root to the leaf labeled mby
computing a signature on pkw0/bardblpkw1, using private key skw, for each
stringwthat is a proper preﬁx of m.
3. Finally, it “certiﬁes” mitself by computing a signature on musing the
private key skm.
The ﬁnal signature on mconsists of the signature on mwith respect to pkm,
as well as all the information needed to verify the path from the leaf labeledDigital Signature Schemes 469
/MT112/MT107/MT49/MT115/MT101
/MT115/MT49/MT112/MT107/MT101
/MT112/MT107/MT48
/MT112/MT107/MT49/MT49 /MT112/MT107/MT49/MT48
/MT112/MT107/MT49/MT48/MT49 /MT112/MT107/MT49/MT48/MT48/MT115/MT49/MT48 /MT115/MT49/MT49
/MT112/MT107/MT49/MT49/MT49 /MT112/MT107/MT49/MT49/MT48/MT115/MT49/MT48/MT49 /MT115/MT49/MT49/MT49
/MT109/MT32/MT61/MT32/MT49/MT48/MT49 /MT109/MT32/MT61/MT32/MT49/MT49/MT49
FIGURE 12.5 : Tree-based signatures (conceptually).
mto the root; see Figure 12.5. Additionally, the signer updates its state by
storing all the keys generated as part of the above signing process. A formal
description of this scheme is given as Construction 12.20.
Notice that each of the underlying keys in this scheme is used to sign only
asingle“message.” Each key associated with an internal node signs a pair of
public keys, and a key at a leaf is used to sign only a single message. Since
each key is used to sign a pairof other keys, we again need the one-time-
secure signature scheme Π to be capable of signing messages longer than the
public key. Lemma 12.19 shows that such schemes can be constructed based
on collision-resistant hash functions.
Before proving security of this tree-based approach, note that it improves
on the chain-based scheme in a number of respects. It still allows for signing
an unbounded number of messages. (Although there are only 2nleaves, the
message space contains only 2nmessages. In any case, 2nis eventually larger
thananypolynomialfunction of n.) Intermsofeﬃciency, thesignaturelength
and veriﬁcation time are now proportional to the message length nbut are
independent of the number of messages signed. The scheme is still stateful,
but we will see how this can be avoided after we prove the following result.
THEOREM 12.21 LetΠbe a one-time-secure signature scheme. Then
Construction 12.20 is a secure signature scheme.
PROOF Let Π∗denote Construction 12.20. Let A∗be a probabilistic
polynomial time adversary, let /lscript∗=/lscript∗(n) be a (polynomial) upper bound on
the number of signing queries made by A∗, and set /lscript=/lscript(n)def= 2n/lscript∗(n)+1.470 Introduction to Modern Cryptography
CONSTRUCTION 12.20
LetΠ = (Gen,Sign,Vrfy) be a signature scheme. For a binary string m, let
m|idef=m1···midenote the i-bit preﬁx of m(withm|0def=ε, the empty
string). Construct the scheme Π∗= (Gen∗,Sign∗,Vrfy∗) as follows:
•Gen∗: on input 1n, compute ( pkε,skε)←Gen(1n) and output the
public key pkε. The private key and initial state are skε.
•Sign∗: on input a message m∈{0,1}n, carry out the following.
1. Fori= 0 ton−1:
–Ifpkm|i0,pkm|i1, andσm|iare not in the state, compute
(pkm|i0,skm|i0)←Gen(1n), (pkm|i1,skm|i1)←Gen(1n),
andσm|i←Signskm|i(pkm|i0/bardblpkm|i1). In addition, add
all of these values to the state.
2. Ifσmisnotyetincludedinthestate, compute σm←Signskm(m)
and store it as part of the state.
3. Output the signature/parenleftBig/braceleftbig
σm|i,pkm|i0,pkm|i1/bracerightbign−1
i=0, σm/parenrightBig
.
•Vrfy∗: on input a public key pkε, message m, and signature/parenleftBig/braceleftbig
σm|i,pkm|i0,pkm|i1/bracerightbign−1
i=0, σm/parenrightBig
, output 1 if and only if:
1.Vrfypkm|i(pkm|i0/bardblpkm|i1,σm|i)?= 1 for all i∈{0,...,n−1}.
2.Vrfypkm(m,σm)?= 1.
A “tree-based” signature scheme.
Note that/lscriptupperbounds the numberofpublic keysfromΠ that areneeded to
generate /lscript∗signatures using Π∗. This is because each signature in Π∗requires
at most 2 nnew keys from Π (in the worst case), and one additional key from
Π is used as the actual public key pkε.
Consider the following pptadversaryAattacking the one-time-secure sig-
nature scheme Π:
AdversaryA:
Ais given as input a public key pk(the security parameter nis implicit).
•Choose a uniform index i∗∈{1,...,/lscript}. Construct a list pk1,...,pk/lscriptof
keys as follows:
–Setpki∗:=pk.
–Fori/negationslash=i∗, compute ( pki,ski)←Gen(1n).
•RunA∗on input public key pkε=pk1. WhenA∗requests a signature
on a message mdo:
1. Fori= 0 ton−1:Digital Signature Schemes 471
–If the values pkm|i0,pkm|i1, andσm|ihave not yet been de-
ﬁned, then set pkm|i0andpkm|i1equal to the next two unused
public keys pkjandpkj+1, and compute a signature σm|ion
pkm|i0/bardblpkm|i1with respect to pkm|i.6
2. Ifσmis not yet deﬁned, compute a signature σmonmwith respect
topkm(see footnote 6).
3. Give/parenleftBig/braceleftbig
σm|i,pkm|i0,pkm|i1/bracerightbign−1
i=0, σm/parenrightBig
toA∗.
•SayA∗outputs a message m(for which it had not previously requested
a signature) and a signature/parenleftBig/braceleftbig
σ/prime
m|i,pk/prime
m|i0,pk/prime
m|i1/bracerightbign−1
i=0, σ/prime
m/parenrightBig
. If this
is a valid signature on m, then:
Case 1: Say there exists a j∈{0,...,n−1}for which pk/prime
m|j0/negationslash=pkm|j0
orpk/prime
m|j1/negationslash=pkm|j1; this includes the case when pkm|j0orpkm|j1were
never deﬁned by A. Take the minimal such j, and let ibe such that
pki=pkm|j=pk/prime
m|j(such an iexists by the minimality of j). Ifi=i∗,
output (pk/prime
m|j0/bardblpk/prime
m|j1, σ/prime
m|j).
Case 2: If case 1 does not hold, then pk/prime
m=pkm. Letibe such that
pki=pkm. Ifi=i∗, output ( m,σ/prime
m).
Inexperiment Sig-forge1-time
A,Π(n), the viewofA∗being runasasubroutineby
Aisdistributedidenticallytothe viewof A∗inexperiment Sig-forgeA∗,Π∗(n).7
Thus, the probability that A∗outputs a forgery is exactly δ(n) when it is run
as a subroutine by Ain this experiment. Given that A∗outputs a forgery,
consider each of the two possible cases described above:
Case 1: Sincei∗isuniformandindependentoftheviewof A∗, theprobability
thati=i∗is exactly 1 //lscript. Ifi=i∗, thenArequested a signature on the
message pkm|j0/bardblpkm|j1with respect to the public key pk=pki∗=pkm|jthat
it was given (and requested no other signatures). Moreover,
pk/prime
m|j0/bardblpk/prime
m|j1/negationslash=pkm|j0/bardblpkm|j1
and yetσ/prime
m|jis a valid signature on pk/prime
m|j0/bardblpk/prime
m|j1with respect to pk. Thus,
Aoutputs a forgery in this case.
Case 2: Again, since i∗was chosen uniformly at random and is independent
of the view ofA∗, the probability that i=i∗is exactly 1 //lscript. Ifi=i∗, thenA
6Ifi/negationslash=i∗thenAcan compute a signature with respect to pkiby itself. Acan also obtain
a (single) signature with respect to pki∗by making the appropriate query to its signing
oracle. This is what is meant here.
7As we have mentioned, Anever “runs out” of public keys. A signing query of A∗uses
2npublic keys; thus, even if new public keys were required to answer everysigning query
ofA∗(which will in general not be the case), only 2 n/lscript∗(n) public keys would be needed
byAin addition to the “root” public key pkε.472 Introduction to Modern Cryptography
did not request any signatures with respect to the public key pk=pki=pkm
and yetσ/prime
mis a valid signature on mwith respect to pk.
We see that, conditioned on A∗outputting a forgery, Aoutputs a forgery
with probability exactly 1 //lscript. This means that
Pr[Sig-forge1-time
A,Π(n) = 1] = Pr[ Sig-forgeA∗,Π∗(n) = 1]//lscript(n).
Because Π is a one-time-securesignature scheme, there is a negligible function
neglfor which
Pr[Sig-forge1-time
A,Π(n) = 1]≤negl(n).
Since/lscriptis polynomial, this means Pr[ Sig-forgeA∗,Π∗(n) = 1] is negligible.
A Stateless Solution
Asdescribed, the signer generates state on-the-ﬂy as needed. However, we
can imagine having the signer generate the necessary information for all the
nodes in the entire tree in advance , at the time of key generation. (That is,
at the time of key generation the signer could generate the keys {(pkw,skw)}
and the signatures {σw}for all binary strings wof length at most n.) If key
generation were done in this way, the signer would not have to update its
state at all; these values could all be stored as part of a (huge) private key,
and we would obtain a stateless scheme. The problem with this approach, of
course, is that generating all these values would require exponential time, and
storing them all would require exponential memory.
An alternative is to store some randomness that can be used to generate
the values{(pkw,skw)}and{σw}, as needed, rather than storing the values
themselves. That is, the signer could store a random string rwfor eachw, and
wheneverthevalues pkw,skwareneededthesignercancompute( pkw,skw) :=
Gen(1n;rw), where this denotes the generationof a length- nkey using random
coinsrw. Similarly, if the signing procedure is probabilistic, the signer can
storer/prime
wand then set σw:=Signskw(pkw0/bardblpkw1;r/prime
w) (assuming here that
|w|< n). Generating and storing suﬃciently many random strings, however,
still requires exponential time and memory.
A simple modiﬁcation of this alternative gives a polynomial-time solution.
Instead of storing random rwandr/prime
was suggested above, the signer can store
two keys k,k/primefor a pseudorandom function F. When needed, the values
pkw,skwcan now be generated by the following two-step process:
1. Compute rw:=Fk(w).8
2. Compute ( pkw,skw) :=Gen(1n;rw) (as before).
8Weassume that the output length of Fis suﬃciently long, and that wis padded to some
ﬁxed-length string in a one-to-one fashion. We ignore these technicalities here.Digital Signature Schemes 473
In addition, the key k/primeis used to generatethe value r/prime
wthat is used to compute
the signature σw. This gives a stateless scheme in which key generation (as
well as signing and verifying) can be done in polynomial time. Intuitively,
this is secure because storing a random function is equivalent to storing all
therwandr/prime
wvalues that are needed, and storing a pseudorandom function
is “just as good.” We leave it as an exercise to give a formal proof that this
modiﬁed scheme remains secure.
Since the existence ofcollision-resistanthash functions implies the existence
of one-way functions (cf. Exercise 7.4), and the latter implies the existence of
pseudorandom functions (see Chapter 7), we have:
THEOREM 12.22 If collision-resistant hash functions exist, then there
exists a (stateless) secure signature scheme.
We remark that it is possible to construct signature schemes satisfying
Deﬁnition 12.2 from the (minimal) assumption that one-way functions exist;
a proof of this result is beyond the scope of this book.
12.7 *Certiﬁcates and Public-Key Infrastructures
Inthis section we brieﬂy discuss one of the primary applications of digital
signatures: the secure distribution of public keys. This brings us full circle in
ourdiscussion ofpublic-key cryptography. In this and the previouschapterwe
have seen how to usepublic-key cryptography once public keys are securely
distributed. Now we show how public-key cryptography itself can be used to
securely distribute public keys. This may sound circular, but it is not. What
we will show is that once a singlepublic key, belonging to a trusted party, is
distributed in a secure fashion, that key can be used to “bootstrap”the secure
distribution of arbitrarily many other public keys. Thus, at least in principle,
the problem of secure key distribution need only be solved once.
The key notion here is a digital certiﬁcate , which is simply a signature
binding an entity to some public key. To be concrete, say a party Charlie
has generated a key-pair ( pkC,skC) for a secure digital signature scheme (in
this section, we will only be concerned with signature schemes satisfying Def-
inition 12.2). Assume further that another party Bob has also generated a
key-pair ( pkB,skB) (in the present discussion, these may be keys for either a
signature scheme or a public-key encryption scheme), and that Charlie knows
thatpkBis Bob’s public key. Then Charlie can compute the signature
certC→Bdef=SignskC(‘Bob’s key is pkB’)
and give this signature to Bob. We call certC→Bacertiﬁcate for Bob’s key474 Introduction to Modern Cryptography
issued by Charlie. In practice a certiﬁcate should unambiguously identify the
party holding a particular public key and so a more uniquely descriptive term
than “Bob” would be used, for example, Bob’s full name and email address,
or the URL of Bob’s website.
Now say Bob wants to communicate with some other party Alice who al-
ready knows pkC. Bob can send ( pkB,certC→B) to Alice, who can then verify
thatcertC→Bisindeedavalidsignatureonthemessage ‘Bob’s key is pkB’
with respect to pkC. Assuming veriﬁcation succeeds, Alice now knows that
Charlie has signed the indicated message. If Alice trusts Charlie, she can
acceptpkBas Bob’s legitimate public key.
All communication between Bob and Alice can occur over an insecure and
unauthenticated channel. If an active adversary interferes with the transmis-
sion of (pkB,certC→B) from Bob to Alice, that adversary will be unable to
generate a valid certiﬁcate linking Bob to any otherpublic key pk/prime
Bunless
Charlie had previously signed some other certiﬁcate linking Bob with pk/prime
B
(in which case this is anyway not much of an attack). This all assumes that
Charlie is not dishonest and that his private key has not been compromised.
We have omitted many details in the above description. Most prominently,
we have not discussed how Alice learns pkCin the ﬁrst place; how Charlie
can be sure that pkBis Bob’s public key; and how Alice decides whether to
trust Charlie. Fully specifying such details (and others) deﬁnes a public-key
infrastructure (PKI) that enables the widespread distribution of public keys.
A variety of diﬀerent PKI models have been suggested, and we mention a few
of the more popular ones now. Our treatment here will be kept at a relatively
high level, and the reader interested in further details is advised to consult
the references at the end of this chapter.
A single certiﬁcate authority. The simplest PKI assumes a single certiﬁ-
cate authority (CA) who is completely trusted by everybody and who issues
certiﬁcates for everyone’s public key. A certiﬁcate authority would not typi-
cally be a person, but would more likely be a company whose business it is to
certify public keys, a government agency, or perhaps a department within an
organization (although in this latter case the CA would likely only be used by
people within the organization). Anyone who wants to rely on the services of
the CA would have to obtain a legitimate copy of the CA’s public key pkCA.
Clearly, this step must be carried out in a secure fashion since if some party
obtains an incorrect versionof pkCAthen that partymay not be able to obtain
an authentic copy of anyone else’s public key. This means that pkCAmust be
distributed over an authenticated channel. The easiest way of doing this is
via physical means: for example, if the CA is within an organization then any
employee can obtain an authentic copy of pkCAdirectly from the CA on their
ﬁrst day of work. If the CA is a company, then other users would have to go
to this company at some point and, say, pick up a USB stick that contains
the CA’s public key. This inconvenient step need only be carried out once.
A common way for a CA to distribute its public key in practice is to “bun-Digital Signature Schemes 475
dle” this public key with some other software. For example, this occurs today
in many popular web browsers: a CA’s public key is provided together with
the browser, and the browser is programmed to automatically verify certiﬁ-
cates as they arrive. (Actually, modern web browsers have public keys of
multiple CAs hard-wired into their code, and so more accurately fall into the
“multiple CA” model discussed below.)
The mechanism by which a CA issues a certiﬁcate to some party Bob must
also be very carefully controlled, although the details may vary from CA
to CA. As one example, Bob may have to show up in person with a copy
of his public key pkBalong with identiﬁcation proving that his name (or his
emailaddress)iswhatheclaims. OnlythenwouldtheCAissuethecertiﬁcate.
In the model where there is a single CA, parties completely trust this CA to
issue certiﬁcatesonlywhen appropriate; this is whyit is crucialthat a detailed
veriﬁcation process be used before a certiﬁcate is issued. As a consequence, if
Alice receives a certiﬁcate certCA→Bcertifying that pkBis Bob’s public key,
Alice will accept this assertion as valid, and use pkBas Bob’s public key.
Multiple certiﬁcate authorities. While the model in which there is only
one CA is simple and appealing, it is not verypractical. For onething, outside
of a single organization it is unlikely for everyone to trust the same CA. This
need not imply that anyone thinks the CA is corrupt; it could simply be the
case that someone ﬁnds the CA’s veriﬁcation process to be insuﬃcient (say,
the CA asks for only one form of identiﬁcation when generating a certiﬁcate
but Alice would prefer that two be used instead). Moreover, the CA is a
single point of failure for the entire system. If the CA is corrupt, or can be
bribed, or even if the CA is merely lax with the way it protects its private
key, the legitimacy of issued certiﬁcates may be called into question. It is also
inconvenient for all parties who want certiﬁcates to have to contact this CA.
One approachto alleviating these issues is to rely on multiple CAs. A party
Bob who wants to obtain a certiﬁcate on his public key can choose which
CA(s) it wants to issue a certiﬁcate, and a party Alice who is presented
with a certiﬁcate, or even multiple certiﬁcates issued by diﬀerent CAs, can
choose which CA’s certiﬁcates she trusts. There is no harm in having Bob
obtain a certiﬁcate from more than one CA (apart from some inconvenience
and expense for Bob), but Alice must be more careful since the security of
her communication is ultimately only as good as the least-secure CA that
she trusts. That is, say Alice trusts two CAs CA 1and CA 2, and CA 2is
corrupted by an adversary. Then, although this adversary will not be able to
forge certiﬁcates issued by CA 1, it will be able to issue fake certiﬁcates in the
name of CA 2for any identity/public key of its choice. This is a real problem
in current systems. As mentioned earlier, operating systems/web browsers
typically come pre-conﬁgured with many CAs’ public keys, and the default
setting is for all these CAs to be treated as equally trustworthy. Essentially
any company willing to pay, however, can be included as a CA. So the list
of pre-conﬁgured CAs includes some reputable, well-established companies476 Introduction to Modern Cryptography
along with other, newer companies whose trustworthiness cannot be easily
established. It is left to the user to manually conﬁgure their settings so as to
only accept certiﬁcates from CAs the user trusts.
Delegation and certiﬁcate chains. Another approach which alleviates
some of the burden on a single CA (but does not address the security concerns
of having a single point of failure) is to use certiﬁcate chains . We present the
idea for certiﬁcate chains of length 2, although it is easy to see that everything
we say generalizes to chains of arbitrary length.
Say Charlie, acting as a CA, issues a certiﬁcate for Bob as in our original
discussion. Assume further that Bob’s key pkBis a public key for a signature
scheme. Bob, in turn, can issue his own certiﬁcates for other parties. For
example, Bob may issue a certiﬁcate for Alice of the form
certB→Adef=SignskB(‘Alice’s key is pkA’).
Now, if Alice wants to communicate with some fourth party Dave who knows
Charlie’s public key (but not Bob’s), then Alice can send
pkA,certB→A, pkB,certC→B,
to Dave. What can Dave deduce from this? Well, he can ﬁrst verify that
Charlie, whom he trusts and whose public key is already in his possession, has
signed a certiﬁcate certC→Bindicating that pkBindeed belongs to someone
named Bob. Dave can also verify that this person named Bob has signed a
certiﬁcate certB→Aindicating that pkAindeed belongs to Alice. If Davetrusts
Charlie to issue certiﬁcates only to trustworthy people, then Dave may accept
pkAas being the authentic key of Alice.
We highlight that in this example stronger semantics are associated with a
certiﬁcate certC→B. In our prior discussion, a certiﬁcate of this form was only
an assertion that Bob holds public key pkB. Now, a certiﬁcate asserts that
Bob holds public key pkBand Bob is trusted to issue other certiﬁcates . When
Charlie signs a certiﬁcate for Bob having these stronger semantics, Charlie is,
in eﬀect, delegating his ability to issue certiﬁcates to Bob. Bob can now act
as a proxy for Charlie, issuing certiﬁcates on Charlie’s behalf.
Coming back to a CA-based PKI, we can imagine one “root” CA and n
“second-level” CAs CA 1,...,CAn. The root CA can issue certiﬁcates for
each of the second-level CAs, who can then in turn issue certiﬁcates for other
principles holding public keys. This eases the burden on the root CA, and
also makes it more convenient for parties to obtain certiﬁcates (since they
may now contact the second-level CA who is closest to them, for example).
On the other hand, managing these second-level CAs may be diﬃcult, and
their presence means that there are now more points of attack in the system.
The “web of trust” model. The last example of a PKI we will discuss is
a fully distributed model, with no central points of trust, called the “web ofDigital Signature Schemes 477
trust.” A variant of this model is used by the PGP (“Pretty Good Privacy”)
email-encryption software for distribution of public keys.
In the “web of trust” model, anyone can issue certiﬁcates to anyone else
and each user has to make their own decision about how much trust to place
in certiﬁcates issued by other users. As an example of how this might work,
say a user Alice is already in possession of public keys pk1,pk2,pk3for some
usersC1,C2,C3. (We discuss below how these public keys might initially
be obtained by Alice.) Another user Bob who wants to communicate with
Alice might have certiﬁcates certC1→B,certC3→B, andcertC4→B, and will
send these certiﬁcates (along with his public key pkB) to Alice. Alice cannot
verifycertC4→B(since she doesn’t have C4’s public key), but she can verify
the other two certiﬁcates. Now she has to decide how much trust she places
inC1andC3. She may decide to accept pkBif she unequivocally trusts C1,
or if she trusts both C1andC3to a lesser extent. (She may, for example,
consider it likely that either C1orC3is corrupt, but consider it unlikely for
thembothto be corrupt.)
In this model, as described, users are expected to collect both public keys
of other parties, as well as certiﬁcates on their own public key. In the context
of PGP, this used to be done at “key-signing parties” where PGP users got
together(say, at aconference), gaveeach otherauthentic copiesoftheir public
keys, and issued certiﬁcates for each other. In general the users at a key-
signing party may not know each other, but they can check a driver’s license,
say, before accepting or issuing a certiﬁcate for someone’s public key.
Public keys and certiﬁcates can also be stored in a central database, and
this is done for PGP (see http://pgp.mit.edu ). When Alice wants to send
an encrypted message to Bob, she can search for Bob’s public key in this
database; along with Bob’s public key, the database will return a list of all
certiﬁcates it holds that have been issued for Bob’s public key. It is also
possible that multiple public keys for Bob will be found in the database, and
each of these public keys may be certiﬁed by certiﬁcates issued by a diﬀerent
set of parties. Once again, Alice then needs to decide how much trust to place
in any of these public keys before using them.
The web of trust model is attractive because it does not require trust in
any central authority. On the other hand, while it may work well for the
average user encrypting their email, it does not seem appropriate for settings
where security is more critical, or for the distribution of organizational public
keys (e.g., for e-commerce on the web). If a user wants to communicate with
his bank, for example, it is unlikely that he would trust people he met at
a conference to certify his bank’s public key, and also unlikely that a bank
representative will go to a key-signing party to get the bank’s key certiﬁed.
Invalidating Certiﬁcates
One important issue we have not yet touched upon at all is the fact that
certiﬁcates should generally not be valid indeﬁnitely. An employee may leave478 Introduction to Modern Cryptography
a company, in which case he or she is no longer allowed to receive encrypted
communication from others within the company; a user’s private key might
also be stolen, at which point the user (assuming they know about the theft)
will wantto generatea newkey-pairand havethe old public keyremovedfrom
circulation. In either of these scenarios, we need a way to render previously
issued certiﬁcates invalid.
Approaches for handling these issues are varied and complex, and we will
only mention two relatively simple ideas that, in some sense, represent op-
posite extremes. (Improving these methods is an active area of real-world
network-security research.)
Expiration. One method for preventing certiﬁcates from being used indef-
initely is to include an expiry date as part of the certiﬁcate. A certiﬁcate
issued by a CA Charlie for Bob’s public key might now have the form
certC→Bdef=SignskC(‘Bob’s key is pkB’, date),
wheredateis some date in the future at which point the certiﬁcate becomes
invalid. (For example, one year from the day the certiﬁcate is issued.) When
another user veriﬁes this certiﬁcate, they need to know not only pkBbut
also the expiry date, and they now need to check not only that the signature
is valid, but also that the expiry date has not passed. A user who holds a
certiﬁcate must contact the CA to get a new certiﬁcate issued whenever their
current one expires; at this point, the CA veriﬁes the identity/credentials of
the user again before issuing another certiﬁcate.
Using expiry dates provides a very coarse-grained solution to the problems
mentioned earlier. If an employee leaves a company the day after getting a
certiﬁcate, and the certiﬁcate expires one year after its issuance date, then
this employee can use his or her public key illegitimately for an entire year
until the expiry date passes. For this reason, this approach is typically used
in conjunction with other methods such as the one we describe next.
Revocation. When an employee leaves an organization, or a user’s private
key is stolen, we would like the certiﬁcates that have been issued for their
public keys to become invalid immediately, or at least as soon as possible.
This can be achieved by having the CA explicitly revokethe certiﬁcate. For
simplicityweassumeasingleCA,buteverythingwesayappliesmoregenerally
if the user had certiﬁcates issued by multiple CAs.
There are many diﬀerent ways revocation can be handled. One possibility
(the only one we will discuss) is for the CA to include a serial number in every
certiﬁcate it issues; that is, a certiﬁcate will now have the form
certC→Bdef=SignskC(‘Bob’s key is pkB’, ###),
where “###” represents the serial number of this certiﬁcate. Each certiﬁcate
should have a unique serial number, and the CA will store the information
(Bob,pkB,###) for each certiﬁcate it generates.Digital Signature Schemes 479
If a user Bob’s private key corresponding to a public key pkBis stolen,
Bob can alert the CA to this fact. (The CA must verify Bob’s identity here,
to prevent another user from falsely revoking a certiﬁcate issued to Bob.)
The CA will then search its database to ﬁnd the serial number associated
with the certiﬁcate issued for Bob and pkB. At the end of each day, say,
the CA will then generate a certiﬁcate revocation list (CRL) with the serial
numbers of all revoked certiﬁcates, and sign the CRL and the current date.
The signed CRL is then widely distributed or otherwise made available to
potential veriﬁers. Veriﬁcation of a certiﬁcate now requires checking that the
signature in the certiﬁcate is valid, checking that the serial number does not
appear on the most current revocation list, and verifying the CA’s signature
on the revocation list itself.
In this approach the way we have described it, there is a gap of at most one
day before a certiﬁcate becomes invalid. This oﬀers more ﬂexibility than an
approach based only on expiry dates.
12.8 Putting It All Together – SSL/TLS
Asa culmination of what we have covered in the book so far, we discuss
theTransport Layer Security (TLS) protocolthat is used extensively to secure
communication over the web; TLS is the protocol used by your browser any
time you connect to a website using httpsrather than http. We should be
clear that our goal here is to focus on the underlying cryptographyused in the
core TLS protocol, and not various other aspects that, although interesting
from a network-security standpoint, are irrelevant for our concerns. As usual,
we have slightly simpliﬁed and abstracted parts of the protocol in order to
convey the main point, and our description should not be relied upon for an
implementation. Finally, we do not formally deﬁne or claim security for the
protocol; indeed, a formal analysis of TLS is the subject of active research.
TLS is a standardized protocol based on a precursor called SSL (or Secure
Socket Layer ) that was developed by Netscape in the mid-1990s; the last
version available was SSL 3.0. TLS version 1.0 was released in 1999, updated
to version 1.1 in 2006, and updated again to version 1.2 (the current version)
in 2008. As of the time of this writing, approximately50% of websites still use
TLS 1.0 rather than a more recent version; all major web browsers support
TLS 1.2, although in some cases earlier versions of TLS are used by default.
For the most part, our description below is at a suﬃciently high level that
the diﬀerences between the versions are unimportant for our purposes. We
caution, however, that there are several known attacks on earlier versions.
TLS allows a client (e.g., a web browser) and a server (e.g., a website)
to agree on a set of shared keys and then to use those keys to encrypt and480 Introduction to Modern Cryptography
authenticate their subsequent communication. It consists of two parts: a
handshake protocol that performs authenticated key exchange to establish
the shared keys, and a record-layer protocol that uses those shared keys to
encrypt/authenticate the parties’ communication. Although TLS allows for
clientstoauthenticatetoservers,it isprimarilyusedonlyforauthenticationof
serversto clients because only serverstypically have certiﬁcates. (After a TLS
session is established, user-to-server authentication—if desired—can be done
at the application layer of the network stack by, e.g., sending a password.)
The handshake protocol. We now describe the basic ﬂow of the handshake
protocol. At the outset of the protocol, the client Cholds a set of CA’s public
keys{pk1,...,pk n}, and the server Shas a key-pair ( pkS,skS) for a KEM9
along with a certiﬁcate certi→Sissued by one of the CAs whose public key C
knows. To connect to S, the parties run the following steps.
1.Cbegins by sending a message to Sthat includes information about
versions of the protocol supported by the client, the ciphersuites sup-
ported by the client (e.g., which hash functions or block ciphers the
client allows), and a uniform value (a “nonce”) NC.
2.Sresponds by selecting the latest version of the protocol it supports
as well as an appropriate ciphersuite. In addition, it sends its public
keypkS, its certiﬁcate certi→S, and its own uniform value NS.
3.Cchecks whether one of the CA’s public keys it holds, say pki, matches
the CA who issued S’s certiﬁcate. If so, Cveriﬁes the certiﬁcate (and
also checks that it has not expired or been revoked) and, if successful,
learns that pkSisS’s public key. It then runs ( c,pmk)←EncapspkS(1n)
(seeSection11.3)toobtainaciphertext candwhatiscalleda pre-master
keypmk. It sends cto the server.
pmkis used to derive a master key mkusing a key-derivation function
(cf. Section 5.6.4) applied to pmk,NC, andNS. The client then applies
a pseudorandom generator to mkto derive four keys kC,k/prime
C,kS,k/prime
S.
Finally,Ccomputes τC←Macmk(transcript ), where transcript denotes
all messages exchangedbetween CandSthus far. The client then sends
τCtoS. (In fact, τCis itself encrypted and authenticated as done for
communication in the record-layer, described below.)
4.Scomputes pmk:=DecapsskS(c), from which it can derive mkand
kC,k/prime
C,kS,k/prime
Sas the client did. If Vrfymk(transcript ,τC)/negationslash= 1, then S
aborts. Otherwise, it sets τS←Macmk(transcript/prime), where transcript/prime
denotesallmessagesexchangedbetween CandSthusfar(i.e., including
9Itis also possible for Sto have a public key for a signature scheme and to use an ephemeral
KEM public key in the protocol below. We do not discuss this more complicated option.Digital Signature Schemes 481
the last message received from C).Sthen sends τStoC. (Again, τSis
actually encrypted and authenticated as record-layer traﬃc is.)
5. IfVrfymk(transcript/prime,τS)/negationslash= 1, the client aborts.
At the end of a successful execution of the handshake protocol, CandSshare
a set of four symmetric keys kC,k/prime
C,kS,k/prime
S.
TLS 1.2 supports two KEMs: a CDH/DDH-based KEM as in Construc-
tion 11.19, or the RSA-based encryption scheme PKCS #1 v1.5. To prevent
Bleichenbacher-styleattacksontheschemeinthelattercase,theservershould
not report a decryption error if Decapsfails in step 4. Instead, if decryption
fails it should choose a uniform pmkand then continue running the protocol
using that value. (In that case, of course, the value τCwill not verify and S
will abort; the point is that the attacker cannot distinguish whether this was
due to a decryption failure or not.)
The intuition for the security of the handshake protocol is that since C
veriﬁesthe certiﬁcate, itknowsthat onlythelegitimateserver Scanlearn pmk
and hence mk. Thus, if the protocol terminates successfully, Cknows that it
shareskeys kC,k/prime
C,kS,k/prime
Swiththelegitimate S, andthatnoadversarylearned
anything about thosekeys. This is supposed to hold evenin the presenceofan
active attacker, although a formal proof of this is quite involved. We remark,
however, that the message authentication code on the transcript is used to
prevent a man-in-the-middle attacker from changing the protocol version and
ciphersuites sent at the beginning of the handshake protocol. This prevents
an attacker from causing SorCto use old, weaker versions of the protocol,
or weak block ciphers and short keys.
The record-layer protocol. Once keys have been agreed upon by Cand
S, the parties use those keys to encrypt and authenticate all their subsequent
communication. CuseskC(resp.,k/prime
C)toencrypt(resp., authenticate)allmes-
sages it sends to S; similarly, SuseskSandk/prime
Sto encrypt and authenticate all
the messages it sends. Sequence numbers are used to prevent replay attacks,
as discussed in Section 4.5.3. TLS 1.2 uses an authenticate-then-encrypt ap-
proach, which, as we have seen in Section 4.5.2, can be problematic.
12.9 *Signcryption
Toclose this chapter, we brieﬂy and informally discuss the issue of joint
secrecy and integrity in the public-key setting. While this parallels our treat-
ment from Section 4.5, the fact that we are now in the public-key setting
introduces several additional complications.
For simplicity, we consider a network in which all relevant parties have pub-
lic/private key-pairs for bothencrypting and signing. We let ( ek,dk) denote482 Introduction to Modern Cryptography
a (public) encryption key and (private) decryption key, and use ( vk,sk) for
a (public) veriﬁcation key and (private) signing key. We assume all parties
know everyone else’s public keys.
Informally, our goal is to design a mechanism that allows a sender Sto
send a message mto a receiver Rwhile ensuring that (1) no other party
in the network can learn any information about m(i.e., secrecy) and (2) R
is assured that the message came from S(i.e., integrity). We will want to
consider both of these security properties even against active (e.g., chosen-
ciphertext) attacks by other parties in the network.
Following our discussion in Section 4.5, a natural idea is to use an “encrypt-
then-authenticate” approach in which Ssends/angbracketleftS,c,SignskS(c)/angbracketrighttoR, where
cis an encryption of musingR’s encryption key ekR. (We explicitly in-
clude the sender’s identity here for convenience.) However, there is a clever
chosen-ciphertext attack here regardless of the encryption scheme used. Hav-
ing observed a transmission as above, another (adversarial) party Acan strip
oﬀS’s signature and replace it with its own, sending /angbracketleftA,c,SignskA(c)/angbracketrighttoR.
In this case, Rwould not detect anything wrong, and would mistakenly think
thatAhas sent it the message m. IfRreplies to A, or otherwise behaves
towardAin a way that depends on the contents of the message, then Acan
potentially learn the unknown message m.
(Another problem with this scheme, although somewhat independent of
our discussion here, is that it no longer provides non-repudiation . That is, R
cannot easily prove to a third party that Shas signed the message m, at least
not without divulging its own decryption key dkR.)
One could instead try an “authenticate-then-encrypt” approach. Here, S
would ﬁrst compute a signature σ←SignskS(m) and then send
/angbracketleftS,EncekR(m/bardblσ)/angbracketright.
(Note that this solves the non-repudiation issue mentioned above.) If the
encryptionschemeisonlyCPA-securethenproblemsjust likethosementioned
in Section 4.5 apply, so let us assume a CCA-secure encryption scheme is used
instead. Even then, there is an attack that can be carried by a malicious R.
Upon receiving/angbracketleftS,EncekR(m/bardblσ)/angbracketrightfromS, a malicious Rcan decrypt to obtain
m/bardblσ, and then re-encrypt and send /angbracketleftS,EncekR/prime(m/bardblσ)/angbracketrightto another receiver R/prime.
This (honest) receiver R/primewill then think that Ssent it the message m. This
can have serious consequences, e.g., if mis the message “I owe you $100.”
These attacks can be prevented if parties are more careful about how they
handle identiﬁers. When encrypting, a sender should include its own identity
along with the message; when signing, a party should sign the identity of the
intended recipient along with what is being signed. For example, the second
approach would be modiﬁed so that Sﬁrst computes σ←SignskS(m/bardblR),
and then sends/angbracketleftS,EncekR(S/bardblm/bardblσ)/angbracketrighttoR. When decrypting, the receiver
should check that the resulting decrypted value includes the (purported)
sender’s identity; when verifying, the receiver should check that what wasDigital Signature Schemes 483
signed incorporates its own identity. When including identities in this way,
both authenticate-then-encrypt and encrypt-then-authenticate are secure if a
CCA-secureencryptionschemeanda stronglysecuresignaturescheme(whose
deﬁnition parallels Deﬁnition 4.3 for MACs) are used.
References and Additional Reading
Notable early work on signatures includes that of Diﬃe and Hellman [58],
Rabin [144, 145], Rivest, Shamir, and Adleman [148], and Goldwasser, Micali,
and Yao [82]. For an extensive treatment of signature schemes beyond what
could be covered here, see [98].
Goldwasser, Micali, and Rivest [81] deﬁned the notion of existential un-
forgeability under an adaptive chosen-message attack, and also gave the ﬁrst
construction of a stateful signature scheme satisfying this deﬁnition. Gold-
reich[74]suggestedanapproachtomaketheGoldwasser–Micali–Rivestscheme
stateless, and we have essentially adopted Goldreich’s ideas in Section 12.6.3.
Plain RSA signatures date to the original RSA paper [148]. RSA-FDH was
proposedbyBellareandRogawayin theiroriginalpaperon the random-oracle
model [21], although the idea (without proof) of using a cryptographic hash
function to prevent algebraic attacks can be traced back to Rabin [145]. A
later improvement [23] was standardized as part of PKCS #1 v2.1, available
athttp://www.emc.com/emc-plus/rsa-labs .
The Fiat–Shamir transform [65] and the Schnorr signature scheme [152]
both date to the late-1980s, although our proof of Theorem 12.10 is due to [1]
and our proof of Theorem 12.11 is inspired by [20]. The DSA and ECDSA
standards are described in [132].
Lamport’s signature scheme was published in 1979 [111], although it was
already described in [58]. A tree-based construction similar in spirit to Con-
struction 12.20 was suggested by Merkle [121, 122], although a tree-based
approach was also used in [81]. Naor and Yung [128] showed that one-way
permutations suﬃce for constructing one-time-secure signatures that can sign
messages of arbitrary length, and this was improved by Rompel [151], who
showed that one-way functions are suﬃcient. (See also [99].) As we have
seen in Section 12.6.3, one-time-secure signatures of this sort can be used to
construct secure signature schemes, implying that one-way functions suﬃce
for the existence of (stateless) secure signatures.
The notion of certiﬁcates was ﬁrst described by Kohnfelder [107] in his un-
dergraduate thesis. Public-key infrastructures are discussed in greater detail
in [102, Chapter 15]. See also [3, 62]. Further details of the TLS protocol
can be found in, e.g., [102, 165]. A formal treatment of combined secrecy and
integrity in the public-key setting is given by An et al. [10].484 Introduction to Modern Cryptography
Exercises
12.1 ShowthatConstruction4.7forconstructingavariable-lengthMACfrom
anyﬁxed-length MAC can alsobe used (with appropriatemodiﬁcations)
to construct a signature scheme for arbitrary-length messages from any
signature scheme for messages of ﬁxed length /lscript(n)≥n.
12.2 Prove that the existence of a one-time-secure signature scheme for 1-bit
messages implies the existence of one-way functions.
12.3 InSection12.4.1weshowedanattackontheplainRSAsignaturescheme
in which an attacker forges a signature on an arbitrary message using
two signing queries. Show how an attacker can forge a signature on an
arbitrary message using a singlesigning query.
12.4 Assume the RSA problem is hard. Show that the plain RSA signature
scheme satisﬁes the following weak deﬁnition of security: an attacker is
given the public key /angbracketleftN,e/angbracketrightand a uniform message m∈Z∗
N. The adver-
sary succeeds if it can output a valid signature on mwithout making
any signing queries.
12.5 Another approach (besides hashing) that has been tried to construct
secure RSA-based signatures is to encodethe message before applying
the RSA permutation. Here the signer ﬁxes a public encoding function
enc:{0,1}/lscript→Z∗
Nas part of its public key, and the signature on a
message misσ:= [enc(m)dmodN].
(a) How is veriﬁcation performed in encoded RSA?
(b) Discuss why appropriate choice of encoding function for /lscript/lessmuch/bardblN/bardbl
prevents the “no-message attack” described in Section 12.4.1.
(c) Show that encoded RSA is insecure if enc(m) =0x00/bardblm/bardbl0κ/10
(whereκdef=/bardblN/bardbl,/lscript=|m|def= 4κ/5,andmis notthe all-0message).
Assumee= 3.
(d) Show that encoded RSA is insecure for enc(m) = 0/bardblm/bardbl0/bardblm(where
/lscript=|m|def= (/bardblN/bardbl−1)/2 andmis not the all-0 message). Assume
e= 3.
(e) Solve parts (c) and (d) for arbitrary e.
12.6 Consider a variant of the Fiat–Shamir transform in which the signature
is (I,s) rather than ( r,s) and veriﬁcation is changed in the natural way.
Show that if the underlying identiﬁcation scheme is secure, then the
resulting signature scheme is secure here as well.Digital Signature Schemes 485
12.7 Consider a variant of DSA in which the message space is ZqandH
is omitted. (So the second component of the signature is now s:=
[k−1·(m+xr) modq].) Show that this variant is not secure.
12.8 Let fbe a one-way permutation. Consider the following signature
scheme for messages in the set {1,...,n}:
•To generate keys, choose uniform x∈{0,1}nand sety:=f(n)(x)
(wheref(i)(·) refers to i-fold iteration of f, andf(0)(x)def=x). The
public key is yand the private key is x.
•To sign message i∈{1,...,n}, output f(n−i)(x).
•To verify signature σon message iwith respect to public key y,
check whether y?=f(i)(σ).
(a) Show that the above is not a one-time-secure signature scheme.
Given a signature on a message i, for what messages jcan an
adversary output a forgery?
(b) Prove that no pptadversary given a signature on ican output a
forgery on any message j > iexcept with negligible probability.
(c) Suggesthowtomodify theschemesoastoobtainaone-time-secure
signature scheme.
Hint:Include two values y,y/primein the public key.
12.9 Astrongone-time-secure signature scheme satisﬁes the following (infor-
mally): given a signature σ/primeon a message m/prime, it is infeasible to output
(m,σ)/negationslash= (m/prime,σ/prime)forwhich σisavalidsignatureon m(notethat m=m/prime
is allowed).
(a) Give a formal deﬁnition of strong one-time-secure signatures.
(b) Assuming the existence of one-wayfunctions, show a one-wayfunc-
tion for which Lamport’s scheme is nota strong one-time-secure
signature scheme.
(c) Construct a strong one-time-secure signature scheme based on any
assumption used in this book.
Hint:Use a particular one-way function in Lamport’s scheme.
12.10 Consider the Lamport signature scheme. Describe an adversary who
obtains signatures on twomessages of its choice and can then forge
signatures on any message it likes.
12.11 The Lamport scheme uses 2 /lscriptvalues in the public key to sign messages
of length /lscript. Consider the variant in which the private key contains 2 /lscript
valuesx1,...,x 2/lscriptand the public key contains the values y1,...,y 2/lscriptwith
yi:=f(xi). A message m∈{0,1}/lscript/primeis mapped in a one-to-one fashion
to a subset Sm⊂{1,...,2/lscript}of size/lscript. To sign m, the signer reveals
{xi}i∈Sm. Prove that this gives a one-time-secure signature scheme.
What is the maximum message length /lscript/primethat this scheme supports?486 Introduction to Modern Cryptography
12.12 At the end of Section 12.6.3, we show how a pseudorandom function can
be used to make Construction 12.20 stateless. Does a similar approach
work for the chain-based scheme described in Section 12.6.2? If so,
sketch a construction and proof. If not, explain why and modify the
scheme to obtain a stateless variant.
12.13 Prove Theorem 12.22.
12.14 Assume revocation of certiﬁcates is handled in the following way: when
a user Bob claims that the private key corresponding to his public key
pkBhas been stolen, the user sends to the CA a statement of this fact
signed with respect to pkB. Upon receiving such a signed message, the
CA revokes the appropriate certiﬁcate.
Explainwhyit is not necessaryforthe CA to checkBob’sidentity in this
case. Inparticular,explainwhyitisofnoconcernthatanadversarywho
has stolen Bob’s private key can forge signatures with respect to pkB.Chapter 13
*Advanced Topics in Public-Key
Encryption
In Chapter 11 we saw several examples of public-key encryption schemes used
in practice. Here, we explore some schemes that are currently more of theo-
retical interest—although in some cases it is possible that these schemes (or
variants thereof) will be used more widely in the future.
We begin with a treatment of trapdoor permutations , a generalization of
one-way permutations, and show how to use them to construct public-key
encryption schemes. Trapdoor permutations neatly encapsulate the key char-
acteristics of the RSA permutation that make it so useful. As such, they often
provide a useful abstraction for designing new cryptosystems.
Next, we present three schemes based on problems related to factoring:
•ThePaillier encryption scheme is an example of an encryption scheme
that ishomomorphic . This property turns out to be useful for con-
structing more-complex cryptographic protocols, something we touch
on brieﬂy in Section 13.3.
•TheGoldwasser–Micali encryption scheme is of historicalinterest as the
ﬁrst scheme to be proven CPA-secure. It is also homomorphic, and uses
some interesting number theory that can be applied in other contexts.
•Finally, wediscussthe Rabin trapdoor permutation , whichcanbe usedto
constructapublic-keyencryptionscheme. Althoughsuperﬁciallysimilar
to the RSA trapdoor permutation, the Rabin trapdoor permutation
is distinguished by the fact that its security is based directlyon the
hardness of factoring. (Recall from Section 8.2.5 that hardness of the
RSA problem appears to be a stronger assumption.)
13.1 Encryption from Trapdoor Permutations
InSection 11.5.3 we saw how to construct a CPA-secure public-key encryp-
tion scheme based on the RSA assumption. By distilling those properties of
487488 Introduction to Modern Cryptography
RSA that are used in the construction, and deﬁning an abstract notion that
encapsulates those properties, we obtain a general template for constructing
secure encryption schemes based on any primitive satisfying the same set of
properties. Trapdoor permutations turnouttobethe“right”abstractionhere.
In the following section we deﬁne (families of) trapdoor permutations and
observe that the RSA family of one-way permutations (Construction 8.77)
satisﬁes the additional requirements needed to be a family of trapdoor permu-
tations. In Section 13.1.2 we generalize the construction from Section 11.5.3
and show that public-key encryption can be constructed from any trapdoor
permutation. These results will be used again in Section 13.5, where we show
a second example of a trapdoor permutation, this time based directly on the
factoring assumption.
In this section we rely on the material from Section 8.4.1 or, alternately,
Chapter 7.
13.1.1 Trapdoor Permutations
Recall the deﬁnitions of families of functions and families of one-way per-
mutations from Section 8.4.1. In that section, we showed that the RSA as-
sumption naturally givesrise to a family ofone-waypermutations. The astute
readermayhavenoticedthattheconstructionwegave(Construction8.77)has
a special property that was not remarked upon there: namely, the parameter-
generation algorithm Genoutputs some additional information along with I
thatenables eﬃcient inversion of fI. We refer to such additional information
as atrapdoor, and call families of one-way permutations with this additional
property families of trapdoor permutations . A formal deﬁnition follows.
DEFINITION 13.1 A tuple of polynomial-time algorithms (Gen,Samp,
f,Inv)is afamily of trapdoor permutations (or atrapdoor permutation )if:
•The probabilistic parameter-generation algorithm Gen , on input 1n, out-
puts(I,td)with|I|≥n. Each value of Ideﬁnes a setDIthat constitutes
the domain and range of a permutation (i.e., bijection) fI:DI→DI.
•LetGen1denote the algorithm that results by running Genand outputting
onlyI. Then(Gen1,Samp,f)is a family of one-way permutations.
•Let(I,td)be an output of Gen(1n). The deterministic invertingalgorithm
Inv, on input tdandy∈ DI, outputs x∈ DI. We denote this by
x:=Invtd(y). It is required that with all but negligible probability over
(I,td)output by Gen(1n)and uniform choice of x∈DI, we have
Invtd(fI(x)) =x.
As shorthand, we drop explicit mention of Sampand simply refer to trap-
door permutation ( Gen,f,Inv). For (I,td) output by Genwe write x←DIto*Advanced Topics in Public-Key Encryption 489
denote uniform selection of x∈DI(with the understanding that this is done
by algorithm Samp).
The second condition above implies that fIcannot be eﬃciently inverted
without td, but the ﬁnal condition means that fIcanbe eﬃciently inverted
withtd. It is immediate that Construction 8.77can be modiﬁed to give a fam-
ily of trapdoor permutations if the RSA problem is hard relative to GenRSA,
and so we refer to that construction as the RSA trapdoor permutation .
13.1.2 Public-Key Encryption from Trapdoor Permutations
We now sketch how a public-key encryption scheme can be constructed
from an arbitrary family of trapdoor permutations. The construction is sim-
ply a generalization of what was already done for the speciﬁc RSA trapdoor
permutation in Section 11.5.3.
Webeginby(re-)introducingthenotionofahard-corepredicate. Thisisthe
natural adaptation of Deﬁnition 7.4 to our context, and also generalizes our
previous discussion of one speciﬁc hard-core predicate for the RSA trapdoor
permutation in Section 11.5.3.
DEFINITION 13.2 LetΠ = (Gen,f,Inv)be a family of trapdoor per-
mutations, and let hcbe a deterministic polynomial-time algorithm that, on
inputIandx∈DI, outputs a single bit hcI(x). We say that hcis ahard-core
predicate of Πif for every probabilistic polynomial-time algorithm Athere is
a negligible function neglsuch that
Pr[A(I,fI(x)) =hcI(x)]≤1
2+negl(n),
where the probability is taken over the experiment in which Gen(1n)is run to
generate (I,td)and then xis chosen uniformly from DI.
The asymmetry provided by trapdoor permutations implies that anyone
who knows the trapdoor tdassociated with Ican recover xfromfI(x) and
thus compute hcI(x) fromfI(x). But given only I, it is infeasible to compute
hcI(x) fromfI(x) for a uniform x.
The following can be proved by a suitable modiﬁcation of Theorem 7.5:
THEOREM 13.3 Given a family of trapdoor permutations Π, there is a
family of trapdoor permutations /hatwideΠwith a hard-core predicate hcfor/hatwideΠ.
Given a family of trapdoor permutations /hatwideΠ = (/hatwidestGen,f,Inv) with hard-core
predicate hc, we can construct asingle-bit encryption scheme viathe following
approach (see Construction 13.4 below, and compare to Construction 11.32):
To generate keys, run /hatwidestGen(1n) to obtain ( I,td); the public key is Iand the490 Introduction to Modern Cryptography
private key is td. Given a public key I, encryption of a message m∈{0,1}
works by choosing uniform r∈DIsubject to the constraint that hcI(r) =m,
andthensettingtheciphertextequalto fI(r). Inordertodecrypt, thereceiver
usestdto recover rfromfI(r) and then outputs the message m:=hcI(r).
CONSTRUCTION 13.4
Let/hatwideΠ= (/hatwidestGen,f,Inv) be a family of trapdoor permutations with hard-
core predicate hc. Deﬁne a public-key encryption scheme as follows:
•Gen: on input 1n, run/hatwidestGen(1n) to obtain ( I,td). Outputthe public
keyIand the private key td.
•Enc: on input a public key Iand a message m∈{0,1}, choose a
uniform r∈DIsubject to the constraint that hcI(r) =m. Output
the ciphertext c:=fI(r).
•Dec: on input a private key tdand a ciphertext c, compute the
valuer:=InvI(c) and output the message hcI(r).
Public-key encryption from any family of trapdoor permutations.
Aproof of security follows along the lines of the proof of Theorem 11.33.
THEOREM 13.5 If/hatwideΠis a family of trapdoor permutations with hard-core
predicate hc, then Construction 13.4 is CPA-secure.
PROOF Let Π denote Construction 13.4. We prove that Π has indistin-
guishable encryptions in the presence of an eavesdropper; by Proposition11.3,
this implies it is CPA-secure.
We ﬁrst observe that hcmust be unbiased in the following sense. Let
δ0(n)def= Pr
(I,td)←/hatwidestGen(1n);x←DI[hcI(x) = 0]
and
δ1(n)def= Pr
(I,td)←/hatwidestGen(1n);x←DI[hcI(x) = 1].
Then there is a negligible function neglsuch that
δ0(n),δ1(n)≥1
2−negl(n);
if not, then an attacker who simply outputs the more frequently occurring bit
would violate Deﬁnition 13.2.
Now letAbe a probabilistic polynomial-time adversary. Without loss of
generality, we may assume m0= 0 and m1= 1 in experiment PubKeav
A,Π(n).*Advanced Topics in Public-Key Encryption 491
We then have
Pr[PubKeav
A,Π(n) = 1] =1
2·Pr[A(pk,c) = 0|cis an encryption of 0]
+1
2·Pr[A(pk,c) = 1|cis an encryption of 1] .
But then
Pr[A(I,fI(x)) =hcI(x)]
=δ0(n)·Pr[A(I,fI(x)) = 0|hcI(x) = 0]
+δ1(n)·Pr[A(I,fI(x)) = 1|hcI(x) = 1]
≥/parenleftbigg1
2−negl(n)/parenrightbigg
·Pr[A(I,fI(x)) = 0|hcI(x) = 0]
+/parenleftbigg1
2−negl(n)/parenrightbigg
·Pr[A(I,fI(x)) = 1|hcI(1) = 1]
≥1
2·Pr[A(I,fI(x)) = 0|hcI(x) = 0]
+1
2·Pr[A(I,fI(x)) = 1|hcI(1) = 1]−2·negl(n)
= Pr[PubKeav
A,Π(n) = 1]−2·negl(n).
Sincehcis a hard-corepredicate for /hatwideΠ, there is a negligible function negl/primesuch
thatnegl/prime(n)≥Pr[A(I,fI(x)) =hcI(x)]; this means that
Pr[PubKeav
A,Π(n) = 1]≤negl/prime(n)+2·negl(n),
completing the proof.
Encrypting longer messages. Using Claim 11.7, we know that we can
extend Construction 13.4 to encrypt /lscript-bit messages using ciphertexts /lscripttimes
as long. Better eﬃciency can be obtained by constructing a KEM, following
along the lines of Construction 11.34. We leave the details as an exercise.
13.2 The Paillier Encryption Scheme
Inthis section we describe the Paillier encryption scheme , a public-key
encryption scheme whose security is based on an assumption related (but
not known to be equivalent) to the hardness of factoring. This encryption
scheme is particularlyinteresting because it possessessome nice homomorphic
properties, as we will discuss further in Section 13.2.3.492 Introduction to Modern Cryptography
The Paillier encryption scheme utilizes the group Z∗
N2, the multiplicative
group of elements in the range {1,...,N2}that are relatively prime to N,
forNa product of two distinct primes. To understand the scheme it is helpful
to ﬁrst understand the structure of Z∗
N2. A useful characterization of this
group is given by the following proposition, which says, among other things,
thatZ∗
N2is isomorphic to ZN×Z∗
N(cf. Deﬁnition 8.23) for Nof the form
we will be interested in. We prove the proposition in the next section. (The
reader willing to accept the proposition on faith can skip to Section 13.2.2.)
PROPOSITION 13.6 LetN=pq, wherep,qare distinct odd primes of
equal length. Then:
1.gcd(N,φ(N)) = 1.
2. For any integer a≥0, we have (1+N)a= (1+aN) modN2.
As a consequence, the order of (1+N)inZ∗
N2isN. That is, (1+N)N=
1 modN2and(1+N)a/negationslash= 1 mod N2for any1≤a < N.
3.ZN×Z∗
Nis isomorphic to Z∗
N2, with isomorphism f:ZN×Z∗
N→Z∗
N2
given by
f(a,b) = [(1+ N)a·bNmodN2].
In light of the last part of the above proposition, we introduce some con-
venient notation. With Nunderstood, and x∈Z∗
N2,a∈ZN,b∈Z∗
N, we
writex↔(a,b) iff(a,b) =xwherefis the isomorphism from the proposi-
tion above. One way to think about this notation is that it means “ xinZ∗
N2
corresponds to (a,b) inZN×Z∗
N.” We have used the same notation in this
book with regard to the isomorphism Z∗
N/similarequalZ∗
p×Z∗
qgiven by the Chinese
remainder theorem; we keep the notation because in both cases it refers to an
isomorphism of groups. Nevertheless, there should be no confusion since the
groupZ∗
N2and the abovepropositionareonly used in this section. We remark
that heretheisomorphism—butnotitsinverse—iseﬃcientlycomputableeven
without the factorization of N.
13.2.1 The Structure of Z∗
N2
This section is devoted to a proof of Proposition 13.6. Throughout, we let
N,p,qbe as in the proposition.
CLAIM 13.7 gcd(N,φ(N)) = 1.
PROOF Recall that φ(N) = (p−1)(q−1). Assume p > qwithout loss of
generality. Since pis prime and p > p−1> q−1, clearly gcd( p,φ(N)) = 1.
Similarly, gcd( q,q−1) = 1. Now, if gcd( q,p−1)/negationslash= 1 then gcd( q,p−1) =q*Advanced Topics in Public-Key Encryption 493
sinceqis prime. But then ( p−1)/q≥2, contradicting the assumption that
pandqhave the same length.
CLAIM 13.8 Fora≥0an integer, we have (1+N)a= 1+aNmodN2.
Thus, the order of (1+N)inZ∗
N2isN.
PROOF Using the binomial expansion theorem (Theorem A.1):
(1+N)a=a/summationdisplay
i=0/parenleftbigga
i/parenrightbigg
Ni.
Reducing the right-hand side modulo N2, all terms with i≥2 become 0 and
so (1+N)a= 1+aNmodN2. The smallest nonzero asuch that (1+ N)a=
1 modN2is therefore a=N.
CLAIM 13.9 The groupZN×Z∗
Nis isomorphic to the group Z∗
N2, with
isomorphism f:ZN×Z∗
N→Z∗
N2given by f(a,b) = [(1+ N)a·bNmodN2].
PROOF Note that (1+ N)a·bNdoes not have a factor in common with
N2since gcd((1 + N),N2) = 1 and gcd( b,N2) = 1 (because b∈Z∗
N). So
[(1+N)a·bNmodN2] lies inZ∗
N2. We now prove that fis an isomorphism.
We ﬁrst show that fis a bijection. Since
|Z∗
N2|=φ(N2) =p·(p−1)·q·(q−1) =pq·(p−1)(q−1)
=|ZN|·|Z∗
N|=|ZN×Z∗
N|
(see Theorem 8.19 for the second equality), it suﬃces to show that fis one-
to-one. Say a1,a2∈ZNandb1,b2∈Z∗
Nare such that f(a1,b1) =f(a2,b2).
Then:
(1+N)a1−a2·(b1/b2)N= 1 mod N2. (13.1)
(Note that b2∈Z∗
Nand thus b2∈Z∗
N2, and sob2has a multiplicative inverse
moduloN2.) Raising both sides to the power φ(N) and using the fact that
the order of Z∗
N2isφ(N2) =N·φ(N) we obtain
(1+N)(a1−a2)·φ(N)·(b1/b2)N·φ(N)= 1 mod N2
⇒(1+N)(a1−a2)·φ(N)= 1 mod N2.
By Claim 13.8, (1+ N) has order NmoduloN2. Applying Proposition 8.53,
we see that ( a1−a2)·φ(N) = 0 mod Nand soNdivides ( a1−a2)·φ(N).
Since gcd( N,φ(N)) = 1 by Claim 13.7, it follows that N|(a1−a2). Since
a1,a2∈ZN, this can only occur if a1=a2.494 Introduction to Modern Cryptography
Returning to Equation (13.1) and setting a1=a2, we thus have bN
1=
bN
2modN2. This implies bN
1=bN
2modN. SinceNis relatively prime to
φ(N), the order of Z∗
N, exponentiation to the power Nis a bijection in Z∗
N
(cf. Corollary 8.17). This means that b1=b2modN; sinceb1,b2∈Z∗
N, we
haveb1=b2. We conclude that fis one-to-one, and hence a bijection.
To show that fis an isomorphism, we show that f(a1,b1)·f(a2,b2) =
f(a1+a2, b1·b2). (Note that multiplication on the left-hand side of the
equality takes place modulo N2, while addition/multiplication on the right-
hand side takes place modulo N.) We have:
f(a1,b1)·f(a2,b2) =/parenleftbig
(1+N)a1·bN
1/parenrightbig
·/parenleftbig
(1+N)a2·bN
2/parenrightbig
modN2
= (1+N)a1+a2·(b1b2)NmodN2.
Since (1+ N) has order NmoduloN2(by Claim 13.8), we can apply Propo-
sition 8.52 and obtain
f(a1,b1)·f(a2,b2) = (1+ N)a1+a2·(b1b2)NmodN2
= (1+N)[a1+a2modN]·(b1b2)NmodN2.(13.2)
We are not yet done, since b1b2in Equation (13.2) represents multiplication
moduloN2whereas we would like it to be modulo N. Letb1b2=r+γN,
whereγ,rare integers with 1 ≤r < N(rcannot be 0 since b1,b2∈Z∗
Nand
so their product cannot be divisible by N). Note that r=b1b2modN. We
also have
(b1b2)N= (r+γN)NmodN2
=N/summationdisplay
k=0/parenleftbiggN
k/parenrightbigg
rN−k(γN)kmodN2
=rN+N·rN−1·(γN) =rN= ([b1b2modN])NmodN2,
using the binomial expansion theorem as in Claim 13.8. Plugging this in to
Equation (13.2) we get the desired result:
f(a1,b1)·f(a2,b2) = (1+ N)[a1+a2modN]·(b1b2modN)NmodN2
=f(a1+a2,b1b2),
proving that fis an isomorphism from ZN×Z∗
NtoZ∗
N2.
13.2.2 The Paillier Encryption Scheme
LetN=pqbe a product of two distinct primes of equal length. Proposi-
tion 13.6 says that ZN×Z∗
Nis isomorphic to Z∗
N2, with isomorphism given
byf(a,b) = [(1+ N)a·bNmodN2]. A consequence is that a uniform element*Advanced Topics in Public-Key Encryption 495
y∈Z∗
N2corresponds to a uniform element ( a,b)∈ZN×Z∗
Nor, in other
words, an element ( a,b) with uniform a∈ZNand uniform b∈Z∗
N.
Cally∈Z∗
N2anNth residue modulo N2ifyis anNth power, that is,
if there exists an x∈Z∗
N2withy=xNmodN2. We denote the set of Nth
residues modulo N2byRes(N2). Let us characterizethe Nth residues in Z∗
N2.
Taking any x∈Z∗
N2withx↔(a,b) and raising it to the Nth power gives:
[xNmodN2]↔(a,b)N= (N·amodN, bNmodN) = (0,bNmodN).
(Recall that the group operation in ZN×Z∗
Nis addition modulo Nin the ﬁrst
component and multiplication modulo Nin the second component.) More-
over, we claim that any element ywithy↔(0,b) is anNth residue. To see
this, recall that gcd( N,φ(N)) = 1 and so ddef= [N−1modφ(N)] exists. So
(a,[bdmodN])N= (NamodN,[bdNmodN]) = (0,b)↔y
for anya∈ZN. We have thus shown that Res(N2) corresponds to the set
/braceleftbig
(0,b)|b∈Z∗
N/bracerightbig
.
Theabovealsodemonstratesthatthenumberof Nthrootsofany y∈Res(N2)
is exactly N, and so computing Nth powers is an N-to-1 function. As such,
ifr∈Z∗
N2is uniform then [ rNmodN2] is a uniform element of Res(N2).
Thedecisional composite residuosity problem , roughlyspeaking, is to distin-
guish a uniform element of Z∗
N2from a uniform element of Res(N2). Formally,
letGenModulus be a polynomial-time algorithm that, on input 1n, outputs
(N,p,q) whereN=pq, andpandqaren-bit primes (except with probability
negligible in n). Then:
DEFINITION 13.10 Thedecisional composite residuosity problem is hard
relative to GenModulus if for all probabilistic polynomial-time algorithms D
there is a negligible function neglsuch that
/vextendsingle/vextendsingle/vextendsinglePr[D(N,[rNmodN2]) = 1]−Pr[D(N,r) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl(n),
where in each case the probabilities are taken over the experiment in which
GenModulus (1n)outputs(N,p,q), and then a uniform r∈Z∗
N2is chosen.
(Recall that [rNmodN2]is a uniform element of Res(N2).)
Thedecisional composite residuosity (DCR)assumption is the assumption
that there is a GenModulus relative to which the decisional composite residu-
osity problem is hard.
As we have discussed, elements of Z∗
N2have the form ( r/prime,r) withr/primeand
rarbitrary (in the appropriate groups), whereas Nth residues have the form
(0,r) withr∈Z∗
Narbitrary. The DCR assumption is that it is hard to496 Introduction to Modern Cryptography
distinguish uniform elements of the ﬁrst type from uniform elements of the
second type. This suggests the following abstract way to encrypt a message
m∈ZNwith respect to a public key N: choose a uniform Nth residue (0 ,r)
and set the ciphertext equal to
c↔(m,1)·(0,r) = (m+0,1·r) = (m,r).
Without worryingfornowhowthiscanbecarriedouteﬃcientlybythesender,
or how the receiver can decrypt, let us simply convince ourselves (on an in-
tuitive level) that this is secure. Since a uniform Nth residue (0 ,r) cannot
be distinguished from a uniform element ( r/prime,r), the ciphertext as constructed
above is indistinguishable (from the point of an eavesdropper who does not
know the factorization of N) from the ciphertext
c/prime↔(m,1)·(r/prime,r) = ([m+r/primemodN],r)
for uniform r/prime∈ZNandr∈Z∗
N. Lemma 11.15 shows that [ m+r/primemodN]
is uniformly distributed in ZNand so, in particular, this ciphertext c/primeis
independent of the message m. CPA-security follows. A formal proof that
proceeds exactly along these lines is given further below.
Before turning to the formal description and proof of security, we show how
encryption and decryption can be performed eﬃciently.
Encryption. We have described encryption above as though it is taking
place in ZN×Z∗
N. In fact it takes place in the isomorphic group Z∗
N2. That
is, the sender generates a ciphertext c∈Z∗
N2by choosing a uniform1r∈Z∗
N
and then computing
c:= [(1+N)m·rNmodN2].
Observe that
c=/parenleftbig
(1+N)m·1N/parenrightbig
·/parenleftbig
(1+N)0·rN/parenrightbig
modN2↔(m,1)·(0,r),
and soc↔(m,r) as desired.
Decryption. We now describe how decryption can be performed eﬃciently
given the factorization of N. Forcconstructed as above, we claim that mis
recovered by the following steps:
•Set ˆc:= [cφ(N)modN2].
•Set ˆm:= (ˆc−1)/N. (Note that this is carried out over the integers.)
•Setm:=/bracketleftbig
ˆm·φ(N)−1modN/bracketrightbig
.
1Weremarkthat itdoes notmake any diﬀerence whether the sender chooses uniform r∈Z∗
N
or uniform r∈Z∗
N2, since in either case the distribution of [ rNmodN2] is the same (as
can be veriﬁed by looking at what happens in the isomorphic group ZN×Z∗
N).*Advanced Topics in Public-Key Encryption 497
To see why this works, let c↔(m,r) for an arbitrary r∈Z∗
N. Then
ˆcdef= [cφ(N)modN2]
↔(m, r)φ(N)
=/parenleftBig
[m·φ(N) modN],[rφ(N)modN]/parenrightBig
=/parenleftbig
[m·φ(N) modN],1/parenrightbig
.
By Proposition 13.6(3), this means that ˆ c= (1 +N)[m·φ(N) modN]modN2.
Using Proposition 13.6(2), we know that
ˆc= (1+N)[m·φ(N) modN]= (1+[m·φ(N) modN]·N) modN2.
Since 1+[ m·φ(N) modN]·Nis alwaysless that N2we can drop the mod N2
at the end and view the above as an equality over the integers. Thus, ˆ mdef=
(ˆc−1)/N= [m·φ(N) modN] and, ﬁnally,
m= [ˆm·φ(N)−1modN],
as required. (Note that φ(N) is invertible modulo Nsince gcd( N,φ(N)) = 1.)
We give a complete description of the Paillier encryption scheme, followed
by an example of the above calculations.
CONSTRUCTION 13.11
LetGenModulus be a polynomial-time algorithm that, on input 1n, out-
puts (N,p,q) where N=pqandpandqaren-bit primes (except with
probability negligible in n). Deﬁne the following encryption scheme:
•Gen: on input 1nrunGenModulus (1n) to obtain ( N,p,q). The
public key is N, and the private key is /angbracketleftN,φ(N)/angbracketright.
•Enc: on input a public key Nand a message m∈ZN, choose a
uniform r←Z∗
Nand output the ciphertext
c:= [(1+ N)m·rNmodN2].
•Dec: on inputa private key /angbracketleftN,φ(N)/angbracketrightand a ciphertext c, compute
m:=/bracketleftbigg[cφ(N)modN2]−1
N·φ(N)−1modN/bracketrightbigg
.
The Paillier encryption scheme.
Example 13.12
LetN= 11·17 = 187 (and so N2= 34969), and consider encrypting the
messagem= 175andthendecryptingthecorrespondingciphertext. Choosing498 Introduction to Modern Cryptography
r= 83∈Z∗
187, we compute the ciphertext
c:= [(1+187)175·83187mod 34969]= 23911
corresponding to (175 ,83). To decrypt, note that φ(N) = 160. So we ﬁrst
compute ˆ c:= [23911160mod 34969] = 25620. Subtracting 1 and dividing
by 187 gives ˆ m:= (25620−1)/187 = 137; since 90 = [160−1mod 187], the
message is recovered as m:= [137·90 mod 187] = 175. ♦
THEOREM 13.13 If the decisional composite residuosity problem is hard
relative to GenModulus , then the Paillier encryption scheme is CPA-secure.
PROOF Let Π denote the Paillier encryption scheme. We prove that
Π has indistinguishable encryptions in the presence of an eavesdropper; by
Theorem 11.6 this implies that it is CPA-secure.
LetAbe an arbitrary probabilistic polynomial-time adversary. Consider
the following pptalgorithm Dthat attempts to solvethe decisionalcomposite
residuosity problem relative to GenModulus :
Algorithm D:
The algorithm is given N,yas input.
•Setpk=Nand runA(pk) to obtain two messages m0,m1.
•Choose a uniform bit band setc:= [(1+N)mb·ymodN2].
•Give the ciphertext ctoAand obtain an output bit b/prime. If
b/prime=b, output 1; otherwise, output 0.
Let us analyze the behavior of D. There are two cases to consider:
Case 1: Say the input to Dwas generated by running GenModulus (1n) to
obtain (N,p,q), choosing uniform r∈Z∗
N2, and setting y:= [rNmodN2].
(That is, yis a uniform element of Res(N2).) In this case,
c= [(1+N)mb·rNmodN2]
for uniform r∈Z∗
N2. Recalling that the distribution on [ rNmodN2] is the
same whether ris chosen uniformly from Z∗
Nor fromZ∗
N2, we see that in this
case the view ofAwhen run as a subroutine by Dis distributed identically
toA’s view in experiment PubKeav
A,Π(n). Since Doutputs 1 exactly when the
outputb/primeofAis equal to b, we have
Pr/bracketleftbig
D(N,[rNmodN2]) = 1/bracketrightbig
= Pr[PubKeav
A,Π(n) = 1],
where the ﬁrst probability is taken over the experiment as in Deﬁnition 13.10.
Case 2: Say the input to Dwas generated by running GenModulus (1n) to
obtain (N,p,q) and choosing uniform y∈Z∗
N2. We claim that the view of A*Advanced Topics in Public-Key Encryption 499
in this case is independent of the bit b. This follows because yis a uniform
element of the group Z∗
N2, and so the ciphertext cis uniformly distributed in
Z∗
N2(see Lemma 11.15), independent of m. Thus, the probability that b/prime=b
in this case is exactly1
2.That is,
Pr[D(N,r) = 1] =1
2,
where the probability is taken over the experiment as in Deﬁnition 13.10.
Combining the above, we see that
/vextendsingle/vextendsingle/vextendsinglePr/bracketleftbig
D(N,[rNmodN2]) = 1/bracketrightbig
−Pr[D(N,r) = 1]/vextendsingle/vextendsingle/vextendsingle
=/vextendsingle/vextendsinglePr[PubKeav
A,Π(n) = 1]−1
2/vextendsingle/vextendsingle.
Bythe assumption that the decisional composite residuosity problem is hard
relative to GenModulus , there is a negligible function neglsuch that
/vextendsingle/vextendsinglePr[PubKeav
A,Π(n) = 1]−1
2/vextendsingle/vextendsingle≤negl(n).
Thus Pr[ PubKeav
A,Π(n) = 1]≤1
2+negl(n), completing the proof.
13.2.3 Homomorphic Encryption
The Paillier encryption scheme is useful in a number of settings because it
ishomomorphic . Roughly, a homomorphic encryption scheme enables (cer-
tain) computations to be performed on encrypted data, yielding a ciphertext
containing the encrypted result. In the case of Paillier encryption, the compu-
tation that can be performed is (modular) addition. Speciﬁcally, ﬁx a public
keypk=N. Then the Paillier scheme has the property that multiplying an
encryption of m1and an encryption of m2(with multiplication done mod-
uloN2) results in an encryption of [ m1+m2modN]; this is because
/parenleftbig
(1+N)m1·rN
1/parenrightbig
·/parenleftbig
(1+N)m2·rN
2/parenrightbig
= (1+N)[m1+m2modN]·(r1r2)NmodN2.
Although the ability to add encrypted values may not seem very useful, it
suﬃces for several interesting applications including voting, discussed below.
We present a generaldeﬁnition, ofwhich Paillerencryption is a special case.
DEFINITION 13.14 A public-key encryption scheme (Gen,Enc,Dec)is
homomorphic if for all nand all(pk,sk)output by Gen(1n), it is possible to
deﬁne groups M,C(depending on pkonly) such that:
•The message space is M, and all ciphertexts output by Encpkare el-
ements of C. For notational convenience, we write Mas an additive
group and Cas a multiplicative group.500 Introduction to Modern Cryptography
•For any m1,m2∈M, anyc1output by Encpk(m1), and any c2output
byEncpk(m2), it holds that
Decsk(c1·c2) =m1+m2.
Moreover, the distribution on ciphertexts obtained by encrypting m1,
encrypting m2, and then multiplying the results is identical to the distri-
bution on ciphertexts obtained by encrypting m1+m2.
The last part of the deﬁnition ensures that if ciphertexts c1←Encpk(m1)
andc2←Encpk(m2) are generated and the result c3:=c1·c2is computed,
then the resulting ciphertext c3contains no more information about m1orm2
than the sum m3.
The Paillier encryption scheme with pk=Nis homomorphic with M=ZN
andC=Z∗
N2. This is not the ﬁrst example of a homomorphic encryption
scheme we have seen; El Gamal encryption is also homomorphic. Speciﬁcally,
for public key pk=/angbracketleftG,q,g,h/angbracketrightwe can take M=GandC=G×G; then
/angbracketleftgy1, hy1·m1/angbracketright·/angbracketleftgy2, hy2·m2/angbracketright=/angbracketleftgy1+y2, hy1+y2·m1m2/angbracketright,
where multiplication of ciphertexts is component-wise. The Goldwasser–
Micali encryption scheme we will see later is also homomorphic (see Exer-
cise 13.10).
A nice feature of Paillier encryption is that it is homomorphic over a large
additive group (namely, ZN). To see an application of this, consider the
following distributed voting scheme, where /lscriptvoters can vote “no” or “yes”
and the goal is to tabulate the number of “yes” votes:
1. A voting authority generates a public key Nfor the Paillier encryption
scheme and publicizes N.
2. Let 0stand for a“no,” and let 1 standfor a“yes.” Eachvotercaststheir
vote by encrypting it. That is, voter icasts her vote viby computing
ci:= [(1+N)vi·(ri)NmodN2] for a uniform ri∈Z∗
N.
3. Each voter broadcasts their vote ci. These votes are then publicly ag-
gregated by computing
ctotal:=/bracketleftBig/producttext/lscript
i=1cimodN2/bracketrightBig
.
4. The authority is given ctotal. (We assume the authority has not been
able to observe what goes on until now.) By decrypting it, the authority
obtains the vote total
vtotaldef=/summationtext/lscript
i=1vimodN.
If/lscriptis small (so that vtotal/lessmuchN), there is no wrap-around modulo N
andvtotal=/summationtext/lscript
i=1vi.*Advanced Topics in Public-Key Encryption 501
Key features of the above are that no voter learns anyone else’s vote , and
calculation of the total is publicly veriﬁable if the authority is trusted to
correctly compute vtotalfromctotal. Also, the authority obtains the correct
totalwithout learning any individual votes . (Here, we assume the authority
cannot see voters’ ciphertexts. In Section 13.3.3 we show a protocol in which
votesarekept hidden fromauthoritieseven ifthey see allthe communication.)
We assume allvotersact honestly(and only tryto learnothers’votesbasedon
informationtheyobserve);anentireresearchareaofcryptographyisdedicated
to addressing potential threats from participants who might be malicious and
not follow the protocol.
13.3 Secret Sharing and Threshold Encryption
Motivatedbythe discussionofdistributed votingin the previoussection, we
brieﬂy consider secure (interactive) protocols . Such protocols can be signiﬁ-
cantlymorecomplicatedthanthe basiccryptographicprimitives(e.g., encryp-
tion and signature schemes) we have focused on until now, both because they
can involve multiple parties exchanging several rounds of messages, as well as
because they are intended to realize more-complex security requirements.
Thegoalofthissectionismainlytogivethereaderatasteofthisfascinating
area, and no attempt is made at being comprehensive or complete. Although
the protocolspresentedherecanbe provensecure(with respectto appropriate
deﬁnitions), we omit formal deﬁnitions, details, and proofs and instead rely
on informal discussion.
13.3.1 Secret Sharing
Consider the following problem. A dealerholds asecrets—say, a nuclear-
launch code—that it wishes to share among some set of NusersP1,...,P N
by giving each user a share. Anytusers should be able to pool their shares
and reconstruct the secret, but no coalition of fewer than tusers should get
anyinformation about sfrom their collective shares (beyond whatever infor-
mation they had about salready). We refer to such a sharing mechanism
as a (t,N)-threshold secret-sharing scheme . Such a scheme ensures that sis
not revealed without suﬃcient authorization, while also guaranteeing avail-
ability of swhen needed (since any tusers can reconstruct it). Beyond their
direct application, secret-sharing schemes are also a building block of many
cryptographic protocols.
Consider a simple solution for the case t=N, assuming s∈{0,1}/lscript. The
dealer chooses uniform s1,...,s N−1∈{0,1}/lscriptand sets sN:=s⊕/parenleftBig/circleplustextN−1
i=1si/parenrightBig
;
the share of user Piissi. Since/circleplustextN
i=1si=sby construction, clearly all
the users together can recover s. However, the shares of any coalition of502 Introduction to Modern Cryptography
N−1 users are (jointly) uniform and independent of s, and thus reveal no
information about s. This is clear when the coalition is P1,...,P N−1. In the
general case, when the coalition includes everyone except for Pj(j/negationslash=N), this
is true because s1,...,s j−1,sj+1,...,s N−1are uniform and independent of s
by construction, and
sN=s⊕/parenleftBig/circleplustext
i<N,i/negationslash=jsi/parenrightBig
⊕sj;
thus, even conditioned on some ﬁxed values for sand the shares of the other
members of the coalition, the share sNof userPNis uniform because sjis
uniform and independent of s.
We can extend this to obtain a solution for t < N. The basic idea is to
replicate the above scheme for each subset T⊂Nof sizet. That is, for
each such subset T={Pi1,...,P it}, we choose uniform shares sT,i1,...,s T,it
subject to the constraint that ⊕t
j=1sT,ij=s, and give sT,ijto userPij. It is
not hard to see that this satisﬁes the requirements.
Unfortunately, this extension of the original scheme is not eﬃcient. Each
user now stores a share sT,iforeverysubsetTof which she is a member. For
each user there are/parenleftbigN−1
t−1/parenrightbig
such subsets, which is exponential in Nift≈N/2.
Shamir’s scheme. Fortunately, it is possible to do signiﬁcantly better us-
ing a secret-sharing scheme introduced by Adi Shamir (of RSA fame). This
scheme is based on polynomials2overa ﬁnite ﬁeld F, whereFis chosenso that
s∈Fand|F|> N. (See Appendix A.5 for a brief discussion of ﬁnite ﬁelds.)
Before describing the scheme, we brieﬂy review some background related to
polynomials over a ﬁeld F.
A valuex∈Fis arootofa polynomial pifp(x) = 0. We use the well-known
fact that any nonzero, degree- tpolynomial over a ﬁeld has at most troots.
This implies:
COROLLARY 13.15 Any two distinct degree- tpolynomials pandqagree
on at most tpoints.
PROOF If not, then the nonzero, degree- tpolynomial p−qwould have
more than troots.
Shamir’s scheme relies on the fact that for any tpairs of elements ( x1,y1),
..., (xt,yt) fromF(with the{xi}distinct), there is a uniquepolynomial pof
degree(t−1)such that p(xi) =yifor1≤i≤t. We can provethis quite easily.
The fact that there exists such a puses standard polynomial interpolation.
2Adegree-tpolynomial poverFis given by p(X) =/summationtextt
i=0aiXi, where ai∈FandXis a
formal variable. (Note that we allow at= 0 and so we really mean a polynomial of degree
at most t.) Any such polynomial naturally deﬁnes a function mapping Fto itself, given by
evaluating the polynomial on its input.*Advanced Topics in Public-Key Encryption 503
In detail: for i= 1,...,t, deﬁne the degree-( t−1) polynomial
δi(X)def=/producttextt
j=1,j/negationslash=i(X−xj)
/producttextt
j=1,j/negationslash=i(xi−xj).
Note that δi(xj) = 0 for any j/negationslash=i, andδi(xi) = 1. So p(X)def=/summationtextt
i=1δi(X)·yi
is a polynomial of degree ( t−1) withp(xi) =yifor 1≤i≤t. (We remark
that this, in fact, demonstrates that the desired polynomial pcan be found
eﬃciently .) Uniqueness follows from Corollary 13.15.
We now describe Shamir’s ( t,N)-threshold secret-sharing scheme. Let Fbe
a ﬁnite ﬁeld that contains the domain of possible secrets, and with |F|> N.
Letx1,...,x N∈Fbe distinct, nonzero elements that are ﬁxed and publicly
known. (Such elements exist since |F|> N.) The scheme works as follows:
Sharing: Given a secret s∈F, the dealer chooses uniform a1,...,a t−1∈F
and deﬁnes the polynomial p(X)def=s+/summationtextt−1
i=1aiXi. This is a uniform
degree-(t−1) polynomial with constant term s. The share of user Pi
issi:=p(xi)∈F.
Reconstruction: SaytusersPi1,...,P itpool their shares si1,...,s it. Us-
ing polynomial interpolation, they compute the unique degree-( t−1)
polynomial p/primefor which p/prime(xij) =sijfor 1≤j≤t. The secret is p/prime(0).
It is clear that reconstruction works since p/prime=pandp(0) =s.
It remains to show that any t−1 users learn nothing about the secret s
from their shares. By symmetry, it suﬃces to consider the shares of users
P1,...,P t−1. We claim that for anysecrets, the shares s1,...,s t−1are
(jointly) uniform. Since the dealer chooses a1,...,a t−1uniformly, this follows
if we show that there is a one-to-one correspondence between the polyno-
mialpchosen by the dealer and the shares s1,...,s t−1. But this is a direct
consequence of Corollary 13.15.
13.3.2 Veriﬁable Secret Sharing
So far we have considered passiveattacks in which t−1 users may try
to use their shares to learn information about the secret. But we may also
be concerned about active, malicious behavior. Here there are two separate
concerns: First, a corrupted dealermay give inconsistent shares to the users,
i.e., such that diﬀerent secrets are recovered depending on which tusers pool
their shares. Second, in the reconstructionphase a malicioususer maypresent
adiﬀerent share from the one given to them by the dealer, and thus aﬀect the
recovered secret. (While this could be addressed by having the dealer sign the
shares, this does not work when the dealer itself may be dishonest.) Veriﬁable
secret-sharing (VSS) schemes prevent both these attacks.
More formally, we allow any t−1 users to be corrupted and to collude
with each other and, possibly, the dealer. We require (1a) at the end of the504 Introduction to Modern Cryptography
sharing phase, a secret sis deﬁned such that any collection that includes t
uncorrupted users(whether ornot this collectionalsoincludes some corrupted
users) will successfully recover sin the reconstruction phase; moreover, (1b) if
the dealer is honest, then scorresponds to the dealer’s secret. In addition,
(2) when the dealer is honest then, as before, the t−1 corrupted users learn
nothing about the secret from their shares and any public information the
dealer publishes. Since we want there to be tuncorrupted users even if t−1
users are corrupted, we require N≥t+(t−1)>2(t−1); in other words, we
assume a majority of the users remain uncorrupted.
We describe a VSS scheme due to Feldman that relies on an algorithm G
relative to which the discrete-logarithm problem is hard. For simplicity, we
describe it in the random-oracle model and let Hdenote a function to be
modeled as a random oracle. We also assume that some trusted parameters
(G,q,g), generated using G(1n), are published in advance, where qis prime
andsoZqisaﬁeld. Finally, weassumethatallusershaveaccesstoabroadcast
channel, such that a message broadcast by any user is heard by everyone.
The sharing phase now involvesthe Nusers running an interactive protocol
with the dealer that proceeds as follows:
1. To share a secret s, the dealer chooses uniform a0∈Zqand then
sharesa0as in Shamir’s scheme. That is, the dealer chooses uniform
a1,...,a t−1∈Zqand deﬁnes the polynomial p(X)def=/summationtextt−1
i=0aiXi. The
dealer sends the share si:=p(i) =/summationtextt−1
j=0ai·ijto userPi.3
In addition, the dealer publicly broadcasts the values A0:=ga0, ...,
At−1:=gat−1, and the “masked secret” c:=H(a0)⊕s.
2. Each user Piveriﬁes that its share sisatisﬁes
gsi?=/producttextt−1
j=0(Aj)ij. (13.3)
If not,Pipublicly broadcasts a complaint.
Note that if the dealer is honest, we have
/producttextt−1
j=0(Aj)ij=/producttextt−1
j=0(gaj)ij=g/summationtextt−1
j=0aj·ij=gp(i)=gsi,
and so no honest user will complain. Since there are at most t−1
corruptedusers, thereareat most t−1complaintsif the dealeris honest.
3. If more than t−1 users complain, the dealer is disqualiﬁed and the pro-
tocol is aborted. Otherwise, the dealer responds to a complaint from Pi
by broadcasting si. If this share does not satisfy Equation (13.3) (or if
the dealer refuses to respond to a complaint at all), the dealer is dis-
qualiﬁed and the protocol is aborted. Otherwise, Piuses the broadcast
value (rather than the value it received in the ﬁrst round) as its share.
3Note that we are now setting xi=i, which is ﬁne since we are using the ﬁeld Zq.*Advanced Topics in Public-Key Encryption 505
In the reconstruction phase, say a group of users (that includes at least
tuncorrupted users) pool their shares. A share siprovided by a user Piis
discarded if it does not satisfy Equation (13.3). Among the remaining shares,
anytof them are used to recover a0exactly as in Shamir’s scheme. The
original secret is then computed as s:=c⊕H(a0).
We now argue that this protocol meets the desired security requirements.
We ﬁrst showthat, assumingthe dealer is not disqualiﬁed, the value recovered
in the reconstruction phase is uniquely determined by the public information;
speciﬁcally, the recovered value is c⊕H(loggA0). (Combined with the fact
that an honest dealer is never disqualiﬁed, this proves that conditions (1a)
and (1b) hold.) Deﬁne ai:= loggAifor 0≤i≤t−1; the{ai}cannot be
computed eﬃciently if the discrete-logarithm problem is hard, but they are
still well-deﬁned. Deﬁne the polynomial p(X)def=/summationtextt−1
i=0aiXi. Any share si,
contributed by party Pi, that is not discarded during the reconstructionphase
must satisfy Equation (13.3), and hence satisﬁes si=p(i). It follows that,
regardless of which shares are used, the parties will reconstruct polynomial p,
compute a0=p(0), and then recover s=c⊕H(a0).
It is also possible to show that condition (2) holds for computationally
bounded adversaries if the discrete-logarithm problem is hard for G. (In con-
trast to Shamir’s secret-sharing scheme, secrecy here is no longer uncondi-
tional. Unconditionally secure VSS schemes are possible, but are beyond the
scope of our treatment.) Intuitively, this is because the secret sis masked
by the random value H(a0), and the information given to any t−1 users in
the sharing phase—namely, their shares and the public values {Ai}—reveals
onlyga0, from which it is hard to compute a0. This intuition can be made
rigorous, but we do not do so here.
13.3.3 Threshold Encryption and Electronic Voting
In Section 13.2.3 we introduced the notion of homomorphic encryption
schemes and gavethe Paillierencryptionscheme as an example. Here we show
a diﬀerent homomorphic encryption scheme that is a variant of El Gamal
encryption. Speciﬁcally, given a public key pk=/angbracketleftG,q,g,h/angbracketrightas in regular
El Gamal encryption, we now encrypt a message m∈Zqby setting M:=gm,
choosing a uniform y∈Zq, and sending the ciphertext c:=/angbracketleftgy, hy·M/angbracketright. To
decrypt, the receiver recovers Mas in standard El Gamal decryption and
then computes m:= loggM. Although this is not eﬃcient if mcomes from a
large domain, if mis from a small domain—as it will be in our application—
then the receiver can compute loggMeﬃciently using exhaustive search. The
advantage of this variant scheme is that it is homomorphic with respect to
addition inZq. That is,
/angbracketleftgy1, hy1·gm1/angbracketright·/angbracketleftgy2, hy2·gm2/angbracketright=/angbracketleftgy1+y2, hy1+y2·gm1+m2/angbracketright.
Recall that the basic approach to electronic voting using homomorphic en-506 Introduction to Modern Cryptography
cryption has each voter iencrypt her vote vi∈{0,1}to obtain a ciphertext ci.
Once everyone has voted, the ciphertexts are multiplied to obtain an encryp-
tion of the sum vtotaldef=/summationtext
ivimodq=/summationtext
ivi. (The value qis, in practice,
large enough so that no wrap-around modulo qoccurs.) Since 0≤vtotal≤/lscript,
where/lscriptis the total number of voters, an authority with the private key can
eﬃciently decrypt the ﬁnal ciphertext and recover vtotal.
A drawback of this approach is that the authority is trusted, both to (cor-
rectly) decryptthe ﬁnal ciphertextaswell asnotto decryptanyofthe individ-
ual voters’ ciphertexts. (In Section 13.2.3 we assumed the authority could not
see the individual voters’ ciphertexts.) We might instead prefer to distribute
trust among a set of Nauthorities, such that any set of tauthorities is able
to jointly decrypt an agreed-upon ciphertext (this ensures availability even if
some authorities are down or unwilling to help decrypt), but no collection of
t−1 authorities is able to decrypt any ciphertext on their own (this ensures
privacy as long as fewer than tauthorities are corrupted).
At ﬁrst glance, it may seem that secret sharing solves the problem. If we
share the private key among the Nauthorities, then no set of t−1 authorities
learns the private key and so they cannot decrypt. On the other hand, any
tauthorities can pool their shares, recover the private key, and then decrypt
any desired ciphertext.
A little thought shows that this does not quite work. If the authorities
reconstruct the private key in order to decrypt some ciphertext, then as part
of this process all the authorities learn the private key ! Thus, afterward, any
authority could decrypt any ciphertext of its choice, on its own.
We need instead a modiﬁed approach in which the “secret” (namely, the
private key) is never reconstructed in the clear, yet is implicitly reconstructed
only enough to enable decryption of one, agreed-upon ciphertext. We can
achieve this for the speciﬁc case of El Gamal encryption in the following way.
Fix a public key pk=/angbracketleftG,q,g,h/angbracketright, and let x∈Zqbe the private key, i.e.,
gx=h. Each authority is given a share xi∈Zqexactly as in Shamir’s secret-
sharing scheme. That is, a uniform degree-( t−1) polynomial pwithp(0) =x
is chosen, and the ith authority is given xi:=p(i). (We assume a trusted
dealer who knows xand securely deletes it once it is shared. It is possible to
eliminate the dealer entirely, but this is beyond our present scope.)
Now, say some tauthorities i1,...,itwish to jointly decrypt a ciphertext
/angbracketleftc1,c2/angbracketright. To do so, authority ijﬁrst publishes the value wj:=cxij
1. Re-
call from the previous section that there exist publicly computable polynomi-
als{δj(X)}(that depend on the identities of these tauthorities) such that
p(X)def=/summationtextt
j=1δj(X)·xij. Setting δjdef=δj(0), we see that there exist publicly
computable values δ1,...,δ t∈Zqfor which x=p(0) =/summationtextt
j=1δj·xij. Any
authority can then compute
M/prime:=c2/producttextt
j=1wδj
j.*Advanced Topics in Public-Key Encryption 507
(They can then each compute loggM, if desired.) To see that this correctly
recovers the message, say c1=gyandc2=hy·M. Then
t/productdisplay
j=1wδj
j=t/productdisplay
j=1cxijδj
1=c/summationtextt
j=1xijδj
1 =cp(0)
1=cx
1,
and so
M/primedef=c2/producttextt
j=1wδj
j=hy·M
cx
1=(gx)y·M
(gy)x=M.
Note that any set of t−1 corrupted authorities learns nothing about the
private key xfrom their shares. Moreover, it is possible to show that they
learn nothing from the decryption process beyond the recovered value M.
Malicious (active) adversaries. Our treatment above assumes that the
authorities decrypting some ciphertext all behave correctly. (If they do not,
it would be easy for any of them to cause an incorrect result by publishing an
arbitrary value wj.) We also assume that voters behave honestly, and encrypt
a vote of either 0 or 1. (Note that a voter could unfairly sway the election by
encrypting a large value or a negative value.) Potential malicious behavior of
this sort can be prevented using techniques beyond the scope of this book.
13.4 The Goldwasser–Micali Encryption Scheme
Before we present the Goldwasser–Micali encryption scheme, we need to
develop a better understanding of quadratic residues . We ﬁrst explore the
easier case of quadratic residues modulo a prime p, and then look at the
slightly more complicated case of quadratic residues modulo a composite N.
Throughout this section, pandqdenote odd primes, and N=pqdenotes
a product of two distinct, odd primes.
13.4.1 Quadratic Residues Modulo a Prime
In a group G, an element y∈Gis aquadratic residue if there exists an
x∈Gwithx2=y. In this case, we call xasquare root ofy. An element
that is not a quadratic residue is called a quadratic non-residue . In an abelian
group, the set of quadratic residues forms a subgroup.
In the speciﬁc case of Z∗
p, we have that yis a quadratic residue if there
exists an xwithx2=ymodp. We begin with an easy observation.
PROPOSITION 13.16 Letp >2be prime. Every quadratic residue in
Z∗
phas exactly two square roots.508 Introduction to Modern Cryptography
PROOF Lety∈Z∗
pbe a quadratic residue. Then there exists an x∈Z∗
p
such that x2=ymodp. Clearly, (−x)2=x2=ymodp. Furthermore,
−x/negationslash=xmodp: if−x=xmodpthen 2x= 0 mod p, which implies p|2x.
Sincepis prime, this would mean that either p|2 (which is impossible since
p >2) orp|x(which is impossible since 0 < x < p ). So, [xmodp] and
[−xmodp] are distinct elements of Z∗
p, andyhas at least two square roots.
Letx/prime∈Z∗
pbe a square root of y. Thenx2=y= (x/prime)2modp, implying
thatx2−(x/prime)2= 0 mod p. Factoring the left-hand side we obtain
(x−x/prime)(x+x/prime) = 0 mod p,
so that (by Proposition 8.3) either p|(x−x/prime) orp|(x+x/prime). In the ﬁrst case,
x/prime=xmodpand in the second case x/prime=−xmodp, showing that yindeed
has only [±xmodp] as square roots.
Letsqp:Z∗
p→Z∗
pbe the function sqp(x)def= [x2modp]. The above shows
thatsqpis a two-to-one function when p >2 is prime. This immediately
implies that exactly half the elements of Z∗
pare quadratic residues . We denote
the set of quadratic residues modulo pbyQRp, and the set of quadratic
non-residues byQNR p. We have just seen that for p >2 prime
|QRp|=|QNR p|=/vextendsingle/vextendsingleZ∗
p/vextendsingle/vextendsingle
2=p−1
2.
DeﬁneJp(x), theJacobi symbol of xmodulop, as follows.4Letp >2 be
prime, and x∈Z∗
p. Then
Jp(x)def=/braceleftbigg
+1 ifxis a quadratic residue modulo p
−1 ifxisnota quadratic residue modulo p.
The notation can be extended in the natural way for any xrelatively prime
topby settingJp(x)def=Jp([xmodp]).
Can we characterize the quadratic residues in Z∗
p? We begin with the fact
thatZ∗
pisacyclicgroupoforder p−1(seeTheorem8.56). Let gbeagenerator
ofZ∗
p. This means that
Z∗
p={g0,g1,g2,...,gp−1
2−1,gp−1
2,gp−1
2+1,...,gp−2}
(recall that pis odd, so p−1 is even). Squaring each element in this list and
reducing modulo p−1 in the exponent (cf. Corollary 8.15) yields a list of all
the quadratic residues in Z∗
p:
QRp={g0,g2,g4,...,gp−3,g0,g2,...,gp−3}.
4Forpprime,Jp(x) is also sometimes called the Legendre symbol ofxand denoted by
Lp(x); we have chosen our notation to be consistent with notation introduced later.*Advanced Topics in Public-Key Encryption 509
Each quadratic residue appears twice in this list. Therefore, the quadratic
residues in Z∗
pare exactly those elements that can be written as giwith
i∈{0,...,p−2}aneveninteger.
The above characterization leads to a simple way to compute the Jacobi
symbol and thus tell whether an element x∈Z∗
pis a quadratic residue or not.
PROPOSITION 13.17 Letp >2be a prime. Then Jp(x) =xp−1
2modp.
PROOF Letgbe an arbitrary generator of Z∗
p. Ifxis a quadratic residue
modulop, our earlier discussion shows that x=gifor some even integer i.
Writingi= 2jwithjan integer we then have
xp−1
2=/parenleftbig
g2j/parenrightbigp−1
2=g(p−1)j=/parenleftbig
gp−1/parenrightbigj=1j= 1 mod p,
and soxp−1
2=+1 =Jp(x) modpas claimed.
On the other hand, if xis not a quadratic residue then x=gifor some odd
integeri. Writing i= 2j+1 with jan integer we have
xp−1
2=/parenleftbig
g2j+1/parenrightbigp−1
2=/parenleftbig
g2j/parenrightbigp−1
2·gp−1
2=1·gp−1
2=gp−1
2modp.
Now,/parenleftBig
gp−1
2/parenrightBig2
=gp−1=1modp,
and sogp−1
2=±1modpsince [±1 modp] are the two square roots of 1
(cf. Proposition 13.16). Since gis a generator, it has order p−1 and so
gp−1
2/negationslash=1modp. It follows that xp−1
2=−1=Jp(x)modp.
Proposition 13.17 directly gives a polynomial-time algorithm (cf. Algo-
rithm 13.18) for testing whether an element x∈Z∗
pis a quadratic residue.
ALGORITHM 13.18
Deciding quadratic residuosity modulo a prime
Input:A prime p; an element x∈Z∗
p
Output:Jp(x) (or, equivalently, whether xis a quadratic residue or
quadratic non-residue)
b:=/bracketleftBig
xp−1
2modp/bracketrightBig
ifb= 1return“quadratic residue”
else return “quadratic non-residue”
Weconcludethissectionbynotinganicemultiplicativepropertyofquadratic
residues and non-residues modulo p.510 Introduction to Modern Cryptography
PROPOSITION 13.19 Letp >2be a prime, and x,y∈Z∗
p. Then
Jp(xy) =Jp(x)·Jp(y).
PROOF Using the previous proposition,
Jp(xy) = (xy)p−1
2=xp−1
2·yp−1
2=Jp(x)·Jp(y)modp.
SinceJp(xy),Jp(x),Jp(y) =±1, equalityholdsoverthe integersaswell.
COROLLARY 13.20 Letp >2be prime, and say x,x/prime∈ QR pand
y,y/prime∈QNR p. Then:
1.[xx/primemodp]∈QRp.
2.[yy/primemodp]∈QRp.
3.[xymodp]∈QNR p.
13.4.2 Quadratic Residues Modulo a Composite
We now turn our attention to quadratic residues in the group Z∗
N, where
N=pq. Characterizing the quadratic residues modulo Nis easy if we use
the results of the previous section in conjunction with the Chinese remainder
theorem. Recall that the Chinese remainder theorem says that Z∗
N/similarequalZ∗
p×Z∗
q,
and we let y↔(yp,yq) denote the correspondence guaranteed by the theorem
(i.e.,yp= [ymodp] andyq= [ymodq]). The key observation is:
PROPOSITION 13.21 LetN=pqwithp,qdistinct primes, and y∈Z∗
N
withy↔(yp,yq). Thenyis a quadratic residue modulo Nif and only if yp
is a quadratic residue modulo pandyqis a quadratic residue modulo q.
PROOF Ifyis a quadratic residue modulo Nthen, by deﬁnition, there
exists an x∈Z∗
Nsuch that x2=ymodN. Letx↔(xp,xq). Then
(yp, yq)↔y=x2↔(xp, xq)2= ([x2
pmodp],[x2
qmodq]),
where (xp,xq)2is simply the square of the element ( xp,xq) in the group Z∗
p×
Z∗
q. We have thus shown that
yp=x2
pmodpandyq=x2
qmodq (13.4)
andyp,yqare quadratic residues (with respect to the appropriate moduli).*Advanced Topics in Public-Key Encryption 511
Conversely,if y↔(yp,yq) andyp,yqarequadratic residues modulo pandq,
respectively, then there exist xp∈Z∗
pandxq∈Z∗
qsuch that Equation (13.4)
holds. Let x∈Z∗
Nbe such that x↔(xp,xq). Reversing the above steps
shows that xis a square root of ymoduloN.
The above proposition characterizes the quadratic residues modulo N.A
careful examination of the proof yields another important observation: each
quadratic residue y∈Z∗
Nhas exactly foursquare roots. To see this, let
y↔(yp,yq) be a quadratic residue modulo Nand letxp,xqbe square roots
ofypandyqmodulopandq, respectively. Then the four square roots of y
are given by the elements in Z∗
Ncorresponding to
(xp, xq),(−xp, xq),(xp,−xq),(−xp,−xq). (13.5)
Each of these is a square root of ysince
(±xp,±xq)2=/parenleftBig
[(±xp)2modp],[(±xq)2modq]/parenrightBig
= ([x2
pmodp],[x2
qmodq]) = (yp, yq)↔y
(where again the notation ( ·,·)2refers to squaring in the group Zp×Zq).
The Chinese remainder theorem guarantees that the four elements in Equa-
tion (13.5)correspondto distinctelements of Z∗
N, sincexpand−xpareunique
modulop(and similarly for xqand−xqmoduloq).
Example 13.22
Consider Z∗
15(the correspondence given by the Chinese remainder theorem is
tabulated in Example 8.25). Element 4 is a quadratic residue modulo 15 with
square root 2. Since 2 ↔(2,2), the other square roots of 4 are given by
•/parenleftbig
2,[−2 mod 3]/parenrightbig
= (2,1)↔7;
•/parenleftbig
[−2 mod 5],2/parenrightbig
= (3,2)↔8; and
•/parenleftbig
[−2 mod 5],[−2 mod 3]/parenrightbig
= (3,1)↔13.
One can verify that 72= 82= 132= 4 mod 15. ♦
LetQRNdenote the set of quadratic residues modulo N. Since squaring
moduloNis a four-to-one function, we see that exactly 1 /4 of the elements
ofZ∗
Nare quadratic residues. Alternately, we could note that since y∈Z∗
Nis
a quadratic residue if and only if yp,yqare quadratic residues, there is a one-
to-one correspondence between QRNandQRp×QR q. Thus, the fraction of
quadratic residues modulo Nis
|QRN|
|Z∗
N|=|QRp|·|QRq|
|Z∗
N|=p−1
2·q−1
2
(p−1)(q−1)=1
4,
inagreement with the above.512 Introduction to Modern Cryptography
/MT81/MT82/MT112/MT81/MT78/MT82/MT112/MT112/MT42/MT78/MT42
/MT74/MT43/MT49/MT74/MT45/MT49/MT81/MT82
/MT81/MT78/MT82/MT78/MT78
/MT78
/MT78
FIGURE 13.1 :The structure of Z∗
pandZ∗
N.
In the previoussection, we deﬁned the Jacobisymbol Jp(x) forp >2prime.
We extend the deﬁnition to the case of Na product of distinct, odd primes p
andqas follows. For any xrelatively prime to N=pq,
JN(x)def=Jp(x)·Jq(x)
=Jp([xmodp])·Jq([xmodq]).
We deﬁneJ+1
Nas the set of elements in Z∗
Nhaving Jacobi symbol +1, and
deﬁneJ−1
Nanalogously.
We know from Proposition 13.21 that if xis a quadratic residue modulo N,
then [xmodp] and [xmodq] are quadratic residues modulo pandq, respec-
tively; that is,Jp(x) =Jq(x) = +1. SoJN(x) = +1 and we see that:
Ifxis a quadratic residue modulo N, thenJN(x) = +1.
However,JN(x) = +1 can also occur when Jp(x) =Jq(x) =−1, that is,
whenboth[xmodp] and [xmodq] arenotquadraticresidues modulo pandq
(and soxis not a quadratic residue modulo N). This turns out to be useful
for the Goldwasser–Micali encryption scheme, and we therefore introduce the
notationQNR+1
Nfor the set of elements of this type. That is,
QNR+1
Ndef=/braceleftbigg
x∈Z∗
N/vextendsingle/vextendsingle/vextendsinglexis not a quadratic residue modulo N,
butJN(x) = +1/bracerightbigg
.
It is now easy to prove the following (see Figure 13.1):
PROPOSITION 13.23 LetN=pqwithp,qdistinct, odd primes. Then:
1. Exactly half the elements of Z∗
Nare inJ+1
N.
2.QRNis contained inJ+1
N.
3. Exactly half the elements of J+1
Nare inQRN(the other half are in
QNR+1
N).*Advanced Topics in Public-Key Encryption 513
PROOF We know thatJN(x) = +1 if either Jp(x) =Jq(x) = +1 or
Jp(x) =Jq(x) =−1. We also know (from the previous section) that exactly
half the elements of Z∗
phave Jacobi symbol +1, and half have Jacobi symbol
−1 (and similarly for Z∗
q). DeﬁningJ+1
p,J−1
p,J+1
q, andJ−1
qin the natural
way, we thus have
/vextendsingle/vextendsingleJ+1
N/vextendsingle/vextendsingle=|J+1
p×J+1
q|+|J−1
p×J−1
q|
=|J+1
p|·|J+1
q|+|J−1
p|·|J−1
q|
=(p−1)
2(q−1)
2+(p−1)
2(q−1)
2=φ(N)
2.
So/vextendsingle/vextendsingleJ+1
N/vextendsingle/vextendsingle=|Z∗
N|/2, proving that half the elements of Z∗
Nare inJ+1
N.
We have noted earlier that all quadratic residues modulo Nhave Jacobi
symbol +1, showing that QRN⊆J+1
N.
Sincex∈QRNif and only ifJp(x) =Jq(x) = +1, we have
|QRN|=|J+1
p×J+1
q|=(p−1)
2(q−1)
2=φ(N)
4,
and so|QRN|=/vextendsingle/vextendsingleJ+1
N/vextendsingle/vextendsingle/2. SinceQRNis a subset ofJ+1
N, this proves that
half the elements of J+1
Nare inQRN.
ThenexttworesultsareanaloguesofProposition13.19andCorollary13.20.
PROPOSITION 13.24 LetN=pqbe a product of distinct, odd primes,
andx,y∈Z∗
N. ThenJN(xy) =JN(x)·JN(y).
PROOF Using the deﬁnition of JN(·) and Proposition 13.19:
JN(xy) =Jp(xy)·Jq(xy) =Jp(x)·Jp(y)·Jq(x)·Jq(y)
=Jp(x)·Jq(x)·Jp(y)·Jq(y) =JN(x)·JN(y).
COROLLARY 13.25 LetN=pqbe a product of distinct, odd primes,
and sayx,x/prime∈QRNandy,y/prime∈QNR+1
N. Then:
1.[xx/primemodN]∈QRN.
2.[yy/primemodN]∈QRN.
3.[xymodN]∈QNR+1
N.514 Introduction to Modern Cryptography
PROOF We prove the ﬁnal claim; proofs of the others are similar. Since
x∈ QR N, we haveJp(x) =Jq(x) = +1. Since y∈ QNR+1
N, we have
Jp(y) =Jq(y) =−1. Using Proposition 13.19,
Jp(xy) =Jp(x)·Jp(y) =−1 andJq(xy) =Jq(x)·Jq(y) =−1,
and soJN(xy) = +1. But xyis not a quadratic residue modulo N, since
Jp(xy) =−1 and so [ xymodp] is not a quadratic residue modulo p. We
conclude that xy∈QNR+1
N.
In contrast to Corollary 13.20, it is nottrue that y,y/prime∈QNR Nimplies
yy/prime∈QR N. (Instead, as indicated in the corollary, this is only guaranteed
ify,y/prime∈QNR+1
N.) For example, we could have Jp(y) = +1,Jq(y) =−1
andJp(y/prime) =−1,Jq(y/prime) = +1, soJp(yy/prime) =Jq(yy/prime) =−1 andyy/primeis not a
quadratic residue even though JN(yy/prime) = +1.
13.4.3 The Quadratic Residuosity Assumption
In Section 13.4.1, we showed an eﬃcient algorithm for deciding whether
an input xis a quadratic residue modulo a prime p. Can we adapt the
algorithm to work modulo a composite number N? Proposition 13.21 gives
an easy solution to this problem provided the factorization of Nis known . See
Algorithm 13.26.
ALGORITHM 13.26
Deciding quadratic residuosity modulo a composite
of known factorization
Input:Composite N=pq; the factors pandq; element x∈Z∗
N
Output: A decision as to whether x∈QR N
computeJp(x) andJq(x)
ifJp(x) =Jq(x) = +1return“quadratic residue”
else return “quadratic non-residue”
(As always, we assume the factors of Nare distinct odd primes.) A simple
modiﬁcation of the above algorithm allows for computing JN(x) when the
factorization of Nis known.
When the factorization of Nisunknown , however, there is no known
polynomial-time algorithm for deciding whether a given xis a quadratic
residue modulo Nor not. Somewhat surprisingly, a polynomial-time algo-
rithmisknown for computing JN(x) without the factorization of N. (Al-
though the algorithm itself is not that complicated, its proof of correctness
is beyond the scope of this book and we therefore do not present the algo-
rithm at all. The interested reader can refer to the references listed at the*Advanced Topics in Public-Key Encryption 515
end of this chapter.) This leads to a partial test of quadratic residuosity: if,
for a given input x, it holds thatJN(x) =−1, thenxcannot possibly be
a quadratic residue. (See Proposition 13.23.) This test says nothing when
JN(x) = +1, and there is noknown polynomial-time algorithm for deciding
quadratic residuosity in that case (that does better than random guessing).
Wenowformalizetheassumptionthatthisproblemishard. Let GenModulus
be a polynomial-time algorithm that, on input 1n, outputs ( N,p,q) where
N=pq, andpandqaren-bit primes except with probability negligible in n.
DEFINITION 13.27 We saydeciding quadratic residuosity is hard relative
toGenModulus if for all probabilistic polynomial-time algorithms Dthere exists
a negligible function neglsuch that
/vextendsingle/vextendsingle/vextendsinglePr[D(N,qr) = 1]−Pr[D(N,qnr) = 1]/vextendsingle/vextendsingle/vextendsingle≤negl(n),
where in each case the probabilities are taken over the experiment in which
GenModulus (1n)is run to give (N,p,q),qris chosen uniformly from QRN,
andqnris chosen uniformly from QNR+1
N.
It is crucial in the above that qnris chosen fromQNR+1
Nrather than
QNR N; ifqnrwerechosenfrom QNR Nthen with probability2 /3it wouldbe
the case thatJN(x) =−1 and so distinguishing qnrfrom a uniform quadratic
residue would be easy. (Recall that JN(x) can be computed eﬃciently even
without the factorization of N.)
The quadratic residuosity assumption is simply the assumption that there
exists aGenModulus relative to which deciding quadratic residuosity is hard.
It is easy to see that if deciding quadratic residuosity is hard relative to
GenModulus , then factoring must be hard relative to GenModulus as well.
13.4.4 The Goldwasser–Micali Encryption Scheme
The preceding sectionimmediately suggestsa public-key encryptionscheme
for single-bit messages based on the quadratic residuosity assumption:
•The public key is a modulus N, and the private key is its factorization.
•To encrypt a ‘0,’ send a uniform quadratic residue; to encrypt a ‘1,’ send
a uniform quadratic non-residue with Jacobi symbol +1.
•The receiver can decrypt a ciphertext cwith its private key by using the
factorization of Nto decide whether cis a quadratic residue or not.
CPA-security of this scheme follows almost trivially from the hardness of the
quadratic residuosity problem as formalized in Deﬁnition 13.27.
One thing missing from the above description is a speciﬁcation of how the
sender, who does not know the factorization of N, can choose a uniform516 Introduction to Modern Cryptography
element ofQRN(to encrypt a 0) or a uniform element of QNR+1
N(to encrypt
a 1). The ﬁrst of these is easy, while the second requires some ingenuity.
Choosing a uniform quadratic residue. Choosing a uniform element
y∈QRNis easy: simply pick a uniform x∈Z∗
N(see Appendix B.2.5) and set
y:=x2modN. Clearly y∈QR N. The fact that yis uniformly distributed
inQRNfollows from the facts that squaring modulo Nis a 4-to-1 function
(see Section 13.4.2) and that xis chosen uniformly from Z∗
N. In more detail,
ﬁx any ˆy∈QR Nand let us compute the probability that y= ˆyafter the
above procedure. Denote the four square roots of ˆ yby±ˆx,±ˆx/prime. Then:
Pr[y= ˆy] = Pr[xis a square root of ˆ y]
= Pr[x∈{±ˆx,±ˆx/prime}]
=4
|Z∗
N|=1
|QRN|.
Since the above holds for every ˆ y∈QR N, we see that yis distributed uni-
formly inQRN.
Choosing a uniform element of QNR+1
N.In general, it is not known how
to choose a uniform element of QNR+1
Nif the factorization of Nis unknown.
What saves us in the present context is that the receiver can help by including
certain information in the public key. Speciﬁcally, we modify the scheme so
that the receiver additionally chooses a uniform z∈QNR+1
Nand includes z
as part of its public key. (This is easy for the receiver to do since it knows
the factorization of N; see Exercise 13.6.) The sender can choose a uniform
elementy∈QNR+1
Nby choosing a uniform x∈Z∗
N(as above) and setting
y:= [z·x2modN]. It follows from Corollary 13.25 that y∈QNR+1
N. We
leave it as an exercise to show that yis uniformly distributed in QNR+1
N; we
do not use this fact directly in the proof of security given below.
WegiveacompletedescriptionoftheGoldwasser–Micaliencryptionscheme,
implementing the above ideas, in Construction 13.28.
THEOREM 13.29 If the quadratic residuosity problem is hard relative to
GenModulus , then the Goldwasser–Micali encryption scheme is CPA-secure.
PROOF Let Π denote the Goldwasser–Micali encryption scheme. We
prove that Π has indistinguishable encryptions in the presence of an eaves-
dropper; by Theorem 11.6 this implies that it is CPA-secure.
LetAbe an arbitrary probabilistic polynomial-time adversary. Consider
thefollowing pptadversary Dthatattemptstosolvethequadraticresiduosity
problem relative to GenModulus :
Algorithm D:
The algorithm is given Nandzas input, and its goal is to deter-
mine ifz∈QRNorz∈QNR+1
N.*Advanced Topics in Public-Key Encryption 517
CONSTRUCTION 13.28
LetGenModulus be as usual. Construct a public-key encryption scheme
as follows:
•Gen: on input 1n, runGenModulus (1n) to obtain ( N,p,q), and
choose a uniform z∈QNR+1
N. The public key is pk=/angbracketleftN,z/angbracketrightand
the private key is sk=/angbracketleftp,q/angbracketright.
•Enc: on input a public key pk=/angbracketleftN,z/angbracketrightand a message m∈{0,1},
choose a uniform x∈Z∗
Nand output the ciphertext
c:= [zm·x2modN].
•Dec: on input a private key skand a ciphertext c, determine
whether cis a quadratic residue modulo Nusing, e.g., Algo-
rithm 13.26. If yes, output 0; otherwise, output 1.
The Goldwasser–Micali encryption scheme.
•Setpk=/angbracketleftN,z/angbracketrightand runA(pk) to obtain two single-bit mes-
sagesm0,m1.
•Choose a uniform bit band a uniform x∈Z∗
N, and then set
c:= [zmb·x2modN].
•Give the ciphertext ctoA, who in turn outputs a bit b/prime. If
b/prime=b, output 1; otherwise, output 0.
Let us analyze the behavior of D. There are two cases to consider:
Case 1: Say the input to Dwas generated by running GenModulus (1n) to
obtain (N,p,q) and then choosing a uniform z∈QNR+1
N. ThenDrunsAon
a public key constructed exactly as in Π, and we see that in this case the view
ofAwhen run as a subroutine by Dis distributed identically to A’s view in
experiment PubKeav
A,Π(n). SinceDoutputs 1 exactly when the output b/primeofA
is equal to b, we have
Pr[D(N,qnr) = 1] = Pr[ PubKeav
A,Π(n) = 1],
whereqnrrepresents a uniform element of QNR+1
Nas in Deﬁnition 13.27.
Case 2: Say the input to Dwas generated by running GenModulus (1n) to
obtain (N,p,q) and then choosing a uniform z∈QR N. We claim that the
view ofAin this case is independent of the bit b. To see this, note that the
ciphertext cgiven toAis a uniform quadratic residue regardless of whether
a 0 or a 1 is encrypted:
•When a 0 is encrypted, c= [x2modN] for a uniform x∈Z∗
N, and so c
is a uniform quadratic residue.
•When a 1 is encrypted, c= [z·x2modN] for a uniform x∈Z∗
N. Let
ˆxdef= [x2modN], and note that ˆ xis a uniformly distributed element518 Introduction to Modern Cryptography
of the groupQRN. Since z∈QR N, we can apply Lemma 11.15 to
conclude that cis uniformly distributed in QRNas well.
SinceA’s view is independent of b, the probability that b/prime=bin this case is
exactly1
2.That is,
Pr[D(N,qr) = 1] =1
2,
whereqrrepresents a uniform element of QRNas in Deﬁnition 13.27.
Thus,
/vextendsingle/vextendsingle/vextendsinglePr[D(N,qr) = 1]−Pr[D(N,qnr) = 1]/vextendsingle/vextendsingle/vextendsingle=/vextendsingle/vextendsinglePr[PubKeav
A,Π(n) = 1]−1
2/vextendsingle/vextendsingle.
Bythe assumption that the quadratic residuosity problem is hard relative to
GenModulus , there is a negligible function neglsuch that
/vextendsingle/vextendsingleε(n)−1
2/vextendsingle/vextendsingle≤negl(n);
thus,ε(n)≤1
2+negl(n). This completes the proof.
13.5 The Rabin Encryption Scheme
Asmentionedatthe beginningofthischapter, the Rabinencryptionscheme
is attractivebecause its securityis equivalent to the assumption that factoring
is hard. An analogous result is notknown for RSA-based encryption, and the
RSA problem may potentially be easier than factoring. (The same is true
of the Goldwasser–Micali encryption scheme, and it is possible that deciding
quadratic residuosity modulo Nis easier than factoring N.)
Interestingly, the Rabin encryption scheme is (superﬁcially, at least) very
similar to the RSA encryption scheme yet has the advantage of being based
on a potentially weaker assumption. The fact that RSA is more widely used
than the former seemsto be due more to historicalfactorsthan technicalones;
we discuss this further at the end of this section.
We begin with some preliminaries about computing modular square roots.
We then introduce a trapdoor permutation that can be based directly on
the assumption that factoring is hard. The Rabin encryption scheme (or, at
least, one instantiation of it) is then obtained by applying the results from
Section 13.1. Throughout this section, we continue to let pandqdenote odd
primes, and let N=pqdenote a product of two distinct, odd primes.
13.5.1 Computing Modular Square Roots
The Rabin encryption scheme requires the receiver to compute modular
square roots, and so in this section we explore the algorithmic complexity of*Advanced Topics in Public-Key Encryption 519
this problem. We ﬁrst show an eﬃcient algorithm for computing square roots
modulo a prime p, and then extend this algorithm to enable computation of
squarerootsmoduloacomposite Nofknownfactorization. Thereaderwilling
to accept the existence of these algorithms on faith can skip to the following
section, where we show that computing square roots modulo a composite N
withunknown factorization is equivalent to factoring N.
Letpbe an odd prime. Computing square roots modulo pis relatively
simple when p= 3 mod 4, but much more involved when p= 1 mod 4. (The
easier case is all we need for the Rabin encryption scheme as presented in
Section 13.5.3; we include the second case for completeness.) In both cases,
we showhow to compute one ofthe squarerootsofa quadraticresidue a∈Z∗
p.
Note that if xis one of the square roots of a, then [−xmodp] is the other.
We tackle the easier case ﬁrst. Say p= 3 mod 4, meaning we can write
p= 4i+ 3 for some integer i. Sincea∈Z∗
pis a quadratic residue, we have
Jp(a) = 1 = ap−1
2modp(see Proposition 13.17). Multiplying both sides by
awe obtain
a=ap−1
2+1=a2i+2=/parenleftbig
ai+1/parenrightbig2modp,
and soai+1=ap+1
4modpis a square root of a. That is, we obtain a square
root ofamodulopby simply computing x:= [ap+1
4modp].
It is crucial above that ( p+1)/2 isevenbecause this ensures that ( p+1)/4
is aninteger(this is necessary in order for ap+1
4modpto be well-deﬁned;
recall that the exponent must be an integer). This approach does not succeed
whenp= 1 mod 4, in which case p+1 is an integer that is notdivisible by 4.
Whenp= 1 mod 4 we proceed slightly diﬀerently. Motivated by the above
approach, we might hope to ﬁnd an odd integer rfor which it holds that
ar= 1 mod p. Then, as above, ar+1=amodpandar+1
2modpwould be a
square root of awith (r+1)/2 an integer. Although we will not be able to do
this, we cando something just as good: we will ﬁnd an odd integer ralong
with an element b∈Z∗
pand anevenintegerr/primesuch that
ar·br/prime= 1 mod p.
Thenar+1·br/prime=amodpandar+1
2·br/prime
2modpis a square root of a(with the
exponents ( r+1)/2 andr/prime/2 being integers).
We now describe the general approach to ﬁnding r,b, andr/primewith the stated
properties. Letp−1
2=2/lscript·mwhere/lscript,mare integers with /lscript≥1 andmodd.5
Sinceais a quadratic residue, we know that
a2/lscriptm=ap−1
2=1modp. (13.6)
Thismeansthat a2/lscriptm/2=a2/lscript−1mmodpisasquarerootof1. Thesquareroots
of 1 modulo pare±1 modp, soa2/lscript−1m=±1 modp. Ifa2/lscript−1m= 1 mod p, we
5The integers /lscriptandmcan be computed easily by taking out factors of 2 from ( p−1)/2.520 Introduction to Modern Cryptography
arein the samesituation asin Equation(13.6)except that the exponent of ais
now divisible by a smaller power of 2. This is progress in the right direction:
if we can get to the point where the exponent of ais not divisible by any
power of 2 (as would be the case here if /lscript= 1), then the exponent of aisodd
and we can compute a square root as discussed earlier. We give an example,
and discuss in a moment how to deal with the case when a2/lscript−1m=−1 modp.
Example 13.30
Takep= 29 and a= 7. Since 7 is a quadratic residue modulo 29, we have
714mod 29 = 1 and we know that 77mod 29 is a square root of 1. In fact,
77= 1 mod 29 ,
and the exponent 7 is odd. So 7(7+1)/2= 74= 23 mod 29 is a square root of 7
modulo 29. ♦
To summarize the algorithm so far: we begin with a2/lscriptm= 1 mod pand we
pull out factors of 2 from the exponent until one of two things happen: either
am= 1 mod p, ora2/lscript/primem=−1 modpfor some /lscript/prime< /lscript. In the ﬁrst case, since m
is odd we can immediately compute a square root of aas in Example 13.30.
In the second case, we will “restore” the +1 on the right-hand side of the
equation by multiplying each side of the equation by −1 modp. However,
as motivated at the beginning of this discussion, we want to achieve this by
multiplying the left-hand side of the equation by some element braised to an
evenpower. If we have available a quadratic non-residueb∈Z∗
p, this is easy:
sinceb2/lscriptm=bp−1
2=−1modp, we have
a2/lscript/primem·b2/lscriptm= (−1)(−1) = +1 mod p.
Withthiswecanproceedasbefore, takingasquarerootoftheleft-handside
to reduce the largest power of 2 dividing the exponent of a, and multiplying
byb2/lscriptm(as needed) so the right-hand side is always +1. Observe that the
exponent of bis always divisible by a larger power of 2 than the exponent of a
(and so we can indeed take square roots by dividing by 2 in both exponents).
We continue performing these steps until the exponent of ais odd, and can
then compute a square root of aas described earlier. Pseudocode for this
algorithm, which givesanotherwayofviewing what is goingon, is givenbelow
in Algorithm 13.31. It can be veriﬁed that the algorithm runs in polynomial
time given a quadratic non-residue bsince the number of iterations of the
inner loop is /lscript=O(logp).
One point we have not yet addressed is how to ﬁnd bin the ﬁrst place.
In fact, no deterministic polynomial-time algorithm for ﬁnding a quadratic
non-residue modulo pis known. Fortunately, it is easy to ﬁnd a quadratic
non-residue probabilistically: simply choose uniform elements of Z∗
puntil a*Advanced Topics in Public-Key Encryption 521
ALGORITHM 13.31
Computing square roots modulo a prime
Input:Primep; quadratic residue a∈Z∗
p
Output: A square root of a
casep= 3 mod 4:
return[ap+1
4modp]
casep= 1 mod 4:
letbbe a quadratic non-residue modulo p
compute /lscriptandmodd with 2/lscript·m=p−1
2
r:=2/lscript·m, r/prime:= 0
fori=/lscriptto 1{
//maintain the invariant ar·br/prime= 1 mod p
r:=r/2, r/prime:=r/prime/2
ifar·br/prime=−1 modp
r/prime:=r/prime+2/lscript·m
}
//nowr=m,r/primeis even, and ar·br/prime= 1 mod p
return/bracketleftBig
ar+1
2·br/prime
2modp/bracketrightBig
quadratic non-residue is found. This works because exactly half the elements
ofZ∗
pare quadratic non-residues, and because a polynomial-time algorithm
for deciding quadraticresiduositymodulo a prime is known(see Section 13.4.1
for proofs of both these statements). This means that the algorithm we have
shown is actually randomized when p= 1 mod 4; a deterministic polynomial-
time algorithm for computing square roots in this case is not known.
Example 13.32
Here we considerthe “worstcase,” when taking a squarerootalwaysgives −1.
Leta∈Z∗
pbe the element whose square root we are trying to compute; let
b∈Z∗
pbe a quadratic non-residue; and letp−1
2=23·mwheremis odd.
In the ﬁrst step, we have a23m= 1 mod p. Sincea23m=/parenleftBig
a22m/parenrightBig2
and the
square roots of 1 are ±1, this means that a22m=±1 modp; assuming the
worst case, a22m=−1 modp. So, we multiply by bp−1
2=b23m=−1modp
to obtain
a22m·b23m= 1 mod p.
In the second step, we observe that a2m·b22mis a square root of 1; again
assuming the worst case, we thus have a2m·b22m=−1 modp. Multiplying
byb23mto “correct” this gives
a2m·b22m·b23m= 1 mod p.
In the third step, taking square roots and assuming the worst case (as522 Introduction to Modern Cryptography
above) we obtain am·b2m·b22m=−1 modp; multiplying by the “correction
factor”b23mwe get
am·b2m·b22m·b23m= 1 mod p.
We are now where we want to be. To conclude the algorithm, multiply both
sides by ato obtain
am+1·b2m+22m+23m=amodp.
Sincemis odd, ( m+ 1)/2 is an integer and am+1
2·bm+2m+22mmodpis a
square root of a. ♦
Example 13.33
Here we work out a concrete example. Let p= 17,a= 2, and b= 3. Note
that here ( p−1)/2 = 23andm= 1.
We begin with 223= 1 mod 17. So 222should be equal to ±1 mod 17; by
calculation, 222=−1 mod 17. Multiplying by 323gives 222·323= 1 mod 17.
Continuing, we know that 22·322is a square root of 1 and so must be equal
to±1 mod 17; calculation gives 22·322= 1 mod 17. So no correction term is
needed here.
Halving the exponents again we ﬁnd that 2 ·32= 1 mod 17. We are now
almost done: multiplying both sides by 2 gives 22·32= 2 mod 17, and so
2·3 = 6 mod 17 is a square root of 2. ♦
Computing Square Roots Modulo N
It is not hard to see that the algorithm we haveshown for computing square
roots modulo a prime extends easily to the case of computing square roots
modulo a composite N=pqof known factorization. Speciﬁcally, let a∈Z∗
N
be a quadratic residue with a↔(ap,aq) via the Chinese remainder theorem.
Computing the square roots xp,xqofap,aqmodulopandq, respectively,
gives a square root ( xp,xq) ofa(see Section 13.4.2). Given xpandxq, the
representation xcorresponding to ( xp,xq) can be recovered as discussed in
Section8.1.5. Thatis,tocomputeasquarerootof amoduloaninteger N=pq
of known factorization:
•Compute ap:= [amodp] andaq:= [amodq].
•Using Algorithm 13.31, compute a square root xpofapmodulopand a
square root xqofaqmoduloq.
•Convert from the representation ( xp,xq)∈Z∗
p×Z∗
qtox∈Z∗
Nwith
x↔(xp,xq). Output x, which is a square root of amoduloN.
It is easy to modify the algorithm so that it returns all four square roots of a.*Advanced Topics in Public-Key Encryption 523
13.5.2 A Trapdoor Permutation Based on Factoring
We have seen that computing square roots modulo Ncan be carried out
in polynomial time if the factorization of Nis known. We show here that, in
contrast, computing square roots modulo a composite Nofunknown factor-
ization is as hard as factoring N.
More formally, let GenModulus be a polynomial-time algorithm that, on
input 1n, outputs ( N,p,q) whereN=pqandpandqaren-bit primes except
with probability negligible in n. Consider the following experiment for a given
algorithmAand parameter n:
The square-root computation experiment SQRA,GenModulus (n):
1. RunGenModulus (1n)to obtain output N,p,q.
2. Choose a uniform y∈QRN.
3.Ais given(N,y), and outputs x∈Z∗
N.
4. The outputof the experiment is deﬁned tobe 1ifx2=ymodN,
and0otherwise.
DEFINITION 13.34 We say that computingsquarerootsishardrelativeto
GenModulus if for all probabilistic polynomial-time algorithms Athere exists
a negligible function neglsuch that
Pr[SQRA,GenModulus (n) = 1]≤negl(n).
Itiseasytoseethatifcomputingsquarerootsishardrelativeto GenModulus
then factoring must be hard relative to GenModulus too: if moduli Noutput
byGenModulus could be factored easily, then it would be easy to compute
square roots modulo Nby ﬁrst factoring Nand then applying the algorithm
discussed in the previous section. Our goal now is to show the converse: that
if factoringis hardrelativeto GenModulus then so isthe problemofcomputing
square roots. We emphasize again that an analogous result is not known for
the RSA problem or the problem of deciding quadratic residuosity.
The key is the following lemma, which says that two “unrelated” square
roots of any element in Z∗
Ncan be used to factor N.
LEMMA 13.35 LetN=pqwithp,qdistinct, odd primes. Given x,ˆx
such that x2=y= ˆx2modNbutx/negationslash=±ˆxmodN, it is possible to factor N
in time polynomial in /bardblN/bardbl.
PROOF We claim that either gcd( N,x+ ˆx) or gcd( N,x−ˆx) is equal to
one of the prime factors of N.6Since gcd computations can be carried out in
polynomial time (see Appendix B.1.2), this proves the lemma.
6Infact, both of these are equal to one of the prime factors of N.524 Introduction to Modern Cryptography
Ifx2= ˆx2modNthen
0 =x2−ˆx2= (x−ˆx)·(x+ ˆx) modN,
and soN|(x−ˆx)(x+ ˆx). Then p|(x−ˆx)(x+ ˆx) and so pdivides one of
these terms. Say p|(x+ ˆx) (the proof proceeds similarly if p|(x−ˆx)). If
q|(x+ ˆx) thenN|(x+ ˆx), but this cannot be the case since x/negationslash=−ˆxmodN.
Soq/negationslash|(x+ ˆx) and gcd( N,x+ ˆx) =p.
An alternative way of proving the above is to look at what happens in the
Chinese remaindering representation. Say x↔(xp, xq). Then, because x
and ˆxare square roots of the same value y, we know that ˆ xcorresponds to
either(−xp, xq)or(xp,−xq). (Itcannotcorrespondto( xp, xq)or(−xp,−xq)
since the ﬁrst corresponds to xwhile the second corresponds to [ −xmodN],
and both possibilities are ruled out by the assumption of the lemma.) Say
ˆx↔(−xp, xq). Then
[x+ ˆxmodN]↔(xp, xq)+(−xp, xq) = (0,[2xqmodq]),
and we see that x+ ˆx= 0 mod pwhilex+ ˆx/negationslash= 0 mod q. It follows that
gcd(N,x+ ˆx) =p, a factor of N.
We can now prove the main result of this section.
THEOREM 13.36 If factoring is hard relative to GenModulus , then com-
puting square roots is hard relative to GenModulus .
PROOF LetAbe a probabilistic polynomial-time algorithm computing
square roots (as in Deﬁnition 13.34). Consider the following probabilistic
polynomial-time algorithm Afactfor factoring moduli output by GenModulus :
AlgorithmAfact:
The algorithm is given a modulus Nas input.
•Choose a uniform x∈Z∗
Nand compute y:= [x2modN].
•RunA(N,y) to obtain output ˆ x.
•If ˆx2=ymodNand ˆx/negationslash=±xmodN, then factor Nusing
Lemma 13.35.
By Lemma 13.35, we know that Afactsucceeds in factoring Nexactly when
ˆx/negationslash=±xmodNand ˆx2=ymodN. That is,
Pr[FactorAfact,GenModulus (n) = 1]
= Pr/bracketleftbig
ˆx/negationslash=±xmodN∧ˆx2=ymodN/bracketrightbig
= Pr/bracketleftbig
ˆx/negationslash=±xmodN/vextendsingle/vextendsingleˆx2=ymodN/bracketrightbig
·Pr/bracketleftbig
ˆx2=ymodN/bracketrightbig
,(13.7)*Advanced Topics in Public-Key Encryption 525
where the above probabilities all refer to experiment FactorAfact,GenModulus (n)
(see Section 8.2.3 for a description of this experiment). In the experiment, the
modulus Ngiven as input to Afactis generated by GenModulus (1n), andyis
a uniform quadratic residue modulo Nsincexwas chosen uniformly from Z∗
N
(see Section 13.4.4). So the view of Awhen run as a subroutine by Afactis
distributed exactly as A’s view in experiment SQRA,GenModulus (n). Therefore,
Pr/bracketleftbig
ˆx2=ymodN/bracketrightbig
= Pr/bracketleftbig
SQRA,GenModulus (n) = 1/bracketrightbig
. (13.8)
Conditioned on the value of the quadratic residue yused in experiment
FactorAfact,GenModulus (n), the value xis equally likely to be any of the four
possiblesquarerootsof y. Thismeansthatfromthepointofviewofalgorithm
A(being run as a subroutine by Afact),xis equally likely to be each of the
four square roots of y. This in turn means that, conditioned on Aoutputting
somesquare root ˆ xofy, the probability that ˆ x=±xmodNis exactly 1 /2.
(We stress that we do not make any assumption about how ˆ xis distributed
among the square roots of y, and in particular are not assuming here that A
outputs a uniform square root of y. Rather we are using the fact that xis
uniformly distributed among the square roots of y.) That is,
Pr/bracketleftbig
ˆx/negationslash=±xmodN/vextendsingle/vextendsingleˆx2=ymodN/bracketrightbig
=1
2. (13.9)
Combining Equations (13.7)–(13.9), we see that
Pr[FactorAfact,GenModulus (n) = 1] =1
2·Pr/bracketleftbig
SQRA,GenModulus (n) = 1/bracketrightbig
.
Since factoring is hard relative to GenModulus , there is a negligible function
neglsuch that
Pr[FactorAfact,GenModulus (n) = 1]≤negl(n),
which impliesPr/bracketleftbig
SQRA,GenModulus (n) = 1/bracketrightbig
≤2·negl(n). SinceAwasarbitrary,
this completes the proof.
The previous theorem leads directly to a family of one-way functions (see
Deﬁnition 8.76) based on any GenModulus relative to which factoring is hard:
•Algorithm Gen, on input 1n, runsGenModulus (1n) to obtain ( N,p,q)
and outputs I=N. The domainDIisZ∗
Nand the rangeRIisQRN.
•Algorithm Samp, on input N, chooses a uniform element x∈Z∗
N.
•Algorithm f, on input Nandx∈Z∗
N, outputs [ x2modN].
The preceding theorem showsthat this family is one-wayif factoringis hard
relative to GenModulus .526 Introduction to Modern Cryptography
We can turn this into a family of one-way permutations by using moduli
Nof a special form and letting DIbe a subset of Z∗
N. (See Exercise 13.19
for another way to make this a permutation.) Call N=pqaBlum integer
ifpandqare distinct primes with p=q= 3 mod 4. The key to building a
permutation is the following proposition.
PROPOSITION 13.37 LetNbe a Blum integer. Then every quadratic
residue modulo Nhas exactly one square root that is also a quadratic residue.
PROOF SayN=pqwithp=q= 3 mod 4. Using Proposition 13.17,
we see that−1 is not a quadratic residue modulo porq. This is because for
p= 3 mod 4 it holds that p= 4i+3 for some iand so
(−1)p−1
2=(−1)2i+1=−1 modp
(because 2 i+1is odd). Now let y↔(yp,yq) be an arbitraryquadratic residue
moduloNwith the four square roots
(xp, xq),(−xp, xq),(xp,−xq),(−xp,−xq).
We claim that exactly one of these is a quadratic residue modulo N. To see
this, assumeJp(xp) = +1 andJq(xq) =−1 (the proof proceeds similarly in
any other case). Using Proposition 13.19, we have
Jq(−xq) =Jq(−1)·Jq(xq) = +1,
and so (xp,−xq) corresponds to a quadratic residue modulo N(using Propo-
sition 13.21). Similarly, Jp(−xp) =−1 and so none of the other square roots
ofyare quadratic residues modulo N.
Expressed diﬀerently, the above proposition says that when NisaBlum
integer, the function fN:QRN→QR Ngiven by fN(x) = [x2modN] is a
permutation over QRN. Modifying the sampling algorithm Sampabove to
choose a uniform x∈QR N(which, as we have already seen, can be done
easily by choosing uniform r∈Z∗
Nand setting x:= [r2modN]) gives a fam-
ily of one-way permutations . Finally, because square roots modulo Ncan
be computed in polynomial time given the factorization of N, a straight-
forward modiﬁcation yields a family of trapdoor permutations based on any
GenModulus relative to which factoring is hard. This is sometimes called the
Rabinfamily of trapdoor permutations. In summary:
THEOREM 13.38 LetGenModulus be an algorithm that, on input 1n,
outputs(N,p,q)whereN=pqandpandqare distinct primes (except possibly
with negligible probability) with p=q= 3 mod 4 . If factoring is hard relative
toGenModulus , then there exists a family of trapdoor permutations.*Advanced Topics in Public-Key Encryption 527
13.5.3 The Rabin Encryption Scheme
We can apply the results of Section 13.1.2 to the Rabin trapdoor permu-
tation to obtain a public-key encryption scheme whose security is based on
factoring. To do this, we ﬁrst need to identify a hard-core predicate for this
trapdoor permutation. Although we could appeal to Theorem 13.3, which
states that a suitable hard-core predicate always exists, it turns out that the
least signiﬁcant bit lsbis a hard-core predicate for the Rabin trapdoor per-
mutation just as it is for the case of RSA (see Section 11.5.3). Using this as
our hard-core predicate, we obtain the scheme of Construction 13.39.
CONSTRUCTION 13.39
LetGenModulus be a polynomial-time algorithm that, on input 1n, out-
puts (N,p,q) where N=pqandpandqaren-bit primes (except with
probability negligible in n) withp=q= 3 mod 4. Construct a public-
key encryption scheme as follows:
•Gen: on input 1nrunGenModulus (1n) to obtain ( N,p,q). The
public key is N, and the private key is /angbracketleftp,q/angbracketright.
•Enc: on input a public-key Nand message m∈{0,1}, choose
a uniform x∈QR Nsubject to the constraint that lsb(x) =m.
Output the ciphertext c:= [x2modN].
•Dec: on input a private key /angbracketleftp,q/angbracketrightand a ciphertext c, compute the
uniquex∈QR Nsuch that x2=cmodN, and output lsb(x).
The Rabin encryption scheme.
Theorems 13.5 and 13.38 imply the following result.
THEOREM 13.40 If factoring is hard relative to GenModulus , then Con-
struction 13.39 is CPA-secure.
Rabin Encryption vs. RSA Encryption
It is worthwhile to remark on the similarities and diﬀerences between the
Rabin and RSA cryptosystems. (The discussion here applies to any crypto-
graphic construction—not necessarily a public-key encryption scheme—based
on the Rabin or RSA trapdoor permutations.)
The RSA and Rabin trapdoor permutations appear quite similar, with
squaring in the case of Rabin corresponding to taking e= 2 in the case
of RSA. (Of course, 2 is notrelatively prime to φ(N) and so Rabin is not
a special case of RSA.) In terms of the security oﬀered by each construc-
tion, hardness of computing modular square roots is equivalent to hardness
of factoring, whereas hardness of solving the RSA problem is not known to528 Introduction to Modern Cryptography
be implied by the hardness of factoring. The Rabin trapdoor permutation is
thusbasedonapotentially weakerassumption: itistheoreticallypossiblethat
someone might develop an eﬃcient algorithm for solving the RSA problem,
yet computing square roots will remain hard. Or, someone may develop an al-
gorithm that solves the RSA problem faster than known factoring algorithms.
Lemma 13.35 ensures, however, that computing square roots modulo Ncan
never be much faster than the best available algorithm for factoring N.
In terms of their eﬃciency, the RSA and Rabin permutations are essentially
the same. Actually, if a large exponent eis used in the case of RSA then
computing eth powers (as in RSA) is slightly slower than squaring (as in
Rabin). On the other hand, a bit more care is required when working with
the Rabin permutation since it is only a permutation over a subsetofZ∗
N, in
contrast to RSA, which gives a permutation over all of Z∗
N.
A “plain Rabin” encryption scheme, constructed in a manner analogous to
plain RSA encryption, is vulnerableto achosen-ciphertextattackthat enables
an adversary to learn the entire private key (see Exercise 13.17). Although
plain RSA isnot CCA-secureeither, knownchosen-ciphertextattacksonplain
RSA are less damaging since they recover the message but not the private
key. Perhaps the existence of such an attack on “plain Rabin” inﬂuenced
cryptographers, early on, to reject the use of Rabin encryption entirely.
In summary, the RSA permutation is much more widely used in practice
than the Rabin permutation, but in light of the above this appears to be due
more to historical accident than to any compelling technical justiﬁcation.
References and Additional Reading
The existence of public-key encryption based on arbitrary trapdoor permu-
tations was shown by Yao [179], and the eﬃciency improvement discussed at
the end of Section 13.1.2 is due to Blum and Goldwasser [36].
Childs [44] and Shoup [159] provide further coverageof the (computational)
number theory used in this chapter. A good description of the algorithm for
computing the Jacobi symbol modulo a composite of unknown factorization,
along with a proof of correctness, is given in [57].
The Paillier encryption scheme was introduced in [136]. Shoup [159, Sec-
tion 7.5] gives a characterization of Z∗
Nefor arbitrary integers N,e(and not
justN=pq,e= 2 as done here).
The problem of deciding quadratic residuosity modulo a composite of un-
known factorization goes back to Gauss [71] and is related to other (conjec-
tured) hard number-theoretic problems. The Goldwasser–Micali encryption
scheme [80], introduced in 1982, was the ﬁrst public-key encryption scheme
with a proof of security.*Advanced Topics in Public-Key Encryption 529
Rabin [145] showed that computing square roots modulo a composite is
equivalent to factoring. The results of Section 13.5.2 are due to Blum [35].
Hard-core predicates for the Rabin trapdoor permutation are discussed in
[8, 86, 7] and references therein.
Exercises
13.1 Construct and prove CPA-security for a KEM based on any trapdoor
permutation by suitably generalizing Construction 11.34.
13.2 Show that the isomorphism of Proposition 13.6 can be eﬃciently in-
verted when the factorization of Nis known.
13.3 Let Φ( N2) denote the set{(a,1)|a∈ZN}⊂Z∗
N2. Show that it is not
hard to decide whether a given element y∈Z∗
N2is in Φ(N2).
13.4 Let Gbe an abelian group. Show that the set of quadratic residues in
Gforms a subgroup.
13.5 This question concerns the quadratic residues in the additive group ZN.
(An element y∈ZNis a quadratic residue if and only if there exists an
x∈ZNwith 2x=ymodN.)
(a) Letpbe an odd prime. How many elements of Zpare quadratic
residues?
(b) LetN=pqbe a product of two odd primes pandq. How many
elements of ZNare quadratic residues?
(c) LetNbe an even integer. How many elements of ZNare quadratic
residues?
13.6 Let N=pqwithp,qdistinct, odd primes. Show a pptalgorithm for
choosing a uniform element of QNR+1
Nwhen the factorization of Nis
known. (Your algorithm can have failure probability negligible in /bardblN/bardbl.)
13.7 Let N=pqwithp,qdistinct, odd primes. Prove that if x∈QRNthen
[x−1modN]∈QRN, andifx∈QNR+1
Nthen[x−1modN]∈QNR+1
N.
13.8 Let N=pqwithp,qdistinct, odd primes, and ﬁx z∈QNR+1
N. Show
that choosing uniform x∈QRNand setting y:= [z·xmodN] gives ay
that is uniformly distributed in QNR+1
N. That is, for any ˆ y∈QNR+1
N
Pr[z·x= ˆymodN] = 1/|QNR+1
N|,
where the probability is taken over uniform choice of x∈QRN.
Hint:Use the previous exercise.530 Introduction to Modern Cryptography
13.9 Let Nbe the product of 5 distinct, odd primes. If y∈Z∗
Nis a quadratic
residue, how many solutions are there to the equation x2=ymodN?
13.10 Show that the Goldwasser–Micali encryption scheme is homomorphic if
the message space {0,1}is viewed as the group Z2.
13.11 Consider the following variation of the Goldwasser–Micali encryption
scheme: GenModulus (1n) is run to obtain ( N,p,q) whereN=pqand
p=q= 3 mod 4. (I.e., Nis a Blum integer.) The public key is N
and the private key is /angbracketleftp,q/angbracketright. To encrypt m∈{0,1}, the sender chooses
uniformx∈ZNand computes the ciphertext c:= [(−1)m·x2modN].
(a) Prove that for Nof the stated form, [ −1 modN]∈QNR+1
N.
(b) Prove that the scheme described has indistinguishable encryptions
under a chosen-plaintext attack if deciding quadratic residuosity is
hard relative to GenModulus .
13.12 Assume deciding quadratic residuosity is hard for GenModulus . Show
that this implies the hardness of distinguishing a uniform element of
QRNfrom a uniform element of J+1
N.
13.13 Show that plain RSA encryption of a message mleaksJN(m).
13.14 Consider the following variation of the Goldwasser–Micali encryption
scheme: GenModulus (1n) is run to obtain ( N,p,q). The public key
isNand the private key is /angbracketleftp,q/angbracketright. To encrypt a 0, the sender chooses
nuniform elements c1,...,c n∈ QR N. To encrypt a 1, the sender
choosesnuniform elements c1,...,c n∈J+1
N. In each case, the resulting
ciphertext is c∗=/angbracketleftc1,...,c n/angbracketright.
(a) Show how the sender can generate a uniform element of J+1
Nin
polynomial time, where failing with negligible probability.
(b) Suggest a way for the receiver to decrypt eﬃciently, although with
negligible error probability.
(c) Prove that if deciding quadratic residuosity is hard relative to
GenModulus , this scheme is CPA-secure.
Hint:Use the previous exercise.
13.15 LetGbeapolynomial-timealgorithmthat, oninput 1n, outputsaprime
pwith/bardblp/bardbl=nand a generator gofZ∗
p. Prove that the DDH problem
isnothard relative toG.
Hint:Use the fact that quadratic residuosity can be decided eﬃciently
modulo a prime.
13.16 The discrete logarithm problem is believed to be hard for Gas in the
previous exercise. This means that the function (family) fp,gwhere
fp,g(x)def= [gxmodp] is one-way. Let lsb(x) denote the least-signiﬁcant
bit ofx. Show that lsbisnota hard-core predicate for fp,g.*Advanced Topics in Public-Key Encryption 531
13.17 Consider the plain Rabin encryption scheme in which a message m∈
QRNis encrypted relative to a public key N(whereNis a Blum in-
teger) by computing the ciphertext c:= [m2modN]. Show a chosen-
ciphertext attack on this scheme that recovers the entire private key.
13.18 TheplainRabinsignatureschemeisliketheplainRSAsignaturescheme,
except using the Rabin trapdoor permutation. Show an attack on plain
Rabin signatures by which the attacker learns the signer’s private key.
13.19 Let Nbe a Blum integer.
(a) Deﬁne the set Sdef={x∈Z∗
N|x < N/2 andJN(x) = +1}. Deﬁne
the function fN:S→Z∗
Nby:
fN(x) =/braceleftbigg
[x2modN] if [x2modN]< N/2
[−x2modN] if [x2modN]> N/2
Show that fNis a permutation over S.
(b) Deﬁne a family of trapdoor permutations based on factoring using
fNas deﬁned above.
13.20 Let Nbe a Blum integer. Deﬁne the function halfN:Z∗
N→{0,1}as
halfN(x) =/braceleftbigg
−1 ifx < N/2
+1 ifx > N/2
Show that the function f:Z∗
N→QR N×{−1,+1}2deﬁned as
f(x) =/parenleftbig
[x2modN],JN(x),halfN(x)/parenrightbig
is one-to-one.Index of Common Notation
General notation:
•:= refers to deterministic assignment
•IfSis a set, then x←Sdenotes that xis chosen uniformly from S
•IfAis a randomized algorithm, then y←A(x) denotes running Aon
inputxwith a uniform random tape and assigning the output to y. We
writey:=A(x;r) to denote running Aon input xusing random tape r
and assigning the output to y
• ∧denotes Boolean conjunction (the AND operator)
• ∨denotes Boolean disjunction (the OR operator)
• ⊕denotes the exclusive-or(XOR) operator; this operatorcan be applied
to single bits or entire strings (in the latter case, the XOR is bitwise)
• {0,1}nis the set of all bit-strings of length n
• {0,1}≤nis the set of all bit-strings of length at most n
• {0,1}∗is the set of all ﬁnite bit-strings
•0n(resp., 1n) denotes the string comprised of nzeroes (resp., nones)
• /bardblx/bardbldenotes the length of the binary representation of the (positive)
integerx, written with leading bit 1. Note that log x </bardblx/bardbl≤logx+1
• |x|denotesthelengthofthebinarystring x(whichmayhaveleading0s),
or the absolute value of the real number x
• O(·),Θ(·),Ω(·),ω(·) see Appendix A.2
•0xdenotes that digits are being represented in hexadecimal
•x/bardblydenotes umambiguous concatenation of the strings xandy(“un-
ambiguous” means that xandycan be recovered from x/bardbly)
•Pr[X] denotes the probability of event X
•logxdenotes the base-2 logarithm of x
533534 Introduction to Modern Cryptography
Crypto-speciﬁc notation:
•nis the security parameter
•pptstands for “probabilistic polynomial time”
• AO(·)denotes the algorithm Awith oracle access to O
•ktypicallydenotesasecretkey(asinprivate-keyencryptionandMACs)
•(pk,sk)denotesapublic/privatekey-pair(forpublic-keyencryptionand
digital signatures)
•negldenotes a negligible function; see Deﬁnition 3.4
•poly(n) denotes an arbitrary polynomial
•polylog(n) denotes poly(log(n))
•Funcndenotes the set of functions mapping n-bit strings to n-bit strings
•Permndenotes the set of bijections on n-bit strings
•IVdenotes an initialization vector (used for modes of operation and
collision-resistant hash functions)
Algorithms and procedures:
•Gdenotes a pseudorandom generator
•Fdenotes a keyed function that is typically a pseudorandom function
or permutation
•(Gen,Enc,Dec) denote the key-generation, encryption, and decryption
procedures, respectively, for both private- and public-key encryption.
For the case of private-key encryption, when Genis unspeciﬁed then
Gen(1n) outputs a uniform k∈{0,1}n
•(Gen,Mac,Vrfy) denote the key-generation, tag-generation, and veriﬁca-
tion procedures, respectively, for a message authentication code. When
Genis unspeciﬁed then Gen(1n) outputs a uniform k∈{0,1}n
•(Gen,Sign,Vrfy) denote the key-generation, signature-generation, and
veriﬁcation procedures, respectively, for a digital signature scheme
•GenPrime denotes a pptalgorithm that, on input 1n, outputs an n-bit
prime except with probability negligible in n
•GenModulus denotesa pptalgorithmthat, on input 1n, outputs( N,p,q)
whereN=pqand (except with negligible probability) pandqaren-bit
primesIndex of Common Notation 535
•GenRSAdenotesa pptalgorithmthat, oninput1n, outputs(exceptwith
negligibleprobability)amodulus N,aninteger e >0withgcd( e,φ(N)) =
1, and an integer dsatisfying ed= 1 mod φ(N)
• Gdenotes a pptalgorithm that, on input 1n, outputs (except with neg-
ligible probability) a description of a cyclic group G, the group order q
(with/bardblq/bardbl=n), and a generator g∈G.
Number theory:
•Zdenotes the set of integers
•a|bmeansadividesb
•a/negationslash|bmeans that adoes not divide b
•gcd(a,b) denotes the greatest common divisor of aandb
•[amodb] denotes the remainder of awhen divided by b. Note that
0≤[amodb]< b.
•x1=x2=···=xnmodNmeans that x1,...,x nare all congruent
moduloN
Note:x=ymodNmeans that xandyare congruent modulo N,
whereas x= [ymodN] means that xis equal to the remainder of y
when divided by N.
•ZNdenotes the additive group of integers modulo Nas well as the set
{0,...,N−1}
•Z∗
Ndenotes the multiplicative group of invertible integers modulo N
(i.e., those that are relatively prime to N)
•φ(N) denotes the size of Z∗
N
•GandHdenote groups
•G1/similarequalG2means that groups G1andG2are isomorphic. If this isomor-
phism is given by fandf(x1) =x2then we write x1↔x2
•gis typically a generator of a group
•logghdenotes the discrete logarithm of hto the base g
• /angbracketleftg/angbracketrightdenotes the group generated by g
•pandqusually denote primes
•Ntypically denotes the product of two distinct primes pandqof equal
length536 Introduction to Modern Cryptography
• QR pis the set of quadratic residues modulo p
• QNR pis the set of quadratic non-residues modulo p
• Jp(x) is the Jacobi symbol of xmodulop
• J+1
Nis the set of elements with Jacobi symbol +1 modulo N
• J−1
Nis the set of elements with Jacobi symbol −1 modulo N
• QNR+1
Nis the set of quadratic non-residues modulo Nhaving Jacobi
symbol +1Appendix A
Mathematical Background
A.1 Identities and Inequalities
Welist some standard identities and inequalities that are used at various
points throughout the text.
THEOREM A.1 (Binomial expansion theorem) Letx,ybe real num-
bers, and let nbe a positive integer. Then
(x+y)n=n/summationdisplay
i=0/parenleftbiggn
i/parenrightbigg
xiyn−i.
PROPOSITION A.2 For allx≥1it holds that (1−1/x)x≤e−1.
PROPOSITION A.3 For allxit holds that 1−x≤e−x.
PROPOSITION A.4 For allxwith0≤x≤1it holds that
e−x≤1−/parenleftbigg
1−1
e/parenrightbigg
·x≤1−x
2.
A.2 Asymptotic Notation
Weuse standard notation for expressing asymptotic behavior of functions.
DEFINITION A.5 Letf(n),g(n)be functions from non-negative integers
to non-negative reals. Then:
•f(n) =O(g(n))means that there exist positive integers candn/primesuch
that for all n > n/primeit holds that f(n)≤c·g(n).
537538 Introduction to Modern Cryptography
•f(n) = Ω(g(n))means that there exist positive integers candn/primesuch
that for all n > n/primeit holds that f(n)≥c·g(n).
•f(n) = Θ(g(n))means that there exist positive integers c1,c2, andn/prime
such that for all n > n/primeit holds that c1·g(n)≤f(n)≤c2·g(n).
•f(n) =o(g(n))means that limn→∞f(n)
g(n)=0.
•f(n)=ω(g(n))means that limn→∞f(n)
g(n)=∞.
Example A.6
Letf(n) =n4+3n+500. Then:
•f(n) =O(n4).
•f(n) =O(n5). In fact, f(n) =o(n5).
•f(n) = Ω(n3logn). In fact, f(n) =ω(n3logn).
•f(n) = Θ(n4).
♦
A.3 Basic Probability
Weassume the reader is familiar with basic probability theory, on the level
of what is covered in a typical undergraduate course on discrete mathematics.
Here we simply remind the reader of some notation and basic facts.
IfEis an event, then ¯Edenotes the complement of that event; i.e., ¯Eis the
event that Edoesnotoccur. By deﬁnition, Pr[ E] = 1−Pr[¯E]. IfE1andE2
are events, then E1∧E2denotes their conjunction; i.e., E1∧E2is the event
thatbothE1andE2occur. By deﬁnition, Pr[ E1∧E2]≤Pr[E1]. Events E1
andE2are said to be independent if Pr[E1∧E2] = Pr[E1]·Pr[E2].
IfE1andE2are events, then E1∨E2denotes the disjunction of E1and
E2; that is, E1∨E2is the event that eitherE1orE2occurs. It follows from
the deﬁnition that Pr[ E1∨E2]≥Pr[E1]. Theunion bound is often a very
useful upper bound of this quantity.
PROPOSITION A.7 (Union Bound)
Pr[E1∨E2]≤Pr[E1]+Pr[E2].Mathematical Background 539
Repeated application of the union bound for any events E1,...,E kgives
Pr/bracketleftBig/logicalortextk
i=1Ei/bracketrightBig
≤k/summationdisplay
i=1Pr[Ei].
Theconditional probability of E1givenE2, denotedPr[ E1|E2], isdeﬁnedas
Pr[E1|E2]def=Pr[E1∧E2]
Pr[E2]
aslong as Pr[ E2]/negationslash= 0. (If Pr[ E2] = 0 then Pr[ E1|E2] is undeﬁned.) This rep-
resentsthe probabilitythat event E1occurs, giventhat event E2hasoccurred.
It follows immediately from the deﬁnition that
Pr[E1∧E2] = Pr[E1|E2]·Pr[E2];
equality holds even if Pr[ E2] = 0 as long as we interpret multiplication by
zero on the right-hand side in the obvious way.
We can now easily derive Bayes’ theorem.
THEOREM A.8 (Bayes’ Theorem) IfPr[E2]/negationslash= 0then
Pr[E1|E2] =Pr[E2|E1]·Pr[E1]
Pr[E2].
PROOF This follows because
Pr[E1|E2] =Pr[E1∧E2]
Pr[E2]=Pr[E2∧E1]
Pr[E2]=Pr[E2|E1]·Pr[E1]
Pr[E2].
LetE1,...,Enbe eventssuch that Pr[ E1∨···∨En] = 1 and Pr[ Ei∧Ej] = 0
for alli/negationslash=j. That is, the{Ei}partition the space of all possible events, so
that with probability 1 exactly one of the events Eioccurs. Then for any F
Pr[F] =n/summationdisplay
i=1Pr[F∧Ei].
A special case is when n= 2 and E2=¯E1, giving
Pr[F] = Pr[F∧E1]+Pr[F∧¯E1]
= Pr[F|E1]·Pr[E1]+Pr[F|¯E1]·Pr[¯E1].
TakingF=E1∨E2, we get a tighter version of the union bound:
Pr[E1∨E2] = Pr[E1∨E2|E1]·Pr[E1]+Pr[E1∨E2|¯E1]·Pr[¯E1]
≤Pr[E1]+Pr[E2|¯E1].540 Introduction to Modern Cryptography
Extending this to events E1,...,E nwe obtain
PROPOSITION A.9
Pr/bracketleftBig/logicalortextk
i=1Ei/bracketrightBig
≤Pr[E1]+k/summationdisplay
i=2Pr[Ei|¯E1∧···∧¯Ei−1].
* Useful Probability Bounds
We review some terminology and state probability bounds that are stan-
dard, but may not be encountered in a basic discrete mathematics course.
The material here is used only in Section 7.3.
A (discrete, real-valued) random variable Xis a variable whose value is
assigned probabilistically from some ﬁnite set Sof real numbers. Xis non-
negative if it does not take negative values; it is a 0 /1-random variable
ifS={0,1}. The 0/1-random variables X1,...,X kareindependent if for
allb1,...,b kit holds that Pr[ X1=b1∧···∧Xk=bk] =/producttextk
i=1Pr[Xi=bi].
We letExp[X] denote the expectation of a random variable X; ifXtakes
values in a set SthenExp[X]def=/summationtext
s∈Ss·Pr[X=s]. One of the most
important facts is that expectation is linear; for random variables X1,...,X k
(with arbitrary dependencies) we have Exp[/summationtext
iXi] =/summationtext
iExp[Xi]. IfX1,X2
are independent, then Exp[Xi·Xj] =Exp[Xi]·Exp[Xj].
Markov’s inequality is useful when little is known about X.
PROPOSITION A.10 (Markov’s inequality) LetXbe a non-negative
random variable and v >0. ThenPr[X≥v]≤Exp[X]/v.
PROOF SayXtakes values in a set S. We have
Exp[X] =/summationdisplay
s∈Ss·Pr[X=s]
≥/summationdisplay
x∈S, x<vPr[X=s]·0+/summationdisplay
x∈S, x≥vv·Pr[X=s]
=v·Pr[X≥v].
The variance of X,denotedVar[X], measures how much Xdeviates from
its expectation. We have Var[X]def=Exp[(X−Exp[X])2] =Exp[X2]−Exp[X]2,
and one can easily show that Var[aX+b] =a2Var[X]. For a 0 /1-random
variable Xi, we have Var[Xi]≤1/4 because in this case Exp[Xi] =Exp[X2
i]
and soVar[Xi] =Exp[Xi](1−Exp[Xi]), which is maximized when Exp[Xi] =1
2.Mathematical Background 541
PROPOSITION A.11 (Chebyshev’s inequality) LetXbe a random
variable and δ >0. Then:
Pr[|X−Exp[X]|≥δ]≤Var[X]
δ2.
PROOFDeﬁne the non-negative random variable Ydef= (X−Exp[X])2and
then apply Markov’s inequality. So,
Pr[|X−Exp[X]|≥δ] = Pr[(X−Exp[X])2≥δ2]
≤Exp[(X−Exp[X])2]
δ2=Var[X]
δ2.
The 0/1-randomvariables X1,...,Xmarepairwise independent if for every
i/negationslash=jand every bi,bj∈{0,1}it holds that
Pr[Xi=bi∧Xj=bj] = Pr[Xi=bi]·Pr[Xj=bj].
IfX1,...,X mare pairwise independent then Var[/summationtextm
i=1Xi] =/summationtextm
i=1Var[Xi].
(This follows since Exp[Xi·Xj] =Exp[Xi]·Exp[Xj] wheni/negationslash=j, using pairwise
independence.) An important corollary of Chebyshev’s inequality follows.
COROLLARY A.12 LetX1,...,X mbe pairwise-independent random
variables with the same expectation µand variance σ2. Then for every δ >0,
Pr/bracketleftbigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle/summationtextm
i=1Xi
m−µ/vextendsingle/vextendsingle/vextendsingle/vextendsingle≥δ/bracketrightbigg
≤σ2
δ2m.
PROOF By linearity of expectation, Exp[/summationtextm
i=1Xi/m] =µ. Applying
Chebyshev’s inequality to the random variable/summationtextm
i=1Xi/m, we have
Pr/bracketleftbigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle/summationtextm
i=1Xi
m−µ/vextendsingle/vextendsingle/vextendsingle/vextendsingle≥δ/bracketrightbigg
≤Var/bracketleftbig1
m·/summationtextm
i=1Xi/bracketrightbig
δ2.
Using pairwise independence, it follows that
Var/bracketleftBigg
1
m·m/summationdisplay
i=1Xi/bracketrightBigg
=1
m2m/summationdisplay
i=1Var[Xi] =1
m2m/summationdisplay
i=1σ2=σ2
m.
The inequality is obtained by combining the above two equations.
Say 0/1-random variables X1,...,Xmeach provides an estimate of some
ﬁxed (unknown) bit b. That is, Pr[ Xi=b]≥1/2+εfor alli, whereε >0.542 Introduction to Modern Cryptography
We can estimate bby looking at the value of X1; this estimate will be correct
with probability Pr[ X1=b]. A better estimate can be obtained by looking
at the values of X1,...,X mand taking the value that occurs the majority
of the time. We analyze how well this does when X1,...,X mare pairwise
independent.
PROPOSITION A.13 Fixε >0andb∈{0,1}, and let{Xi}be pairwise-
independent, 0/1-random variables for which Pr[Xi=b]≥1
2+εfor alli.
Consider the process in which mvaluesX1,...,X mare recorded and Xis set
to the value that occurs a strict majority of the time. Then
Pr[X/negationslash=b]≤1
4·ε2·m.
PROOF Assume b= 1; by symmetry, this is without loss of generality.
ThenExp[Xi] =1
2+ε.LetXdenote the strict majority of the {Xi}as in the
proposition, and note that X/negationslash= 1 if and only if/summationtextm
i=1Xi≤m/2. So
Pr[X/negationslash= 1] = Pr/bracketleftBiggm/summationdisplay
i=1Xi≤m/2/bracketrightBigg
= Pr/bracketleftbigg/summationtextm
i=1Xi
m−1
2≤0/bracketrightbigg
=Pr/bracketleftbigg/summationtextm
i=1Xi
m−/parenleftbigg1
2+ε/parenrightbigg
≤−ε/bracketrightbigg
≤Pr/bracketleftbigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle/summationtextm
i=1Xi
m−/parenleftbigg1
2+ε/parenrightbigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle≥ε/bracketrightbigg
.
SinceVar[Xi]≤1/4 for all i, applying the previous corollary shows that
Pr[X/negationslash= 1]≤1
4ε2masclaimed.
A better bound is obtained if the {Xi}are independent:
PROPOSITION A.14 (Chernoﬀ bound) Fixε >0andb∈{0,1},
and let{Xi}be independent 0/1-random variables with Pr[Xi=b] =1
2+ε
for alli. The probability that their majority value is not bis at most e−ε2m/2.
A.4 The “Birthday” Problem
Ifwe choose qelements y1,...,y quniformly from a set ofsize N, what is the
probability that there exist distinct i,jwithyi=yj? We refer to the statedMathematical Background 543
event as a collision, and denote the probability of this event by coll(q,N).
This problem is related to the so-called birthday problem , which asks what
size group of people we need such that with probability 1 /2 some pair of
people in the group share a birthday. To see the relationship, let yidenote
the birthday of the ith person in the group. If there are qpeople in the group
then we have qvaluesy1,...,y qchosen uniformly from {1,...,365}, making
the simplifying assumption that birthdays are uniformly and independently
distributed among the 365 days of a non-leap year. Furthermore, matching
birthdays correspond to a collision, i.e., distinct i,jwithyi=yj. So the
desired solution to the birthday problem is given by the minimal (integer)
value ofqfor which coll(q,365)≥1/2. (The answer may surprise you—taking
q= 23 people suﬃces!)
In this section, we prove lower and upper bounds on coll(q,N). Taken
together and summarized at a high level, they show that if q <√
Nthen
the probability of a collision is Θ( q2/N); alternately, for q= Θ(√
N)the
probability of a collision is constant.
An upper bound for the collision probability is easy to obtain.
LEMMA A.15 Fix a positive integer N, and say qelements y1,...,y qare
chosen uniformly and independently at random from a set of size N. Then the
probability that there exist distinct i,jwithyi=yjis at mostq2
2N.That is,
coll(q,N)≤q2
2N.
PROOF The proof is a simple application of the union bound (Proposi-
tion A.7). Recall that a collision means that there exist distinct i,jwith
yi=yj. LetColldenote the event of a collision, and let Colli,jdenote the
event that yi=yj. It is immediate that Pr[ Colli,j] = 1/Nfor any distinct
i,j. Furthermore, Coll=/logicalortext
i/negationslash=jColli,jand so repeated application of the union
bound implies that
Pr[Coll] = Pr
/logicalordisplay
i/negationslash=jColli,j

≤/summationdisplay
i/negationslash=jPr[Colli,j] =/parenleftbiggq
2/parenrightbigg
·1
N≤q2
2N.544 Introduction to Modern Cryptography
LEMMA A.16 Fix a positive integer N, and say q≤√
2Nelements
y1,...,yqare chosen uniformly and independently at random from a set of
sizeN. Then the probability that there exist distinct i,jwithyi=yjis at
leastq(q−1)
4N.Infact,
coll(q,N)≥1−e−q(q−1)/2N≥q(q−1)
4N.
PROOF Recall that a collision means that there exist distinct i,jwith
yi=yj. LetColldenote this event. Let NoColl ibe the event that there
isnocollision among y1,...,y i; that is, yj/negationslash=ykfor allj < k≤i. Then
NoColl q=Collisthe event that there is no collision at all.
IfNoCollqoccurs then NoColl imust also have occurred for all i≤q. Thus,
Pr[NoColl q] = Pr[NoColl 1]·Pr[NoColl 2|NoColl 1]···Pr[NoColl q|NoColl q−1].
Now, Pr[ NoColl 1] = 1 since y1cannot collide with itself. Furthermore, if event
NoColl ioccurs then{y1,...,y i}contains idistinct values; so, the probability
thatyi+1collides with one of these values isi
Nand hence the probability that
yi+1doesnotcollide with any of these values is 1 −i
N.This means
Pr[NoColl i+1|NoColl i] = 1−i
N,
and so
Pr[NoColl q] =q−1/productdisplay
i=1/parenleftbigg
1−i
N/parenrightbigg
.
Sincei/N <1 for all i, we have 1−i
N≤e−i/N(by Inequality A.3) and so
Pr[NoColl q]≤q−1/productdisplay
i=1e−i/N=e−/summationtextq−1
i=1(i/N)=e−q(q−1)/2N.
We conclude that
Pr[Coll] = 1−Pr[NoColl q]≥1−e−q(q−1)/2N≥q(q−1)
4N,
using Inequality A.4 in the last step (note that q(q−1)/2N <1).
A.5 *Finite Fields
Weuse ﬁnite ﬁelds only sparingly in the book, but we include a deﬁnition
and some basic facts for completeness. Further details can be found in any
textbook on abstract algebra.Mathematical Background 545
DEFINITION A.17 A(ﬁnite) ﬁeld is a (ﬁnite) set Falong with two
binary operations +,·for which the following hold:
•Fis an abelian group with respect to the operation ‘ +.’ We let 0denote
the identity element of this group.
•F\{0}is an abelian group with respect to the operation ‘ ·.’ We let 1
denote the identity element of this group.
As usual, we often write abin place of a·b.
•(Distributivity:) For alla,b,c∈F, we have a·(b+c) =ab+ac.
Theadditive inverse ofa∈F, denoted by−a, is the unique element satisfy-
inga+(−a) = 0; we write b−ain place of b+(−a). Themultiplicative inverse
ofa∈F\{0}, denoted by a−1, is the unique element satisfying aa−1= 1; we
often write b/ain place of ba−1.
Example A.18
It follows from the results of Section 8.1.4 that for any prime pthe set
{0,...,p−1}is a ﬁnite ﬁeld with respect to addition and multiplication mod-
ulop. We denote this ﬁeld by Fp. ♦
Finite ﬁelds have a rich theory. For our purposes, we need only a few basic
facts. The orderofFis the number of elements in F(assuming it is ﬁnite).
Recallalsothat qisaprimepowerif q=prforsomeprime pandinteger r≥1.
THEOREM A.19 IfFis a ﬁnite ﬁeld, then the order of Fis a prime
power. Conversely, for every prime power qthere is a ﬁnite ﬁeld of order q,
which is moreover the unique such ﬁeld (up to relabeling of the elements).
Forq=prwithpprime, we let Fqdenote the (unique) ﬁeld of order q.
We callpthecharacteristic ofFq. The preceding theorem tells us that the
characteristic of any ﬁnite ﬁeld is prime.
As in the case of groups, if nis a positive integer and a∈Fthen
n·adef=a+···+a/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright
ntimesandandef=a···a/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright
ntimes.
The notation is extended for n≤0 in the natural way.
THEOREM A.20 LetFqbe a ﬁnite ﬁeld of characteristic p. Then for all
a∈Fqwe have p·a= 0.
Letq=prwithpprime. For r= 1, wehaveseeninExampleA.18that Fq=
Fpcan be taken to be the set {0,...,p−1}under addition and multiplication546 Introduction to Modern Cryptography
modulop. We caution, however, that for r >1 the set{0,...,q−1}isnot
a ﬁeld under addition and multiplication modulo q. For example, if we take
q= 32= 9 then the element3 doesnothaveamultiplicative inversemodulo9.
Finiteﬁeldsofcharacteristic pcanberepresentedusingpolynomialsover Fp.
We give an example to demonstrate the ﬂavor of the construction, without
discussing why the construction works or describing the general case. We con-
struct the ﬁeld F4by working with polynomials over F2. Fix the polynomial
r(x) =x2+x+1,andnote that r(x) hasno rootsover F2sincer(0) =r(1) = 1
(recall that we are working in F2, which means that all operations are carried
out modulo 2). In the same way that we can introduce the imaginary num-
berito be a root of x2+1 over the reals, we can introduce a value ωto be a
root ofr(x) overF2; that is, ω2=−ω−1. We then deﬁne F4to be the set of
all degree-1 polynomials in ωoverF2; that is, F4={0,1,ω,ω+1}. Addition
inF4will just be regular polynomial addition, remembering that operations
on the coeﬃcients are done in F2(that is, modulo 2). Multiplication in F4
will be polynomial multiplication (again, with operations on the coeﬃcients
carried out modulo 2) followed by the substitution ω2=−ω−1; this also
ensures that the result lies in F4. So, for example,
ω+(ω+1) = 2ω+1 = 1
and
(ω+1)·(ω+1) =ω2+2ω+1 = (−ω−1)+1 =−ω=ω.
Although not obvious, one can check that this is a ﬁeld; the only diﬃcult
condition to verify is that every nonzero element has a multiplicative inverse.
We need only one other result.
THEOREM A.21 LetFqbe a ﬁnite ﬁeld of order q. Then the abelian
groupFq\{0}with respect to ‘·’ is acyclicgroup of order q−1.Appendix B
Basic Algorithmic Number Theory
For the cryptographic constructions given in this book to be eﬃcient (i.e.,
to run in time polynomial in the lengths of their inputs), it is necessary for
theseconstructionstoutilizeeﬃcient(thatis, polynomial-time)algorithmsfor
performing basic number-theoretic operations. Although in some cases there
exist “trivial” algorithms that would work, it is still worthwhile to carefully
consider their eﬃciency since for cryptographic applications it is not uncom-
mon to use integers that are thousands of bits long. In other cases obtaining
any polynomial-time algorithm requires a bit of cleverness, and an analysis of
their performance may rely on non-trivial group-theoretic results.
In Appendix B.1 we describe basic algorithms for integer arithmetic. Here
we cover the familiar algorithms for addition, subtraction, etc., as well as the
Euclidean algorithmfor computing greatestcommon divisors. We alsodiscuss
the extended Euclidean algorithm, assuming there that the readerhas covered
the material in Section 8.1.1.
In Appendix B.2 we show various algorithms for modular arithmetic. In
addition to a briefdiscussionofbasicmodular operations(i.e., modular reduc-
tion, addition, multiplication, and inversion), we also describe Montgomery
multiplication , which can greatly simplify (and speed up) implementations of
modular arithmetic. We then discuss algorithms for problems that are less
common outside the ﬁeld of cryptography: exponentiation modulo N(as well
as in arbitrary groups) and choosing a uniform element of ZNorZ∗
N(or in
an arbitrary group). This section assumes familiarity with the basic group
theory covered in Section 8.1.
The material above is used implicitly throughout the second half of the
book, although it is not absolutely necessary to read this material in order
to follow the book. (In particular, the reader willing to accept the results of
this Appendix without proof can simply read the summary of those results
in the theorems below.) Appendix B.3, which discusses ﬁnding generators
in cyclic groups (when the factorization of the group order is known) and
assumes the results of Section 8.3.1, contains material that is hardly used at
all; it is included for completeness and reference.
Since our goal is only to establish that certain problems can be solved in
polynomial time, we have opted for simplicity rather than eﬃciency in our
selection of algorithms and their descriptions (as long as the algorithms run
in polynomial time). For this reason, we generally will not be interested in
547548 Introduction to Modern Cryptography
the exact running times of the algorithms we present beyond establishing that
they indeed run in polynomial time. The reader who is seriously interested
in implementing these algorithms is forewarned to look at other sources for
more eﬃcient alternatives as well as various techniques for speeding up the
necessary computations.
The results in this Appendix are summarized by the theorems that follow.
Throughout, we assume that any integer aprovided as input is written using
exactly/bardbla/bardblbits; i.e., the high-order bit is 1. In Appendix B.1 we show:
THEOREM B.1 (Integer operations) Given integers aandb, it is
possible to perform the following operations in time polynomial in /bardbla/bardbland/bardblb/bardbl:
1. Computing the sum a+band the diﬀerence a−b;
2. Computing the product ab;
3. Computing positive integers qandr < bsuch that a=qb+r(i.e.,
computing division with remainder );
4. Computing the greatest common divisor of aandb,gcd(a,b);
5. Computing integers X,YwithXa+Yb= gcd(a,b).
The following results are proved in Appendix B.2:
THEOREM B.2 (Modular operations) Given integers N >1,a,
andb, it is possible to perform the following operations in time polynomial
in/bardbla/bardbl,/bardblb/bardbl, and/bardblN/bardbl:
1. Computing the modular reduction [amodN];
2. Computing the sum [(a+b) modN], the diﬀerence [(a−b) modN], and
the product [abmodN];
3. Determining whether ais invertible modulo N;
4. Computing the multiplicative inverse [a−1modN], assuming ais in-
vertible modulo N;
5. Computing the exponentiation [abmodN].
The following generalizes Theorem B.2(5) to arbitrary groups:
THEOREM B.3 (Group exponentiation) LetGbe a group, written
multiplicatively. Let gbe an element of the group and let bbe a non-negative
integer. Then gbcan be computed using poly(/bardblb/bardbl)group operations.Basic Algorithmic Number Theory 549
THEOREM B.4 (Choosing uniform elements) There exists a ran-
domized algorithm with the following properties: on input N,
•The algorithm runs in time polynomial in /bardblN/bardbl;
•The algorithm outputs failwith probability negligible in /bardblN/bardbl; and
•Conditioned on not outputting fail, the algorithm outputs a uniformly
distributed element of ZN.
An algorithm with analogous properties exists for Z∗
Nas well.
Since the probability that either algorithm referenced in the above theorem
outputsfailis negligible, we ignore this possibility (and instead leave it im-
plicit). In Appendix B.2 we also discuss generalizations of the above to the
case of selecting a uniform element from any ﬁnite group (subject to certain
requirements on the representation of group elements).
A proof of the following is in Appendix B.3:
THEOREM B.5 (Testing and ﬁnding generators) LetGbe a cyclic
group of order q, and assume that the group operation and selection of a
uniform group element can be carried out in unit time.
1. There is an algorithm that on input q, the prime factorization of q, and
an element g∈G, runs in poly(/bardblq/bardbl)time and decides whether gis a
generator of G.
2. There is a randomized algorithm that on input qand the prime factor-
ization of q, runs in poly(/bardblq/bardbl)time and outputs a generator of Gexcept
with probability negligible in /bardblq/bardbl. Conditioned on the output being a
generator, it is uniformly distributed among the generators of G.
B.1 Integer Arithmetic
B.1.1 Basic Operations
We begin our exploration of algorithmic number theory with a discussion
of integer addition/subtraction, multiplication, and division with remainder.
A little thought shows that all these operations can be carried out in time
polynomial in the input length using the standard “grade-school” algorithms
for these problems. For example, addition of two positive integers aandb
witha > bcan be done in time linear in /bardbla/bardblby stepping one-by-one through
the bits of aandb, starting with the low-order bits, and computing the cor-
responding output bit and a “carry bit” at each step. (Details are omitted.)
Multiplication of two n-bit integers aandb, to take another example, can550 Introduction to Modern Cryptography
be done by ﬁrst generating a list of nintegers of length at most 2 n(each of
which is equal to a·2i−1·bi, wherebiis theith bit of b) and then adding
thesenintegers together to obtain the ﬁnal result. (Division with remainder
is trickier to implement eﬃciently, but can also be done.)
Although these grade-school algorithms suﬃce to demonstrate that the
aforementioned problems can be solved in polynomial time, it is interesting
to note that these algorithms are in some cases not the best ones available.
As an example, the simple algorithm for multiplication given above multiplies
twon-bit numbers in time O(n2), but there exists a better algorithm running
in timeO(nlog23) (and even that is not the best possible). While the diﬀer-
ence is insigniﬁcant for numbers of the size we encounter daily, it becomes
noticeable when the numbers are large. In cryptographic applications it is
not uncommon to use integers that are thousands of bits long (i.e., n >1000),
and a judicious choice of which algorithms to use then becomes critical.
B.1.2 The Euclidean and Extended Euclidean Algorithms
Recall from Section 8.1 that gcd( a,b), thegreatest common divisor of two
integersaandb, is the largest integer dthat divides both aandb. We state
an easy proposition regarding the greatest common divisor, and then show
how this leads to an eﬃcient algorithm for computing gcd’s.
PROPOSITION B.6 Leta,b >1withb/negationslash|a. Then
gcd(a,b) = gcd(b,[amodb]).
PROOF Ifb > athe stated claim is immediate. So assume a > b. Write
a=qb+rforq,rpositive integers and r < b(cf. Proposition 8.1); note that
r >0 because b/negationslash|a. Sincer= [amodb], we prove the proposition by showing
that gcd( a,b) = gcd(b,r).
Letd= gcd(a,b). Then ddivides both aandb, and so dalso divides
r=a−qb. By deﬁnition of the greatest common divisor, we thus have
gcd(b,r)≥d= gcd(a,b).
Letd/prime= gcd(b,r). Then d/primedivides both bandr, and so d/primealso divides
a=qb+r. By deﬁnition of the greatest common divisor, we thus have
gcd(a,b)≥d/prime= gcd(b,r).
Sinced≥d/primeandd/prime≥d, we conclude that d=d/prime.
The above suggests the recursive Euclidean algorithm (Algorithm B.7) for
computing the greatest common divisor gcd( a,b) of two integers aandb.
Correctness of the algorithm follows readily from Proposition B.6. As for its
running time, we show below that on input ( a,b) the algorithm makes fewer
than 2·/bardblb/bardblrecursive calls. Since checking whether bdividesaand computingBasic Algorithmic Number Theory 551
ALGORITHM B.7
The Euclidean algorithm GCD
Input:Integers a,bwitha≥b >0
Output: The greatest common divisor of aandb
ifbdividesa
returnb
else return GCD(b,[amodb])
[amodb]can both be done in time polynomial in /bardbla/bardbland/bardblb/bardbl, this implies
that the entire algorithm runs in polynomial time.
PROPOSITION B.8 Consider an execution of GCD(a0,b0), and let ai,bi
(fori= 1,...,/lscript)denote the arguments to the ith recursive call of GCD. Then
bi+2≤bi/2for0≤i≤/lscript−2.
PROOF First note that for any a > bwe have [ amodb]< a/2. To see
this, considerthe twocases: If b≤a/2then [amodb]< b≤a/2is immediate.
On the other hand, if b > a/2 then [amodb] =a−b < a/2.
Now ﬁx arbitrary iwith 0≤i≤/lscript−2. Then bi+2= [ai+1modbi+1]<
ai+1/2 =bi/2.
COROLLARY B.9 Inan execution of algorithm GCD(a,b), there are at
most2/bardblb/bardbl−2recursive calls to GCD.
PROOF Letai,bi(fori= 1,...,/lscript) denote the arguments to the ith recur-
sive call of GCD. The{bi}are always greater than zero, and the algorithm
makes no further recursive calls if it ever happens that bi= 1 (since then
bi|ai). The previous proposition indicates that the {bi}decrease by a mul-
tiplicative factor of (at least) 2 in every two iterations. It follows that the
number of recursive calls to GCDis at most 2·(/bardblb/bardbl−1).
The Extended Euclidean Algorithm
ByProposition 8.2, we know that for positive integers a,bthere exist inte-
gersX,YwithXa+Yb= gcd(a,b). A simple modiﬁcation of the Euclidean
algorithm, called the extended Euclidean algorithm , can be used to ﬁnd X,Y
in addition to computing gcd( a,b); see Algorithm B.10. You are asked to
show correctness of the extended Euclidean algorithm in Exercise B.1, and to
prove that the algorithm runs in polynomial time in Exercise B.2.552 Introduction to Modern Cryptography
ALGORITHM B.10
The extended Euclidean algorithm eGCD
Input:Integers a,bwitha≥b >0
Output: (d,X,Y) withd= gcd(a,b) andXa+Yb=d
ifbdividesa
return(b,0,1)
else
Compute integers q,rwitha=qb+rand 0< r < b
(d,X,Y) :=eGCD(b,r)//note that Xb+Yr=d
return(d,Y,X−Yq)
B.2 Modular Arithmetic
Wenow turn our attention to basic arithmetic operations modulo N >1.
We will use ZNto refer both to the set {0,...,N−1}as well as to the group
that results by consideringaddition modulo Namong the elements of this set.
B.2.1 Basic Operations
Eﬃcient algorithms for the basic arithmetic operations over the integers
immediately imply eﬃcient algorithms for the corresponding arithmetic oper-
ations modulo N. For example, computing the modular reduction [ amodN]
can be done in time polynomial in /bardbla/bardbland/bardblN/bardblby computing division-with-
remainder over the integers. Next consider modular operations on two ele-
mentsa,b∈ZNwhere/bardblN/bardbl=n. (Note that a,bhave length at most n. Ac-
tually, it is convenient to simply assume that all elements of ZNhave length
exactlyn, padding to the left with 0s if necessary.) Addition of aandbmod-
uloNcan be done by ﬁrst computing a+b, an integer of length at most n+1,
and then reducing this intermediate result modulo N. Similarly, multiplica-
tion modulo Ncan be performed by ﬁrst computing the integer abof length
at most 2 nand then reducing the result modulo N. Since addition, multipli-
cation, and division-with-remainder can all be done in polynomial time, these
give polynomial-time algorithms for addition and multiplication modulo N.
B.2.2 Computing Modular Inverses
Our discussion thus far has shown how to add, subtract, and multiply mod-
uloN. One operation we are missing is “division” or, equivalently, computing
multiplicative inverses modulo N. Recall from Section 8.1.2 that the multi-
plicative inverse (modulo N) of an element a∈ZNis an element a−1∈ZN
such that a·a−1= 1 mod N. Proposition 8.7 shows that ahas an inverse
if and only if gcd( a,N) = 1, i.e., if and only if a∈Z∗
N. Thus, using theBasic Algorithmic Number Theory 553
Euclidean algorithm we can easily determine whether a given element ahas
a multiplicative inverse modulo N.
GivenNanda∈ZNwith gcd( a,N) = 1, Proposition 8.2 tells us that
there exist integers X,YwithXa+YN= 1. This means that [ XmodN]
is the multiplicative inverse of a. Integers XandYsatisfying Xa+YN= 1
can be found eﬃciently using the extended Euclidean algorithm eGCDshown
in Section B.1.2. This leads to the following polynomial-time algorithm for
computing multiplicative inverses:
ALGORITHM B.11
Computing modular inverses
Input:Modulus N; element a
Output: [a−1modN] (if it exists)
(d,X,Y) :=eGCD(a,N)//note that Xa+YN= gcd(a,N)
ifd/negationslash= 1return“ais not invertible modulo N”
else return [XmodN]
B.2.3 Modular Exponentiation
Amore challenging task is that of exponentiation moduloN, that is, com-
puting [abmodN] for base a∈ZNand integer exponent b >0. (When b= 0
the problem is easy. When b <0 anda∈Z∗
Nthenab= (a−1)−bmodN
and the problem is reduced to the case of exponentiation with a positive
exponent given that we can compute inverses, as discussed in the previous
section.) Notice that the basic approach used in the case of addition and
multiplication (i.e., computing the integer aband then reducing this inter-
mediate result modulo N) doesnotwork here: the integer abhas length/vextenddouble/vextenddoubleab/vextenddouble/vextenddouble= Θ(logab) = Θ(b·/bardbla/bardbl), and so even storing the intermediate result ab
would require time exponential in /bardblb/bardbl= Θ(logb).
We can address this problem by reducing modulo Nat all intermediate
steps of the computation, rather than only reducing modulo Nat the end.
This has the eﬀect of keeping the intermediate results “small” throughout
the computation. Even with this important initial observation, it is still non-
trivial to design a polynomial-time algorithm for modular exponentiation.
Consider the na¨ ıve approach of Algorithm B.12, which simply performs b
multiplications by a. This still runs in time that is exponential in/bardblb/bardbl.
This na¨ ıve algorithm can be viewed as relying on the following recurrence:
[abmodN] = [a·ab−1modN] = [a·a·ab−2modN] =···
Any algorithm based on this relationship will require Θ( b) time. We can do554 Introduction to Modern Cryptography
ALGORITHM B.12
Ana¨ ıve algorithm for modular exponentiation
Input:Modulus N; basea∈ZN; integer exponent b >0
Output: [abmodN]
x:= 1
fori= 1 tob:
x:= [x·amodN]
returnx
better by relying on the following recurrence:
[abmodN] =

/bracketleftbigg/parenleftBig
ab
2/parenrightBig2
modN/bracketrightbigg
whenbis even
/bracketleftbigg
a·/parenleftBig
ab−1
2/parenrightBig2
modN/bracketrightbigg
whenbis odd.
Doing so leads to an algorithm—called, for obvious reasons, “square-and-
multiply” (or “repeated squaring”)—that requires only O(logb) =O(/bardblb/bardbl)
modular squarings/multiplications; see Algorithm B.13. In this algorithm,
the length of bdecreases by 1 in each iteration; it follows that the number
of iterations is/bardblb/bardbl, and so the overall algorithm runs in time polynomial
in/bardbla/bardbl,/bardblb/bardbl, and/bardblN/bardbl. More precisely, the number of modular squarings is
exactly/bardblb/bardbl, and the number of additional modular multiplications is exactly
the Hamming weight of b(i.e., the number of 1s in the binary representation
ofb). This explains the preference, discussed in Section 8.2.4, for choosing
the public RSA exponent eto have small length/Hamming weight.
ALGORITHM B.13
Algorithm ModExp for eﬃcient modular exponentiation
Input:Modulus N; basea∈ZN; integer exponent b >0
Output: [abmodN]
x:=a
t:= 1
//maintain the invariant that the answer is [ t·xbmodN]
whileb >0 do:
ifbis odd
t:= [t·xmodN], b:=b−1
x:= [x2modN], b:=b/2
returnt
FixaandNand consider the modular exponentiation function given by
fa,N(b) = [abmodN]. We have just seen that computing fa,Nis easy. In
contrast, computing the inverseof this function—that is, computing bgiven
a,N, and [abmodN]—is believed to be hard for appropriate choice of aBasic Algorithmic Number Theory 555
andN. Invertingthis function requiressolvingthe discrete-logarithm problem ,
something we discuss in detail in Section 8.3.2.
Using precomputation. If the base ais known in advance, and there is
a bound on the length of the exponent b, then one can use precomputation
and a small amount of memory to speed up computation of [ abmodN]. Say
/bardblb/bardbl≤n. Then we precompute and store the nvalues
x0:=a, x1:= [a2modN], ..., x n−1:= [a2n−1modN].
Given exponent bwith binary representation bn−1···b0(written from most
to least signiﬁcant bit), we then have
ab=a/summationtextn−1
i=02i·bi=n−1/productdisplay
i=0xbi
imodN.
Sincebi∈{0,1}, the number of multiplications needed to compute the result
is exactly one less than the Hamming weight of b.
Exponentiation in Arbitrary Groups
The eﬃcient modular exponentiation algorithm given above carries over in
a straightforward way to enable eﬃcient exponentiation in any group, as long
as the underlying group operation can be performed eﬃciently. Speciﬁcally,
ifGis a group and gis an element of G, thengbcan be computed using at
most 2·/bardblb/bardblapplications of the underlying group operation. Precomputation
could also be used, exactly as described above.
If the order qofGis known, then ab=a[bmodq](cf. Proposition 8.52) and
this can be used to speed up the computation by reducing bmoduloqﬁrst.
Considering the (additive) group ZN, the group exponentiation algorithm
just described gives a method for computing the “exponentiation”
[b·gmodN]def= [g+···+g/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright
btimesmodN]
that diﬀers from the method discussed earlier that relies on standard integer
multiplication followed by a modular reduction. In comparing the two ap-
proaches to solving the same problem, note that the original algorithm uses
speciﬁc information about ZN; in particular, it (essentially) treats the “ex-
ponent” bas an element of ZN(possibly by reducing bmoduloNﬁrst). In
contrast, the “square-and-multiply” algorithm just presented treats ZNonly
as an abstract group. (Of course, the group operation of addition modulo N
relies on the speciﬁcs of ZN.) The point of this discussion is merely to illus-
trate that some group algorithms are generic(i.e., they apply equally well to
all groups) while some group algorithms rely on speciﬁc properties of a par-
ticulargroup or class of groups. We saw some examples of this phenomenon
in Chapter 9.556 Introduction to Modern Cryptography
B.2.4 *Montgomery Multiplication
Although division over the integers (and hence modular reduction) can be
done in polynomial time, algorithms for integer division are slow in compari-
son to, say, algorithms for integer multiplication. Montgomery multiplication
provides a way to perform modular multiplication withoutcarrying out any
expensive modular reductions. Since pre- and postprocessing is required, the
method is advantageous only when several modular multiplications will be
done in sequence as, e.g., when computing a modular exponentiation.
Fix an odd modulus Nwith respect to which modular operations are to be
done. Let R > Nbeapoweroftwo,say R= 2w, andnotethatgcd( R,N) = 1.
The key property we will exploit is that division by Ris fast: the quotient of
xupon division by Ris obtained by simply shifting xto the right wpositions,
and [xmodR] is just the wleast-signiﬁcant bits of x.
Deﬁne the Montgomery representation ofx∈Z∗
Nby ¯xdef= [xRmodN].
Montgomery multiplication of ¯ x,¯y∈Z∗
Nis deﬁned as
Mont(¯x,¯y)def= [¯x¯yR−1modN].
(We show below how this can be computed without any expensive modular
reductions.) Note that
Mont(¯x,¯y) = ¯x¯yR−1= (xR)(yR)R−1= (xy)R=xymodN.
This means we can multiply several values in ZNby (1) converting to the
Montgomery representation, (2) carrying out all multiplications using Mont-
gomery multiplication to obtain the ﬁnal result, and then (3) converting the
result from Montgomery representation back to the standard representation.
Letαdef= [−N−1modR], avaluewhichcanbeprecomputed. (Computation
ofα, and conversion to/from Montgomery representation, can also be done
without any expensive modular reductions; details are beyond our scope.) To
compute cdef=Mont(x,y) without any expensive modular reductions do:
1. Letz:=x·y(over the integers).
2. Setc/prime:= (z+[zαmodR]·N)/R.
3. Ifc/prime< Nthen set c:=c/prime; else set c:=c/prime−N.
To see that this works, we ﬁrst need to verify that step 2 is well-deﬁned,
namely, that the numerator is divisible by R. This follows because
z+[zαmodR]·N=z+zαN=z−zN−1N= 0 mod R.
Next, note that c/prime=z/RmodNafter step 2; moreover, since z < N2< RN
we have 0 < c/prime<(z+RN)/R <2RN/R= 2N. But then [ c/primemodN] =c/primeif
c/prime< N, and [c/primemodN] =c/prime−Nifc/prime> N. We conclude that
c= [c/primemodN] = [z/RmodN] = [xyR−1modN],
as desired.Basic Algorithmic Number Theory 557
B.2.5 Choosing a Uniform Group Element
For cryptographic applications, it is often necessary to choose a uniform
element of a group G. We ﬁrst treat the problem in an abstract setting, and
then focus speciﬁcally on the cases of ZNandZ∗
N.
Note that if Gis a cyclic group of order q, and a generator g∈Gis known,
then choosing a uniform element h∈Greduces to choosing a uniform integer
x∈Zqand setting h:=gx. In what follows we make no assumptions on G.
Elements of a group Gmust be speciﬁed using some representation of these
elements as bit-strings, where we assume without any real loss of generality
that all elements are represented using strings of the same length. (It is also
crucial that there is a uniquestring representing each group element.) For
example, if/bardblN/bardbl=nthen elements of ZNcan all be represented as strings of
lengthn, where the integer a∈ZNis padded to the left with 0s if /bardbla/bardbl< n.
We do not focus much on the issue of representation, since for all the groups
considered in this text the representation can simply be taken to be the “nat-
ural” one (as in the case of ZN, above). Note, however, that diﬀerent repre-
sentations of the same group can aﬀect the complexity of performing various
computations, and so choosing the “right” representation for a given group is
often important in practice. Since our goal is only to show polynomial-time
algorithms for each of the operations we need (and not to show the most ef-
ﬁcient algorithms known), the exact representation used is less important for
our purposes. Moreover, most of the “higher-level” algorithms we present use
the group operation in a “black-box” manner, so that as long as the group
operation can be performed in polynomial time (in some parameter), the re-
sulting algorithm will run in polynomial time as well.
Given a group Gwhere elements are represented by strings of length /lscript,
a uniform group element can be selected by choosing uniform /lscript-bit strings
until the ﬁrst string that corresponds to a group element is found. (Note this
assumes that testing group membership can be done eﬃciently.) To obtain an
algorithm with bounded running time, we introduce a parameter tbounding
the maximum number of times this process is repeated; if all titerations fail
to ﬁnd an element of G, then the algorithm outputs fail. (An alternative is to
output an arbitrary element of G.) That is:
ALGORITHM B.14
Choosing a uniform group element
Input:A (description of a) group G; length-parameter /lscript;
parameter t
Output: A uniform element of G
fori= 1 tot:
Choose uniform x∈{0,1}/lscript
ifx∈Greturnx
return“fail”558 Introduction to Modern Cryptography
Itisclearthat wheneverthe abovealgorithmdoes notoutputfail, it outputs
a uniformly distributed element of G. This is simply because each element of
Gis equally likely to be chosen in any iteration. Formally, if we let Failbe
the event that the algorithm outputs fail, then for any element g∈Gwe have
Pr/bracketleftBig
output of the algorithm equals g|Fail/bracketrightBig
=1
|G|.
What is the probability that the algorithm outputs fail? In any iteration
the probability that x∈Gis exactly|G|/2/lscript, and so the probability that x
doesnotlie inGin any of the titerations is
/parenleftbigg
1−|G|
2/lscript/parenrightbiggt
. (B.1)
There is a trade-oﬀbetween the running time ofAlgorithmB.14and the prob-
ability that the algorithm outputs fail: increasing tdecreases the probability
of failure but increases the worst-case running time. For cryptographic appli-
cations we need an algorithm where the worst-caserunning time is polynomial
in the security parameter n, while the failure probability is negligible in n.
LetKdef= 2/lscript/|G|. If we set t:=K·nthen the probability that the algorithm
outputsfailis:
/parenleftbigg
1−1
K/parenrightbiggK·n
=/parenleftBigg/parenleftbigg
1−1
K/parenrightbiggK/parenrightBiggn
≤/parenleftbig
e−1/parenrightbign=e−n,
usingPropositionA.2. Thus,if K=poly(n)(weassumesomegroup-generation
algorithm that depends on the security parameter n, and so both|G|and/lscript
are functions of n), we obtain an algorithm with the desired properties.
The case of ZN.Consider the group ZN, withn=/bardblN/bardbl. Checking whether
ann-bit string x(interpreted as a positive integer of length at most n) is an
element of ZNsimply requires checking whether x < N. Furthermore,
2n
|ZN|=2n
N≤2n
2n−1=2,
and sowe cansampleauniformelement of ZNinpoly(n) time andwith failure
probability negligible in n.
The case of Z∗
N.Consider next the group Z∗
N, withn=/bardblN/bardblas before.
Determining whether an n-bit string xis an element of Z∗
Nis also easy (see
the exercises). Moreover,
2n
|Z∗
N|=2n
φ(N)=2n
N·N
φ(N)≤2·N
φ(N).
Apoly(n) upper-bound is a consequence of the following theorem.Basic Algorithmic Number Theory 559
THEOREM B.15 ForN≥3of length n, we haveN
φ(N)<2n.
(Stronger bounds are known, but the above suﬃces for our purpose.) The
theorem can be proved using Bertrand’s Postulate (Theorem 8.32), but we
content ourselves with a proof in two special cases: when Nis prime and
whenNis a product of two equal-length (distinct) primes.
The analysis is easy when Nis an odd prime. Here φ(N) =N−1 and so
N
φ(N)≤2n
φ(N)=2n
N−1≤2n
2n−1=2
(using the fact that Nis odd for the second inequality). Consider next the
case ofN=pqforpandqdistinct, odd primes. Then
N
φ(N)=pq
(p−1)(q−1)=p
p−1·q
q−1</parenleftbigg3
2/parenrightbigg
·/parenleftbigg5
4/parenrightbigg
<2.
Weconclude that when Nis prime or the product of two distinct, odd primes,
there is an algorithm for generatinga uniform element of Z∗
Nthat runs in time
polynomial in n=/bardblN/bardbland outputs failwith probability negligible in n.
Throughout this book, when we speak of sampling a uniform element of
ZNorZ∗
Nwe simply ignore the negligible probability of outputting failwith
the understanding that this has no signiﬁcant eﬀect on the analysis.
B.3 *Finding a Generator of a Cyclic Group
Inthis section we address the problem of ﬁnding a generatorof an arbitrary
cyclic group Goforderq. Here,qdoes not necessarilydenote a prime number;
indeed, ﬁnding a generator when qis prime is trivial by Corollary 8.55.
We actually show how to sample a uniform generator, proceeding in a
manner very similar to that of Section B.2.5. Here, we repeatedly sample
uniform elements of Guntil we ﬁnd an element that is a generator. As in
Section B.2.5, an analysis of this method requires understanding two things:
•How to eﬃciently test whether a given element is a generator; and
•the fraction of group elements that are generators.
In order to understand these issues, we ﬁrst develop a bit of additional group-
theoretic background.
B.3.1 Group-Theoretic Background
We tackle the second issue ﬁrst. Recall that the order of an element his
the smallest positive integer ifor which hi= 1. Let gbe a generator of a560 Introduction to Modern Cryptography
groupGof order q >1; this means the order of gisq. Consider an element
h∈Gthat is not the identity (the identity cannot be a generator of G), and
let us ask whether hmight also be a generator of G. Sinceggenerates G, we
can write h=gxfor some x∈{1,...,q−1}(notex/negationslash= 0 since his not the
identity). Consider two cases:
Case 1: gcd(x,q) =r >1. Write x=α·randq=β·rwithα,βnon-zero
integers less than q. Then:
hβ= (gx)β=gαrβ= (gq)α= 1.
So the order of his at most β < q, andhcannot be a generator of G.
Case 2: gcd(x,q) = 1. Let i≤qbe the order of h. Then
g0= 1 =hi= (gx)i=gxi,
implying xi= 0 mod qby Proposition 8.53. This means that q|xi. Since
gcd(x,q) = 1, however, Proposition 8.3 shows that q|iand soi=q. We
conclude that his a generator of G.
Summarizing the above, we see that for x∈ {1,...,q−1}the element
h=gxis a generator of Gexactly when gcd( x,q) = 1. We have thus proved
the following:
THEOREM B.16 LetGbe a cyclic group of order q >1with generator g.
There are φ(q)generators of G, and these are exactly given by {gx|x∈Z∗
q}.
In particular, if Gis a group of prime order q, then it has φ(q) =q−1
generators—exactly in agreement with Corollary 8.55.
We turn next to the ﬁrst issue, that of deciding whether a given element
his a generator of G. Of course, one way to check whether hgenerates G
is to enumerate{h0,h1,...,hq−1}and see whether this list includes every
element of G. This requires time linear in q(i.e., exponential in /bardblq/bardbl) and
is therefore unacceptable for our purposes. Another approach, if we already
know a generator g, is to compute the discrete logarithm x= logghand then
apply the previous theorem; in general, however, we may not have such a g,
and anyway computing the discrete logarithm may itself be a hard problem.
If we know the factorization of q, we can do better.
PROPOSITION B.17 LetGbe a group of order q, and let q=/producttextk
i=1pei
i
be the prime factorization of q, where the{pi}are distinct primes and ei≥1.
Setqi=q/pi. Thenh∈Gis a generator of Gif and only if
hqi/negationslash= 1fori= 1,...,k.Basic Algorithmic Number Theory 561
PROOF One direction is easy. Say hqi= 1 for some i. Then the order of
his at most qi< q, and so hcannot be a generator.
Conversely, say his not a generator but instead has order q/prime< q. By
Proposition 8.54, we know q/prime|q. This implies that q/primecan be written as q/prime=/producttextk
i=1pe/prime
i
i, wheree/prime
i≥0 and for at least one index jwe have e/prime
j< ej. But
thenq/primedividesqj=pej−1
j·/producttext
i/negationslash=jpei
i, and so (using Proposition 8.53) hqj=
h[qjmodq/prime]=h0= 1.
The proposition does not require Gtobe cyclic; if Gis not cyclic then every
elementh∈Gwill satisfy hqi= 1 for some iand there are no generators.
B.3.2 Eﬃcient Algorithms
Armed with the results of the previous section, we show how to eﬃciently
testwhether a given element is a generator, as well as how to eﬃciently ﬁnd
a generator in an arbitrary group.
Testing if an element is a generator. Proposition B.17 immediately
suggests an eﬃcient algorithm for deciding whether a given element his a
generator or not.
ALGORITHM B.18
Testing whether an element is a generator
Input:Group order q; prime factors{pi}k
i=1ofq; element h∈G
Output: A decision as to whether his a generator of G
fori= 1 tok:
ifhq/pi= 1return“his not a generator”
return“his a generator”
Correctness of the algorithm is evident from Proposition B.17. We now
show that the algorithm terminates in time polynomial in /bardblq/bardbl. Since, in each
iteration, hq/pican be computed in polynomial time, we need only show that
the number of iterations kis polynomial. This is the case since an integer q
can have no more than log2q=O(/bardblq/bardbl) prime factors; this is because
q=k/productdisplay
i=1pei
i≥k/productdisplay
i=1pi≥k/productdisplay
i=12 = 2k
and sok≤log2q.
Algorithm B.18 requires the prime factors of the group order qto be pro-
vided as input. Interestingly, there is no known eﬃcient algorithm for testing
whether an element of an arbitrary group is a generator when the factors of
the group order are notknown.562 Introduction to Modern Cryptography
The fraction of elements that are generators. As shown in Theo-
rem B.16, the fraction of elements of a group Gof orderqthat are generators
isφ(q)/q. Theorem B.15 says that φ(q)/q= Ω(1//bardblq/bardbl). The fraction of ele-
ments that are generators is thus suﬃciently high to ensure that sampling a
polynomial number of elements from the group will yield a generator with all
but negligible probability. (The analysis is the same as in Section B.2.5.)
Concrete examples in Z∗
p.Putting everything together, we see there is
an eﬃcient probabilistic algorithm for ﬁnding a generator of a group Gas
long as the factorization of the group order is known . When selecting a group
for cryptographic applications, it is therefore important that the group is
chosen in such a way that this holds. This explains again the preference,
discussed extensively in Section 8.3.2, for working in an appropriate prime-
order subgroup of Z∗
p. Another possibility is to use G=Z∗
pforpa strong
prime (i.e., p= 2q+1with qalsoprime), in which casethe prime factorization
of the group order p−1 is known. One ﬁnal possibility is to generate a prime
pin such a way that the factorization of p−1 is known. Further details are
beyond the scope of this book.
References and Additional Reading
ThebookbyShoup[159]ishighlyrecommendedforthoseseekingtoexplore
the topics of this chapter in further detail. In particular, bounds on φ(N)/N
(andanasymptoticversionofTheoremB.15)canbefoundin[159, Chapter5].
Hankerson et al. [83] also provide extensive detail on the implementation of
number-theoretic algorithms for cryptography.
Exercises
B.1Prove correctness of the extended Euclidean algorithm.
B.2 Prove that the extended Euclidean algorithm runs in time polynomial
in the lengths of its inputs.
Hint:First prove a proposition analogous to Proposition B.8.
B.3 Show how to determine that an n-bit string is in Z∗
Nin polynomial time.References
[1]M. Abdalla, J.H. An, M. Bellare, and C. Namprempre. From iden-
tiﬁcation to signatures via the Fiat-Shamir transform: Necessary and
suﬃcient conditions for security and forward-security. IEEE Trans. In-
formation Theory , 54(8):3631–3646, 2008.
[2] M. Abdalla, M. Bellare, and P. Rogaway. The oracle Diﬃe-Hellman
assumptions and an analysis of DHIES. In Cryptographers’ Track—
RSA 2001 , volume 2020 of LNCS, pages 143–158. Springer, 2001. See
http://cseweb.ucsd.edu/ ∼mihir/papers/dhies.html .
[3] C. Adams and S. Lloyd. Understanding PKI: Concepts, Standards, and
Deployment Considerations . Addison Wesley, 2nd edition, 2002.
[4] L.M. Adleman. A subexponential algorithm for the discrete logarithm
problem with applications to cryptography. In 20th Annual Symposium
on Foundations of Computer Science , pages 55–60. IEEE, 1979.
[5] M. Agrawal, N. Kayal, and N. Saxena. PRIMES is in P. Annals of
Mathematics , 160(2):781–793, 2004.
[6] W. Aiello, M. Bellare, G. Di Crescenzo, and R. Venkatesan. Security
ampliﬁcationbycomposition: Thecaseofdoubly-iterated, idealciphers.
InAdvances in Cryptology—Crypto ’98 , volume 1462 of LNCS, pages
390–407. Springer, 1998.
[7] A. Akavia, S. Goldwasser, and S. Safra. Proving hard-core predicates
using list decoding. In Proc. 44th Annual Symposium on Foundations
of Computer Science , pages 146–157. IEEE, 2003.
[8] W. Alexi, B. Chor, O. Goldreich, and C.P. Schnorr. RSA and Rabin
functions: Certain parts are as hard as the whole. SIAM Journal on
Computing , 17(2):194–209, 1988.
[9] N.J. AlFardan, D.J. Bernstein, K.G. Paterson, B. Poettering, and
J.C.N. Schuldt. On the security of RC4 in TLS and WPA. In USENIX
Security Symposium , 2013.
[10] J.H. An, Y. Dodis, and T. Rabin. On the security of joint signature and
encryption. In Advances in Cryptology—Eurocrypt 2002 , volume 2332
ofLNCS, pages 83–107. Springer, 2002.
563564 Introduction to Modern Cryptography
[11] R. Barbulescu, P. Gaudry, A. Joux, and E. Thom´ e. A heuristic quasi-
polynomial algorithm for discrete logarithm in ﬁnite ﬁelds of small char-
acteristic. In Advances in Cryptology—Eurocrypt 2014 , volume 8441 of
LNCS, pages 1–16. Springer, 2014.
[12] R. Bardou, R. Focardi, Y. Kawamoto, L. Simionato, G. Steel, and J.-
K. Tsay. Eﬃcient padding oracle attacks on cryptographic hardware.
InAdvances in Cryptology—Crypto 2012 , volume 7417 of LNCS, pages
608–625. Springer, 2012.
[13] E. Barker, W. Barker, W. Burr, W. Polk, and M. Smid. Recommen-
dation for key management—part 1: General (revision 3), July 2012.
NIST Special Publication 800-57.
[14] M. Bellare, R. Canetti, and H. Krawczyk. Keying hash functions for
messageauthentication. In Advances in Cryptology—Crypto ’96 , volume
1109 ofLNCS, pages 1–15. Springer, 1996.
[15] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A concrete security
treatment of symmetric encryption. In Proc. 38th Annual Symposium
on Foundations of Computer Science , pages 394–403. IEEE, 1997.
[16] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among
notions of security for public-key encryption schemes. In Advances in
Cryptology—Crypto ’98 , volume 1462 of LNCS, pages 26–45. Springer,
1998.
[17] M. Bellare, O. Goldreich, and A. Mityagin. The power of veriﬁcation
queries in message authentication and authenticated encryption. Avail-
able athttp://eprint.iacr.org/2004/309 .
[18] M. Bellare, J. Kilian, and P. Rogaway. The security of the cipher block
chaining messageauthentication code. Journal of Computer and System
Sciences, 61(3):362–399, 2000.
[19] M. Bellare and C. Namprempre. Authenticated encryption: Relations
among notions and analysis of the generic composition paradigm. In
Advances in Cryptology—Asiacrypt 2000 , volume 1976 of LNCS, pages
531–545. Springer, 2000.
[20] M. BellareandG. Neven. Multi-signaturesinthe plainpublic-keymodel
and a general forking lemma. In 13th ACM Conf. on Computer and
Communications Security , pages 390–399. ACM Press, 2006.
[21] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm
for designing eﬃcient protocols. In 1st ACM Conf. on Computer and
Communications Security , pages 62–73. ACM, 1993.References 565
[22] M. Bellare and P. Rogaway. Optimal asymmetric encryption. In Ad-
vances in Cryptology—Eurocrypt ’94 , volume 950 of LNCS, pages 92–
111. Springer, 1994.
[23] M. Bellare and P. Rogaway. The exact security of digital signatures:
How to sign with RSA and Rabin. In Advances in Cryptology—
Eurocrypt ’96 , volume 1070 of LNCS, pages 399–416. Springer, 1996.
[24] M. Bellare and P. Rogaway. The security of triple encryption
and a framework for code-based game-playing proofs. In Advances
in Cryptology—Eurocrypt 2006 , volume 4004 of LNCS, pages 409–
426. Springer, 2006. A full version of the paper is available at
http://eprint.iacr.org .
[25] S.M. Bellovin. Frank Miller: Inventor of the one-time pad. Cryptologia ,
35(3):203–222, 2011.
[26] D.J. Bernstein. A short proof of the unpredictability of cipher block
chaining. Available at http://cr.yp.to/papers.html#easycbc .
[27] D.J. Bernstein. How to stretch random functions: The security of pro-
tected counter sums. Journal of Cryptology , 12(3):185–192, 1999.
[28] G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche. On the indif-
ferentiability of the sponge construction. In Advances in Cryptology—
Eurocrypt 2008 , volume 4965 of LNCS, pages 181–197. Springer, 2008.
[29] E. Biham and A. Shamir. Diﬀerential cryptanalysis of DES-like cryp-
tosystems. Journal of Cryptology , 4(1):3–72, 1991.
[30] E. Biham and A. Shamir. Diﬀerential Cryptanalysis of the Data En-
cryption Standard . Springer, 1993.
[31] A. Biryukov and A. Shamir. Structural cryptanalysis of SASAS. J.
Cryptology , 23(4):505–518, 2010.
[32] J. Black and P. Rogaway. CBC MACs for arbitrary-length messages:
The three-key constructions. Journal of Cryptology , 18(2):111–131,
2005.
[33] J. Black, P. Rogaway, T. Shrimpton, and M. Stam. An analysis of the
blockcipher-based hash functions from PGV. J. Cryptology , 23(4):519–
545, 2010.
[34] D. Bleichenbacher. Chosen ciphertext attacks against protocols based
onthe RSAencryptionstandardPKCS#1. In Advances in Cryptology—
Crypto ’98 , volume 1462 of Lecture Notes in Computer Science , pages
1–12. Springer, 1998.566 Introduction to Modern Cryptography
[35] M. Blum. Coin ﬂippingbytelephone. In Proc. IEEE COMPCOM , pages
133–137, 1982.
[36] M. Blum and S. Goldwasser. An eﬃcient probabilistic public-key en-
cryption scheme which hides all partial information. In Advances in
Cryptology—Crypto ’84 , volume 196 of Lecture Notes in Computer Sci-
ence, pages 289–302. Springer, 1985.
[37] M. Blum and S. Micali. How to generate cryptographically strong
sequences of pseudo-random bits. SIAM Journal on Computing ,
13(4):850–864, 1984.
[38] D. Boneh. Twenty years of attacks on the RSA cryptosystem. Notices
of the American Mathematical Society , 46(2):203–213, 1999.
[39] D. Boneh. Simpliﬁed OAEP for the RSA and Rabin functions. In
Advances in Cryptology—Crypto 2001 , volume 2139 of LNCS, pages
275–291. Springer, 2001.
[40] D. Boneh, A. Joux, and P.Q. Nguyen. Why textbook ElGamal and RSA
encryption are insecure. In Advances in Cryptology—Asiacrypt 2000 ,
volume 1976 of LNCS, pages 30–43. Springer, 2000.
[41] R. Canetti, O. Goldreich, and S. Halevi. The random oracle methodol-
ogy, revisited. Journal of the ACM , 51(4):557–594, 2004.
[42] L. Carter and M.N. Wegman. Universal classes of hash functions. J.
Computer and System Sciences , 18(2):143–154, 1979.
[43] D. Chaum, E. van Heijst, and B. Pﬁtzmann. Cryptographically strong
undeniable signatures, unconditionally secure for the signer. In Ad-
vances in Cryptology—Crypto ’91 , volume 576 of LNCS, pages 470–484.
Springer, 1992.
[44] L.N. Childs. A Concrete Introduction to Higher Algebra . Undergraduate
Texts in Mathematics. Springer, 2nd edition, 2000.
[45] D. Coppersmith. TheDataEncryptionStandard(DES) anditsstrength
against attacks. IBM Journal of Research and Development , 38(3):243–
250, 1994.
[46] D. Coppersmith. Small solutions to polynomial equations, and low ex-
ponent RSA vulnerabilities. Journal of Cryptology , 10(4):233–260,1997.
[47] D. Coppersmith, M.K. Franklin, J. Patarin, and M.K. Reiter. Low-
exponent RSA with related messages. In Advances in Cryptology—
Eurocrypt ’96 , volume 1070 of LNCS, pages 1–9. Springer, 1996.References 567
[48] J.-S.Coron,Y.Dodis, C.Malinaud, andP.Puniya. Merkle-Damg˚ ardre-
visited: How to construct a hash function. In Advances in Cryptology—
Crypto 2005 , volume 3621 of LNCS, pages 430–448. Springer, 2005.
[49] J.-S. Coron, M. Joye, D. Naccache, and P. Paillier. New attacks on
PKCS #1 v1.5 encryption. In Advances in Cryptology—Eurocrypt 2000 ,
volume 1807 of LNCS, pages 369–381. Springer, 2000.
[50] R. Cramer and V. Shoup. Design and analysis of practical public-key
encryption schemes secure against adaptive chosen ciphertext attack.
SIAM Journal on Computing , 33(1):167–226, 2003.
[51] R. Crandall and C. Pomerance. Prime Numbers: A Computational
Perspective . Springer, 2nd edition, 2005.
[52] I. Damg˚ ard. Collision free hash functions and public key signature
schemes. In Advances in Cryptology—Eurocrypt ’87 , volume 304 of
LNCS, pages 203–216. Springer, 1988.
[53] I. Damg˚ ard. A design principle for hash functions. In Advances in
Cryptology—Crypto ’89 , volume 435 of LNCS, pages 416–427. Springer,
1990.
[54] J.P. Degabriele and K.G. Paterson. On the (in)security of IPsec in
MAC-then-encrypt conﬁgurations. In 17th ACM Conf. on Computer
and Communications Security , pages 493–504. ACM Press, 2010.
[55] J. DeLaurentis. A further weakness in the common modulus protocol
for the RSA cryptoalgorithm. Cryptologia , 8:253–259, 1984.
[56] G.DiCrescenzo,J.Katz,R.Ostrovsky,andA.Smith. Eﬃcientandnon-
interactive non-malleable commitment. In Advances in Cryptology—
Eurocrypt 2001 , volume 2045 of LNCS, pages 40–59. Springer, 2001.
[57] M. Dietzfelbinger. Primality Testing in Polynomial Time . Springer,
2004.
[58] W. Diﬃe and M. Hellman. New directions in cryptography. IEEE
Transactions on Information Theory , 22(6):644–654, 1976.
[59] W. Diﬃe and M. Hellman. Exhaustive cryptanalysis of the NBS data
encryption standard. Computer , pages 74–84, June 1977.
[60] J.D. Dixon. Asymptotically fast factorization of integers. Mathematics
of Computation , 36:255–260, 1981.
[61] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography. SIAM
J. Computing , 30(2):391–437, 2000. Preliminary version in STOC ’91.568 Introduction to Modern Cryptography
[62] C. Ellisonand B. Schneier. Ten risksofPKI: What you’renot being told
about public key infrastructure. Computer Security Journal , 16(1):1–7,
2000.
[63] S. Even and Y. Mansour. A construction of a cipher from a single
pseudorandom permutation. J. Cryptology , 10(3):151–162, 1997.
[64] H. Feistel. Cryptography and computer privacy. Scientiﬁc American ,
228(5):15–23, 1973.
[65] A. Fiat and A. Shamir. How to prove yourself: Practical solutions
to identiﬁcation and signature problems. In Advances in Cryptology—
Crypto ’86 , volume 263 of LNCS, pages 186–194. Springer, 1987.
[66] R. Fischlin and C.-P. Schnorr. Stronger security proofs for RSA and
Rabin bits. Journal of Cryptology , 13(2):221–244, 2000.
[67] J.B. Fraleigh. A First Course in Abstract Algebra . Addison Wesley, 7th
edition, 2002.
[68] E. Fujisaki, T. Okamoto, D. Pointcheval, and J. Stern. RSA-OAEP is
secure under the RSA assumption. Journal of Cryptology , 17(2):81–104,
2004.
[69] S.D. Galbraith. The Mathematics of Public Key Cryptography . Cam-
bridge University Press, 2012.
[70] T. El Gamal. A public-key cryptosystem and a signature scheme based
on discrete logarithms. IEEE Trans. Info. Theory , 31(4):469–472, 1985.
[71] C.F. Gauss. Disquisitiones Arithmeticae . Springer, 1986. (English edi-
tion).
[72] R. Gennaro, Y. Gertner, and J. Katz. Lower bounds on the eﬃciency of
encryption and digital signature schemes. In 35th Annual ACM Sym-
posium on Theory of Computing , pages 417–425. ACM Press, 2003.
[73] E.N. Gilbert, F.J. MacWilliams, and N.J.A. Sloane. Codes which detect
deception. Bell Systems Technical Journal , 53(3):405–424, 1974.
[74] O. Goldreich. Two remarks concerning the Goldwasser-Micali-Rivest
signature scheme. In Advances in Cryptology—Crypto ’86 , volume 263
ofLNCS, pages 104–110. Springer, 1987.
[75] O. Goldreich. Foundations of Cryptography, vol. 1: Basic Tools . Cam-
bridge University Press, 2001.
[76] O. Goldreich. Foundations of Cryptography, vol. 2: Basic Applications .
Cambridge University Press, 2004.References 569
[77] O. Goldreich, S. Goldwasser, and S. Micali. On the cryptographic ap-
plications of random functions. In Advances in Cryptology—Crypto ’84 ,
volume 196 of LNCS, pages 276–288. Springer, 1985.
[78] O. Goldreich, S. Goldwasser, and S. Micali. How to construct random
functions. Journal of the ACM , 33(4):792–807, 1986.
[79] O. Goldreich and L.A. Levin. A hard-core predicate for all one-way
functions. In 21st Annual ACM Symposium on Theory of Computing ,
pages 25–32. ACM Press, 1989.
[80] S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Com-
puter and System Sciences , 28(2):270–299, 1984.
[81] S. Goldwasser, S. Micali, and R. Rivest. A digital signature scheme
secure against adaptive chosen-message attacks. SIAM J. Computing ,
17(2):281–308, 1988.
[82] S. Goldwasser, S. Micali, and A.C.-C. Yao. Strong signature schemes.
InProc. 15th Annual ACM Symposium on Theory of Computing , pages
431–439. ACM, 1983.
[83] D.Hankerson,A.J.Menezes,andS.A.Vanstone. Guide to Elliptic Curve
Cryptography . Springer, 2004.
[84] J. H˚ astad. Solvingsimultaneousmodularequationsoflowdegree. SIAM
Journal on Computing , 17(2):336–341, 1988.
[85] J. H˚ astad, R. Impagliazzo, L. Levin, and M. Luby. A pseudorandom
generator from any one-way function. SIAM Journal on Computing ,
28(4):1364–1396, 1999.
[86] J. H˚ astad and M. N¨ aslund. The security of all RSA and discrete log
bits.Journal of the ACM , 51(2):187–230, 2004.
[87] M. Hellman. A cryptanalytic time-memory trade-oﬀ. IEEE Trans. In-
formation Theory , 26(4):401–406, 1980.
[88] N. Heninger, Z. Durumeric, E. Wustrow, and J.A. Halderman. Mining
your Ps and Qs: Detection of widespread weak keys in network devices.
InProc. 21st USENIX Security Symposium , 2012.
[89] I.N. Herstein. Abstract Algebra . Wiley, 3rd edition, 1996.
[90] H.M. Heys. The Design of Substitution-Permutation Network Ciphers
Resistant to Cryptanalysis . PhD thesis, Queen’s University, 1994.
[91] H.M. Heys. A tutorial on linear and diﬀerential cryptanal-
ysis. Cryptologia , 26(3):189–221, 2002. Also available at
http://www.engr.mun.ca/ ∼howard/Research/Papers/ .570 Introduction to Modern Cryptography
[92] D. Hofheinz and E. Kiltz. Practical chosen ciphertext secure encryption
from factoring. In Advances in Cryptology—Eurocrypt 2009 , volume
5479 ofLNCS, pages 313–332. Springer, 2009.
[93] R. Impagliazzo and M. Luby. One-way functions are essential for
complexity-based cryptography. In 30th Annual Symposium on Foun-
dations of Computer Science , pages 230–235. IEEE, 1989.
[94] ISO/IEC 9797. Data cryptographic techniques—data integrity mech-
anism using a cryptographic check function employing a block cipher
algorithm, 1989.
[95] T. Iwata and K. Kurosawa. OMAC: One-key CBC MAC. In Fast
Software Encryption—FSE 2003 , volume 2887 of LNCS, pages 129–153.
Springer, 2003.
[96] A.Joux. Algorithmic Cryptanalysis . Chapman&Hall/CRCPress,2009.
[97] D.Kahn. The Codebreakers: The Comprehensive History of SecretCom-
munication from Ancient Times to the Internet . Scribner, 1996.
[98] J. Katz. Digital Signatures . Springer, 2010.
[99] J. Katz and C.-Y. Koo. On constructing universal one-way hash func-
tions from arbitrary one-way functions. J. Cryptology , to appear. Avail-
able athttp://eprint.iacr.org/2005/328 .
[100] J. Katz and M. Yung. Unforgeable encryption and chosen ciphertext
secure modes of operation. In Fast Software Encryption—FSE 2000 ,
volume 1978 of LNCS, pages 284–299. Springer, 2000.
[101] J.KatzandM.Yung. Characterizationofsecuritynotionsforprobabilis-
tic private-key encryption. Journal of Cryptology , 19(1):67–96, 2006.
[102] C. Kaufman, R. Perlman, and M. Speciner. Network Security: Private
Communication in a Public World . Prentice Hall, 2nd edition, 2002.
[103] A. Kerckhoﬀs. La cryptographie militaire. Journal des Sciences Mil-
itaires, IX:5–38, January 1883. A copy of the paper is available at
http://www.petitcolas.net/fabien/kerckhoffs .
[104] A. Kerckhoﬀs. La cryptographie militaire. Journal des Sciences Mili-
taires, IX:161–191, February 1883. A copy of the paper is available at
http://www.petitcolas.net/fabien/kerckhoffs .
[105] J. Kilian and P. Rogaway. How to protect DES against exhaustive key
search (an analysis of DESX). Journal of Cryptology , 14(1):17–35, 2001.
[106] L. Knudsen and M.J.B. Robshaw. The Block Cipher Companion .
Springer, 2011.References 571
[107] L.M. Kohnfelder. Towards a practical public-key cryptosystem, 1978.
Undergraduate thesis, MIT.
[108] H. Krawczyk. The order of encryption and authentication for protecting
communications (or: How secure is SSL?). In Advances in Cryptology—
Crypto 2001 , volume 2139 of LNCS, pages 310–331. Springer, 2001.
[109] H. Krawczyk. Cryptographicextraction and key derivation: The HKDF
scheme. In Advances in Cryptology—Crypto 2010 , volume 6223 of
LNCS, pages 631–648. Springer, 2010.
[110] T.KrovetzandP.Rogaway. Thesoftwareperformanceofauthenticated-
encryption modes. In Fast Software Encryption—FSE 2011 , volume
6733 ofLNCS, pages 306–327. Springer, 2011.
[111] L. Lamport. Constructing digital signatures from a one-way function.
Technical Report CSL-98, SRI International, 1978.
[112] A.K. Lenstra, J.P. Hughes, M. Augier, J.W. Bos, T. Kleinjung, and
C. Wachter. Public keys. In Advances in Cryptology—Crypto 2012 ,
volume 7417 of LNCS, pages 626–642. Springer, 2012.
[113] A.K. Lenstra and E.R. Verheul. Selecting cryptographickey sizes. Jour-
nal of Cryptology , 14(4):255–293, 2001.
[114] S. Levy. Crypto: How the Code Rebels Beat the Government—Saving
Privacy in the Digital Age . Viking, 2001.
[115] M. Luby. Pseudorandomness and Cryptographic Applications . Princeton
University Press, 1996.
[116] M. Luby and C. Rackoﬀ. How to construct pseudorandom permuta-
tions from pseudorandom functions. SIAM J. Computing , 17(2):373–
386, 1988.
[117] J. Manger. A chosen ciphertext attack on RSA optimal asymmetric
encryption padding (OAEP) as standardized in PKCS #1 v2.0. In
Advances in Cryptology—Crypto 2001 , volume 2139 of LNCS, pages
230–238. Springer, 2001.
[118] M. Matsui. Linear cryptoanalysis method for DES cipher. In Advances
in Cryptology—Eurocrypt ’93 , volume 765 of LNCS, pages 386–397.
Springer, 1993.
[119] A. May. New RSA Vulnerabilities Using Lattice Reduction Methods .
PhD thesis, University of Paderborn, 2003.
[120] A.J. Menezes, P.C. van Oorschot, and S.A. Vanstone. Handbook of
Applied Cryptography . CRS Press, 1997.572 Introduction to Modern Cryptography
[121] R.C. Merkle. A digital signature based on a conventional encryption
function. In Advances in Cryptology—Crypto ’87 , volume 293 of LNCS,
pages 369–378. Springer, 1988.
[122] R.C. Merkle. A certiﬁed digital signature. In Advances in Cryptology—
Crypto ’89 , volume 435 of LNCS, pages 218–238. Springer, 1990.
[123] R.C. Merkle. One way hash functions and DES. In Advances in
Cryptology—Crypto ’89 , volume 435 of LNCS, pages 428–446. Springer,
1990.
[124] R.C. Merkle and M. Hellman. On the security of multiple encryption.
Communications of the ACM , 24(7):465–467, 1981.
[125] S. Micali, C. Rackoﬀ, and B. Sloan. The notion of security for proba-
bilistic cryptosystems. SIAM J. Computing , 17(2):412–426, 1988.
[126] E. Miles and E. Viola. Substitution-permutation networks, pseudo-
random functions, and natural proofs. In Advances in Cryptology—
Crypto 2012 , volume 7417 of LNCS, pages 68–85. Springer, 2012.
[127] G.L. Miller. Riemann’s hypothesis and tests for primality. Journal of
Computer and System Sciences , 13(3):300–317, 1976.
[128] M. Naor and M. Yung. Universal one-way hash functions and their
cryptographic applications. In Proc. 21st Annual ACM Symposium on
Theory of Computing , pages 33–43. ACM, 1989.
[129] M. Naor and M. Yung. Public-key cryptosystems provably secure
against chosen ciphertext attacks. In 22nd Annual ACM Symposium
on Theory of Computing , pages 427–437. ACM Press, 1990.
[130] National Bureau of Standards. Federal information processing standard
publication 81: DES modes of operation, 1980.
[131] National Institute of Standards and Technology. Federal information
processingstandardpublication 198-1: Thekeyed-hashmessageauthen-
tication code (HMAC), July 2008.
[132] National Institute of Standards and Technology. Federal informa-
tion processing standards publication 186-4: Digital signature standard
(DSS), July 2013.
[133] V.I. Nechaev. Complexity of a determinate algorithm for the discrete
logarithm. Mathematical Notes , 55(2):165–172, 1994.
[134] P. Oechslin. Making a faster cryptanalytic time-memory trade-oﬀ. In
Advances in Cryptology—Crypto 2003 , volume 2729 of LNCS, pages
617–630. Springer, 2003.References 573
[135] C. Paar and J. Pelzl. Understanding Cryptography . Springer, 2010.
[136] P. Paillier. Public-key cryptosystems based on composite degree resid-
uosity classes. In Advances in Cryptology—Eurocrypt ’99 , volume 1592
ofLNCS, pages 223–238. Springer, 1999.
[137] E. Petrank and C. Rackoﬀ. CBC MAC for real-time data sources. Jour-
nal of Cryptology , 13(3):315–338, 2000.
[138] S. Pohlig and M. Hellman. An improved algorithm for computing log-
arithms over GF( p) and its cryptographic signiﬁcance. IEEE Trans.
Information Theory , 24(1):106–110, 1978.
[139] J.M. Pollard. Theorems of factorization and primality testing. Proc.
Cambridge Philosophical Society , 76:521–528, 1974.
[140] J.M. Pollard. A Monte Carlo method for factorization. BIT Numerical
Mathematics , 15(3):331–334, 1975.
[141] J.M. Pollard. Monte Carlo methods for index computation (mod p).
Mathematics of Computation , 32(143):918–924, 1978.
[142] C. Pomerance. The quadratic sieve factoring algorithm. In Advances
in Cryptology—Eurocrypt ’84 , volume 209 of LNCS, pages 169–182.
Springer, 1985.
[143] B. Preneel, R. Govaerts, and J. Vandewalle. Hash functions based
on block ciphers: A synthetic approach. In Advances in Cryptology—
Crypto ’93 , volume 773 of LNCS, pages 368–378. Springer, 1994.
[144] M.O. Rabin. Digitalized signatures. In R.A. Demillo, D.P. Dobkin, A.K.
Jones, and R.J. Lipton, editors, Foundations of Security Computation ,
pages 155–168. Academic Press, 1978.
[145] M.O. Rabin. Digitalized signaturesasintractableas factorization. Tech-
nical Report TR-212, MIT/LCS, 1979.
[146] M.O. Rabin. Probabilistic algorithm for testing primality. Journal of
Number Theory , 12(1):128–138, 1980.
[147] C. Rackoﬀ and D.R. Simon. Non-interactive zero-knowledge proof of
knowledge and chosen ciphertext attack. In Advances in Cryptology—
Crypto ’91 , volume 576 of LNCS, pages 433–444. Springer, 1992.
[148] R. Rivest, A. Shamir, and L. Adleman. A method for obtaining digital
signatures and public-key cryptosystems. Communications of the ACM ,
21(2):120–126, 1978.
[149] P. Rogaway. The security of DESX. RSA Laboratories’ CryptoBytes ,
Summer 1996.574 Introduction to Modern Cryptography
[150] P. Rogaway and T. Shrimpton. Cryptographic hash-function ba-
sics: Deﬁnitions, implications, and separations for preimage resistance,
second-preimage resistance, and collision resistance. In Fast Software
Encryption—FSE 2004 , volume3017of LNCS, pages371–388.Springer,
2004.
[151] J. Rompel. One-way functions are necessary and suﬃcient for secure
signatures. In Proc. 22nd Annual ACM Symposium on Theory of Com-
puting, pages 387–394. ACM, 1990.
[152] C.-P. Schnorr. Eﬃcient identiﬁcation and signatures for smart cards.
InAdvances in Cryptology—Crypto ’89 , volume 435 of LNCS, pages
239–252. Springer, 1990.
[153] D. Shanks. Classnumber, a theoryoffactorization, and genera. In Proc.
Symposia in Pure Mathematics 20 , pages415–440.AmericanMathemat-
ical Society, 1971.
[154] C.E. Shannon. Communication theory of secrecy systems. Bell Systems
Technical Journal , 28(4):656–715, 1949.
[155] V. Shoup. Lower bounds for discrete logarithms and related problems.
InAdvances in Cryptology—Eurocrypt ’97 , volume 1233of LNCS, pages
256–266. Springer, 1997.
[156] V. Shoup. Why chosen ciphertext security matters. Techni-
cal Report RZ 3076, IBM Zurich, November 1998. Available at
http://shoup.net/papers/expo.pdf .
[157] V. Shoup. A proposal for an ISO standard for public key encryption,
2001. Available at http://eprint.iacr.org/201/112 .
[158] V. Shoup. OAEP reconsidered. Journal of Cryptology , 15(4):223–249,
2002.
[159] V. Shoup. A Computational Introduction to Number Theory and Alge-
bra. Cambridge University Press, 2nd edition, 2009. Also available at
http://www.shoup.net/ntb .
[160] J.H. Silverman and J. Tate. Rational Points on Elliptic Curves . Under-
graduate Texts in Mathematics. Springer, 1994.
[161] G. Simmons. A “weak” privacy protocol using the RSA crypto algo-
rithm.Cryptologia , 7:180–182, 1983.
[162] G. Simmons. A survey of information authentication. In G. Simmons,
editor,Contemporary Cryptology: The Science of Information Integrity ,
pages 379–419. IEEE Press, 1992.References 575
[163] S. Singh. The Code Book: The Science of Secrecy from Ancient Egypt
to Quantum Cryptography . Anchor Books, 2000.
[164] R. SolovayandV.Strassen. AfastMonte-Carlotestforprimality. SIAM
Journal on Computing , 6(1):84–85, 1977.
[165] W. Stallings. Network Security Essentials: Applications and Standards .
Prentice Hall, 5th edition, 2013.
[166] D.R. Stinson. Universal hashing and authentication codes. Designs,
Codes, and Cryptography , 4(4):369–380, 1994.
[167] D.R. Stinson. Cryptography: Theory and Practice . Chapman & Hall/
CRC Press, 1st edition, 1995.
[168] D.R. Stinson. Cryptography: Theory and Practice . Chapman & Hall/
CRC Press, 3rd edition, 2005.
[169] W. Trappe and L. Washington. Introduction to Cryptography with Cod-
ing Theory . Prentice Hall, 2nd edition, 2005.
[170] P.C. van OorschotandM.J. Wiener. Parallelcollisionsearchwith crypt-
analytic applications. Journal of Cryptology , 12(1):1–28, 1999.
[171] S. Vaudenay. Security ﬂaws induced by CBC padding—applications to
SSL, IPSEC, WTLS, .... In Advances in Cryptology—Eurocrypt 2002 ,
volume 2332 of LNCS, pages 534–546. Springer, 2002.
[172] G.S. Vernam. Cipher printing telegraph systems for secret wire and
radio telegraphic communications. Journal of the American Institute
for Electrical Engineers , 55:109–115, 1926.
[173] S.S.Wagstaﬀ,Jr. Cryptanalysis of Number Theoretic Ciphers . Chapman
& Hall/CRC Press, 2003.
[174] X. Wang, Y.L. Yin, and H. Yu. Finding collisions in the full SHA-1.
InAdvances in Cryptology—Crypto 2005 , volume 3621 of LNCS, pages
17–36. Springer, 2005.
[175] X. Wang and H. Yu. How to break MD5 and other hash functions. In
Advances in Cryptology—Eurocrypt 2005 , volume 3494 of LNCS, pages
19–35. Springer, 2005.
[176] L. Washington. Elliptic Curves: Number Theory and Cryptography .
Chapman & Hall/CRC Press, 2003.
[177] M.N. Wegman and L. Carter. New hash functions and their use in
authentication and set equality. J. Computer and System Sciences ,
22(3):265–279, 1981.576 Introduction to Modern Cryptography
[178] ANSI X9.9. American national standard for ﬁnancial institution mes-
sage authentication (wholesale), 1981.
[179] A.C.-C. Yao. Theory and applications of trapdoor functions. In 23rd
Annual Symposium on Foundations of Computer Science , pages 80–91.
IEEE, 1982.
[180] G. Yuval. How to swindle Rabin. Cryptologia , 3:187–189, 1979.Chapman & Hall/CRC
CRYPTOGRAPHY AND NETWORK SECURITY
INTRODUCTION TO 
 
MODERN 
CRYPTOGRAPHY
Second Edition
Jonathan Katz
Yehuda Lindell
INTRODUCTION TO 
 
MODERN CRYPTOGRAPHY
Second
Edition
Katz
Lindell
K16475
www.crcpress.com
Cryptography is ubiquitous and plays a key role in ensuring data secrecy and 
integrity as well as in securing computer systems more broadly. 
Introduction 
to Modern Cryptography
 provides a rigorous yet accessible treatment of this 
fascinating subject. 
The authors introduce the core principles of modern cryptography, with an 
emphasis on formal definitions, clear assumptions, and rigorous proofs of se
-
curity. The book begins by focusing on private-key cryptography, including an 
extensive treatment of private-key encryption, message authentication codes, 
and hash functions. The authors also present design principles for widely used 
stream ciphers and block ciphers including RC4, DES, and AES, plus they pro
-
vide provable constructions of stream ciphers and block ciphers from lower-
level primitives. The second half of the book covers public-key cryptography, 
beginning with a self-contained introduction to the number theory needed to 
understand the RSA, Diffie–Hellman, and El Gamal cryptosystems (and oth
-
ers), followed by a thorough treatment of several standardized public-key en
-
cryption and digital signature schemes. 
Integrating a more practical perspective without sacrificing rigor, this widely 
anticipated 
Second Edition
 offers improved treatment of
•
 
Stream ciphers and block ciphers, including modes of operation and 
design principles
•
 
Authenticated encryption and secure communication sessions
•
 
Hash functions, including hash-function applications and design 
principles 
•
 
Attacks on poorly implemented cryptography, including attacks on 
chained-CBC encryption, padding-oracle attacks, and timing attacks
•
 
The random-oracle model and its application to several standardized, 
widely used public-key encryption and signature schemes
•
 
Elliptic-curve cryptography and associated standards such as DSA/
ECDSA and DHIES/ECIES
Containing updated exercises and worked examples, 
Introduction to Modern 
Cryptography, Second Edition
 can serve as a textbook for undergraduate- or 
graduate-level courses in cryptography, a valuable reference for researchers 
and practitioners, or a general introduction suitable for self-study. 
Computer Science/Mathematics
K16475_cover.indd   1
10/3/14   9:48 AM