T/h.sc/e.sc J/o.sc/y.sc /o.sc/f.sc C/r.sc/y.sc/p.sc/t.sc/o.sc/g.sc/r.sc/a.sc/p.sc/h.sc/y.sc
Mike Rosulekhmike@joyofcryptography.com i
School of Electrical Engineering & Computer Science
Oregon State University, Corvallis, Oregon, USA
Draft of January 3, 2021>Preface
The Joy of Cryptography is an undergraduate textbook in cryptography. This book evolved
from lecture notes I developed for the /c.sc/s.sc427 course at Oregon State University (and before
that, /c.sc/s.sc473 at the University of Montana).
Yes, I know that the title is ridiculous. All of the serious titles were already taken. I
hope you understand that actual joy is not guaranteed.
What Is This Book About?
This book is about the fundamentals of provable security.
ISecurity: Cryptography is about controlling access to information. We break apart
the nebulous concept of “security” into more speci/f_ic goals: con/f_identiality, authen-
ticity, integrity.
IProvable: We can formally de/f_ine what it means to be secure, and then mathemat-
ically prove claims about security. One prominent theme in the book is the logic of
composing building blocks together in secure ways.
IFundamentals: This is an introductory book on the subject that covers the basics.
After completing this course, you will have a solid theoretical foundation that you
can apply to most real-world situations. You will also be equipped to study more
advanced topics in cryptography.
This book is not a handbook telling you which cryptographic algorithm to use in every
situation, nor a guide for securely implementing production-ready cryptographic libraries.
We do not discuss speci/f_ic cryptographic software ( e.g., PGP, Tor, Signal, TrueCrypt) or
crypto currencies like Bitcoin. You won’t learn how to become a hacker by reading this
book.
Who Is This Book For?
This book is for anyone who might need to secure information with cryptography, and
who is curious about what makes some things “secure” (and what makes other things
insecure). I don’t imagine that most readers of this book will develop their own novel
cryptography ( e.g., designing new block ciphers), but they will be far more likely to use
and combine cryptographic building blocks — thus our focus on the logic of composition.
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021
What Background Is Needed To Understand This Book?
You will get the most out of this book if you have a solid foundation in standard under-
graduate computer science material:
IDiscrete mathematics (of the kind you typically /f_ind in year 2 or 3 of an under-
graduate CS program) is required background . The book assumes that you are
familiar with basic modular arithmetic, discrete probabilities, simple combinatorics,
and especially proof techniques. Chapter 0 contains a brief review of some of these
topics.
IAlgorithms & data structures background is highly recommended , and theory of
computation (automata, formal languages & computability) is also recommended .
We deal with computations and algorithms at a high level of abstraction, and with
mathematical rigor. Prior exposure to this style of thinking will be helpful.
Why Is Cryptography A Diﬀicult Subject?
It’s all the math, right? Cryptography has a reputation of being a diﬃcult subject be-
cause of the amount of diﬃcult math, but I think this assessment misses the mark. A former
victim, I mean student, summed it up bluntly when he shared in class (paraphrased):
Some other students were thinking of taking your course but were worried that
it is really math-heavy. I wouldn’t say that this course is a lot of math exactly.
It’s somehow even worse!
Thanks, I think.
Anyway, many corners of cryptography use math that most CS undergrads would /f_ind
quite advanced (advanced factoring algorithms, elliptic curves, isogenies, even algebraic
geometry), but these aren’t the focus of this book. Our focus is instead on the logic of
composing diﬀerent building blocks together in provably secure ways. Yes, you will prob-
ably learn some new math in this book — enough to understand RSA, for example. And
yes, there are plenty of “proofs.” But I honestly believe you’ll be /f_ine if you did well in
a standard discrete math course. I always tell my /c.sc/s.sc427 students that I’m not expecting
them to love math, proofs, and theory — I only ask them to choose not to be scared of it.
If not math, then what? In an algorithms course, I could introduce and explain con-
cepts with concrete examples — here’s what happens step-by-step when I run mergesort
on this particular array, here’s what happens when I run Dijkstra’s algorithm on this par-
ticular graph, here are 42 examples of a spanning tree. You could study these concrete
examples, or even make your own, to develop your understanding of the general case.
Cryptography is diﬀerent because our main concerns are higher up the ladder of
abstraction than most students are comfortable with.1Yes, I can illustrate what happens
1Of course, abstraction is the heart of math. I may be making a false distinction by saying “it’s not the
math , it’s the abstraction. ” But I think there’s something to the distinction between a CS major’s typical
math-aversion and what is really challenging about cryptography.
iiiDraft: January 3, 2021
step-by-step when you run a cryptographic algorithm on a particular input. This might
help you understand what the algorithm does , but it can never illustrate why the al-
gorithm is secure . This question of “why” is the primary focus of this book.
ISecurity is a global property about the behavior of a system across all possible
inputs. You can’t demonstrate security by example, and there’s nothing to see in a
particular execution of an algorithm. Security is about a higher level of abstraction.
IMost security de/f_initions in this book are essentially: “the thing is secure if its outputs
look like random junk.” If I give an example that is concrete enough to show actual
inputs and outputs, and if things are working as they should, then all the outputs
will just look like meaningless garbage. Unfortunately, no one ever learned very
much by staring at meaningless garbage.
Systems are insecure when they fail to adequately look like random junk. Occasionally
they fail so spectacularly that you can actually see it by looking at concrete input and
output values (as in the case of the ECB penguin). But more often, the reason for insecurity
is far from obvious. For example, suppose an encryption scheme was insecure because the
/x.sc/o.sc/r.scof the /f_irst two output blocks is the same as the /x.sc/o.sc/r.scof the third and fourth output
blocks. I’m not convinced that it would be helpful to show concrete example values with
this property. What’s more, sometimes the reason for insecurity only “jumps oﬀ the page”
on speci/f_ic, non-obvious, choices of inputs.
If you want to be equipped to answer questions like “why is this thing secure but this
other very similar thing is not?”, then you must develop an understanding at this higher
level of abstraction. You’ll have to directly come to terms with abstract ideas like “this
algorithm’s outputs look like random junk, under these circumstances,” and the conse-
quences of these kinds of ideas. It’s hard to arrive at understanding without the usual
scafolding of concrete examples (seeing algorithms executed on speci/f_ic inputs), but this
book is my best eﬀort at making the path as smooth as I know how.
Known Shortcomings
II’ve used this book as a primary course reference for several years now, but I still
consider it to be a draft. Of course I try my best to ensure the accuracy of the content,
but there are sure to be plenty of bugs, ranging in their severity. Caveat emptor!
I welcome feedback of all kinds — not just on errors and typos but also on the se-
lection, organization, and presentation of the material.
II usually cover essentially this entire book during our 10-week quarters. There is
probably not enough material to sustain an entire 16-week semester, though. I al-
ways /f_ind it easier to polish existing material than to add completely new material.
Someday I hope to add more chapters (see the roadmap below), but for now you’ll
have to get by without some important and interesting topics.
IThere is no solutions manual, and I currently have no plans to make one.
ivDraft: January 3, 2021
Code-Based Games Philosophy
The security de/f_initions and proofs in these notes are presented in a style that is known
to the research community as code-based games . I’ve chosen this style because I think it
oﬀers signi/f_icant pedagogical bene/f_its:
IEvery security de/f_inition can be expressed in the same style, as the indistinguisha-
bility of two games. In my terminology, the games are libraries with a common
interface/API but diﬀerent internal implementations. An adversary is any calling
program on that interface. These libraries use a concrete pseudocode that reduces
ambiguity about an adversary’s capabilities. For instance, the adversary controls
arguments to subroutines that it calls and sees only the return value. The adversary
cannot see any variables that are privately scoped to the library.
IA consistent framework for de/f_initions leads to a consistent process for proving and
breaking security — the two fundamental activities in cryptography.
In these notes, breaking a construction always corresponds to writing a program that
expects a particular interface and behaves as diﬀerently as possible in the presence
of two particular implementations of the interface.
Proving security nearly always refers to showing a sequence of libraries (called hy-
brids ), each of which is indistinguishable from the previous one. Each of these hy-
brids is written in concrete pseudocode. By identifying what security property we
wish to prove, we identify what the endpoints of this sequence must be. The steps
that connect adjacent hybrids are stated in terms of syntactic rewriting rules for
pseudocode, including down-to-earth steps like factoring out and inlining subrou-
tines, changing the value of unused variables, and so on.
ICryptography is full of conditional statements of security: “if A is a secure thinga-
majig, then B is a secure doohickey.” A conventional proof of such a statement would
address the contrapositive: “given an adversary that attacks the doohickey-security
of B, I can construct an attack on the thingamajig-security of A.”
In my experience, students struggle to /f_ind the right way to transform an abstract,
hypothetical B-attacking adversary into a successful A-attacking adversary. By
de/f_ining security in terms of games/libraries, we can avoid this abstract challenge,
and indeed avoid the context switch into the contrapositive altogether. In these
notes, the thingamajig-security of A gives the student a new constructive rewriting
rulethat can be placed in his/her toolbox and used to bridge hybrids when proving
the doohickey-security of B.
Code-based games were /f_irst proposed by Shoup2and later expanded by Bellare & Rog-
away.3These notes adopt a simpli/f_ied and uni/f_ied style of games, since the goal is not to
encompass every possible security de/f_inition but only the fundamental ones. The most
signi/f_icant diﬀerence in style is that the games in these notes have no explicit I/n.sc/i.sc/t.sc/i.sc/a.sc/l.sc/i.sc/z.sc/e.sc
2Victor Shoup: Sequences of Games: A Tool for Taming Complexity in Security Proofs. ia.cr/2004/332
3Mihir Bellare & Philip Rogaway: Code-Based Game-Playing Proofs and the Security of Triple Encryption.
ia.cr/2004/331
vDraft: January 3, 2021
orF/i.sc/n.sc/a.sc/l.sc/i.sc/z.sc/e.sc step. As a result, all security de/f_initions are expressed as indistinguishability
of two games/libraries, even security de/f_initions that are fundamentally about unforge-
ability. Yet, we can still reason about unforgeability properties within this framework. For
instance, to say that no adversary can forge a MAC, it suﬃces to say that no adversary can
distinguish a MAC-veri/f_ication subroutine from a subroutine that always returns /f.sc/a.sc/l.sc/s.sc/e.sc .
An index of security de/f_initions has been provided at the end of the book.
One instance where the approach falls short, however, is in de/f_ining collision resis-
tance. I have not been able to de/f_ine it in this framework in a way that is both easy to use
and easy to interpret (and perhaps I achieved neither in the end). See Chapter 11 for my
best attempt.
Other Boring Stuﬀ
Copyright
This work is copyright by Mike Rosulek and made available under the Creative Commons
BY-NC-SA 4.0 license. Under this license, you are free to:
Share: copy and redistribute the material in any medium or format.
Adapt: remix, transform, and build upon the material.
The licensor cannot revoke these freedoms as long as you follow the following license
terms:
Attribution: You must give appropriate credit, provide a link to the license, and in-
dicate if changes were made. You may do so in any reasonable man-
ner, but not in any way that suggests the licensor endorses you or
your use.
NonCommercial: You may not use the material for commercial purposes.
ShareAlike: If you remix, transform, or build upon the material, you must dis-
tribute your contributions under the same license as the original.
You may not apply legal terms or technological measures that legally restrict others from
doing anything the license permits.
About the cover
The cover design consists of assorted shell illustrations from Bibliothèque conchyliologique ,
published in 1846. The images are no longer under copyright, and were obtained from the
Biodiversity Heritage Library ( h/t_tp://biodiversitylibrary.org/bibliography/11590 ).
Why shells? Just like a properly deployed cryptographic primitive, a properly de-
ployed shell is the most robust line of defense for a mollusk. To an uniformed observer, a
shell is just a shell. However, there are many kinds of shells, each of which provides pro-
tection against a diﬀerent kind of attack. The same is true of the cryptographic building
blocks we study in this course.
viDraft: January 3, 2021
Acknowledgements
Some /f_inancial support for writing this book has been kindly provided by the National
Science Foundation (awards #1149647, #1617197) and the Oregon State University Open
Textbook Initiative.
Thanks to Brent Carmer & Leo Reyzin for many thoughtful suggestions and comments
about the material. I am also grateful for the many students in /c.sc/s.sc427 who have reported
countless bugs.
Changelog
2021-01-03 Chapter 2 (provable security basics) is now much more explicit about how security de/f_ini-
tions are a “template” that we “/f_ill in” with speci/f_ic algorithms ( e.g.,Enc,Dec). Chapter 5
(PRGs) now compares/contrasts two approaches for extending the stretch of a PRG — one
secure and one insecure. This chapter also introduces a “socratic dialogue” approach to
thinking about security proofs (previously there was only one such dialogue in Chapter
7). Hints to the exercises are now upside-down for extra security!
2020-02-05 Overhaul of Chapter 2 (provable security fundamentals). The structure is arguably more
coherent now. The total number of examples is increased. I now also include both a
successful security proof and an example of where an attempted security proof goes wrong
(since the scheme is actually insecure).
2020-01-09 High-frequency winter revisions are continuing. This update focuses entirely on Chapter
13 (RSA): Many many more examples are included, in Sage! Discussion of CRT is (hope-
fully) clearer. Digital signatures content is /f_inally there. There’s a new discussion of how
to actually compute modular exponentiation on huge numbers, and a couple fun new ex-
ercises.
2020-01-05 Revising in preparation for teaching CS427 during Winter term.
IChapter 0: More examples. Expanded treatment of modular arithmetic. Tips & tricks
for modular arithmetic and probabilities.
IChapter 1: Moderate reorganization of “things that cryptographers blissfully ig-
nore.”
IChapters 12–15: Moved AEAD chapter into position as chapter 12. Public-key stuﬀ
is now chapters 13–15.
IChapter 13 (RSA): More (but not enough) examples of multiplicative inverses. New
discussion of algorithmic aspects of exponentiation mod N. This chapter will even-
tually focus on signatures exclusively, but we’re not year that. Expect updates over
the next few months.
2019-03-21 Chapter 11 (hash functions) signi/f_icant revisions: no more impenetrable security de/f_inition
for collision-resistance; explicit treatment of salts; better examples for Merkle-Damgård
and length-extension. New draft Chapter 15 on AEAD (after next revision will be inserted
after Chapter 11).
viiDraft: January 3, 2021
2019-01-07 Extensive revisions; only the major ones listed here. Lots of homework problems
added/updated throughout. I tried to revise the entire book in time for my Winter 2019
oﬀering, but ran out of time.
IAdded a changelog!
IChapter 1: Kerckhoﬀs’ Principle now discussed here (previously only mentioned for
the /f_irst time in Ch 2).
IChapter 2: Now the concepts are introduced in context of speci/f_ic one-time security
de/f_inition, not in the abstract. More examples of interchangeable libraries.
IChapter 3: Polynomial interpolation now shown explicitly with LaGrange polyno-
mials (rather than Vandermonde matrices). Full interpolation example worked out.
IChapter 4: Better organization. Real-world contextual examples of extreme (large
& small) 2nvalues. Full proof of bad-event lemma. Generalized avoidance-sampling
libraries.
IChapter 5: Motivate PRGs via pseudo-OTP idea. Better illustration of PRG function,
and conceptual pitfalls. How NOT to build a PRG. New section on stream cipher &
symmetric ratchet.
IChapter 6: Combined PRF & PRP chapters. Motivate PRFs via m7!¹r;F¹k;rºmº
construction. Better discussion of eager vs. lazy sampling of exponentially large
table. How NOT to build a PRF. New section on constructing PRG from PRF, and
more clarity on security proofs with variable number of hybrids. Better illustrations
& formal pseudocode for Feistel constructions.
IChapter 7: Other ways to avoid insecurity of deterministic encryption (stateful &
nonce-based). Ridiculous Socratic dialog on the security of the PRF-based encryp-
tion scheme.
IChapter 8: Compare & contrast CTR & CBC modes.
Road Map
The following topics are shamefully missing from the book, but are planned or being con-
sidered:
1. authenticated key agreement, secure messaging / ratcheting (high priority)
2. random oracle & ideal cipher models (medium priority)
3. elliptic curves, post-quantum crypto (but I would need to learn them /f_irst)
4. DH-based socialist millionaires, PSI, PAKE, simple PIR, basic MPC concepts (low
priority)
viiiContents
0 Review of Concepts & Notation 1
0.1 Logs & Exponents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
0.2 Modular Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
0.3 Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
0.4 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
0.5 Probability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
0.6 Notation in Pseudocode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
0.7 Asymptotics (Big- O) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1 One-Time Pad & Kerckhoﬀs’ Principle 10
1.1 What Is [Not] Cryptography? . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.2 Speci/f_ics of One-Time Pad . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2 The Basics of Provable Security 21
2.1 How to Write a Security De/f_inition . . . . . . . . . . . . . . . . . . . . . . 21
2.2 Formalisms for Security De/f_initions . . . . . . . . . . . . . . . . . . . . . . 25
2.3 How to Demonstrate Insecurity with Attacks . . . . . . . . . . . . . . . . . 30
2.4 How to Prove Security with The Hybrid Technique . . . . . . . . . . . . . 33
2.5 How to Compare/Contrast Security De/f_initions . . . . . . . . . . . . . . . 38
3 Secret Sharing 47
3.1 De/f_initions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
3.2 A Simple 2-out-of-2 Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . 51
3.3 Polynomial Interpolation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
3.4 Shamir Secret Sharing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
3.5? Visual Secret Sharing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
4 Basing Cryptography on Intractable Computations 67
4.1 What Quali/f_ies as a “Computationally Infeasible” Attack? . . . . . . . . . . 67
4.2 What Quali/f_ies as a “Negligible” Success Probability? . . . . . . . . . . . . 70
4.3 Indistinguishability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.4 Birthday Probabilities & Sampling With/out Replacement . . . . . . . . . . 76
5 Pseudorandom Generators 85
5.1 De/f_initions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
5.2 Pseudorandom Generators in Practice . . . . . . . . . . . . . . . . . . . . . 87
5.3 Application: Shorter Keys in One-Time-Secret Encryption . . . . . . . . . 90
5.4 Extending the Stretch of a PRG . . . . . . . . . . . . . . . . . . . . . . . . . 92
5.5? Applications: Stream Cipher & Symmetric Ratchet . . . . . . . . . . . . . . 98
6 Pseudorandom Functions & Block Ciphers 106
6.1 De/f_inition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
6.2 PRFs vs PRGs; Variable-Hybrid Proofs . . . . . . . . . . . . . . . . . . . . . 110
6.3 Block Ciphers (Pseudorandom Permutations) . . . . . . . . . . . . . . . . . 120
6.4 Relating PRFs and Block Ciphers . . . . . . . . . . . . . . . . . . . . . . . . 121
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021
6.5 PRFs and Block Ciphers in Practice . . . . . . . . . . . . . . . . . . . . . . 124
6.6? Strong Pseudorandom Permutations . . . . . . . . . . . . . . . . . . . . . . 125
7 Security Against Chosen Plaintext Attacks 130
7.1 Limits of Deterministic Encryption . . . . . . . . . . . . . . . . . . . . . . 130
7.2 Pseudorandom Ciphertexts . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
7.3 CPA-Secure Encryption Based On PRFs . . . . . . . . . . . . . . . . . . . . 135
8 Block Cipher Modes of Operation 144
8.1 A Tour of Common Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
8.2 CPA Security and Variable-Length Plaintexts . . . . . . . . . . . . . . . . . 147
8.3 Security of OFB Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
8.4 Padding & Ciphertext Stealing . . . . . . . . . . . . . . . . . . . . . . . . . 152
9 Chosen Ciphertext Attacks 162
9.1 Padding Oracle Attacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
9.2 What Went Wrong? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
9.3 De/f_ining CCA Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
9.4? A Simple CCA-Secure Scheme . . . . . . . . . . . . . . . . . . . . . . . . . 171
10 Message Authentication Codes 182
10.1 De/f_inition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
10.2? A PRF is a MAC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
10.3 MACs for Long Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
10.4 Encrypt-Then-MAC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
11 Hash Functions 201
11.1 Security Properties for Hash Functions . . . . . . . . . . . . . . . . . . . . 201
11.2 Merkle-Damgård Construction . . . . . . . . . . . . . . . . . . . . . . . . . 205
11.3 Hash Functions vs. MACs: Length-Extension Attacks . . . . . . . . . . . . 208
12 Authenticated Encryption & AEAD 214
12.1 De/f_initions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
12.2 Achieving AE/AEAD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
12.3 Carter-Wegman MACs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
12.4 Galois Counter Mode for AEAD . . . . . . . . . . . . . . . . . . . . . . . . 225
13 RSA & Digital Signatures 227
13.1 “Dividing” Mod n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
13.2 The RSA Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
13.3 Digital Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
13.4 Chinese Remainder Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . 240
13.5 The Hardness of Factoring N. . . . . . . . . . . . . . . . . . . . . . . . . . 244
14 Diﬃe-Hellman Key Agreement 254
14.1 Cyclic Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
14.2 Diﬃe-Hellman Key Agreement . . . . . . . . . . . . . . . . . . . . . . . . . 255
xDraft: January 3, 2021
14.3 Decisional Diﬃe-Hellman Problem . . . . . . . . . . . . . . . . . . . . . . 256
15 Public-Key Encryption 260
15.1 Security De/f_initions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
15.2 One-Time Security Implies Many-Time Security . . . . . . . . . . . . . . . 261
15.3 ElGamal Encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
15.4 Hybrid Encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
Index of Security De/f_initions 271
xi0Review of Concepts & Notation
The material in this section is meant as a review. Despite that, many students report
that they /f_ind this review useful for the rest of the book.
0.1 Logs & Exponents
You probably learned (and then forgot) these identities in middle school or high school:
¹xaº¹xbº=xa+b
¹xaºb=xab
logx¹abº=logxa+logxb
alogxb=logx¹baº
Well, it’s time to get reacquainted with them again.
In particular, never ever write¹xaº¹xbº=xab. If you write this, your cryptography
instructor will realize that life is too short, immediately resign from teaching, and join a
traveling circus. But not before changing your grade in the course to a zero.
0.2 Modular Arithmetic
We write the set of integers as:
Zdef=f: : : ; 2; 1;0;1;2; : : :g;
and the set of natural numbers (nonnegative integers) as:
Ndef=f0;1;2; : : :g:
Note that 0 is considered a natural number.
Definition 0.1 Forx;n2Z, we say that ndivides x(orxis a multiple of n), and write njx, if there exists
an integer ksuch that x=kn.
Remember that the de/f_initions apply to both positive and negative numbers (and to
zero). We generally only care about this de/f_inition in the case where nis positive, but it is
common to consider both positive and negative values of x.
Example 7 divides 84 because we can write 84=127.
7 divides 0 because we can write 0=07.
7 divides 77because we can write  77=¹ 11º7.
 7divides 42 because we can write 42=¹ 6º¹  7º.
1 divides every integer (so does  1). The only integer that 0 divides is itself.
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 0. REVIEW OF CONCEPTS & NOTATION
Definition 0.2
(%operator)Letnbe a positive integer, and let abe any integer. The expression a%n(usually read as “ a
mod n”) represents the remainder after dividing abyn. More formally, a%nis the unique
r2f0; : : : ; n 1gsuch that nj¹a rº.1
Pay special attention to the fact that a%nis always a nonnegative number, even if ais
negative. A good way to remember how this works is:
ais¹a%nºmore than a multiple of n.
Example 21 % 7 =0because 21=37+0.
20 % 7 =6because 20=27+6.
 20 % 7 =1because 20=¹ 3º7+1. ( 20is one more than a multiple of 7.)
 1 % 7 =6because 1=¹ 1º7+6.
Unfortunately, some programming languages de/f_ine %for negative numbers as ¹ aº%
n= ¹a%nº, so they would de/f_ine  20 % 7 to be ¹20 % 7º= 6. This is madness, and
it’s about time we stood up to these programming language designers and smashed them
over the head with some mathematical truth! For now, if you are using some programming
environment to play around with the concepts in the class, be sure to check whether it
de/f_ines %in the correct way.
Definition 0.3
(Zn)For positive n, we write Zndef=f0; : : : ; n 1gto denote the set of integers modulo n.These
are the possible remainders one obtains by dividing by n.2
Definition 0.4
(n)For positive n, we say that integers aandbarecongruent modulo n, and write anb, if
nj¹a bº. An alternative de/f_inition is that anbif and only if a%n=b%n.
You’ll be in a better position to succeed in this class if you can understand the (subtle)
distinction between anbanda=b%n:
anb: In this expression, aandbcan be integers of any size, and any sign. The left
and right side have a certain relationship modulo n.
a=b%n: This expression says that two integers are equal. The “ =” rather than “” is
your clue that the expression refers to equality over the integers. “ b%n” on
the right-hand side is an operation performed on two integers that returns an
integer result. The result of b%nis an integer in the range f0; : : : ; n 1g.
Example “991019” is true. Applying the de/f_inition, you can see that 10divides 99 19.
On the other hand, “ 99=19 % 10 ” is false. The right-hand side evaluates to the integer 9,
but99and9are diﬀerent integers.
1The fact that only one value of rhas this property is a standard fact proven in most introductory courses
on discrete math.
2Mathematicians may recoil at this de/f_inition in two ways: (1) the fact that we call it Znand not Z¹nZº;
and (2) the fact that we say that this set contains integers rather than congruence classes of integers. If you
appreciate the distinction about congruence classes, then you will easily be able to mentally translate from
the style in this book; and if you don’t appreciate the distinction, there should not be any case where it makes
a diﬀerence.
2Draft: January 3, 2021 CHAPTER 0. REVIEW OF CONCEPTS & NOTATION
In short, expressions like anbmake sense for any a;b(including negative!), but
expressions like a=b%nmake sense only if a2Zn.
Most other textbooks will use notation “ ab¹mod nº” instead of “ anb.” I dislike
this notation because “ ¹mod nº” is easily mistaken for an operation or action that only
aﬀects the right-hand side, when in reality it is like an adverb that modi/f_ies the entire
expression ab. Even thoughnis a bit weird, I think the weirdness is worth it.
Ifdjxanddj/y.alt, then dis acommon divisor ofxand/y.alt. The largest possible such d
is called the greatest common divisor (GCD), denoted gcd¹x;/y.altº. Ifgcd¹x;/y.altº=1, then
we say that xand/y.altarerelatively prime . The oldest “algorithm” is the recursive process
that Euclid described for computing GCDs (ca. 300 /b.sc/c.sc/e.sc):
/g.sc/c.sc/d.sc¹x;/y.altº://Euclid’s algorithm
if/y.alt=0then return x
else return /g.sc/c.sc/d.sc¹/y.alt;x%/y.altº
Tips & Tricks
You may often be faced with some complicated expression and asked to /f_ind the value of
that expression mod n. This usually means: /f_ind the unique value in Znthat is congruent
to the result. The straightforward way to do this is to /f_irst compute the result over the
integers , and then reduce the answer mod n(i.e., with the %noperator).
While this approach gives the correct answer (and is a good anchor for your under-
standing), it’s usually advisable to simplify intermediate values mod n.Doing so will
result in the same answer, but will usually be easier or faster to compute:
Example We can evaluate the expression 678910 % 11 without ever calculating that product over
the integers, by using the following reasoning:
678910=¹42º8910
1198910
=¹72º910
116910
=¹54º10
111010
=100
111
In the steps that only work mod 11, we write “ 11”. We can write “ =” when the step holds over
the integers, although it wouldn’t be wrong to write “ 11” in those cases too. If two expressions
represent the same integer , then they surely represent values that are congruent mod 11.
My advice is to simplify intermediate values mod n, but “simplify” doesn’t always mean
“reduce mod nwith the %noperation.” Sometimes an expression can by “simpli/f_ied” by
substituting a value with something congruent, but notin the rangef0; : : : ; n 1g:
3Draft: January 3, 2021 CHAPTER 0. REVIEW OF CONCEPTS & NOTATION
Example I can compute 7500% 8in my head, by noticing that 78 1and simplifying thusly:
75008¹ 1º500=1:
Similarly, I can compute 892% 99 in my head, although I have not memorized the integer
892. All I need to do is notice that 8999 10and compute this way:
89299¹ 10º2=100991
You can compute either of these examples the “hard way” to verify that these shortcuts lead
to the correct answer.
Since addition, subtraction, and multiplication are de/f_ined over the integers ( i.e.,
adding/subtracting/multiplying integers always results in an integer), these kinds of tricks
can be helpful.
On the other hand, dividing integers doesn’t always result in an integer. Does it make
sense to use division when working mod n, where the result always has to lie in Zn? We
will answer this question later in the book.
0.3 Strings
We writef0;1gnto denote the set of n-bit binary strings, and f0;1gto denote the set
of all (/f_inite-length) binary strings. When xis a string of bits, we write jxjto denote the
length (in bits) of that string, and we write xto denote the result of /f_lipping every bit in x.
When it’s clear from context that we’re talking about strings instead of numbers, we write
0nand1nto denote strings of nzeroes and nones, respectively (rather than the result of
raising the integers 0 or 1 to the npower). As you might have noticed, I also try to use a
diﬀerent font and color for characters (including bits, anything that could be used to build
a string through concatenation) vs. integers.
Definition 0.5
(,/x.sc/o.sc/r.sc)When xand/y.altare strings of the same length, we write x/y.altto denote the bitwise exclusive-or
(/x.sc/o.sc/r.sc) of the two strings. The expression x/y.altis generally not de/f_ined when the strings are
diﬀerent lengths, but in rare occasions it is useful to consider the shorter string being padded
with 0s. When that’s the case, we must have an explicit convention about whether the shorter
string is padded with leading 0s or trailing 0s.
For example, 00110101 =0110 . The following facts about the /x.sc/o.sc/r.sc operation are
frequently useful:
xx=000 /x.sc/o.sc/r.sc’ing a string with itself results in zeroes.
x000=x /x.sc/o.sc/r.sc’ing with zeroes has no eﬀect.
x111=x /x.sc/o.sc/r.sc’ing with ones /f_lips every bit.
x/y.alt=/y.altx /x.sc/o.sc/r.scis symmetric.
¹x/y.altºz=x¹/y.altzº /x.sc/o.sc/r.scis associative.
See if you can use these properties to derive the very useful fact below:
a=bc() b=ac() c=ab:
There are a few ways to think about /x.sc/o.sc/r.scthat may help you in this class:
4Draft: January 3, 2021 CHAPTER 0. REVIEW OF CONCEPTS & NOTATION
IBit-/f_lipping: Note that /x.sc/o.sc/r.sc’ing a bit with 0has no eﬀect, while /x.sc/o.sc/r.sc’ing with 1/f_lips
that bit. You can think of x/y.altas: “starting with x, /f_lip the bits at all the positions
where/y.althas a 1.” So if/y.altis all 1’s, then x/y.altgives the bitwise-complement of x. If
/y.alt=1010then x/y.altmeans “(the result of) /f_lipping every other bit in x.”
Many concepts in this course can be understood in terms of bit-/f_lipping. For exam-
ple, we might ask “what happens when I /f_lip the /f_irst bit of xand send it into the
algorithm?” This kind of question could also be phrased as “what happens when I
send x1000into the algorithm?” Usually there is nothing special about /f_lip-
ping just the /f_irst bit of a string, so it will often be quite reasonable to generalize the
question as “what happens when I send x/y.altinto the algorithm, for an arbitrary
(not-all-zeroes) string /y.alt?”
IAddition mod-2: /x.sc/o.sc/r.sc is just addition mod 2 in every bit. This way of thinking
about /x.sc/o.sc/r.schelps to explain why “algebraic” things like ¹x/y.altºz=x¹/y.altzºare
true. They are true for addition, so they are true for /x.sc/o.sc/r.sc.
This also might help you remember why xxis all zeroes. If instead of /x.sc/o.sc/r.sc we
used addition, we would surely write x+x=2x. Since 220, we get that 2xis
congruent to 0x=0.
Definition 0.6
(k, concatenation)We write xk/y.altto denote the result of concatenating xand/y.alt.
0.4 Functions
LetXandYbe /f_inite sets. A function f:X!Yis:
injective (1-to-1) if it maps distinct inputs to distinct outputs. Formally: x,x0)
f¹xº,f¹x0º. If there is an injective function from XtoY, then we must have
jYj>jXj.
surjective (onto) if every element in Yis a possible output of f. Formally: for all /y.alt2Y
there exists an x2Xwith f¹xº=/y.alt. If there is a surjective function from Xto
Y, then we must have jYj6jXj.
bijective (1-to-1 correspondence) if fis both injective and surjective. If there is a bijec-
tive function from XtoY, then we must have jXj=jYj.
0.5 Probability
Definition 0.7
(Distribution)A(discrete) probability distribution over a set Xofoutcomes is usually written as a
function “ Pr” that associates each outcome x2Xwith a probability Pr»x¼. We often say that
the distribution assigns probability Pr»x¼to outcome x.
For each outcome x2X, the probability distribution must satisfy the condition 06
Pr»x¼61. Additionally, the sum of all probabilitiesÍ
x2XPr»x¼must equal 1.
Definition 0.8
(Uniform)A special distribution is the uniform distribution over a /f_inite set X, in which every x2X
is assigned probability Pr»x¼=1jXj.
5Draft: January 3, 2021 CHAPTER 0. REVIEW OF CONCEPTS & NOTATION
We also extend the notation Prtoevents , which are collections of outcomes. If you
want to be formal, an event Ais any subset of the possible outcomes, and its probability
is de/f_ined to be Pr»A¼=Í
x2APr»x¼. We always simplify the notation slightly, so instead
of writing Pr»fxjxsatis/f_ies some condition g¼, we write Pr»condition¼.
Example A 6-sided die has faces numbered f1;2; : : : ; 6g. Tossing the die (at least for a mathemati-
cian) induces a uniform distribution over the choice of face. Then Pr»3 is rolled¼=16, and
Pr»an odd number is rolled ¼=12andPr»a prime is rolled¼=12.
Tips & Tricks
Knowing one of the probabilities Pr»A¼andPr»:A¼(which is “the probability that Adoesn’t
happen”) tells you exactly what the other probability is, via the relationship
Pr»A¼=1 Pr»:A¼:
This is one of the most basic facts about probability, but it can be surprisingly useful since
one of Pr»A¼andPr»:A¼is often much easier to calculate than the other. If you get stuck
trying to come up with an expression for Pr»A¼, try working out an expression for Pr»:A¼
instead.
Example I roll a six-sided die, six times. What is the probability that there is some repeated value?
Let’s think about all the ways of getting a repeated value. Well, two of the rolls could be 1, or
three of rolls could be 1, or all of them could be 1, two of them could be 1 and the rest could
be 2, etc. Oh no, am I double-counting repeated 2s and repeated 1s? Uhh : : :
An easier way to attack the problem is to realize that the probability we care about is
actually 1 Pr»all 6 rolls are distinct ¼. This complementary event (all 6 rolls distinct) happens
exactly when the sequence of dice rolls spell out a permutation of f1; : : : ; 6g. There are 6!=
720such permutations, out of 66=46656 total possible outcomes. Hence, the answer to the
question is
1 6!
66=1 720
46656=45936
466560:9846
Another trick is one I like to call setting breakpoints on the universe. Imagine stop-
ping the universe at a point where some random choices have happened, and others have
not yet happened. This is best illustrated by example:
Example A classic question asks: when rolling two 6-sided dice what is the probability that the dice
match? Here is a standard (and totally correct way) to answer the question:
When rolling two 6-sided dice, there are 62=36total outcomes (a pair of num-
bers), so each has probability 136under a uniform distribution. There are 6
outcomes that make the dice match: both dice 1, both dice 2, both dice 3, and so
on. Therefore, the probability of rolling matching dice is 636=16.
A diﬀerent way to arrive at the answer goes like this:
6Draft: January 3, 2021 CHAPTER 0. REVIEW OF CONCEPTS & NOTATION
Imagine I roll the dice one after another, and I pause the universe (set a break-
point) after rolling the /f_irst die but before rolling the second one. The universe
has already decided the result of the /f_irst die, so let’s call that value d. The dice
will match only if the second roll comes up d. Rolling don the second die (indeed,
rolling any particular value) happens with probability 16.
This technique of setting breakpoints is simple but powerful and frequently useful.
Some other closely related tricks are: (1) postponing a random choice until the last possible
moment, just before its result is used for the /f_irst time, and (2) switching the relative order
of independent random choices.
Precise Terminology
It is tempting in this course to say things like “ xis a random string.” But a statement like
this is sloppy on several accounts.
First, is 42 a random number? Is “heads” a random coin? What is even being asked by
these questions? Being “random” is not a property of an outcome (like a number or a side
of a coin) but a property of the process that generates an outcome.3Instead of saying “ xis
a random string,” it’s much more precise to say “ xwas chosen randomly.”
Second, usually when we use the word “random,” we don’t mean any old probability
distribution. We usually mean to refer to the uniform distribution . Instead of saying “ x
was chosen randomly,” it’s much more precise to say “ xwas chosen uniformly” (assuming
that really iswhat you mean).
Every cryptographer I know (yes, even your dear author) says things like “ xis a ran-
dom string” all the time to mean “ xwas chosen uniformly [from some set of strings].”
Usually the meaning is clear from context, at least to the other cryptographers in the
room. But all of us could bene/f_it by having better habits about this sloppy language. Stu-
dents especially will bene/f_it by internalizing the fact that randomness is a property of
theprocess , not of the individual outcome.
0.6 Notation in Pseudocode
We’ll often describe algorithms/processes using pseudocode. In doing so, we will use sev-
eral diﬀerent operators whose meanings might be easily confused:
 WhenDis a probability distribution, we write “ x D ” to mean “sample xaccord-
ing to the distribution D.”
IfAis an algorithm that takes input and also makes some internal random choices,
then it is natural to think of its output A¹/y.altºas a distribution — possibly a diﬀerent
distribution for each input /y.alt. Then we write “ x A¹/y.altº” to mean the natural thing:
“runAon input/y.altand assign the output to x.”
3There is something called Kolmogorov complexity that can actually give coherent meaning to statements
like “ xis a random string.” But Kolmogorov complexity has no relevance to this book. The statement “ xis
a random string” remains meaningless with respect to the usual probability-distribution sense of the word
“random.”
7Draft: January 3, 2021 CHAPTER 0. REVIEW OF CONCEPTS & NOTATION
We overload the “ ” notation slightly, writing “ x X” when Xis a/f_inite set to
mean that xis sampled from the uniform distribution over X.
:=We write x:=/y.altfor assignments to variables: “take the value of expression /y.altand
assign it to variable x.”
?=We write comparisons as?=(analogous to “==” in your favorite programming lan-
guage). So x?=/y.altdoesn’t modify x(or/y.alt), but rather it is an expression which returns
true ifxand/y.altare equal.
You will often see this notation in the conditional part of an if-statement, but also
in return statements as well. The following two snippets are equivalent:
return x?=/y.alt,ifx?=/y.alt:
return true
else:
return false
In a similar way, we write x?2Sas an expression that evaluates to true if xis in the
setS.
Subroutine conventions
We’ll use mathematical notation to de/f_ine the types of subroutine arguments:
/f.sc/o.sc/o.sc(x2f0;1g):
means “void foo(string x) { ... }00
0.7 Asymptotics (Big- O)
Letf:N!Nbe a function. We characterize the asymptotic growth of fin the following
ways:
f¹nºisO¹/afii10069.ital¹nººdef,lim
n!1f¹nº
/afii10069.ital¹nº<1
,9c>0:for all but /f_initely many n:f¹nº<c/afii10069.ital¹nº
f¹nºisΩ¹/afii10069.ital¹nººdef,lim
n!1f¹nº
/afii10069.ital¹nº>0
,9c>0:for all but /f_initely many n:f¹nº>c/afii10069.ital¹nº
f¹nºisΘ¹/afii10069.ital¹nººdef,f¹nºisO¹/afii10069.ital¹nººandf¹nºisΩ¹/afii10069.ital¹nºº
,0<lim
n!1f¹nº
/afii10069.ital¹nº<1
,9c1;c2>0:for all but /f_initely many n:
c1/afii10069.ital¹nº<f¹nº<c2/afii10069.ital¹nº
8Draft: January 3, 2021 CHAPTER 0. REVIEW OF CONCEPTS & NOTATION
Exercises
0.1. Rewrite each of these expressions as something of the form 2x.
(a)¹2nºn=??
(b)2n+2n=??
(c)¹2nº¹2nº=??(d)¹2nº2=??
(e)p
2n=??
(f)¹2nº2=??
0.2. (a) What is 0+1+2++¹n 2º+¹n 1º%n, when nis an odd integer? Prove your
answer!
(b) What is 0+1+2++¹n 2º+¹n 1º%n, when nis even? Prove your answer!
0.3. What is¹ 99º% 10?
0.4. Without using a calculator, what are the last two digits of 3579986?
0.5. Without using a calculator, what is 1000! % 427 ? (That’s not me being excited about the
number one thousand, it’s one thousand factorial! )
0.6. Which values x2Z11satisfy x2115? Which satisfy x2116?
0.7. What is the result of /x.sc/o.sc/r.sc’ing every nbit string? For example, the expression below is the
/x.sc/o.sc/r.scof every 5-bit string:
00000000010001000011 1111011111
Give a convincing justi/f_ication of your answer.
0.8. Consider rolling several d-sided dice, where the sides are labeled f0; : : : ; d 1g.
(a) When rolling two of these dice, what is the probability of rolling snake-eyes (a pair of
1s)?
(b) When rolling two of these dice, what is the probability that they don’t match?
(c) When rolling three of these dice, what is the probability that they all match?
(d) When rolling three of these dice, what is the probability that they don’t all match
(including the case where two match)?
(e) When rolling three of these dice, what is the probability that at least two of them match
(including the case where all three match)?
(f) When rolling three of these dice, what is the probability of seeing at least one 0?
0.9. When rolling two 6-sided dice, there is some probability of rolling snake-eyes (two 1s).
You determined this probability in the previous problem. In some game, I roll both dice
each time it is my turn. What is the smallest value tsuch that:
Pr»I have rolled snake-eyes in at least one of my /f_irst tturns¼>0:5?
In other words, how many turns until my probability of getting snake-eyes exceeds 50%?
91One-Time Pad & Kerckhoﬀs’
Principle
You can’t learn about cryptography without meeting Alice, Bob, and Eve. This chapter
is about the classic problem of private communication , in which Alice has a message
that she wants to convey to Bob, while also keeping the contents of the message hidden
from an eavesdropper1Eve. You’ll soon learn that there is more to cryptography than just
private communication, but it is the logical place to start.
1.1 What Is [Not] Cryptography?
“To de/f_ine is to limit.”
—Oscar Wilde
Cryptography is not a magic spell that solves all security problems. Cryptography
can provide solutions to cleanly de/f_ined problems that often abstract away important but
messy real-world concerns. Cryptography can give guarantees about what happens in
the presence of certain well-de/f_ined classes of attacks. These guarantees may not apply if
real-world attackers “don’t follow the rules” of a cryptographic security model.
Always keep this in mind as we de/f_ine ( i.e., limit) the problems that we solve in this
course.
Encryption Basics & Terminology
Let’s begin to formalize our scenario involving Alice, Bob, and Eve. Alice has a message
mthat she wants to send (privately) to Bob. We call mtheplaintext . We assume she
will somehow transform that plaintext into a value c(called the ciphertext ) that she will
actually send to Bob. The process of transforming mintocis called encryption, and we will
useEncto refer to the encryption algorithm. When Bob receives c, he runs a corresponding
decryption algorithm Decto recover the original plaintext m.
We assume that the ciphertext may be observed by the eavesdropper Eve, so the (in-
formal) goal is for the ciphertext to be meaningful to Bob but meaningless to Eve.
Enc Decm c m
1“Eavesdropper” refers to someone who secretly listens in on a conversation between others. The term
originated as a reference to someone who literally hung from the eaves of a building in order to hear conver-
sations happening inside.
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 1. ONE-TIME PAD & KERCKHOFFS’ PRINCIPLE
Secrets & Kerckhoﬀs’ Principle
Something important is missing from this picture. If we want Bob to be able to decrypt c,
but Eve to notbe able to decrypt c, then Bob must have some information that Eve doesn’t
have (do you see why?). Something has to be kept secret from Eve.
You might suggest to make the details of the EncandDec algorithms secret. This
is how cryptography was done throughout most of the last 2000 years, but it has major
drawbacks. If the attacker does eventually learn the details of EncandDec, then the only
way to recover security is to invent new algorithms . If you have a system with many users,
then the only way to prevent everyone from reading everyone else’s messages is to invent
new algorithms for each pair of users. Inventing even one good encryption method is
already hard enough!
The /f_irst person to articulate this problem was Auguste Kerckhoﬀs. In 1883 he for-
mulated a set of cryptographic design principles. Item #2 on his list is now known as
Kerckhoﬀs’ principle :
Kerckhoﬀs’ Principle:
“Il faut qu’il n’exige pas le secret, et qu’il puisse sans inconvénient tomber entre
les mains de l’ennemi.”
Literal translation: [The method] must not be required to be secret, and it
must be able to fall into the enemy’s hands without causing inconvenience.
Bottom line: Design your system to be secure even if the attacker has com-
plete knowledge of all its algorithms.
If the algorithms themselves are not secret, then there must be some other secret infor-
mation in the system. That information is called the (secret) key . The key is just an extra
piece of information given to both the EncandDecalgorithms. Another way to interpret
Kerckhoﬀs’ principle is that all of the security of the system should be concentrated in the
secrecy of the key , not the secrecy of the algorithms. If a secret key gets compromised,
you only need to choose a new one, not reinvent an entirely new encryption algorithm.
Multiple users can all safely use the same encryption algorithm but with independently
chosen secret keys.
The process of choosing a secret key is called key generation , and we write KeyGen
to refer to the (randomized) key generation algorithm. We call the collection of three algo-
rithms ( Enc,Dec,KeyGen ) anencryption scheme. Remember that Kerckhoﬀs’ principle
says that we should assume that an attacker knows the details of the KeyGen algorithm.
But also remember that knowing the details (i.e., source code) of a randomized algorithm
doesn’t mean you know the speci/f_ic output it gave when the algorithm was executed.
KeyGen
Enc Decm c mk
11Draft: January 3, 2021 CHAPTER 1. ONE-TIME PAD & KERCKHOFFS’ PRINCIPLE
Excuses, Excuses
Let’s practice some humility. Here is just a partial list of issues that are clearly important
for the problem of private communication, but which are not addressed by our de/f_inition
of the problem.
IWe are not trying to hide the fact that Alice is sending something to Bob, we only
want to hide the contents of that message. Hiding the existence of a communication
channel is called steganography.
IWe won’t consider the question of how creliably gets from Alice to Bob. We’ll just
take this issue for granted.
IFor now, we are assuming that Eve just passively observes the communication be-
tween Alice & Bob. We aren’t considering an attacker that tampers with c(causing
Bob to receive and decrypt a diﬀerent value), although we will consider such attacks
later in the book.
IWe won’t discuss howAlice and Bob actually obtain a common secret key in the real
world. This problem (known as key distribution ) is clearly incredibly important,
and we will discuss some clever approaches to it much later in the book.
In my defense, the problem we are solving is already rather non-trivial: once two
users have established a shared secret key, how can they use that key to communi-
cate privately?
IWe won’t discuss how Alice and Bob keep their key secret, even after they have
established it. One of my favorite descriptions of cryptography is due to Lea Kissner
(former principal security engineer at Google): “cryptography is a tool for turning lots
of diﬀerent problems into key management problems.”
IThroughout this course we simply assume that the users have the ability to uni-
formly sample random strings. Indeed, without randomness there is no cryptogra-
phy. In the real world, obtaining uniformly random bits from deterministic com-
puters is extremely non-trivial. John von Neumann famously said, “Any one who
considers arithmetical methods of producing random digits is, of course, in a state of
sin.” Again, even when we take uniform randomness for granted, we still face the
non-trivial question of how to usethat randomness for private communication (and
other applications), and also how to use only a manageable amount of randomness.
Not Cryptography
People use many techniques to try to hide information, but many are “non-cryptographic”
since they don’t follow Kerckhoﬀs’ principle:
IEncoding/decoding methods like base64 : : :
joy of cryptography $ b25seSBuZXJkcyB3aWxsIHJlYWQgdGhpcw==
12Draft: January 3, 2021 CHAPTER 1. ONE-TIME PAD & KERCKHOFFS’ PRINCIPLE
: : :are useful for incorporating arbitrary binary data into a structured /f_ile format
that supports limited kinds of characters. But since base64 encoding/decoding in-
volves no secret information, it adds nothing in terms of security .
ISometimes the simplest way to describe an encryption scheme is with operations on
binary strings (i.e., 0s and 1s) data. As we will see, one-time pad is de/f_ined in terms
of plaintexts represented as strings of bits. (Future schemes will require inputs to
be represented as a bitstring of a speci/f_ic length, or as an element of Zn, etc.)
In order to make sense of some algorithms in this course, it may be necessary to
think about data being converted into binary representation. Just like with base64 ,
representing things in binary has no eﬀect on security since it does not involve any
secret information. Writing something in binary is not a security measure!
1.2 Specifics of One-Time Pad
People have been trying to send secret messages for roughly 2000 years, but there are really
only 2 useful ideas from before 1900 that have any relevance to modern cryptography.
The /f_irst idea is Kerckhoﬀs’ principle, which you have already seen. The other idea is
one-time pad (OTP) , which illustrates several important concepts, and can even still be
found hiding deep inside many modern encryption schemes.
One-time pad is sometimes called “Vernam’s cipher” after Gilbert Vernam, a telegraph
engineer who patented the scheme in 1919. However, an earlier description of one-time
pad was rather recently discovered in an 1882 text by Frank Miller on telegraph encryp-
tion.2
In most of this book, secret keys will be strings of bits. We generally use the variable λ
to refer to the length (# of bits) of the secret key in a scheme, so that keys are elements of
the setf0;1gλ. In the case of one-time pad, the choice of λdoesn’t aﬀect security ( λ=10
is “just as secure” as λ=1000); however, the length of the keys and plaintexts must be
compatible. In future chapters, increasing λhas the eﬀect of making the scheme harder to
break. For that reason, λis often called the security parameter of the scheme.
In one-time pad, not only are the keys λ-bit strings, but plaintexts and ciphertexts
are too. You should consider this to be just a simple coincidence, because we will soon
encounter schemes in which keys, plaintexts, and ciphertexts are strings of diﬀerent sizes.
The speci/f_ic KeyGen ,Enc, and Decalgorithms for one-time pad are given below:
Construction 1.1
(One-time pad)KeyGen :
k f0;1gλ
return kEnc¹k;m2f0;1gλº:
return kmDec¹k;c2f0;1gλº:
return kc
Recall that “ k f0;1gλ” means to sample kuniformly from the set of λ-bit strings. This
uniform choice of key is the only randomness in all of the one-time pad algorithms. As we
will see, all of its security stems from this choice of using the uniform distribution; keys
that are chosen diﬀerently do not provide equivalent security.
2See the article Steven M. Bellovin: “Frank Miller: Inventor of the One-Time Pad.” Cryptologia 35 (3),
2011.
13Draft: January 3, 2021 CHAPTER 1. ONE-TIME PAD & KERCKHOFFS’ PRINCIPLE
Example Encrypting the following 20-bit plaintext munder the 20-bit key kusing OTP results in the
ciphertext cbelow:
11101111101111100011 (m)
00011001110000111101 (k)
11110110011111011110 (c=Enc¹k;mº)
Decrypting the following ciphertext cusing the key kresults in the plaintext mbelow:
00001001011110010000 (c)
10010011101011100010 (k)
10011010110101110010 (m=Dec¹k;cº)
Note that EncandDec are essentially the same algorithm (return the /x.sc/o.sc/r.scof the two
arguments). This results in some small level of convenience and symmetry when imple-
menting one-time pad, but it is more of a coincidence than something truly fundamental
about encryption (see Exercises 1.12 & 2.5). Later on you’ll see encryption schemes whose
encryption & decryption algorithms look very diﬀerent.
Correctness
The /f_irst property of one-time pad that we should con/f_irm is that the receiver does indeed
recover the intended plaintext when decrypting the ciphertext. Without this property, the
thought of using one-time pad for communication seems silly. Written mathematically:
Claim 1.2 For all k;m2f0;1gλ, it is true that Dec¹k;Enc¹k;mºº=m.
Proof This follows by substituting the de/f_initions of OTP EncandDec, then applying the prop-
erties of /x.sc/o.sc/r.sclisted in Chapter 0.3. For all k;m2f0;1gλ, we have:
Dec¹k;Enc¹k;mºº=Dec¹k;kmº
=k¹kmº
=¹kkºm
=0λm
=m:
Example Encrypting the following plaintext munder the key kresults in ciphertext c, as follows:
00110100110110001111 (m)
11101010011010001101 (k)
11011110101100000010 (c)
Decrypting cusing the same key kresults in the original m:
11011110101100000010 (c)
11101010011010001101 (k)
00110100110110001111 (m)
14Draft: January 3, 2021 CHAPTER 1. ONE-TIME PAD & KERCKHOFFS’ PRINCIPLE
Security
Suppose Alice and Bob are using one-time pad but are concerned that an attacker sees
their ciphertext. They can’t presume what an attacker will do after seeing the ciphertext.
But they would like to say something like, “because of the speci/f_ic way the ciphertext was
generated, it doesn’t reveal any information about the plaintext to the attacker, no matter
what the attacker does with the ciphertext.”
We must /f_irst precisely specify how the ciphertext is generated. The Encalgorithm
already describes the process, but it is written from the point of view of Alice and Bob.
When talking about security, we have to think about what Alice and Bob do, but from the
eavesdropper’s point of view! From Eve’s point of view, Alice uses a key that was chosen
in a speci/f_ic way (uniformly at random), she encrypts a plaintext with that key using OTP,
and /f_inally reveals only the resulting ciphertext (and not the key) to Eve.
More formally, from Eve’s perspective, seeing a ciphertext corresponds to receiving
an output from the following algorithm:
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹m2f0;1gλº:
k f0;1gλ
c:=km
return c:
It’s crucial that you appreciate what this /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc algorithm represents. It is meant
to describe not what the attacker does, but rather the process (carried out by Alice
and Bob!) that produces what the attacker sees. We always treat the attacker as some
(unspeci/f_ied) process that receives output from this /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc algorithm. Our goal is to
say something like “the output of /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc doesn’t reveal the input m.”
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc is arandomized algorithm — remember that “ k f0;1gλ” means to sample
kfrom the uniform distribution on λ-bit strings. If you call /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc several times,
even on the same input, you are likely to get diﬀerent outputs. Instead of thinking of
“/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mº” as a single string, you should think of it as a probability distribution over
strings. Each time you call /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mº, you see a sample from that distribution.
Example Let’s takeλ=3and work out by hand the distributions /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹010ºand/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹111º.
In each case /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc chooses a value of kuniformly inf0;1g3— each of the possible
values with probability 1/8. For each possible choice of k, we can compute what the output of
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc (c) will be:
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹010º:
Pr k output c=k010
1 ⁄8000 010
1 ⁄8001 011
1 ⁄8010 000
1 ⁄8011 001
1 ⁄8100 110
1 ⁄8101 111
1 ⁄8110 100
1 ⁄8111 101/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹111º:
Pr k output c=k111
1 ⁄8000 111
1 ⁄8001 110
1 ⁄8010 101
1 ⁄8011 100
1 ⁄8100 011
1 ⁄8101 010
1 ⁄8110 001
1 ⁄8111 000
15Draft: January 3, 2021 CHAPTER 1. ONE-TIME PAD & KERCKHOFFS’ PRINCIPLE
So the distribution /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹010ºassigns probabilty 1/8 to 010, probability 1/8 to 011, and
so on.
In this example, notice how every string in f0;1g3appears exactly once in the ccolumn
of/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹010º. This means that /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc assigns probability 1/8 to every string in
f0;1g3, which is just another way of saying that the distribution is the uniform distribu-
tiononf0;1g3. The same can be said about the distribution /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹111º, too. Both
distributions are just the uniform distribution in disguise!
There is nothing special about 010or111in these examples. For any λand any m2
f0;1gλ, the distribution /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mºis the uniform distribution over f0;1gλ.
Claim 1.3 For every m2 f0;1gλ, the distribution /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mºis the uniform distribution on
f0;1gλ. Hence, for all m;m02f0;1gλ, the distributions /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mºand/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹m0º
are identical.
Proof Arbitrarily /f_ix m;c2f0;1gλ. We will calculate the probability that /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mºpro-
duces output c. That event happens only when
c=km() k=mc:
The equivalence follows from the properties of /x.sc/o.sc/r.scgiven in Section 0.3. That is,
Pr»/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mº=c¼=Pr»k=mc¼;
where the probability is over uniform choice of k f0;1gλ.
We are considering a speci/f_ic choice for mandc, so there is only one value of kthat
makes k=mctrue (causes mto encrypt to c), and that value is exactly mc. Since kis
chosen uniformly fromf0;1gλ, the probability of choosing the particular value k=mc
is12λ.
In summary, for every mandc, the probability that /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mºoutputs cis ex-
actly 12λ. This means that the output of /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mº, for any m, follows the uniform
distribution. 
One way to interpret this statement of security in more down-to-earth terms:
If an attacker sees a single ciphertext, encrypted with one-time pad, where the
key is chosen uniformly and kept secret from the attacker, then the ciphertext
appears uniformly distributed.
Why is this signi/f_icant? Taking the eavesdropper’s point of view, suppose someone
chooses a plaintext mand you get to see the resulting ciphertext — a sample from the distri-
bution /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mº. But this is a distribution that you can sample from yourself, even if
you don’t know m! You could have chosen a totally diﬀerent m0and run /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹m0ºin
your imagination, and this would have produced the same distribution as /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mº.
The “real” ciphertext that you see doesn’t carry any information about mif it is possible to
sample from the same distribution without even knowing m!
16Draft: January 3, 2021 CHAPTER 1. ONE-TIME PAD & KERCKHOFFS’ PRINCIPLE
Discussion
IIsn’t there a paradox? Claim 1.2 says that ccan always be decrypted to get m,
but Claim 1.3 says that ccontains no information about m! The answer to this
riddle is that Claim 1.2 talks about what can be done with knowledge of the key
k(Alice & Bob’s perspective). Claim 1.3 talks about the output distribution of the
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc algorithm, which doesn’t include k(Eve’s perspective). In short, if you
know k, then you can decrypt cto obtain m; if you don’t know k, then ccarries no
information about m(in fact, it looks uniformly distributed). This is because m;c;k
are all correlated in a delicate way.3
IIsn’t there another paradox? Claim 1.3 says that the output of /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mº
doesn’t depend on m, but we can see the /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc algorithm literally using its
argument mright there in the last line! The answer to this riddle is perhaps best
illustrated by the previous illustrations of the /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹010ºand/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹111º
distributions. The two tables of values are indeed diﬀerent (so the choice of m2
f010;111gclearly has some eﬀect), but they represent the same probability distribu-
tion(since order doesn’t matter). Claim 1.3 considers only the resulting probability
distribution.
IYou probably think about security in terms of a concrete “goal” for the attacker:
recover the key, recover the plaintext, etc. Claim 1.3 doesn’t really refer to attackers
in that way, and it certainly doesn’t specify a goal. Rather, we are thinking about
security by comparing to some hypothetical “ideal” world. I would be satis/f_ied if the
attacker sees only a source of uniform bits, because in this hypothetical world there
are no keys and no plaintexts to recover! Claim 1.3 says that when we actually use
OTP, it looks just like this hypothetical world, from the attacker’s point of view. If
we imagine any “goal” at all for the attacker in this kind of reasoning, it’s to detect
that ciphertexts don’t follow a uniform distribution. By showing that the attacker
can’t even achieve this modest goal, it shows that the attacker couldn’t possibly
achieve other, more natural, goals like key recovery and plaintext recovery.
Limitations
One-time pad is incredibly limited in practice. Most notably:
IIts keys are as long as the plaintexts they encrypt. This is basically unavoidable (see
Exercise 2.11) and leads to a kind of chicken-and-egg dilemma in practice: If two
users want to privately convey a λ-bit message, they /f_irst need to privately agree on
aλ-bit string.
IA key can be used to encrypt only one plaintext (hence, “one-time” pad); see Exer-
cise 1.6. Indeed, we can see that the /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc subroutine in Claim 1.3 provides no
way for a caller to guarantee that two plaintexts are encrypted with the same key,
so it is not clear how to use Claim 1.3 to argue about what happens in one-time pad
when keys are intentionally reused in this way.
3This correlation is explored further in Chapter 3.
17Draft: January 3, 2021 CHAPTER 1. ONE-TIME PAD & KERCKHOFFS’ PRINCIPLE
Despite these limitations, one-time pad illustrates fundamental ideas that appear in
most forms of encryption in this course.
Exercises
1.1. The one-time pad encryption of plaintext mario (when converted from /a.sc/s.sc/c.sc/i.sc/i.sc to binary in
the standard way) under key kis:
1000010000000111010101000001110000011101 .
What is the one-time pad encryption of luigi under the same key?
1.2. Alice is using one-time pad and notices that when her key is the all-zeroes string k=0λ,
then Enc¹k;mº=mand her message is sent in the clear! To avoid this problem, she
decides to modify KeyGen to exclude the all-zeroes key. She modi/f_ies KeyGen to choose
a key uniformly from f0;1gλnf0λg, the set of all λ-bit strings except 0λ. In this way, she
guarantees that her plaintext is never sent in the clear.
Is it still true that the eavesdropper’s ciphertext distribution is uniformly distributed on
f0;1gλ? Justify your answer.
1.3. When Alice encrypts the key kitself using one-time pad, the ciphertext will always be the
all-zeroes string! So if an eavesdropper sees the all-zeroes ciphertext, she learns that Alice
encrypted the key itself. Does this contradict Claim 1.3? Why or why not?
1.4. What is so special about de/f_ining OTP using the /x.sc/o.sc/r.sc operation? Suppose we use the
bitwise- /a.sc/n.sc/d.sc operation (which we will write as ‘&’) and de/f_ine a variant of OTP as follows:
KeyGen :
k f0;1gλ
return kEnc¹k;m2f0;1gλº:
return k&m
Is this still a good choice for encryption? Why / why not?
1.5. Describe the /f_law in this argument:
Consider the following attack against one-time pad: upon seeing a ciphertext c,
the eavesdropper tries every candidate key k2f0;1gλuntil she has found the
one that was used, at which point she outputs the plaintext m. This contradicts
the argument in Section 1.2 that the eavesdropper can obtain no information
about mby seeing the ciphertext.
1.6. Suppose Alice encrypts two plaintexts mandm0using one-time pad with the same key k.
What information about mandm0is leaked to an eavesdropper by doing this (assume the
eavesdropper knows that Alice has reused k)? Be as speci/f_ic as you can!
1.7. You (Eve) have intercepted two ciphertexts:
c1=1111100101111001110011000001011110000110
18Draft: January 3, 2021 CHAPTER 1. ONE-TIME PAD & KERCKHOFFS’ PRINCIPLE
c2=1111101001100111110111010000100110001000
You know that both are OTP ciphertexts, encrypted with the same key . You know that
either c1is an encryption of alpha andc2is an encryption of bravo orc1is an encryption
ofdelta andc2is an encryption of gamma (all converted to binary from /a.sc/s.sc/c.sc/i.sc/i.sc in the standard
way).
Which of these two possibilities is correct, and why? What was the key k?
1.8. A known-plaintext attack refers to a situation where an eavesdropper sees a ciphertext
c=Enc¹k;mºand also learns/knows what plaintext mwas used to generate c.
(a) Show that a known-plaintext attack on OTP results in the attacker learning the key k.
(b) Can OTP be secure if it allows an attacker to recover the encryption key? Is this a
contradiction to the security we showed for OTP? Explain.
1.9. Suppose we modify the subroutine discussed in Claim 1.3 so that it also returns k:
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc0¹m2f0;1gλº:
k f0;1gλ
c:=km
return¹k;cº:
Is it still true that for every m, the output of /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc0¹mºis distributed uniformly in
¹f0;1gλº2? Or is the output distribution diﬀerent for diﬀerent choice of m?
1.10. In this problem we discuss the security of performing one-time pad encryption twice:
(a) Consider the following subroutine that models the result of applying one-time pad
encryption with two independent keys:
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc0¹m2f0;1gλº:
k1 f0;1gλ
k2 f0;1gλ
c:=k2¹k1mº
return c:
Show that the output of this subroutine is uniformly distributed in f0;1gλ.
(b) What security is provided by performing one-time pad encryption twice with the same
key?
1.11. We mentioned that one-time pad keys can be used to encrypt only one plaintext, and how
this was re/f_lected in the /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc subroutine of Claim 1.3. Is there a similar restriction
about re-using plaintexts in OTP (but with independently random keys for diﬀerent cipher-
texts)? If an eavesdropper knows that the same plaintext is encrypted twice (but doesn’t
know what the plaintext is), can she learn anything? Does Claim 1.3 have anything to say
about a situation where the same plaintext is encrypted more than once?
19Draft: January 3, 2021 CHAPTER 1. ONE-TIME PAD & KERCKHOFFS’ PRINCIPLE
1.12. There is nothing exclusively special about strings and XOR in OTP. We can get the same
properties using integers mod nand addition mod n.
This problem considers a variant of one-time pad, in which the keys, plaintexts, and ci-
phertexts are all elements of Zninstead off0;1gλ.
(a) What is the decryption algorithm that corresponds to the following encryption algo-
rithm?
Enc¹k;m2Znº:
return¹k+mº%n:
(b) Show that the output of the following subroutine is uniformly distributed in Zn:
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc0¹m2Znº:
k Zn
c:=¹k+mº%n
return c:
(c) It’s not just the distribution of keys that is important. The way that the key is combined
with the plaintext is also important. Show that the output of the following subroutine
isnotnecessarily uniformly distributed in Zn:
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc0¹m2Znº:
k Zn
c:=¹kmº%n
return c:
202The Basics of Provable Security
Edgar Allan Poe was not only an author, but also a cryptography enthusiast. He once
wrote, in a discussion on the state of the art in cryptography:1
“Human ingenuity cannot concoct a cipher which human ingenuity cannot resolve.”
This was an accurate assessment of the cryptography that existed in 1841. Whenever
someone would come up with an encryption method, someone else would inevitably /f_ind
a way to break it, and the cat-and-mouse game would repeat again and again.
Modern 21st-century cryptography, however, is diﬀerent. This book will introduce
you to many schemes whose security we can prove in a very speci/f_ic sense. The code-
makers canwin against the code-breakers.
It’s only possible to prove things about security by having formal de/f_initions of what
it means to be “secure.” This chapter is about the fundamental skills that revolve around
security de/f_initions: how to write them, how to understand & interpret them, how to
prove security using the hybrid technique , and how to demonstrate insecurity using attacks
against the security de/f_inition.
2.1 How to Write a Security Definition
So far the only form of cryptography we’ve seen is one-time pad, so our discussion of secu-
rity has been rather speci/f_ic to one-time pad. It would be preferable to have a vocabulary
to talk about security in a more general sense, so that we can ask whether anyencryption
scheme is secure.
In this section, we’ll develop two security de/f_initions for encryption.
What Doesn’t Go Into a Security Definition
A security de/f_inition should give guarantees about what can happen to a system in the
presence of an attacker. But not all important properties of a system refer to an attacker.
For encryption speci/f_ically:
IWe don’t reference any attacker when we say that the Encalgorithm takes two
arguments (a key and a plaintext), or that the KeyGen algorithm takes no arguments.
Specifying the types of inputs/outputs ( i.e., the “function signature”) of the various
algorithms is therefore not a statement about security. We call these properties the
syntax of the scheme.
1Edgar Allan Poe, “A Few Words on Secret Writing,” Graham’s Magazine , July 1841, v19.
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
IEven if there is no attacker, it’s still important that decryption is an inverse of en-
cryption. This is not a security property of the encryption scheme. Instead, we call
it acorrectness property.
Below are the generic de/f_initions for syntax and correctness of symmetric-key encryp-
tion:
Definition 2.1
(Encryption syntax)Asymmetric-key encryption (SKE) scheme consists of the following algorithms:
IKeyGen : a randomized algorithm that outputs a keyk2K.
IEnc: a (possibly randomized) algorithm that takes a key k2K andplaintext m2M
as input, and outputs a ciphertext c2C.
IDec: a deterministic algorithm that takes a key k2K and ciphertext c2Cas input,
and outputs a plaintext m2M .
We callKthekey space ,Mthemessage space , andCtheciphertext space of the scheme.
Sometimes we refer to the entire scheme (the collection of all three algorithms) by a single
variable Σ. When we do so, we write Σ:KeyGen ,Σ:Enc,Σ:Dec,Σ:K,Σ:M, andΣ:Cto refer
to its components.
Definition 2.2
(SKE correctness)An encryption scheme Σsatis/f_ies correctness if for all k2Σ:Kand all m2Σ:M,
Prh
Σ:Dec¹k;Σ:Enc¹k;mºº=mi
=1:
The de/f_inition is written in terms of a probability because Encis allowed to be a random-
ized algorithm. In other words, decrypting a ciphertext with the same key that was used
for encryption must always result in the original plaintext.
Example An encryption scheme can have the appropriate syntax but still have degenerate behavior like
Enc¹k;mº=0λ(i.e., every plaintext is “encrypted” to 0λ). Such a scheme would not satisfy
the correctness property.
A diﬀerent scheme de/f_ined by Enc¹k;mº=m(i.e., the “ciphertext” is always equal to the
plaintext itself) and Dec¹k;cº=cdoes satisfy the correctness property, but would not satisfy
any reasonable security property.
“Real-vs-Random” Style of Security Definition
Let’s try to make a security de/f_inition that formalizes the following intuitive idea:
“an encryption scheme is a good one if its ciphertexts look like random junk to
an attacker.”
Security de/f_initions always consider the attacker’s view of the system. What is the “in-
terface” that Alice & Bob expose to the attacker by their use of the cryptography, and does
that particular interface bene/f_it the attacker?
In this example, we’re considering a scenario where the attacker gets to observe ci-
phertexts. How exactly are these ciphertexts generated? What are the inputs to Enc(key
and plaintext), and how are they chosen?
22Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
IKey: It’s hard to imagine any kind of useful security if the attacker knows the key.
Hence, we consider that the key is kept secret from the attacker. Of course, the key
is generated according to the KeyGen algorithm of the scheme.
At this point in the course, we consider encryption schemes where the key is used
to encrypt only one plaintext. Somehow this restriction must be captured in our
security de/f_inition. Later, we will consider security de/f_initions that consider a key
that is used to encrypt many things.
IPlaintext: It turns out to be useful to consider that the attacker actually chooses the
plaintexts. This a “pessimistic” choice, since it gives much power to the attacker.
However, if the encryption scheme is indeed secure when the attacker chooses the
plaintexts, then it’s also secure in more realistic scenarios where the attacker has
some uncertainty about the plaintexts.
These clari/f_ications allow us to /f_ill in more speci/f_ics about our informal idea of security:
“an encryption scheme is a good one if its ciphertexts look like random junk to
an attacker : : :when each key is secret and used to encrypt only one plaintext,
even when the attacker chooses the plaintexts.”
A concise way to express all of these details is to consider the attacker as a calling
program to the following subroutine:
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
k Σ:KeyGen
c:=Σ:Enc¹k;mº
return c:
A calling program can choose the argument to the subroutine (in this case, a plaintext),
and see only the resulting return value (in this case, a ciphertext). The calling program
can’t see values of privately-scoped variables (like kin this case). If the calling program
makes many calls to the subroutine, a fresh key kis chosen each time.
The interaction between an attacker (calling program) and this /c.sc/t.sc/x.sc/t.sc subroutine ap-
pears to capture the relevant scenario. We would like to say that the outputs from the
/c.sc/t.sc/x.sc/t.sc subroutine are uniformly distributed. A convenient way of expressing this property
is to say that this /c.sc/t.sc/x.sc/t.sc subroutine should have the same eﬀect on every calling program
as a/c.sc/t.sc/x.sc/t.sc subroutine that (explicitly) samples its output uniformly.
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
k Σ:KeyGen
c:=Σ:Enc¹k;mº
return cvs./c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
c Σ:C
return c:
Intuitively, no calling program should have any way of determining which of these two
implementations is answering subroutine calls. As an analogy, one way of saying that “ /f.sc/o.sc/o.sc
is a correct sorting algorithm” is to say that “no calling program would behave diﬀerently
if/f.sc/o.sc/o.scwere replaced by an implementation of mergesort.”
In summary, we can de/f_ine security for encryption in the following way:
23Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
“an encryption scheme is a good one if, when you plug its KeyGen andEncalgo-
rithms into the template of the /c.sc/t.sc/x.sc/t.sc subroutine above, the two implementations
of/c.sc/t.sc/x.sc/t.sc induce identical behavior in every calling program.”
In a few pages, we introduce formal notation and de/f_initions for the concepts introduced
here. In particular, both the calling program and subroutine can be randomized algorithms,
so we should be careful about what we mean by “identical behavior.”
Example One-time pad is de/f_ined with KeyGen sampling kuniformly fromf0;1gλandEnc¹k;mº=
km. It satis/f_ies our new security property since, when we plug in this algorithms into the
above template, we get the following two subroutine implementations:
/c.sc/t.sc/x.sc/t.sc¹mº:
k f0;1gλ//KeyGen of OTP
c:=km //Encof OTP
return cvs./c.sc/t.sc/x.sc/t.sc¹mº:
c f0;1gλ//Cof OTP
return c;
and these two implementations have the same eﬀect on all calling programs.
“Le/f_t-vs-Right” Style of Security Definition
Here’s a diﬀerent intuitive idea of security:
“an encryption scheme is a good one if encryptions of mLlook like encryptions
ofmRto an attacker (for all possible mL,mR)”
As above, we are considering a scenario where the attacker sees some ciphertext(s).
These ciphertexts are generated with some key; where does that key come from? These
ciphertexts encrypt either some mLor some mR; where do mLandmRcome from? We can
answer these questions in a similar way as the previous example. Plaintexts mLandmR
can be chosen by the attacker. The key is chosen according to KeyGen so that it remains
secret from the attacker (and is used to generate only one ciphertext).
“an encryption scheme is a good one if encryptions of mLlook like encryptions of
mRto an attacker, when each key is secret and used to encrypt only one plaintext,
even when the attacker chooses mLandmR.”
As before, we formalize this idea by imagining the attacker as a program that calls a par-
ticular interface. This time, the attacker will choose two plaintexts mLandmR, and get
a ciphertext in return.2Depending on whether mLormRis actually encrypted, those
interfaces are implemented as follows:
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
k Σ:KeyGen
c:=Σ:Enc¹k;mLº
return c;/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
k Σ:KeyGen
c:=Σ:Enc¹k;mRº
return c:
2There may be other reasonable ways to formalize this intuitive idea of security. For example, we might
choose to give the attacker twociphertexts instead of one, and demand that the attacker can’t determine which
of them encrypts mLand which encrypts mR. See Exercise 2.15.
24Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
Now the formal way to say that encryptions of mL“look like” encryptions of mRis:
“an encryption scheme is a good one if, when you plug its KeyGen andEnc
algorithms into the template of the /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc subroutines above, the two imple-
mentations of /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc induce identical behavior in every calling program.”
Example Does one-time pad satisfy this new security property? To /f_ind out, we plug in its algorithms
to the above template, and obtain the following implementations:
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
k f0;1gλ//KeyGen of OTP
c:=kmL//Encof OTP
return c/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
k f0;1gλ//KeyGen of OTP
c:=kmR//Encof OTP
return c
If these two implementations have the same eﬀect on all calling programs (and indeed they
do), then we would say that OTP satis/f_ies this security property.
Is this a better/worse way to de/f_ine security than the previous way? One security
de/f_inition considers an attacker whose goal is to distinguish real ciphertexts from ran-
dom values (real-vs-random paradigm), and the other considers an attacker whose goal is
to distinguish real ciphertexts of two diﬀerent plaintexts (left-vs-right paradigm). Is one
“correct” and the other one “incorrect?” We save such discussion until later in the chapter.
2.2 Formalisms for Security Definitions
So far, we’ve de/f_ined security in terms of a single, self-contained subroutine, and imagined
the attacker as a program that calls this subroutine. Later in the course we will need to
generalize beyond a single subroutine, to a collection of subroutines that share common
(private) state information. Staying with the software terminology, we call this collection
alibrary :
Definition 2.3
(Libraries)AlibraryLis a collection of subroutines and private/static variables. A library’s interface
consists of the names, argument types, and output type of all of its subroutines (just like a
Java interface). If a program Aincludes calls to subroutines in the interface of L, then we
writeAL to denote the result of linkingAtoLin the natural way (answering those
subroutine calls using the implementation speci/f_ied in L). We writeAL) zto denote
the event that program AL outputs the value z.
IfAorLis a program that makes random choices, then the output of AL is a
random variable. It is often useful to consider probabilities like Pr»AL) true¼.
Example Here is a familiar library:
L
/c.sc/t.sc/x.sc/t.sc¹mº:
k f0;1gλ
c:=km
return c
25Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
And here is one possible calling program:
A:
m f0;1gλ
c:=/c.sc/t.sc/x.sc/t.sc¹mº
return m?=c
You can hopefully convince yourself that
Pr»AL) true¼=12λ:
If thisAis linked to a diﬀerent library, its output probability may be diﬀerent. If a diﬀerent
calling program is linked to this L, the output probability may be diﬀerent.
Example A library can contain several subroutines and private variables that are kept static between
subroutine calls. For example, here is a simple library that picks a string suniformly and
allows the calling program to guess s.
L
s f0;1gλ
/r.sc/e.sc/s.sc/e.sc/t.sc¹º:
s f0;1gλ
/g.sc/u.sc/e.sc/s.sc/s.sc¹x2f0;1gλº:
return x?=s
Our convention is that code outside of a subroutine (like the /f_irst line here) is run once at
initialization time. Variables de/f_ined at initialization time (like shere) are available in all
subroutine scopes (but not to the calling program).
Interchangeability
The idea that “no calling program behaves diﬀerently in the presence of these two li-
braries” still makes sense even for libraries with several subroutines. Since this is such a
common concept, we devote new notation to it:
Definition 2.4
(Interchangeable)LetLle/f_tandLrightbe two libraries that have the same interface. We say that Lle/f_tandLright
areinterchangeable , and writeLle/f_tL right, if for all programs Athat output a boolean
value,
Pr»AL le/f_t)true¼=Pr»AL right)true¼:
This de/f_inition considers calling programs that give boolean output. Imagine a calling
program / attacker whose only goal is to distinguish two particular libraries (indeed, we
often refer to the calling program as a distinguisher ). A boolean output is enough for
that task. You can think of the output bit as the calling program’s “guess” for which library
the calling program thinks it is linked to.
26Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
The distinction between “calling program outputs true ” and “calling program outputs
false ” is not signi/f_icant. If two libraries don’t aﬀect the calling program’s probability of
outputting true , then they also don’t aﬀect its probability of outputting false :
Pr»AL le/f_t)true¼=Pr»AL right)true¼
, 1 Pr»AL le/f_t)true¼=1 Pr»AL right)true¼
, Pr»AL le/f_t)false¼=Pr»AL right)false¼:
Example Here are some very simple and straightforward ways that two libraries may be interchange-
able. Hopefully it’s clear that each pair of libraries has identical behavior, and therefore
identical eﬀect on all calling programs.
Despite being very simple examples, each of these concepts shows up as a building block
in a real security proof in this book.
/f.sc/o.sc/o.sc¹xº:
ifxis even:
return 0
else if xis odd:
return 1
else:
return -1/f.sc/o.sc/o.sc¹xº:
ifxis even:
return 0
else if xis odd:
return 1
else:
return1Their only diﬀerence happens in an un-
reachable block of code.
/f.sc/o.sc/o.sc¹xº:
return /b.sc/a.sc/r.sc¹x;xº
/b.sc/a.sc/r.sc¹a;bº:
k f0;1gλ
return ka/f.sc/o.sc/o.sc¹xº:
return /b.sc/a.sc/r.sc¹x;0λº
/b.sc/a.sc/r.sc¹a;bº:
k f0;1gλ
return kaTheir only diﬀerence is the value they as-
sign to a variable that is never actually
used.
/f.sc/o.sc/o.sc¹x;nº:
fori=1toλ:
/b.sc/a.sc/r.sc¹x;iº/f.sc/o.sc/o.sc¹x;nº:
fori=1ton:
/b.sc/a.sc/r.sc¹x;iº
fori=n+1toλ:
/b.sc/a.sc/r.sc¹x;iºTheir only diﬀerence is that one library
unrolls a loop that occurs in the other li-
brary.
/f.sc/o.sc/o.sc¹xº:
k f0;1gλ
/y.alt f0;1gλ
return k/y.altx/f.sc/o.sc/o.sc¹xº:
k f0;1gλ
return k/b.sc/a.sc/r.sc¹xº
/b.sc/a.sc/r.sc¹xº:
/y.alt f0;1gλ
return/y.altxTheir only diﬀerence is that one library
inlines a subroutine call that occurs in
the other library.
Example Here are more simple examples of interchangeable libraries that involve randomness:
27Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
/f.sc/o.sc/o.sc¹º:
x f0;1gλ
/y.alt f0;1gλ
return xk/y.alt/f.sc/o.sc/o.sc¹º:
z f0;1g2λ
return zThe uniform distribution over strings acts inde-
pendently on diﬀerent characters in the string (“ k”
refers to concatenation).
k f0;1gλ
/f.sc/o.sc/o.sc¹xº:
return kx/f.sc/o.sc/o.sc¹xº:
ifknot de/f_ined:
k f0;1gλ
return kxSampling a value “eagerly” (as soon as possible)
vs. sampling a value “lazily” (at the last possible
moment before the value is needed). We assume
thatkis static/global across many calls to /f.sc/o.sc/o.sc,
and initially unde/f_ined.
Formal Restatements of Previous Concepts
We can now re-state our security de/f_initions from the previous section, using this new
terminology.
Our “real-vs-random” style of security de/f_inition for encryption can be expressed as
follows:
Definition 2.5
(Uniform ctxts)An encryption scheme Σhasone-time uniform ciphertexts if:
LΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
k Σ:KeyGen
c Σ:Enc¹k;mº
return cLΣ
ots$-rand
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
c Σ:C
return c
In other words, if you /f_ill in the speci/f_ics of Σ(i.e., the behavior of its KeyGen andEnc)
into these two library “templates,” and you get two libraries that are interchangeable ( i.e.,
have the same eﬀect on all calling programs), we will say that Σhas one-time uniform
ciphertexts.
Throughout this course, we will use the “ $” symbol to denote randomness (as in real-
vs-random).3
Our “left-vs-right” style of security de/f_inition can be expressed as follows:
Definition 2.6
(One-time secrecy)An encryption scheme Σhasone-time secrecy if:
LΣ
ots-L
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
k Σ:KeyGen
c Σ:Enc¹k;mLº
return cLΣ
ots-R
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
k Σ:KeyGen
c Σ:Enc¹k;mRº
return c
3It is quite common in CS literature to use the “ $” symbol when referring to randomness. This stems
from thinking of randomized algorithms as algorithms that “toss coins.” Hence, randomized algorithms need
to have spare change (i.e., money) sitting around. By convention, randomness comes in US dollars.
28Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
Previously in Claim 1.3 we argued that one-time-pad ciphertexts follow the uniform
distribution. This actually shows that OTP satis/f_ies the uniform ciphertexts de/f_inition:
Claim 2.7
(OTP rule)One-time pad satis/f_ies the one-time uniform ciphertexts property. In other words:
Lotp-real
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹m2f0;1gλº:
k f0;1gλ//OTP:KeyGen
return km//OTP:Enc¹k;mºLotp-rand
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹m2f0;1gλº:
c f0;1gλ//OTP:C
return c
Because this property of OTP is quite useful throughout the course, I’ve given these
two libraries special names (apart from LOTP
ots$-realandLOTP
ots$-rand).
Discussion, Pitfalls
It is a common pitfall to imagine the calling program Abeing simultaneously linked to
both libraries, but this is not what the de/f_inition says. The de/f_inition of L1L 2refers to
two diﬀerent executions: one where Ais linked only toL1for its entire lifetime, and one
whereAis linked only toL2for its entire lifetime. There is never a time where some of
A’s subroutine calls are answered by L1and others byL2. This is an especially important
distinction whenAmakes several subroutine calls in a single execution.
Another common pitfall is confusion about the diﬀerence between the algorithms of
an encryption scheme ( e.g., what is shown in Construction 1.1) and the libraries used in a
security de/f_inition ( e.g., what is shown in De/f_inition 2.6). The big diﬀerence is:
IThe algorithms of the scheme show a regular user’s view of things. For example,
theEncalgorithm takes two inputs: a key and a plaintext. Is there any way of
describing an algorithm that takes two arguments other than writing something
like Construction 1.1?
IThe libraries capture the attacker’s view of of a particular scenario, where the users
use the cryptographic algorithms in a very speci/f_ic way. For example, when we talk
about security of encryption, we don’t guarantee security when Alice lets the at-
tacker choose her encryption key! But letting the attacker choose the plaintext is
/f_ine; we can guarantee security in that scenario. That’s why De/f_inition 2.5 describes
a subroutine that calls Encon a plaintext that is chosen by the calling program, but
on a key kchosen by the library.
A security de/f_inition says that some task ( e.g., distinguishing ciphertexts from ran-
dom junk) is impossible, when the attacker is allowed certain in/f_luence over the
inputs to the algorithms ( e.g., full choice of plaintexts, but no in/f_luence over the
key), and is allowed to see certain outputs from those algorithms ( e.g., ciphertexts).
It’swrong to summarize one-time secrecy as: “I’m not allowed to choose what to
encrypt, I have to ask the attacker to choose for me.” The correct interpretation is: “If I
encrypt only one plaintext per key, then I am safe to encrypt things even if the attacker
sees the resulting ciphertext and even if she has some in/f_luence or partial information on
what I’m encrypting, because this is the situation captured in the one-time secrecy library.”
29Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
Kerckhoﬀs’ Principle, Revisited
Kerckhoﬀs’ Principle says to assume that the attacker has complete knowledge of the
algorithms being used. Assume that the choice of keys is the only thing unknown to the
attacker. Let’s see how Kerckhoﬀs’ Principle is re/f_lected in our formal security de/f_initions.
Suppose I write down the source code of two libraries, and your goal is to write an
eﬀective distinguisher. So you study the source code of the two libraries and write the
best distinguisher that exists. It would be fair to say that your distinguisher “knows”
what algorithms are used in the libraries, because it was designed based on the source
code of these libraries. The de/f_inition of interchangeability considers literally every calling
program, so it must also consider calling programs like yours that “know” what algorithms
are being used.
However, there is an important distinction to make. If you know you might be linked
to a library that executes the statement “ k f 0;1gλ”, that doesn’t mean you know the
actual value ofkthat was chosen at runtime. Our convention is that all variables within the
library are privately scoped, and the calling program can learn about them only indirectly
through subroutine outputs. In the library-distinguishing game, you are not allowed to
pick a diﬀerent calling program based on random choices that the library makes! After
we settle on a calling program, we measure its eﬀectiveness in terms of probabilities that
take into account all possible outcomes of the random choices in the system.
In summary, the calling program “knows” what algorithms are being used (and how
they are being used!) because the choice of the calling program is allowed to depend on
the 2 speci/f_ic libraries that we consider. The calling program “doesn’t know” things like
secret keys because the choice of calling program isn’t allowed to depend on the outcome
of random sampling done at runtime.
Kerckhoﬀs’ Principle, applied to our formal terminology:
Assume that the attacker knows every fact in the universe, except for:
1. which of the two possible libraries it is linked to in any particular execu-
tion, and
2. the random choices that the library will make during any particular ex-
ecution (which are usually assigned to privately scoped variables within
the library).
2.3 How to Demonstrate Insecurity with A/t_tacks
We always de/f_ine security with respect to two libraries — or, if you like, two library tem-
plates that describe how to insert the algorithms of a cryptographic scheme into two li-
braries. If the two libraries that you get (after /f_illing in the speci/f_ics of a particular scheme)
are interchangeable, then we say that the scheme satis/f_ies the security property. If we want
to show that some scheme is insecure , we have to demonstrate just one calling program
that behaves diﬀerently in the presence of those two libraries.
Let’s demonstrate this process with the following encryption scheme, which is like
one-time pad but uses bitwise- /a.sc/n.sc/d.sc instead of /x.sc/o.sc/r.sc:
30Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
Construction 2.8 K=f0;1gλ
M=f0;1gλ
C=f0;1gλKeyGen :
k f0;1gλ
return kEnc¹k;mº:
return k&m// bitwise- /a.sc/n.sc/d.sc
I haven’t shown the Dec algorithm, because in fact there is no way to write one that
satis/f_ies the correctness requirement. But let’s pretend we haven’t noticed that yet, and ask
whether this encryption scheme satis/f_ies the two security properties de/f_ined previously.
Claim 2.9 Construction 2.8 does nothave one-time uniform ciphertexts (De/f_inition 2.5).
Proof To see whether Construction 2.8 satis/f_ies uniform one-time ciphertexts, we have to plug
in its algorithms into the two libraries of De/f_inition 2.5 and see whether the resulting
libraries are interchangeable. We’re considering the following two libraries:
LΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹m2f0;1gλº:
k f0;1gλ//Σ:KeyGen
c:=k&m //Σ:Enc
return cLΣ
ots$-rand
/c.sc/t.sc/x.sc/t.sc¹m2f0;1gλº:
c f0;1gλ//Σ:C
return c
To show that these two libraries are notinterchangeable, we need to write a calling pro-
gram that behaves diﬀerently in their presence. The calling program should make one
or more calls to the /c.sc/t.sc/x.sc/t.sc subroutine. That means it needs to choose the input mthat it
passes, and it must make some conclusion (about which of the two libraries it is linked to)
based on the return value that it gets. What mshould the calling program choose as input
to/c.sc/t.sc/x.sc/t.sc ? What should the calling program look for in the return values?
There are many valid ways to write a good calling program, and maybe you can think
of several. One good approach is to observe that bitwise- /a.sc/n.sc/d.sc with kcan never “turn a
0into a 1.” So perhaps the calling program should choose mto consist of all 0s. When
m=0λ, theLots$-real library will always return all zeroes, but the Lots$-rand library may
return strings with both 0s and 1s.
We can formalize this idea with the following calling program:
A:
c:=/c.sc/t.sc/x.sc/t.sc¹0λº
return c?=0λ:
Next, let’s ensure that this calling program behaves diﬀerently when linked to each of
these two libraries.
31Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
A:
c:=/c.sc/t.sc/x.sc/t.sc¹0λº
return c?=0λLΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹mº:
k f0;1gλ
c:=k&m
return cWhenAis linked toLots$-real ,cis computed as k&0λ.
No matter what kis, the result is always all-zeroes.
Therefore,Awill always return true .
In other words, Pr»AL ots$-real)true¼=1.
A:
c:=/c.sc/t.sc/x.sc/t.sc¹0λº
return c?=0λLΣ
ots$-rand
/c.sc/t.sc/x.sc/t.sc¹mº:
c f0;1gλ
return cWhenAis linked toLots$-rand ,cis chosen uniformly
fromf0;1gλ. The probability that cthen happens to
be all-zeroes is 12λ.
In other words, Pr»AL ots$-rand)true¼=12λ.
Since these two probabilities are diﬀerent, this shows that LΣ
ots$-real.LΣ
ots$-rand. In
other words, the scheme does not satisfy this uniform ciphertexts property. 
So far we have two security de/f_initions. Does this encryption scheme satisfy one but
not the other?
Claim 2.10 Construction 2.8 does notsatisfy one-time secrecy (De/f_inition 2.6).
Proof This claim refers to a diﬀerent security de/f_inition, which involves two diﬀerent libraries.
When we plug in the details of Construction 2.8 into the libraries of De/f_inition 2.6, we get
the following:
LΣ
ots-L
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
k f0;1gλ//Σ:KeyGen
c:=k&mL//Σ:Enc¹k;mLº
return cLΣ
ots-R
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
k f0;1gλ//Σ:KeyGen
c:=k&mR//Σ:Enc¹k;mRº
return c
Now we need to write a calling program that behaves diﬀerently in the presence of these
two libraries. We can use the same overall idea as last time, but not the same actual calling
program, since these libraries provide a diﬀerent interface. In this example, the calling
program needs to call the /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc subroutine which takes twoarguments mLandmR.
How should the calling program choose mLandmR? Which two plaintexts have diﬀerent
looking ciphertexts?
A good approach is to choose mLto be all zeroes and mRto be all ones. We know
from before that an all-zeroes plaintext always encrypts to an all-zeroes ciphertext, so the
calling program can check for that condition. More formally, we can de/f_ine the calling
program:
A:
c:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹0λ;1λº
return c?=0λ
Next, we need to compute its output probabilities in the presence of the two libraries.
32Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
A:
c:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹0λ;1λº
return c?=0λLΣ
ots-L
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
k f0;1gλ
c:=k&mL
return cWhenAis linked toLots-L,cis
computed as an encryption of mL=
0λ. No matter what kis, the result
is always all-zeroes. So,
Pr»AL ots-L)true¼=1:
A:
c:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹0λ;1λº
return c?=0λLΣ
ots-R
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
k f0;1gλ
c:=k&mR
return cWhenAis linked toLots-R,cis
computed as an encryption of mR=
1λ. In other words, c:=k&1λ.
But the bitwise- /a.sc/n.sc/d.sc of any string k
with all 1s is just kitself. So cis just
equal to k, which was chosen uni-
formly at random. The probability
that a uniformly random chappens
to be all-zeroes is
Pr»AL ots-R)true¼=12λ:
Since these two probabilities are diﬀerent, LΣ
ots-L.LΣ
ots-Rand the scheme does not
have one-time secrecy. 
2.4 How to Prove Security with The Hybrid Technique
We proved that one-time pad satis/f_ies the uniform ciphertexts property (Claim 1.3) by
carefully calculating certain probabilities. This will not be a sustainable strategy as things
get more complicated later in the course. In this section we will introduce a technique for
proving security properties, which usually avoids tedious probability calculations.
Chaining Several Components
Before getting to a security proof, we introduce a convenient lemma. Consider a com-
pound program like AL 1L 2. Our convention is that subroutine calls only happen
from left to right across the symbol, so in this example, L1can make calls to subroutines
inL2, but not vice-versa. Depending on the context, it can sometimes be convenient to
interpretAL 1L 2as:
I¹AL 1ºL 2: acompound calling program linked toL2. After all,AL 1is a
program that makes calls to the interface of L2.
Ior:A¹L 1L 2º:Alinked to a compound library . After all,Ais a program that
makes calls to the interface of ¹L1L 2º.
The placement of the parentheses does not aﬀect the functionality of the overall program,
just like how splitting up a real program into diﬀerent source /f_iles doesn’t aﬀect its func-
tionality.
33Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
In fact, every security proof in this book will have some intermediate steps that involve
compound libraries. We will make heavy use of the following helpful result:
Lemma 2.11
(Chaining)IfLle/f_tL rightthen, for any library L, we haveLL le/f_tLL right.
Proof Note that we are comparing LL le/f_tandLL rightas compound libraries. Hence we
consider a calling program Athat is linked to either LL le/f_torLL right.
LetAbe such an arbitrary calling program. We must show that A¹LL le/f_tºand
A¹LLrightºhave identical output distributions. As mentioned above, we can interpret
ALL le/f_tas a calling program Alinked to the library LL le/f_t, but also as a calling
programALlinked to the library Lle/f_t. SinceLle/f_tL right, swappingLle/f_tforLright
has no eﬀect on the output of any calling program. In particular, it has no eﬀect when the
calling program happens to be the compound program AL. Hence we have:
Pr»A¹LL le/f_tº) true¼=Pr»¹ALºL le/f_t)true¼ (change of perspective)
=Pr»¹ALºL right)true¼ (sinceLle/f_tL right)
=Pr»A¹LL rightº) true¼:(change of perspective)
SinceAwas arbitrary, we have proved the lemma. 
An Example Hybrid Proof
In this section we will prove something about the following scheme, which encrypts twice
with OTP, using independent keys:
Construction 2.12
(“Double OTP”) K=¹f0;1gλº2
M=f0;1gλ
C=f0;1gλKeyGen :
k1 f0;1gλ
k2 f0;1gλ
return¹k1;k2ºEnc
¹k1;k2º;m
:
c1:=k1m
c2:=k2c1
return c2Dec
¹k1;k2º;c2
:
c1:=k2c2
m:=k1c1
return m
It would not be too hard to directly show that ciphertexts in this scheme are uniformly
distributed, as we did for plain OTP. However, the new hybrid technique will allow us to
leverage what we already know about OTP in an elegant way, and avoid any probability
calculations.
Claim 2.13 Construction 2.12 has one-time uniform ciphertexts (De/f_inition 2.6).
Proof In terms of libraries, we must show that:
LΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλo
KeyGenk2 f0;1gλ
c1:=k1m
c2:=k2c1)
Enc
return c2LΣ
ots$-rand
/c.sc/t.sc/x.sc/t.sc¹mº:
c f0;1gλ
return c
34Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
Instead of directly comparing these two libraries, we will introduce some additional li-
brariesLhyb- 1,Lhyb- 2,Lhyb- 3, and show that:
LΣ
ots$-realL hyb- 1L hyb- 2L hyb- 3LΣ
ots$-rand
Since thesymbol is transitive, this will achieve our goal.
The intermediate libraries are called hybrids , since they will contain a mix of char-
acteristics from the two “endpoints” of this sequence. These hybrids are chosen so that it
is very easy to show that consecutive libraries in this sequence are interchangeable. The
particular hybrids we have in mind here are:
LΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλ
k2 f0;1gλ
c1:=k1m
c2:=k2c1
return c2/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλ
c1:=k1m
c2:=/c.sc/t.sc/x.sc/t.sc0¹c1º
return c2Lotp-real
/c.sc/t.sc/x.sc/t.sc0¹m0º:
k f0;1gλ
return km0
|                                              {z                                              }
Lhyb- 1/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλ
c1:=k1m
c2:=/c.sc/t.sc/x.sc/t.sc0¹c1º
return c2Lotp-rand
/c.sc/t.sc/x.sc/t.sc0¹m0º:
c f0;1gλ
return c
|                                          {z                                          }
Lhyb- 2/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλ
c1:=k1m
c2 f0;1gλ
return c2
|              {z              }
Lhyb- 3LΣ
ots$-rand
/c.sc/t.sc/x.sc/t.sc¹mº:
c2 f0;1gλ
return c2
Next, we provide a justi/f_ication for each “ ” in the expression above. For each pair of
adjacent libraries, we highlight their diﬀerences below:
LΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλ
k2 f0;1gλ
c1:=k1m
c2:=k2c1
return c2/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλ
c1:=k1m
c2:=/c.sc/t.sc/x.sc/t.sc0¹c1º
return c2Lotp-real
/c.sc/t.sc/x.sc/t.sc0¹m0º:
k f0;1gλ
return km0
|                                                  {z                                                  }
Lhyb- 1
The only diﬀerence between these two libraries is that the highlighted expressions have
been factored out into a separate subroutine, and some variables have been renamed. In
both libraries, c2is chosen as the /x.sc/o.sc/r.scofc1and a uniformly chosen string. These diﬀerences
make no eﬀect on the calling program. Importantly, the subroutine that we have factored
out is exactly the one in the Lotp-real library (apart from renaming the subroutine).
/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλ
c1:=k1m
c2:=/c.sc/t.sc/x.sc/t.sc0¹c1º
return c2Lotp-real
/c.sc/t.sc/x.sc/t.sc0¹m0º:
k f0;1gλ
return km0
|                                                {z                                                }
Lhyb- 1/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλ
c1:=k1m
c2:=/c.sc/t.sc/x.sc/t.sc0¹c1º
return c2Lotp-rand
/c.sc/t.sc/x.sc/t.sc0¹m0º:
c f0;1gλ
return c
|                                            {z                                            }
Lhyb- 2
Claim 2.7 says thatLotp-realL otp-rand , so Lemma 2.11 says that we can replace an instance
ofLotp-real in a compound library with Lotp-rand , as we have done here. This change will
have no eﬀect on the calling program.
35Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλ
c1:=k1m
c2:=/c.sc/t.sc/x.sc/t.sc0¹c1º
return c2Lotp-rand
/c.sc/t.sc/x.sc/t.sc0¹m0º:
c f0;1gλ
return c
|                                            {z                                            }
Lhyb- 2/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλ
c1:=k1m
c2 f0;1gλ
return c2
|               {z               }
Lhyb- 3
The only diﬀerence between these two libraries is that a subroutine call has been inlined.
This diﬀerence has no eﬀect on the calling program.
/c.sc/t.sc/x.sc/t.sc¹mº:
k1 f0;1gλ
c1:=k1m
c2 f0;1gλ
return c2
|               {z               }
Lhyb- 3LΣ
ots$-rand
/c.sc/t.sc/x.sc/t.sc¹mº:
c2 f0;1gλ
return c2
The only diﬀerence between these two libraries is that the two highlighted lines have been
removed. But it should be clear that these lines have no eﬀect: k1is used only to compute
c1, which is never used again. Hence, this diﬀerence has no eﬀect on the calling program.
The /f_inal hybrid is exactly LΣ
ots$-rand(although with a variable name changed). We
have shown thatLΣ
ots$-randLΣ
ots$-real, meaning that this encryption scheme has one-time
uniform ciphertexts. 
Summary of the Hybrid Technique
We have now seen our /f_irst example of the hybrid technique for security proofs. All secu-
rity proofs in this book use this technique.
IProving security means showing that two particular libraries, say Lle/f_tandLright,
are interchangeable.
IOftenLle/f_tandLrightare signi/f_icantly diﬀerent, making them hard to compare di-
rectly. To make the comparison more manageable, we can show a sequence of hybrid
libraries, beginning with Lle/f_tand ending withLright. The idea is to break up the
large “gap” between Lle/f_tandLrightinto smaller ones that are easier to justify.
IIt is helpful to think of “starting” at Lle/f_t, and then making a sequence of small
modi/f_ications to it, with the goal of eventually reaching Lright. You must justify
why each modi/f_ication doesn’t aﬀect the calling program ( i.e., why the two libraries
before/after your modi/f_ication are interchangeable).
IAs discussed in Section 2.2, simple things like inlining/factoring out subroutines,
changing unused variables, changing unreachable statements, or unrolling loops
are always “allowable” modi/f_ications in a hybrid proof since they have no eﬀect on
36Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
the calling program. As we progress in the course, we will see more kinds of useful
modi/f_ications.
A Contrasting Example
Usually the boundary between secure and insecure is razor thin. Let’s make a small change
to the previous encryption scheme to illustrate this point. Instead of applying OTP to the
plaintext twice, with independent keys, what would happen if we use the same key?
Construction 2.14
(“dOuB `9OTP”)K=f0;1gλ
M=f0;1gλ
C=f0;1gλKeyGen :
k f0;1gλ
return kEnc¹k;mº:
c1:=km
c2:=kc1
return c2Dec¹k;c2º:
c1:=kc2
m:=kc1
return m
You probably noticed that the ciphertext c2is computed as c2:=k¹kmº, which is
just a fancy way of saying c2:=m. There is certainly no way this kind of “double-OTP” is
secure.
For educational purposes, let’s try to repeat the steps of our previous security proof
on this (insecure) scheme and see where things break down. If we wanted to show that
Construction 2.14 has uniform ciphertexts, we would have to show that the following two
libraries are interchangeable:
LΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹mº:
k f0;1gλ//KeyGen
c1:=km
c2:=kc1)
Enc
return c2?LΣ
ots$-rand
/c.sc/t.sc/x.sc/t.sc¹mº:
c f0;1gλ
return c
In the previous hybrid proof, the /f_irst step was to factor out the statements “ k2 f0;1gλ;
c2:=k2c1” into a separate subroutine, so we could argue that the result of c2was
uniformly distributed. If we do something analogous with this example, we get:
LΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹mº:
k f0;1gλ
c1:=km
c2:=kc1
return c2?/c.sc/t.sc/x.sc/t.sc¹mº:
c1:=km// ??
c2:=/c.sc/t.sc/x.sc/t.sc0¹c1º
return c2Lotp-real
/c.sc/t.sc/x.sc/t.sc0¹m0º:
k f0;1gλ
return km0
|                                                  {z                                                  }
Lhyb
Do you see the problem? In “ Lhyb”, we have tried to move the variable kintoLotp-real .
Since this scope is private, every operation we want to do with khas to be provided by
its container library Lotp-real . But there is a mismatch: Lotp-real only gives us a way to use
kin one /x.sc/o.sc/r.sc expression, whereas we need to use the same kin two /x.sc/o.sc/r.sc expressions to
37Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
match the behavior of Lots$-real . The compound library Lhybhas an unresolved reference
tokin the line “ c1:=km,” and therefore doesn’t have the same behavior as Lots$-real .4
This is the step of the security proof that breaks down.
Here’s a more conceptual way to understand what went wrong here. The important
property of OTP is that its ciphertexts look uniform when the key is used to encrypt only one
plaintext . This “double OTP” variant uses OTP in a way that doesn’t ful/f_ill that condition,
and therefore provides no security guarantee. The previous (successful) proof was able to
factor out some /x.sc/o.sc/r.sc’s in terms ofLotp-real without breaking anything, and that’s how we
know the scheme was using OTP in a way that is consistent with its security guarantee.
As you can hopefully see, the process of a security proof provides a way to catch these
kinds of problems. It is very common in a hybrid proof to factor out some statements
in terms of a library from some other security de/f_inition. This step can only be done
successfully if the underlying cryptography is being used in an appropriate way.
2.5 How to Compare/Contrast Security Definitions
In math, a de/f_inition can’t really be “wrong,” but it can be “not as useful as you hoped” or
it can “fail to adequately capture your intuition” about the concept.
Security de/f_initions are no diﬀerent. In this chapter we introduced two security de/f_ini-
tions: one in the “real-vs-random” style and one in the “left-vs-right” style. In this section
we treat the security de/f_initions themselves as objects worth studying. Are both of these
security de/f_initions “the same,” in some sense? Do they both capture all of our intuitions
about security?
One Security Definition Implies Another
One way to compare/contrast two security de/f_initions is to prove that one implies the
other. In other words, if an encryption scheme satis/f_ies de/f_inition #1, then it also satis/f_ies
de/f_inition #2.
Theorem 2.15 If an encryption scheme Σhas one-time uniform ciphertexts (De/f_inition 2.5), then Σalso has
one-time secrecy (De/f_inition 2.6). In other words:
LΣ
ots$-realLΣ
ots$-rand=) LΣ
ots-LLΣ
ots-R:
If you are comfortable with what all the terminology means, then the meaning of this
statement is quite simple and unsurprising. “If all plaintexts minduce a uniform distribu-
tion of ciphertexts, then all minduce the same distribution of ciphertexts.”
This fairly straight-forward statement can be proven formally, giving us another ex-
ample of the hybrid proof technique:
Proof We are proving an if-then statement. We want to show that the “then”-part of the state-
ment is true; that is, LΣ
ots-LLΣ
ots-R. We are allowed to use the fact that the “if”-part is
true; that is,LΣ
ots$-realLΣ
ots$-rand.
4I would say that the library “doesn’t compile” due to a scope/reference error.
38Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
The proof uses the hybrid technique. We will start with the library Lots-L, and make a
small sequence of justi/f_iable changes to it, until /f_inally reaching Lots-R. Along the way, we
can use the fact that Lots$-realL ots$-rand . This suggests some “strategy” for the proof: if
we can somehow get Lots$-real to appear as a component in one of the hybrid libraries, then
we can replace it with Lots$-rand (or vice-versa), in a way that hopefully makes progress
towards our goal of transforming Lots-LtoLots-R.
Below we list the sequence of hybrid libraries, and justify why each one is interchange-
able with the previous library.
LΣ
ots-L
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
k Σ:KeyGen
c Σ:Enc¹k;mLº
return cThe starting point of our hybrid sequence
isLΣ
ots-L.
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=/c.sc/t.sc/x.sc/t.sc¹mLº
return cLΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹mº:
k Σ:KeyGen
c Σ:Enc¹k;mº
return cFactoring out a block of statements into a
subroutine makes it possible to write the
library as a compound one, but does not
aﬀect its external behavior. Note that the
new subroutine is exactly the LΣ
ots$-realli-
brary from De/f_inition 2.5. This was a
strategic choice, because of what hap-
pens next.
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=/c.sc/t.sc/x.sc/t.sc¹mLº
return cLΣ
ots$-rand
/c.sc/t.sc/x.sc/t.sc¹mº:
c Σ:C
return cLΣ
ots$-realhas been replaced with
LΣ
ots$-rand. The chaining lemma
Lemma 2.11 says that this change
has no eﬀect on the library’s behav-
ior, since the twoLots$-?libraries are
interchangeable.
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=/c.sc/t.sc/x.sc/t.sc¹mRº
return cLΣ
ots$-rand
/c.sc/t.sc/x.sc/t.sc¹mº:
c Σ:C
return cThe argument to /c.sc/t.sc/x.sc/t.sc has been changed
from mLtomR. This has no eﬀect on the
library’s behavior since /c.sc/t.sc/x.sc/t.sc does not ac-
tually use its argument in these hybrids!
The previous transition is the most important one in the proof, as it gives insight into how
we came up with this particular sequence of hybrids. Looking at the desired endpoints of
our sequence of hybrids — LΣ
ots-LandLΣ
ots-R— we see that they diﬀer only in swapping
mLformR. If we are not comfortable eyeballing things, we’d like a better justi/f_ication for
why it is “safe” to exchange mLformR(i.e., why it has no eﬀect on the calling program).
However, the uniform ciphertexts property shows that LΣ
ots-Lin fact has the same behavior
as a libraryLhyb- 2that doesn’t use either of mLormR. In a program that doesn’t use mL
ormR, it is clear that we can switch them!
39Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
Having made this crucial change, we can now perform the same sequence of steps, but
in reverse.
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=/c.sc/t.sc/x.sc/t.sc¹mRº
return cLΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹mº:
k Σ:KeyGen
c Σ:Enc¹k;mº
return cLΣ
ots$-randhas been replaced with
LΣ
ots$-real. This is another application of
the chaining lemma.
LΣ
ots-R
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
k Σ:KeyGen
c Σ:Enc¹k;mRº
return cA subroutine call has been inlined, which
has no eﬀect on the library’s behavior.
The result is exactly LΣ
ots-R.
Putting everything together, we showed that LΣ
ots-LL hyb- 1L hyb- 4LΣ
ots-R. This
completes the proof, and we conclude that Σsatis/f_ies the de/f_inition of one-time secrecy. 
One Security Definition Doesn’t Imply Another
Another way we might compare security de/f_initions is to identify any schemes that satisfy
one de/f_inition without satisfying the other. This helps us understand the boundaries and
“edge cases” of the de/f_inition.
A word of warning: If we have two security de/f_initions that both capture our intuitions
rather well, then any scheme which satis/f_ies one de/f_inition and not the other is bound to
appear unnatural and contrived. The point is to gain more understanding of the security
de/f_initions themselves , and unnatural/contrived schemes are just a means to do that.
Theorem 2.16 There is an encryption scheme that satis/f_ies one-time secrecy (De/f_inition 2.6) but not one-time
uniform ciphertexts (De/f_inition 2.5). In other words, one-time secrecy does not necessarily
imply one-time uniform ciphertexts.
Proof One such encryption scheme is given below:
K=f0;1gλ
M=f0;1gλ
C=f0;1gλ+2KeyGen :
k f0;1gλ
return kEnc¹k;m2f0;1gλº:
c0:=km
c:=c0k00
return cDec¹k;c2f0;1gλ+2º:
c0:=/f_irstλbits of c
return kc0
This scheme is just OTP with the bits 00added to every ciphertext. The following
facts about the scheme should be believable (and the exercises encourage you to prove
them formally if you would like more practice at that sort of thing):
IThis scheme satis/f_ies one-time one-time secrecy, meaning that encryptions of mL
are distributed identically to encryptions of mR, for any mLandmRof the attacker’s
choice. We can characterize the ciphertext distribution in both cases as “ λuniform
40Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
bits followed by 00.” Think about how you might use the hybrid proof technique to
formally prove that this scheme satis/f_ies one-time secrecy!
IThis scheme does not satisfy the one-time uniform ciphertexts property. Its cipher-
texts always end with 00, whereas uniform strings end with 00with probability
1/4. Think about how you might formallize this observation as a calling program /
distinguisher for the relevant two libraries! 
You might be thinking, surely this can be /f_ixed by rede/f_ining the ciphertext space as
Cas the set of λ+2-bit strings whose last two bits are 00. This is a clever idea, and
indeed it would work. If we change the de/f_inition of the ciphertext space Cfollowing
this suggestion, then the scheme would satisfy the uniform ciphertexts property (this is
because theLots$-rand library samples uniformly from whatever Cis speci/f_ied as part of
the encryption scheme).
But this observation raises an interesting point. Isn’t it weird that security hinges
on how narrowly you de/f_ine the set Cof ciphertexts, when Creally has no eﬀect on
thefunctionality of encryption? Again, no one really cares about this contrived “OTP +
00” encryption scheme. The point is to illuminate interesting edge cases in the security
de/f_inition itself!
Exercises
2.1. Below are two calling programs A1;A2and two librariesL1;L2with a common interface:
A1
r1:=/r.sc/a.sc/n.sc/d.sc¹6º
r2:=/r.sc/a.sc/n.sc/d.sc¹6º
return r1?=r2A2
r:=/r.sc/a.sc/n.sc/d.sc¹6º
return r?
>3L1
/r.sc/a.sc/n.sc/d.sc¹nº:
r Zn
return rL2
/r.sc/a.sc/n.sc/d.sc¹nº:
return 0
(a) What is Pr»A1L 1)true¼?
(b) What is Pr»A1L 2)true¼?(c) What is Pr»A2L 1)true¼?
(d) What is Pr»A2L 2)true¼?
2.2. In each problem, a pair of libraries are described. State whether or not Lle/f_tL right. If
so, show how they assign identical probabilities to all outcomes. If not, then describe a
successful distinguisher .
Assume that both libraries use the same value of n. Does your answer ever depend on the
choice of n?
In part (a), xdenotes the bitwise-complement of x. In part (d), x&/y.altdenotes the bitwise-
/a.sc/n.sc/d.sc of the two strings:
(a)Lle/f_t
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
x f0;1gn
return xLright
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
x f0;1gn
/y.alt:=x
return/y.alt
41Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
(b)Lle/f_t
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
x Zn
return xLright
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
x Zn
/y.alt:=2x%n
return/y.alt
(c)Lle/f_t
/q.sc_u.sc/e.sc/r.sc/y.sc¹c2Znº:
ifc=0
return null
x Zn
return xLright
/q.sc_u.sc/e.sc/r.sc/y.sc¹c2Znº:
ifc=0
return null
x Zn
/y.alt:=cx%n
return/y.alt(d)Lle/f_t
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
x f0;1gn
/y.alt f0;1gn
return x&/y.altLright
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
z f0;1gn
return z
2.3. Show that the following libraries are interchangeable:
Lle/f_t
/q.sc_u.sc/e.sc/r.sc/y.sc¹m2f0;1gλº:
x f0;1gλ
/y.alt:=xm
return¹x;/y.altºLright
/q.sc_u.sc/e.sc/r.sc/y.sc¹m2f0;1gλº:
/y.alt f0;1gλ
x:=/y.altm
return¹x;/y.altº
Note that xand/y.altare swapped in the /f_irst two lines, but not in the return statement.
2.4. Show that the following libraries are notinterchangeable. Describe an explicit distinguish-
ing calling program, and compute its output probabilities when linked to both libraries:
Lle/f_t
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2f0;1gλº:
k f0;1gλ
c:=kmL
return¹k;cºLright
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2f0;1gλº:
k f0;1gλ
c:=kmR
return¹k;cº
?2.5. In abstract algebra, a (/f_inite) group is a /f_inite set Gof items together with an operator 
satisfying the following axioms:
IClosure: for all a;b2G, we have a
b2G.
IIdentity: there is a special identity element e2Gthat satis/f_ies e
a=a
e=afor
alla2G. We typically write “1” rather than efor the identity element.
IAssociativity: for all a;b;c2G, we have¹a
bº
c=a
¹b
cº.
IInverses: for all a2G, there exists an inverse element b2Gsuch that a
b=b
a
is the identity element of G. We typically write “ a 1” for the inverse of a.
42Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
De/f_ine the following encryption scheme in terms of an arbitrary group¹G;
º:
K=G
M=G
C=GKeyGen :
k G
return kEnc¹k;mº:
return k
mDec¹k;cº:
??
(a) Prove thatf0;1gλis a group with respect to the /x.sc/o.sc/r.sc operator. What is the identity
element, and what is the inverse of a value x2f0;1gλ?
(b) Fill in the details of the Dec algorithm and prove (using the group axioms) that the
scheme satis/f_ies correctness.
(c) Prove that the scheme satis/f_ies one-time secrecy.
2.6. In the proof of Claim 2.9 we considered an attacker / calling program that calls /c.sc/t.sc/x.sc/t.sc¹0λº.
(a) How does this attacker’s eﬀectiveness change if it calls /c.sc/t.sc/x.sc/t.sc¹1λºinstead?
(b) How does its eﬀectiveness change if it calls /c.sc/t.sc/x.sc/t.sc¹mºfor a uniformly chosen m?
2.7. The following scheme encrypts a plaintext by simply reordering its bits, according to the
secret permutation k.
K=permutations
off1; : : : ;λg
M=f0;1gλ
C=f0;1gλ
KeyGen :
k K
return kEnc¹k;mº:
fori:=1toλ:
ck¹iº:=mi
return c1cλ
Dec¹k;cº:
fori:=1toλ:
mi:=ck¹iº
return m1mλ
Show that the scheme does nothave one-time secrecy, by constructing a program that
distinguishes the two relevant libraries from the one-time secrecy de/f_inition.
2.8. Show that the following encryption scheme does nothave one-time secrecy, by construct-
ing a program that distinguishes the two relevant libraries from the one-time secrecy def-
inition.
K=f1; : : : ; 9g
M=f1; : : : ; 9g
C=Z10KeyGen :
k f1; : : : ; 9g
return kEnc¹k;mº:
return km% 10
2.9. Consider the following encryption scheme. It supports plaintexts from M=f0;1gλand
ciphertexts fromC=f0;1g2λ. Its keyspace is:
K=n
k2f0;1;_g2λjkcontains exactly λ“_” characterso
To encrypt plaintext munder key k, we “/f_ill in” the _characters in kusing the bits of m.
43Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
Show that the scheme does nothave one-time secrecy, by constructing a program that
distinguishes the two relevant libraries from the one-time secrecy de/f_inition.
Example: Below is an example encryption of m=1101100001 .
k=1__0__11010 _1_0_0___
m=11 01 1 0 0 001
)Enc¹k;mº=11100111010110000001
2.10. Suppose we modify the scheme from the previous problem to /f_irst permute the bits of m
(as in Exercise 2.7) and then use them to /f_ill in the “ _” characters in a template string. In
other words, the key speci/f_ies a random permutation on positions f1; : : : ;λgas well as a
random template string that is 2λcharacters long with λ“_” characters.
Show that even with this modi/f_ication the scheme does not have one-time secrecy.
?2.11. Prove that if an encryption scheme ΣhasjΣ:Kj<jΣ:Mjthen it cannot satisfy one-
time secrecy. Try to structure your proof as an explicit attack on such a scheme ( i.e., a
distinguisher against the appropriate libraries).
TheEncalgorithm of one-time pad is deterministic, but our de/f_initions of encryption allow
Encto be randomized ( i.e., it may give diﬀerent outputs when called twice with the same
kandm).For full credit , you should prove the statement even for the case of Encis
randomized. However, you may assume that Decis deterministic.
Hint:The de/f_inition of interchangeability does not place any restriction on the running time of the dis-
tinguisher/calling program. Even an exhaustive brute-force attack would be valid.
2.12. Let Σdenote an encryption scheme where Σ:CΣ:M(so that it is possible to use the
scheme to encrypt its own ciphertexts). De/f_ine Σ2to be the following nested-encryption
scheme:
K=¹Σ:Kº2
M=Σ:M
C=Σ:C
KeyGen :
k1 Σ:K
k2 Σ:K
return¹k1;k2ºEnc¹¹k1;k2º;mº:
c1:=Σ:Enc¹k1;mº
c2:=Σ:Enc¹k2;c1º
return c2Dec¹¹k1;k2º;c2º:
c1:=Σ:Dec¹k2;c2º
m:=Σ:Dec¹k1;c1º
return m
Prove that if Σsatis/f_ies one-time secrecy, then so does Σ2.
2.13. Let Σdenote an encryption scheme and de/f_ine Σ2to be the following encrypt-twice
scheme:
44Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
K=¹Σ:Kº2
M=Σ:M
C=Σ:C
KeyGen :
k1 Σ:K
k2 Σ:K
return¹k1;k2ºEnc¹¹k1;k2º;mº:
c1:=Σ:Enc¹k1;mº
c2:=Σ:Enc¹k2;mº
return¹c1;c2ºDec¹¹k1;k2º;¹c1;c2ºº:
m1:=Σ:Dec¹k1;c1º
m2:=Σ:Dec¹k2;c2º
ifm1,m2return err
return m1
Prove that if Σsatis/f_ies one-time secrecy, then so does Σ2.
2.14. Prove that an encryption scheme Σsatis/f_ies one-time secrecy if and only if the following
two libraries are interchangeable:
LΣ
le/f_t
/f.sc/o.sc/o.sc¹m2Σ:Mº:
k Σ:KeyGen
c Σ:Enc¹k;mº
return cLΣ
right
/f.sc/o.sc/o.sc¹m2Σ:Mº:
k Σ:KeyGen
m0 Σ:M
c Σ:Enc¹k;m0º
return c
Note: you must prove both directions of the if-and-only-if with a hybrid proof.
2.15. Prove that an encryption scheme Σhas one-time secrecy if and only if the following two
libraries are interchangeable:
LΣ
le/f_t
/f.sc/o.sc/o.sc¹mL;mR2Σ:Mº:
k1 Σ:KeyGen
c1:=Σ:Enc¹k1;mLº
k2 Σ:KeyGen
c2:=Σ:Enc¹k2;mRº
return¹c1;c2ºLΣ
right
/f.sc/o.sc/o.sc¹mL;mR2Σ:Mº:
k1 Σ:KeyGen
c1:=Σ:Enc¹k1;mRº
k2 Σ:KeyGen
c2:=Σ:Enc¹k2;mLº
return¹c1;c2º
Note: you must prove both directions of the if-and-only-if with a hybrid proof.
2.16. Formally de/f_ine a variant of the one-time secrecy de/f_inition in which the calling program
can obtain two ciphertexts (on chosen plaintexts) encrypted under the same key. Call it
two-time secrecy.
(a) Suppose someone tries to prove that one-time secrecy implies two-time secrecy. Show
where the proof appears to break down.
(b) Describe an attack demonstrating that one-time pad does not satisfy your de/f_inition
of two-time secrecy.
45Draft: January 3, 2021 CHAPTER 2. THE BASICS OF PROVABLE SECURITY
2.17. In this problem we consider modifying one-time pad so that the key is not chosen uni-
formly. LetDλdenote the probability distribution over f0;1gλwhere we choose each bit
of the result to be 0with probability 0.4 and 1with probability 0.6.
LetΣdenote one-time pad encryption scheme but with the key sampled from distribution
Dλrather than the uniform distribution on f0;1gλ.
(a) Consider the case of λ=5. A calling program Afor theLΣ
ots-?libraries calls
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹01011 ;10001ºand receives the result 01101 . What is the probability that
this happens, assuming that Ais linked toLots-L? What about when Ais linked to
Lots-R?
(b) Turn this observation into an explicit attack on the one-time secrecy of Σ.
2.18. Complete the proof of Theorem 2.16.
(a) Formally prove (using the hybrid technique) that the scheme in that theorem satis/f_ies
one-time secrecy.
(b) Give a distinguishing calling program to show that the scheme doesn’t satisfy one-time
uniform ciphertexts.
463Secret Sharing
DNS is the system that maps human-memorable Internet domains like irs.gov to
machine-readable IP addresses like 166.123.218.220 . If an attacker can masquerade as
the DNS system and convince your computer that irs.gov actually resides at some other
IP address, it might result in a bad day for you.
To protect against these kinds of attacks, a replacement called DNSSEC has been pro-
posed. DNSSEC uses cryptography to make it impossible to falsify a domain-name map-
ping. The cryptography required to authenticate DNS mappings is certainly interesting,
but an even more fundamental question remains: Who can be trusted with the master cryp-
tographic keys to the system? The non-pro/f_it organization in charge of these kinds of things
(ICANN) has chosen the following system. The master key is split into 7 pieces and dis-
tributed on smart cards to 7 geographically diverse people, who keep them in safe-deposit
boxes.
At least /f_ive key-holding members of this fellowship would have to meet at a
secure data center in the United States to reboot [DNSSEC] in case of a very
unlikely system collapse.
“If you round up /f_ive of these guys, they can decrypt [the root key] should the
West Coast fall in the water and the East Coast get hit by a nuclear bomb," [said]
Richard Lamb, program manager for DNSSEC at ICANN.1
How is it possible that any 5 out of the 7 key-holders can reconstruct the master key,
but (presumably) 4 out of the 7 cannot? The solution lies in a cryptographic tool called a
secret-sharing scheme , the topic of this chapter.
3.1 Definitions
We begin by introducing the syntax of a secret-sharing scheme:
Definition 3.1
(Secret-sharing)At-out-of- nthreshold secret-sharing scheme (TSSS) consists of the following algorithms:
IShare : a randomized algorithm that takes a message m2M as input, and outputs a
sequence s=¹s1; : : : ; snºofshares .
IReconstruct : a deterministic algorithm that takes a collection of tor more shares as
input, and outputs a message.
We callMthemessage space of the scheme, and titsthreshold . As usual, we refer to the
parameters/components of a scheme ΣasΣ:t,Σ:n,Σ:M,Σ:Share ,Σ:Reconstruct .
1h/t_tp://www.livescience.com/6791-internet-key-holders-insurance-cyber-a/t_tack.html
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
In secret-sharing, we number the users as f1; : : : ; ng, with user ireceiving share si. Let
Uf1; : : : ; ngbe a subset of users. Then fsiji2Ugrefers to the set of shares belonging
to users U. IfjUj>t, we say that Uisauthorized ; otherwise it is unauthorized . The
goal of secret sharing is for all authorized sets of users/shares to be able to reconstruct the
secret, while all unauthorized sets learn nothing.
Definition 3.2
(TSSS correctness)At-out-of- nTSSS satis/f_ies correctness if, for all authorized sets Uf1; : : : ; ng(i.e.,jUj>t)
and for all s Share¹mº, we have Reconstruct¹fsiji2Ugº=m.
m
Share
s1 s2 s3 s4 s5 sn
Reconstruct
mnshares
anytof the shares
Security Definition
We’d like a security guarantee that says something like:
if you know only an unauthorized set of shares, then you learn no information
about the choice of secret message.
To translate this informal statement into a formal security de/f_inition, we de/f_ine two li-
braries that allow the calling program to learn a set of shares (for an unauthorized set),
and that diﬀer only in which secret is shared. If the two libraries are interchangeable,
then we conclude that seeing an unauthorized set of shares leaks no information about
the choice of secret message. The de/f_inition looks like this:
Definition 3.3
(TSSS security)LetΣbe a threshold secret-sharing scheme. We say that Σissecure ifLΣ
tsss-LLΣ
tsss-R, where:
LΣ
tsss-L
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR2Σ:M;Uº:
ifjUj>Σ:t: return err
s Σ:Share¹mLº
returnfsiji2UgLΣ
tsss-R
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR2Σ:M;Uº:
ifjUj>Σ:t: return err
s Σ:Share¹mRº
returnfsiji2Ug
In an attempt to keep the notation uncluttered, we have not written the type of the argument
U, which is Uf1; : : : ;Σ:ng.
48Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
Discussion & Pitfalls
ISimilar to the de/f_inition of one-time secrecy of encryption, we let the calling pro-
gram choose the two secret messages that will be shared. As before, this models an
attack scenario in which the adversary has partial knowledge or in/f_luence on the
secret mbeing shared.
IThe calling program also chooses the set Uof users’ shares to obtain. The libraries
make it impossible for the calling program to obtain the shares of an authorized set
(returning errin that case). This does notmean that a user is never allowed to dis-
tribute an authorized number of shares (this would be strange indeed, since it would
make any future reconstruction impossible). It just means that we want a security
de/f_inition that says something about an attacker who sees only an unauthorized set
of shares, so we formalize security in terms of libraries with this restriction.
IConsider a 6-out-of-10 threshold secret-sharing scheme. With the libraries above,
the calling program can receive the shares of users f1; : : : ; 5g(an unauthorized set)
in one call to /s.sc/h.sc/a.sc/r.sc/e.sc , and then receive the shares of users f6; : : : ; 10gin another call.
It might seem like the calling program can then combine these shares to reconstruct
the secret (if the same message was shared in both calls). However, this is notthe
case because these two sets of shares came from two independent executions of the
Share algorithm. Shares generated by one call to Share should not be expected to
function with shares generated by another call, even if both calls to Share used the
same secret message.
IRecall that in our style of de/f_ining security using libraries, it is only the internal
diﬀerences between the libraries that must be hidden. Anything that is the same
between the two libraries need not be hidden. One thing that is the same for the two
libraries here is the fact that they output the shares belonging to the same set of users
U. This security de/f_inition does not require shares to hide which user they belong
to.Indeed, you can modify a secret-sharing scheme so that each user’s identity
is appended to his/her corresponding share, and the result would still satisfy the
security de/f_inition above.
IJust like the encryption de/f_inition does not address the problem of key distribution,
the secret-sharing de/f_inition does not address the problem of who should run the
Share algorithm (if its input mis so secret that it cannot be entrusted to any sin-
gle person), or how the shares should be delivered to the ndiﬀerent users. Those
concerns are considered out of scope by the problem of secret-sharing (although we
later discuss clever approaches to the /f_irst problem). Rather, the focus is simply on
whether it is even possible to encode data in such a way that an unauthorized set of
shares gives no information about the secret, while any authorized set completely
reveals the secret.
An Insecure Approach
One way to understand the security of secret sharing is to see an example of an “obvious”
but insecure approach for secret sharing, and study why it is insecure.
49Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
Let’s consider a 5-out-of-5 secret-sharing scheme. This means we want to split a secret
into 5 pieces so that any 4 of the pieces leak nothing. One way you might think to do this
is to literally chop up the secret into 5 pieces. For example, if the secret is 500 bits, you
might give the /f_irst 100 bits to user 1, the second 100 bits to user 2, and so on.
Construction 3.4
(Insecure TSSS)M=f0;1g500
t=5
n=5Share¹mº:
split mintom=s1kk s5,
where eachjsij=100
return¹s1; : : : ; s5ºReconstruct¹s1; : : : ; s5º:
return s1kk s5
It is true that the secret can be constructed by concatenating all 5 shares, and so this
construction satis/f_ies the correctness property. (The only authorized set is the set of all 5
users, so we write Reconstruct to expect all 5 shares.)
However, the scheme is insecure (as promised). Suppose you have even just 1 share.
It is true that you don’t know the secret in its entirety, but the security de/f_inition (for 5-
out-of-5 secret sharing) demands that a single share reveals nothing about the secret. Of
course knowing 100 bits of something is not the same as than knowing nothing about it.
We can leverage this observation to make a more formal attack on the scheme, in the
form of a distinguisher between the two Ltsss-?libraries. As an extreme case, we can
distinguish between shares of an all- 0secret and shares of an all- 1secret:
A
s1:=/s.sc/h.sc/a.sc/r.sc/e.sc¹0500;1500;f1gº
return s1?=0100
Let’s link this calling program to both of the Ltsss-?libraries and see what happens:
A
s1:=/s.sc/h.sc/a.sc/r.sc/e.sc¹0500;1500;f1gº
return s1?=0100Ltsss-L
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
ifjUj>t: return err
s Share¹mLº
returnfsiji2UgWhenAis linked toLtsss-L, it
receives a share of 0500, which
will itself be a string of all ze-
roes. In this case,Aoutputs 1
with probability 1.
A
s1:=/s.sc/h.sc/a.sc/r.sc/e.sc¹0500;1500;f1gº
return s1?=0100Ltsss-R
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
ifjUj>t: return err
s Share¹mRº
returnfsiji2UgWhenAis linked toLtsss-R, it
receives a share of 1500which
will be a string of all ones. In this
case,Aoutputs 1 with probabil-
ity 0.
We have constructed a calling program which behaves very diﬀerently (indeed, as
diﬀerently as possible) in the presence of the two libraries. Hence, this secret-sharing
scheme is not secure.
Hopefully this example demonstrates one of the main challenges (and amazing things)
about secret-sharing schemes. It is easy to reveal information about the secret gradually as
50Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
more shares are obtained, like in this insecure example. However, the security de/f_inition
of secret sharing is that the shares must leak absolutely no information about the secret,
until the number of shares passes the threshold value.
3.2 A Simple 2-out-of-2 Scheme
Believe it or not, we have already seen a simple secret-sharing scheme! In fact, it might
even be best to think of one-time pad as the simplest secret-sharing scheme.
Construction 3.5
(2-out-of-2 TSSS)M=f0;1g`
t=2
n=2Share¹mº:
s1 f0;1g`
s2:=s1m
return¹s1;s2ºReconstruct¹s1;s2º:
return s1s2
Since it’s a 2-out-of-2 scheme, the only authorized set of users is f1;2g, soReconstruct is
written to expect both shares s1ands2as its inputs. Correctness follows easily from what
we’ve already learned about the properties of /x.sc/o.sc/r.sc.
Example If we want to share the string m=1101010001 then the Share algorithm might choose
s1:=0110000011
s2:=s1m
=01100000111101010001 =1011010010 :
Then the secret can be reconstructed by /x.sc/o.sc/r.scing the two shares together, via:
s1s2=01100000111011010010 =1101010001 =m:
Remember that this example shows just one possible execution of Share¹1101010001º, but
Share is a randomized algorithm and many other values of ¹s1;s2ºare possible.
Theorem 3.6 Construction 3.5 is a secure 2-out-of-2 threshold secret-sharing scheme.
Proof LetΣdenote Construction 3.5. We will show that LΣ
tsss-LLΣ
tsss-Rusing a hybrid proof.
LΣ
tsss-L:LΣ
tsss-L
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
ifjUj>2: return err
s1 f0;1g`
s2:=s1mL
returnfsiji2UgAs usual, the starting point is
LΣ
tsss-L, shown here with the
details of the secret-sharing
scheme /f_illed in (and the
types of the subroutine ar-
guments omitted to reduce
clutter).
51Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
ifjUj>2: return err
ifU=f1g:
s1 f0;1g`
s2:=s1mL
returnfs1g
elsifU=f2g:
s1 f0;1g`
s2:=s1mL
returnfs2g
else return;It has no eﬀect on the li-
brary’s behavior if we dupli-
cate the main body of the
library into 3 branches of
a new if-statement. The
reason for doing so is that
the scheme generates s1and
s2diﬀerently. This means
that our proof will eventu-
ally handle the 3 diﬀerent
unauthorized sets ( f1g,f2g,
and;) in fundamentally dif-
ferent ways.
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
ifjUj>2: return err
ifU=f1g:
s1 f0;1g`
s2:=s1mR
returnfs1g
elsifU=f2g:
s1 f0;1g`
s2:=s1mL
returnfs2g
else return;The de/f_inition of s2has
been changed in the /f_irst
if-branch. This has no eﬀect
on the library’s behavior
since s2is never actually
used in this branch.
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
ifjUj>2: return err
ifU=f1g:
s1 f0;1g`
s2:=s1mR
returnfs1g
elsifU=f2g:
s2 /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº
returnfs2g
else return;LOTP
ots-L
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
k f0;1g`
c:=kmL
return cRecognizing the second
branch of the if-statement as
a one-time pad encryption
(ofmLunder key s1), we
factor out the generation
ofs2in terms of the library
LOTP
ots-Lfrom the one-time
secrecy de/f_inition. This has
no eﬀect on the library’s
behavior. Importantly, the
subroutine inLOTP
ots-Lexpects
two arguments , so that is
what we must pass. We
choose to pass mLandmR
for reasons that should
become clear very soon.
52Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
ifjUj>2: return err
ifU=f1g:
s1 f0;1g`
s2:=s1mR
returnfs1g
elsifU=f2g:
s2 /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº
returnfs2g
else return;LOTP
ots-R
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
k f0;1g`
c:=kmR
return cWe have replacedLOTP
ots-Lwith
LOTP
ots-R. From the one-time se-
crecy of one-time pad (and
the composition lemma), this
change has no eﬀect on the
library’s behavior.
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
ifjUj>2: return err
ifU=f1g:
s1 f0;1g`
s2:=s1mR
returnfs1g
elsifU=f2g:
s1 f0;1g`
s2:=s1mR
returnfs2g
else return;A subroutine has been in-
lined; no eﬀect on the li-
brary’s behavior.
LΣ
tsss-R:LΣ
tsss-R
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
ifjUj>2: return err
s1 f0;1g`
s2:=s1mR
returnfsiji2UgThe code has been sim-
pli/f_ied. Speci/f_ically, the
branches of the if-statement
can all be uni/f_ied, with no ef-
fect on the library’s behav-
ior. The result isLΣ
tsss-R.
We showed thatLΣ
tsss-L L hyb- 1   L hyb- 5 LΣ
tsss-R, and so the secret-sharing
scheme is secure. 
We in fact proved a slightly more general statement. The only property of one-time pad
we used was its one-time secrecy. Substituting one-time pad for any other one-time secret
encryption scheme would still allow the same proof to go through. So we actually proved
the following:
Theorem 3.7 IfΣis an encryption scheme with one-time secrecy, then the following 2-out-of-2 threshold
secret-sharing scheme Sis secure:
53Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
M=Σ:M
t=2
n=2Share¹mº:
s1 Σ:KeyGen
s2 Σ:Enc¹s1;mº
return¹s1;s2ºReconstruct¹s1;s2º:
return Σ:Dec¹s1;s2º
3.3 Polynomial Interpolation
You are probably familiar with the fact that two points determine a line (in Euclidean
geometry). It is also true that 3 points determine a parabola, and so on. The next secret-
sharing scheme we discuss is based on the following principle:
d+1points determine a unique degree- dpolynomial.
A note on terminology: If fis a polynomial that can be written as f¹xº=Íd
i=0fixi,
then we say that fis adegree- dpolynomial. It would be more technically correct to say
that the degree of fisat most dsince we allow the leading coeﬃcient fdto be zero. For
convenience, we’ll stick to saying “degree- d” to mean “degree at most d.”
Polynomials Over the Reals
Theorem 3.8
(Poly Interpolation)Letf¹x1;/y.alt1º; : : : ;¹xd+1;/y.altd+1ºgR2be a set of points whose xivalues are all distinct. Then
there is a unique degree- dpolynomial fwith real coeﬃcients that satis/f_ies /y.alti=f¹xiºfor
alli.
Proof To start, consider the following polynomial:
`1¹xº=¹x x2º¹x x3º¹ x xd+1º
¹x1 x2º¹x1 x3º¹ x1 xd+1º:
The notation is potentially confusing. `1is a polynomial with formal variable x(written
in bold). The non-bold xivalues are just plain numbers (scalars), given in the theorem
statement. Therefore the numerator in `1is a degree- dpolynomial in x. The denominator
is just a scalar, and since all of the xi’s are distinct, we are not dividing by zero. Overall,
`1is a degree- dpolynomial.
What happens when we evaluate `1at one of the special xivalues?
IEvaluating `1¹x1ºmakes the numerator and denominator the same, so `1¹x1º=1.
IEvaluating `1¹xiºfori,1leads to a term¹xi xiºin the numerator, so `1¹xiº=0.
Of course, `1can be evaluated at any point (not just the special points x1; : : : ; xd+1), but
we don’t care about what happens in those cases.
We can similarly de/f_ine other polynomials `j:
`j¹xº=¹x x1º¹ x xj 1º¹x xj+1º¹ x xd+1º
¹xj x1º¹ xj xj 1º¹xj xj+1º¹ xj xd+1º:
The pattern is that the numerator is “missing” the term ¹x xjºand the denominator is
missing the term¹xj xjº, because we don’t want a zero in the denominator. Polynomials
54Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
of this kind are called LaGrange polynomials . They are each degree- dpolynomials, and
they satisfy the property:
`j¹xiº=(
1ifi=j
0ifi,j
Now consider the following polynomial:
f¹xº=/y.alt1`1¹xº+/y.alt2`2¹xº++/y.altd+1`d+1¹xº:
Note that fis a degree- dpolynomial since it is the sum of degree- dpolynomials (again,
the/y.altivalues are just scalars).
What happens when we evaluate fon one of the special xivalues? Since `i¹xiº=1
and`j¹xiº=0forj,i, we get:
f¹xiº=/y.alt1`1¹xiº++/y.alti`i¹xiº++/y.altd+1`d+1¹xiº
=/y.alt10++/y.alti1++/y.altd+10
=/y.alti
Sof¹xiº=/y.altifor every xi, which is what we wanted. This shows that there is some
degree- dpolynomial with this property.
Now let’s argue that this fis unique. Suppose there are two degree- dpolynomials
fand f0such that f¹xiº=f0¹xiº=/y.altifori2 f1; : : : ; d+1g. Then the polynomial
/afii10069.ital¹xº=f¹xº f0¹xºalso is degree- d, and it satis/f_ies /afii10069.ital¹xiº=0for all i. In other words,
each xiis arootof/afii10069.ital, so/afii10069.italhas at least d+1roots. But the only degree- dpolynomial with
d+1roots is the identically-zero polynomial /afii10069.ital¹xº=0. If/afii10069.ital¹xº=0then f=f0. In other
words, any degree- dpolynomial f0that satis/f_ies f0¹xiº=/y.altimust be equal to f. So fis
the unique polynomial with this property. 
Example Let’s /f_igure out the degree-3 polynomial that passes through the points
¹3;1º;¹4;1º;¹5;9º;¹2;6º:
i1 2 3 4
xi3 4 5 2
/y.alti1 1 9 6
First, let’s construct the appropriate LaGrange polynomials:
`1¹xº=¹x x2º¹x x3º¹x x4º
¹x1 x2º¹x1 x3º¹x1 x4º=¹x 4º¹x 5º¹x 2º
¹3 4º¹3 5º¹3 2º=x3 11x2+38x 40
2
`2¹xº=¹x x1º¹x x3º¹x x4º
¹x2 x1º¹x2 x3º¹x2 x4º=¹x 3º¹x 5º¹x 2º
¹4 3º¹4 5º¹4 2º=x3 10x2+31x 30
 2
`3¹xº=¹x x1º¹x x2º¹x x4º
¹x3 x1º¹x3 x2º¹x3 x4º=¹x 3º¹x 4º¹x 2º
¹5 3º¹5 4º¹5 2º=x3 9x2+26x 24
6
`4¹xº=¹x x1º¹x x2º¹x x3º
¹x4 x1º¹x4 x2º¹x4 x3º=¹x 3º¹x 4º¹x 5º
¹2 3º¹2 4º¹2 5º=x3 12x2+47x 60
 6
55Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
As a sanity check, notice how:
`1¹x1º=`1¹3º=33 1132+383 40
2=2
2=1
`1¹x2º=`1¹4º=43 1142+384 40
2=0
2=0
It will make the next step easier if we rewrite all LaGrange polynomials to have the same
denominator 6:
`1¹xº=3x3 33x2+114x 120
6`3¹xº=x3 9x2+26x 24
6
`2¹xº= 3x3+30x2 93x+90
6`4¹xº= x3+12x2 47x+60
6
Our desired polynomial is
f¹xº=/y.alt1`1¹xº+/y.alt2`2¹xº+/y.alt3`3¹xº+/y.alt4`4¹xº
=1`1¹xº+1`2¹xº+9`3¹xº+6`4¹xº
=1
6©­­­
«1 3x3 33x2+114x 120
+1  3x3+30x2 93x +90
+9 x3 9x2+26x 24
+6  x3+12x2 47x +60ª®®®
¬
=1
6
3x3 12x2 27x+114
=x3
2 2x2 9x
2+19
And indeed, fgives the correct values:
0 1 2 3 4 5 60246810121416
(3,1)(4,1)(5,9)
(2,6)f¹x1º=f¹3º=33
2 232 93
2+19=1=/y.alt1
f¹x2º=f¹4º=43
2 242 94
2+19=1=/y.alt2
f¹x3º=f¹5º=53
2 252 95
2+19=9=/y.alt3
f¹x4º=f¹2º=23
2 222 92
2+19=6=/y.alt4
Polynomials mod p
We will see a secret-sharing scheme based on polynomials, whose Share algorithm must
choose a polynomial with uniformly random coeﬃcients. Since we cannot have a uniform
distribution over the real numbers, we must instead consider polynomials with coeﬃcients
inZp.
It is still true that d+1points determine a unique degree- dpolynomial when working
modulo p,ifpis a prime!
56Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
Theorem 3.9
(Interp mod p)Letpbe a prime, and letf¹x1;/y.alt1º; : : : ;¹xd+1;/y.altd+1ºg¹Zpº2be a set of points whose xival-
ues are all distinct. Then there is a unique degree- dpolynomial fwith coeﬃcients from Zp
that satis/f_ies /y.altipf¹xiºfor all i.
The proof is the same as the one for Theorem 3.8, if you interpret all arithmetic modulo
p. Addition, subtraction, and multiplication mod pare straight forward; the only non-
trivial question is how to interpret “division mod p,” which is necessary in the de/f_inition
of the `jpolynomials. For now, just accept that you can always “divide” mod p(except by
zero) when pis a prime. If you are interested in how division mod pworks, look ahead to
Chapter 13.
We can also generalize the observation that d+1points uniquely determine a degree- d
polynomial. It turns out that:
For any kpoints, there are exactly pd+1 kpolynomials of degree- dthat hit
those points, mod p.
Note how when k=d+1, the statement says that there is just a single polynomial hitting
the points.
Corollary 3.10
(# of polys)LetP=f¹x1;/y.alt1º; : : : ;¹xk;/y.altkºg¹Zpº2be a set of points whose xivalues are distinct. Let d
satisfy k6d+1andp>d. Then the number of degree- dpolynomials fwith coeﬃcients in
Zpthat satisfy the condition /y.altipf¹xiºfor all iis exactly pd+1 k.
Proof The proof is by induction on the value d+1 k. The base case is when d+1 k=0. Then
we have k=d+1distinct points, and Theorem 3.9 says that there is a unique polynomial
satisfying the condition. Since pd+1 k=p0=1, the base case is true.
For the inductive case, we have k6dpoints inP. Let x2Zpbe a value that does
not appear as one of the xi’s. Every polynomial must give some value when evaluated at
x. So,
[# of degree- dpolynomials passing through points in P]
=Õ
/y.alt2Zp[# of degree- dpolynomials passing through points in P[f¹ x;/y.altºg]
¹?º=Õ
/y.alt2Zppd+1 ¹k+1º
=p
pd+1 k 1
=pd+1 k
The equality marked ( ?) follows from the inductive hypothesis, since each of the terms
involves a polynomial passing through a speci/f_ied set of k+1points with distinct x-
coordinates. 
57Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
Example
012345678910110112233445566778899110121132143154165176
(0,7)(1,12)(2,19)(3,28)(4,39)(5,52)(6,67)(7,84)(8,103)(9,124)(10,147)What does a “polynomial mod p” look
like? Consider an example degree-2 poly-
nomial:
f¹xº=x2+4x+7
When we plot this polynomial over the real
numbers (the picture on the left), we get a
familiar parabola.
Let’s see what this polynomial “looks like”
modulo 11 ( i.e., inZ11). Working mod 11
means to “wrap around” every time the
polynomial crosses over a multiple of 11
along the/y.alt-axis. This results in the blue
plot below:
01234567891011011
This is a picture of a mod-11 parabola. In
fact, since we care only about Z11inputs to
f, you could rightfully say that just the 11
highlighted points alone (not the blue
curve) are a picture of a mod-11 parabola.
3.4 Shamir Secret Sharing
Part of the challenge in designing a secret-sharing scheme is making sure that anyautho-
rized set of users can reconstruct the secret. We have just seen that anyd+1points on
a degree- dpolynomial are enough to uniquely reconstruct the polynomial. So a natural
approach for secret sharing is to let each user’s share be a point on a polynomial.
That’s exactly what Shamir secret sharing does. To share a secret m2Zpwith
threshold t, /f_irst choose a degree-( t 1) polynomial fthat satis/f_ies f¹0ºpm, with all
58Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
other coeﬃcients chosen uniformly in Zp. The ith user receives the point ¹i;f¹iº%pºon
the polynomial. The interpolation theorem says that anytof the shares can uniquely
determine the polynomial f, and hence recover the secret f¹0º.
Construction 3.11
(Shamir SSS)
M=Zp
p:prime
n<p
t6nShare¹mº:
f1; : : : ; ft 1 Zp
f¹xº:=m+Ít 1
j=1fjxj
fori=1ton:
si:=¹i;f¹iº%pº
return s=¹s1; : : : ; snº
Reconstruct¹fsiji2Ugº:
f¹xº:=unique degree-¹t 1º
polynomial mod ppassing
through pointsfsiji2Ug
return f¹0º
Correctness follows from the interpolation theorem.
Example Here is an example of 3-out-of-5 secret sharing over Z11(sop=11). Suppose the secret being
shared is m=72Z11. The Share algorithm chooses a random degree-2 polynomial with
constant coeﬃcient 7.
Let’s say that the remaining two coeﬃcients are chosen as f2=1andf1=4, resulting in
the following polynomial:
f¹xº=1x2+4x+7
This is the same polynomial illustrated in the previous example:
01234567891011011
For each user i2f1; : : : ; 5g, we distribute the share ¹i;f¹iº% 11º. These shares correspond to
the highlighted points in the mod-11 picture above.
user ( i) f¹iº share¹i;f¹iº% 11º
1 f¹1º=12¹1;1º
2 f¹2º=19¹2;8º
3 f¹3º=28¹3;6º
4 f¹4º=39¹4;6º
5 f¹5º=52¹5;8º
Remember that this example illustrates just one possible execution of Share . Because Share
is a randomized algorithm, there are many valid sharings of the same secret (induced by
diﬀerent choices of the highlighted coeﬃcients in f).
59Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
Security
To show the security of Shamir secret sharing, we /f_irst show a convenient lemma about
the distribution of shares in an unauthorized set:
Lemma 3.12 Letpbe a prime and de/f_ine the following two libraries:
Lshamir-real
/p.sc/o.sc/l.sc/y.sc¹m;t;Uf1; : : : ; pgº:
ifjUj>t: return err
f1; : : : ; ft 1 Zp
f¹xº:=m+Ít 1
j=1fjxj
fori2U:
si:=¹i;f¹iº%pº
returnfsiji2UgLshamir-rand
/p.sc/o.sc/l.sc/y.sc¹m;t;Uf1; : : : ; pgº:
ifjUj>t: return err
fori2U:
/y.alti Zp
si:=¹i;/y.altiº
returnfsiji2Ug
Lshamir-real chooses a random degree- ¹t 1ºpolynomial that passes through the point ¹0;mº,
then evaluates it at the given x-coordinates (speci/f_ied by U).Lshamir-rand simply gives uni-
formly chosen points, unrelated to any polynomial.
The claim is that these libraries are interchangeable: Lshamir-realL shamir-rand .
Proof Fix a message m2Zp, /f_ix set Uof users withjUj<t, and for each i2U/f_ix a value/y.alti2Zp.
We wish to consider the probability that a call to /p.sc/o.sc/l.sc/y.sc¹m;t;Uºoutputsf¹i;/y.altiºji2Ug, in
each of the two libraries.2
In libraryLshamir-real , the subroutine chooses a random degree-( t 1) polynomial f
such that f¹0ºpm. From Corollary 3.10, we know there are pt 1such polynomials.
In order for /p.sc/o.sc/l.sc/y.sc to output points consistent with our chosen /y.alti’s, the library must
have chosen one of the polynomials that passes through ¹0;mºandall of thef¹i;/y.altiºji2
Ugpoints. The library must have chosen one of the polynomials that passes through a
speci/f_ic choice ofjUj+1points, and Corollary 3.10 tells us that there are pt ¹jUj+1ºsuch
polynomials.
The only way for /p.sc/o.sc/l.sc/y.sc to give our desired output is for it to choose one of the pt ¹jUj+1º
“good” polynomials, out of the pt 1possibilities. This happens with probability exactly
pt jUj 1
pt 1=p jUj
Now, in libraryLshamir-rand ,/p.sc/o.sc/l.sc/y.sc chooses itsjUjoutput values uniformly in Zp. There
arepjUjways to choose them. But only one of those ways causes /p.sc/o.sc/l.sc/y.sc¹m;t;Uºto output
our speci/f_ic choice of f¹i;/y.altiºji2Ug. Hence, the probability of receiving this output is
p jUj.
For all possible inputs to /p.sc/o.sc/l.sc/y.sc , both libraries assign the same probability to every
possible output. Hence, the libraries are interchangeable. 
Theorem 3.13 Shamir’s secret-sharing scheme (Construction 3.11) is secure according to De/f_inition 3.3.
2This is similar to how, in Claim 2.7, we /f_ixed a particular mandcand computed the probability that
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mº=c.
60Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
Proof LetSdenote the Shamir secret-sharing scheme. We prove that LS
tsss-L LS
tsss-Rvia a
hybrid argument.
LS
tsss-L:LS
tsss-L
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
ifjUj>t: return err
f1; : : : ; ft 1 Zp
f¹xº:=mL+Ít 1
j=1fjxj
fori2U:
si:=¹i;f¹iº%pº
returnfsiji2UgOur starting point is LS
tsss-L,
shown here with the details of
Shamir secret-sharing /f_illed in.
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
return /p.sc/o.sc/l.sc/y.sc¹mL;t;UºLshamir-real
/p.sc/o.sc/l.sc/y.sc¹m;t;Uº:
ifjUj>t: return err
f1; : : : ; ft 1 Zp
f¹xº:=m+Ít 1
j=1fjxj
fori2U:
si:=¹i;f¹iº%pº
returnfsiji2UgAlmost the entire body of
the /s.sc/h.sc/a.sc/r.sc/e.sc subroutine has
been factored out in terms
of theLshamir-real library
de/f_ined above. The only thing
remaining is the “choice” of
whether to share mLormR.
Restructuring the code in
this way has no eﬀect on the
library’s behavior.
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
return /p.sc/o.sc/l.sc/y.sc¹mL;t;UºLshamir-rand
/p.sc/o.sc/l.sc/y.sc¹m;t;Uº:
ifjUj>t: return err
fori2U:
/y.alti Zp
si:=¹i;/y.altiº
returnfsiji2UgBy Lemma 3.12, we can replace
Lshamir-real withLshamir-rand ,
having no eﬀect on the li-
brary’s behavior.
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
return /p.sc/o.sc/l.sc/y.sc¹mR;t;UºLshamir-rand
/p.sc/o.sc/l.sc/y.sc¹m;t;Uº:
ifjUj>t: return err
fori2U:
/y.alti Zp
si:=¹i;/y.altiº
returnfsiji2UgThe argument to /p.sc/o.sc/l.sc/y.sc has
been changed from mLtomR.
This has no eﬀect on the li-
brary’s behavior, since /p.sc/o.sc/l.sc/y.sc is
actually ignoring its argument
in these hybrids.
61Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
return /p.sc/o.sc/l.sc/y.sc¹mR;t;UºLshamir-real
/p.sc/o.sc/l.sc/y.sc¹m;t;Uº:
ifjUj>t: return err
f1; : : : ; ft 1 Zp
f¹xº:=m+Ít 1
j=1fjxj
fori2U:
si:=¹i;f¹iº%pº
returnfsiji2UgApplying the same steps
in reverse, we can replace
Lshamir-rand withLshamir-real ,
having no eﬀect on the
library’s behavior.
LS
tsss-R:LS
tsss-R
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR;Uº:
ifjUj>t: return err
f1; : : : ; ft 1 Zp
f¹xº:=mR+Ít 1
j=1fjxj
fori2U:
si:=¹i;f¹iº%pº
returnfsiji2UgA subroutine has been inlined,
which has no eﬀect on the li-
brary’s behavior. The result-
ing library isLS
tsss-R.
We showed thatLS
tsss-LL hyb- 1L hyb- 4LS
tsss-R, so Shamir’s secret sharing
scheme is secure. 
3.5? Visual Secret Sharing
Here is a fun variant of 2-out-of-2 secret-sharing called visual secret sharing. In this
variant, both the secret and the shares are black-and-white images. We require the same
security property as traditional secret-sharing — that is, a single share (image) by itself re-
veals no information about the secret (image). What makes visual secret sharing diﬀerent
is that we require the reconstruction procedure to be done visually.
More speci/f_ically, each share should be printed on transparent sheets. When the two
shares are stacked on top of each other, the secret image is revealed visually. We will dis-
cuss a simple visual secret sharing scheme that is inspired by the following observations:
when
 is stacked on top of
 , the result is
when
 is stacked on top of
 , the result is
when
 is stacked on top of
 , the result is
when
 is stacked on top of
 , the result is
Importantly, when stacking shares on top of each other in the /f_irst two cases, the result is
a22block that is half-black, half-white (let’s call it “gray”); while in the other cases the
result is completely black.
The idea is to process each pixel of the source image independently, and to encode
each pixel as a 22block of pixels in each of the shares. A white pixel should be shared in
62Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
a way that the two shares stack to form a “gray” 22block, while a black pixel is shared
in a way that results in a black 22block.
More formally:
Construction 3.14 Share¹mº:
initialize empty images s1;s2, with dimensions twice that of m
for each position¹i;jºinm:
randomly choose b1 f
 ;
g
ifm»i;j¼is a white pixel: set b2:=b1
ifm»i;j¼is a black pixel: set b2to the “opposite” of b1(i.e.,f
;
gnfb1g)
add22block b1to image s1at position¹2i;2jº
add22block b2to image s2at position¹2i;2jº
return¹s1;s2º
It is not hard to see that share s1leaks no information about the secret image m, because
it consists of uniformly chosen 22blocks. In the exercises you are asked to prove that
s2also individually leaks nothing about the secret image.
Note that whenever the source pixel is white, the two shares have identical 22blocks
(so that when stacked, they make a “gray” block). Whenever a source pixel is black, the
two shares have opposite blocks, so stack to make a black block.
Example
source image
share #1
share #2
stacked shares
Exercises
3.1. Generalize Construction 3.5 to be an n-out-of- nsecret-sharing scheme, and prove that
your scheme is correct and secure.
3.2. Prove Theorem 3.7.
3.3. Fill in the details of the following alternative proof of Theorem 3.6: Starting with Ltsss-L,
apply the /f_irst step of the proof as before, to duplicate the main body into 3 branches of a
new if-statement. Then apply Exercise 2.3 to the second branch of the if-statement. Argue
thatmLcan be replaced with mRand complete the proof.
63Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
3.4. Suppose Tis a /f_ixed (publicly known) invertible nnmatrix over Zp, where pis a prime.
(a) Show that the following two libraries are interchangeable:
Lle/f_t
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
r ¹Zpºn
return r;Lright
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
r ¹Zpºn
return Tr.
(b) Show that the following two libraries are interchangeable:
Lle/f_t
/q.sc_u.sc/e.sc/r.sc/y.sc¹v2¹Zpºnº:
r ¹Zpºn
z:=v+Tr
return z;Lright
/q.sc_u.sc/e.sc/r.sc/y.sc¹v2¹Zpºnº:
z ¹Zpºn
return z.
3.5. Consider a t-out-of- nthreshold secret sharing scheme with M=f0;1g`, and where each
user’s share is also a string of bits. Prove that if the scheme is secure, then every user’s
share must be at least `bits long.
Hint:Prove the contrapositive. Suppose the /f_irst user’s share is less than `bits (and that this fact is known
to everyone). Show how users 2through tcan violate security by enumerating all possibilities for
the /f_irst user’s share. Give your answer in the form of an distinguisher on the relevant libraries.
3.6.nusers have shared two secrets using Shamir secret sharing. User ihas a share si=¹i;/y.altiº
of the secret m, and a share s0
i=¹i;/y.alt0
iºof the secret m0. Both sets of shares use the same
prime modulus p.
Suppose each user ilocally computes zi=¹/y.alti+/y.alt0
iº%p.
(a) Prove that if the shares of mand shares of m0had the same threshold, then the resulting
f¹i;ziºji6ngare a valid secret-sharing of the secret m+m0.
(b) Describe what the users get when the shares of mandm0had diﬀerent thresholds (say,
tandt0, respectively).
3.7. Suppose there are 5 people on a committee: Alice (president), Bob, Charlie, David, Eve.
Suggest how they can securely share a secret so that it can only be opened by:
IAlice and any one other person
IAny three people
Describe in detail how the sharing algorithm works and how the reconstruction works
(for all authorized sets of users).
Note: It is /f_ine if diﬀerent users have shares which are of diﬀerent sizes ( e.g., diﬀerent
number of bits to represent), and it is also /f_ine if the Reconstruct algorithm depends on
the identities of the users who are contributing their shares.
64Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
3.8. Suppose there are 9 people on an important committee: Alice, Bob, Carol, David, Eve,
Frank, Gina, Harold, & Irene. Alice, Bob & Carol form a subcommittee; David, Eve &
Frank form another subcommittee; and Gina, Harold & Irene form another subcommittee.
Suggest how a dealer can share a secret so that it can only be opened when a majority of
each subcommittee is present. Describe why a 6-out-of-9 threshold secret-sharing scheme
does notsuﬃce.
Hint:Alice Bob Carol
David Eve FrankGina Harold IreneMAJ
MAJMAJAND
?3.9. (a) Generalize the previous exercise. A monotone formula is a boolean function ϕ:
f0;1gn!f0;1gthat when written as a formula uses only /a.sc/n.sc/d.sc and/o.sc/r.scoperations (no
/n.sc/o.sc/t.scs). For a set Af1; : : : ; ng, letχAbe the bitstring where whose ith bit is 1 if and
only if i2A.
For every monotone formula ϕ:f0;1gn!f0;1g, construct a secret-sharing scheme
whose authorized sets are fAf1; : : : ; ngjϕ¹χAº=1g. Prove that your scheme is
secure.
Hint:express the formula as a tree of /a.sc/n.sc/d.sc and/o.sc/r.scgates.
(b) Give a construction of a t-out-of- nsecret-sharing scheme in which all shares are binary
strings, and the only operation required of Share andReconstruct is/x.sc/o.sc/r.sc(so no mod- p
operations).
How big are the shares, compared to the Shamir scheme?
3.10. Prove that share s2in Construction 3.14 is distributed independently of the secret m.
3.11. Using actual transparencies or with an image editing program, reconstruct the secret
shared in these two images:
65Draft: January 3, 2021 CHAPTER 3. SECRET SHARING
?3.12. Construct a 3-out-of-3 visual secret sharing scheme. Any two shares should together re-
veal nothing about the source image, but any three reveal the source image when stacked
together.
664Basing Cryptography on
Intractable Computations
John Nash was a mathematician who earned the 1994 Nobel Prize in Economics for his
work in game theory. His life story was made into a successful movie, A Beautiful Mind.
In 1955, Nash was in correspondence with the United States National Security Agency
(NSA),1discussing new methods of encryption that he had devised. In these letters, he also
proposes some general principles of cryptography (bold highlighting not in the original):
: : :in principle the enemy needs very little information to begin to break down
the process. Essentially, as soon as λbits2of enciphered message have been trans-
mitted the key is about determined. This is no security, for a practical key should
not be too long. But this does not consider how easy or diﬃcult it is for
the enemy to make the computation determining the key. If this com-
putation, although possible in principle, were suﬃciently long at best
then the process could still be secure in a practical sense.
Nash is saying something quite profound: it doesn’t really matter whether attacks
areimpossible , only whether attacks are computationally infeasible. If his letters
hadn’t been kept classi/f_ied until 2012, they might have accelerated the development of
“modern” cryptography, in which security is based on intractable computations. As it
stands, he was decades ahead of his time in identifying one of the most important concepts
in modern cryptography.
4.1 What /Q_ualifies as a “Computationally Infeasible” A/t_tack?
Schemes like one-time pad cannot be broken, even by an attacker that performs a brute-
force attack, trying all possible keys (see Exercise 1.5). However, all future schemes that
we will see can indeed be broken by such an attack. Nash is quick to point out that, for a
scheme with λ-bit keys:
The most direct computation procedure would be for the enemy to try all 2λ
possible keys, one by one. Obviously this is easily made impractical for the enemy
by simply choosing λlarge enough.
1The original letters, handwritten by Nash, are available at: h/t_tps://www.nsa.gov/Portals/70/documents/
news-features/declassified-documents/nash-le/t_ters/nash_le/t_ters1.pdf .
2Nash originally used rto denote the length of the key, in bits. In all of the excerpts quoted in this chapter,
I have translated his mathematical expressions into our notation ( λ).
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
We callλthesecurity parameter of the scheme. It is like a knob that allows the
user to tune the security to any desired level. Increasing λmakes the diﬃculty of a brute-
force attack grow exponentially fast. Ideally, when using λ-bit keys, every attack (not just
a brute-force attack) will have diﬃculty roughy 2λ. However, sometimes faster attacks
are inevitable. Later in this chapter, we will see why many schemes with λ-bit keys have
attacks that cost only 2λ2. It is common to see a scheme described as having n-bit security
if the best known attack requires 2nsteps.
Just how impractical is a brute-force computation on a 64-bit key? A 128-bit key?
Huge numbers like 264and2128are hard to grasp at an intuitive level.
Example It can be helpful to think of the cost of a computation in terms of monetary value, and a
convenient way to assign such monetary costs is to use the pricing model of a cloud computing
provider. Below, I have calculated roughly how much a computation involving 2λCPU cycles
would cost on Amazon EC2, for various choices of λ.3
clock cycles approx cost reference
250$3.50 cup of coﬀee
255$100 decent tickets to a Portland Trailblazers game
265$130,000 median home price in Oshkosh, WI
275$130 million budget of one of the Harry Potter movies
285$140 billion GDP of Hungary
292$20 trillion GDP of the United States
299$2 quadrillion all of human economic activity since 300,000 BC4
2128really a lot a billion human civilizations’ worth of eﬀort
Remember, this table only shows the cost to perform 2λclock cycles. A brute-force attack
checking 2λkeys would take many more cycles than that! But, as a disclaimer, these numbers
re/f_lect only the retail cost of performing a computation, on fairly standard general-purpose
hardware. A government organization would be capable of manufacturing special-purpose
hardware that would signi/f_icantly reduce the computation’s cost. The exercises explore some
of these issues, as well as non-/f_inancial ways of conceptualizing the cost of huge computations.
Example In 2017, the /f_irst collision in the SHA-1 hash function was found (we will discuss hash functions
later in the course). The attack involved evaluating the SHA-1 function 263times on a cluster
of GPUs. An article in Ars Technica5estimates the monetary cost of the attack as follows:
Had the researchers performed their attack on Amazon’s Web Services platform,
it would have cost $560,000 at normal pricing. Had the researchers been patient
and waited to run their attack during oﬀ-peak hours, the same collision would
have cost $110,000.
3As of October 2018, the cheapest class of CPU that is suitable for an intensive computation is the
m5.large , which is a 2.5 GHz CPU. Such a CPU performs 243clock cycles per hour. The cheapest rate on
EC2 for this CPU is 0.044 USD per hour (3-year reserved instances, all costs paid upfront). All in all, the cost
for a single clock cycle (rounding down) is 2 48USD.
4I found some estimates ( h/t_tps://en.wikipedia.org/wiki/Gross_world_product ) of the gross world product
(like the GDP but for the entire world) throughout human history, and summed them up for every year.
5h/t_tps://arstechnica.com/information-technology/2017/02/at-deaths-door-for-years-widely-used-sha1-function-is-now-dead/
68Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
Asymptotic Running Time
It is instructive to think about the monetary cost of an enormous computation, but it
doesn’t necessarily help us draw the line between “feasible” attacks (which we want to
protect against) and “infeasible” ones (which we agreed we don’t need to care about). We
need to be able to draw such a line in order to make security de/f_initions that say “only
feasible attacks are ruled out.”
Once again, John Nash thought about this question. He suggested to consider the
asymptotic cost of an attack — how does the cost of a computation scale as the security
parameter λgoes to in/f_inity?
So a logical way to classify enciphering processes is by the way in which the
computation length for the computation of the key increases with in-
creasing length of the key. This is at best exponential and at worst proba-
bly a relatively small power of λ,aλ2oraλ3, as in substitution ciphers.
Nash highlights the importance of attacks that run in polynomial time:
Definition 4.1 A program runs in polynomial time if there exists a constant c>0such that for all suﬃ-
ciently long input strings x, the program stops after no more than O¹jxjcºsteps.
Polynomial-time algorithms scale reasonably well (especially when the exponent is small),
but exponential-time algorithms don’t. It is probably no surprise to modern readers to see
“polynomial-time” as a synonym for “eﬃcient.” However, it’s worth pointing out that,
again, Nash is years ahead of his time relative to the /f_ield of computer science.
In the context of cryptography, our goal will be to ensure that no polynomial-time
attack can successfully break security. We will not worry about attacks like brute-force
that require exponential time.
Polynomial time is not a perfect match to what we mean when we informally talk about
“eﬃcient” algorithms. Algorithms with running time Θ¹n1000ºare technically polynomial-
time, while those with running time Θ¹nlog log log nºaren’t. Despite that, polynomial-time is
extremely useful because of the following closure property : repeating a polynomial-time
process a polynomial number of times results in a polynomial-time process overall.
Potential Pitfall: Numerical Algorithms
When we study public-key cryptography, we will discuss algorithms that operate on very
large numbers (e.g., thousands of bits long). You must remember that representing the
number Non a computer requires only log2Nbits. This means that log2N, rather than
N, is our security parameter! We will therefore be interested in whether certain operations
on the number Nrun in polynomial-time as a function of log2N, rather than in N. Keep
in mind that the diﬀerence between running time O¹logNºandO¹Nºis the diﬀerence
between writing down a number and counting to the number.
For reference, here are some numerical operations that we will be using later in the
class, and their known eﬃciencies:
69Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
Eﬃcient algorithm known: No known eﬃcient algorithm:
Computing GCDs Factoring integers
Arithmetic mod N Computing ϕ¹Nºgiven N
Inverses mod N Discrete logarithm
Exponentiation mod N Square roots mod composite N
Again, “eﬃcient” means polynomial-time. Furthermore, we only consider polynomial-
time algorithms that run on standard, classical computers. In fact, all of the problems in the
right-hand column dohave known polynomial-time algorithms on quantum computers.
4.2 What /Q_ualifies as a “Negligible” Success Probability?
It is not enough to consider only the running time of an attack. For example, consider an
attacker who just tries to guess a victim’s secret key, making a single guess. This attack is
extremely cheap, but it still has a nonzero chance of breaking security!
In addition to an attack’s running time, we also need to consider its success probability.
We don’t want to worry about attacks that are as expensive as a brute-force attack, and
we don’t want to worry about attacks whose success probability is as low as a blind-guess
attack.
An attack with success probability 2 128should not really count as an attack, but an
attack with success probability 1/2 should. Somewhere in between 2 128and2 1we need
to /f_ind a reasonable place to draw a line.
Example Now we are dealing with extremely tiny probabilities that can be hard to visualize. Again, it
can be helpful to conceptualize these probabilities with a more familiar reference:
probability equivalent
2 10full house in 5-card poker
2 20royal /f_lush in 5-card poker
2 28you win this week’s Powerball jackpot
2 40royal /f_lush in 2 consecutive poker games
2 60the next meteorite that hits Earth lands in this square !
As before, it is not clear exactly where to draw the line between “reasonable” and “un-
reasonable” success probability for an attack. Just like we did with polynomial running
time, we can also use an asymptotic approach to de/f_ine when a probability is negligi-
bly small. Just as “polynomial time” considers how fast an algorithm’s running time ap-
proaches in/f_inity as its input grows, we can also consider how fast a success probability
approaches zero as the security parameter grows.
In a scheme with λ-bit keys, a blind-guessing attack succeeds with probability 12λ.
Now what about an attacker who makes 2 blind guesses, or λguesses, or λ42guesses? Such
an attacker would still run in polynomial time, and has success probability 22λ,λ2λ, or
λ422λ. However, no matter what polynomial you put in the numerator, the probability still
goes to zero. Indeed, 12λapproaches zero so fast that no polynomial can “rescue”
it; or, in other words, it approaches zero faster than 1 over any polynomial. This idea leads
to our formal de/f_inition:
70Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
Definition 4.2
(Negligible)A function fisnegligible if, for every polynomial p, we have lim
λ!1p¹λºf¹λº=0.
In other words, a negligible function approaches zero so fast that you can never catch
up when multiplying by a polynomial. This is exactly the property we want from a se-
curity guarantee that is supposed to hold against all polynomial-time adversaries. If a
polynomial-time attacker succeeds with probability f, then repeating the same attack p
independent times would still be an overall polynomial-time attack (if pis a polynomial),
and its success probability would be pf.
When you want to check whether a function is negligible, you only have to consider
polynomials pof the form p¹λº=λcfor some constant c:
Claim 4.3 If for every integer c,lim
λ!1λcf¹λº=0, then fis negligible.
Proof Suppose fhas this property, and take an arbitrary polynomial p. We want to show that
limλ!1p¹λºf¹λº=0.
Ifdis the degree of p, then limλ!1p¹λº
λd+1=0. Therefore,
lim
λ!1p¹λºf¹λº=lim
λ!1p¹λº
λd+1
λd+1f¹λº
=
lim
λ!1p¹λº
λd+1 
lim
λ!1λd+1f¹λº
=00:
The second equality is a valid law for limits since the two limits on the right exist and are
not an indeterminate expression like 01. The /f_inal equality follows from the hypothesis
onf. 
Example The function f¹λº=12λis negligible, since for any integer c, we have:
lim
λ!1λc2λ=lim
λ!12clog¹λº2λ=lim
λ!12clog¹λº λ=0;
since clog¹λº λapproaches 1in the limit, for any constant c. Using similar reasoning,
one can show that the following functions are also negligible:
1
2λ2;1
2p
λ;1
2log2λ;1
λlogλ:
Functions like 1λ5approach zero but not fast enough to be negligible. To see why, we can
take polynomial p¹λº=λ6and see that the resulting limit does not satisfy the requirement
from De/f_inition 4.2:
lim
λ!1p¹λº1
λ5=lim
λ!1λ=1,0
In this class, when we see a negligible function, it will typically always be one that
is easy to recognize as negligible (just as in an undergraduate algorithms course, you
won’t really encounter algorithms where it’s hard to tell whether the running time is
polynomial).
Definition 4.4
(f/afii10069.ital)Iff;/afii10069.ital:N!Rare two functions, we write f/afii10069.italto mean thatf¹λº /afii10069.ital¹λºis a negligible
function.
71Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
We use the terminology of negligible functions exclusively when discussing probabilities,
so the following are common:
Pr»X¼0,“event Xalmost never happens”
Pr»Y¼1,“event Yalmost always happens”
Pr»A¼Pr»B¼ , “events AandBhappen with
essentially the same probability”6
Additionally, thesymbol is transitive :7ifPr»X¼Pr»Y¼andPr»Y¼Pr»Z¼, then Pr»X¼
Pr»Z¼(perhaps with a slightly larger, but still negligible, diﬀerence).
4.3 Indistinguishability
So far we have been writing formal security de/f_initions in terms of interchangeable li-
braries, which requires that two libraries have exactly the same eﬀect on every calling
program. Going forward, our security de/f_initions will not be quite as demanding. First,
we only consider polynomial-time calling programs; second, we don’t require the libraries
to have exactly the same eﬀect on the calling program, only that the diﬀerence in eﬀects
is negligible.
Definition 4.5
(Indistinguishable)LetLle/f_tandLrightbe two libraries with a common interface. We say that Lle/f_tandLright
areindistinguishable , and writeLle/f_tLright, if for all polynomial-time programs Athat
output a single bit, Pr»AL le/f_t)1¼Pr»AL right)1¼:
We call the quantityPr»AL le/f_t)1¼ Pr»AL right)1¼theadvantage orbias
ofAin distinguishingLle/f_tfromLright. Two libraries are therefore indistinguishable if all
polynomial-time calling programs have negligible advantage in distinguishing them.
From the properties of the “ ” symbol, we can see that indistinguishability of libraries is
also transitive, which allows us to carry out hybrid proofs of security in the same way as
before.
Example Here is a very simple example of two indistinguishable libraries:
Lle/f_t
/p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc¹xº:
s f0;1gλ
return x?=sLright
/p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc¹xº:
return false
6Pr»A¼Pr»B¼doesn’t mean that events AandBalmost always happen together (when AandBare
de/f_ined over a common probability space) — imagine Abeing the event “the coin came up heads” and Bbeing
the event “the coin came up tails.” These events have the same probability but never happen together. To say
that “ AandBalmost always happen together,” you’d have to say something like Pr»AB¼0, where AB
denotes the event that exactly one ofAandBhappens.
7It’s only transitive when applied a polynomial number of times. So you can’t de/f_ine a whole series of
events Xi, show that Pr»Xi¼Pr»Xi+1¼, and conclude that Pr»X1¼Pr»X2n¼. It’s rare that we’ll encounter
this subtlety in this course.
72Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
Imagine the calling program trying to predict which string will be chosen when uniformly
sampling fromf0;1gλ. The left library tells the calling program whether its prediction was
correct. The right library doesn’t even bother sampling a string, it just always says “sorry,
your prediction was wrong.”
Here is one obvious strategy (maybe not the best one, we will see) to distinguish these
libraries. The calling program Aobvious calls /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc many times and outputs 1 if it ever
received true as a response. Since it seems like the argument to /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc might not have any
eﬀect, let’s just use the string of all- 0s as argument every time.
Aobvious
doqtimes:
if/p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc¹0λº=true
return 1
return 0
ILrightcan never return true , soPr»AobviousL right)1¼=0.
IInLle/f_teach call to /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc has an independent probability 12λof returning true .
SoPr»AobviousL le/f_t)1¼is surely non-zero. Actually, the exact probability is a bit
cumbersome to write:
Pr»AobviousL le/f_t)1¼=1 Pr»AobviousL le/f_t)0¼
=1 Pr»allqindependent calls to /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc return false¼
=1 
1 1
2λq
Rather than understand this probability, we can just compute an upper bound for it.
Using the union bound, we get:
Pr»AobviousL le/f_t)1¼6Pr»/f_irst call to /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc returns true¼
+Pr»second call to /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc returns true¼+
=q1
2λ
This is an overestimate of some probabilities ( e.g., if the /f_irst call to /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc returns
true , then the second call isn’t made). More fundamentally, q2λexceeds 1 when qis
large. But nevertheless, Pr»AobviousL le/f_t)1¼6q2λ.
We showed thatAobvious has non-zero advantage. This is enough to show that Lle/f_t.Lright.
We also showed that Aobvious has advantage at most q2λ. SinceAobvious runs in poly-
nomial time, it can only make a polynomial number qof queries to the library, so q2λis
negligible. However, this is not enough to show that Lle/f_tLrightsince it considers only a
single calling program. To show that the libraries are indistinguishable, we must show that
every calling program’s advantage is negligible.
In a few pages, we will prove that for anyAthat makes qcalls to /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc ,
Pr»AL le/f_t)1¼ Pr»AL right)1¼6q
2λ:
For any polynomial-time A, the number qof calls to /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc will be a polynomial in λ,
making q2λa negligible function. Hence, Lle/f_tLright.
73Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
Other Properties
Lemma 4.6
(facts)IfL1L 2thenL1L2. Also, ifL1L2L3thenL1L3.
Analogous to Lemma 2.11, we also have the following library chaining lemma, which
you are asked to prove as an exercise:
Lemma 4.7
(Chaining)IfLle/f_tLrightthenLL le/f_tLL rightfor any polynomial-time library L.
Bad-Event Lemma
A common situation is when two libraries are expected to execute exactly the same state-
ments, until some rare & exceptional condition happens. In that case, we can bound an
attacker’s distinguishing advantage by the probability of the exceptional condition.
More formally,
Lemma 4.8
(Bad events)LetLle/f_tandLrightbe libraries that each de/f_ine a variable named ‘ bad’ that is initialized to
0. IfLle/f_tandLrighthave identical code, except for code blocks reachable only when bad=1
(e.g., guarded by an “if bad=1” statement), then
Pr»AL le/f_t)1¼ Pr»AL right)1¼6Pr»AL le/f_tsetsbad=1¼:
Proof? Fix an arbitrary calling program A. In this proof, we use conditional probabilites8to
isolate the cases where badis changed to 1. We de/f_ine the following events:
IBle/f_t: the event thatAL le/f_tsetsbadto 1 at some point.
IBright: the event thatAL rightsetsbadto 1 at some point.
We also writeBle/f_tandBrightto denote the corresponding complement events. From con-
ditional probability, we can write:
Pr»AL le/f_t)1¼=Pr»AL le/f_t)1jBle/f_t¼Pr»Ble/f_t¼
+Pr»AL le/f_t)1jBle/f_t¼Pr»Ble/f_t¼
Pr»AL right)1¼=Pr»AL right)1jBright¼Pr»Bright¼
+Pr»AL right)1jBright¼Pr»Bright¼
Our /f_irst observation is that Pr»Ble/f_t¼=Pr»Bright¼. This is because at the time badis
changed to 1 for the /f_irst time, the library has only been executing instructions that are
the same inLle/f_tandLright. In other words, the choice to set badto 1 is determined by
the same sequence of instructions in both libraries, so it occurs with the same probability
in both libraries.
As a shorthand notation, we de/f_ine pdef=Pr»Ble/f_t¼=Pr»Bright¼. Then we can write the
advantage ofAas:
advantageA=Pr»AL le/f_t)1¼ Pr»AL right)1¼
8The use of conditional probabilites here is delicate and prone to subtle mistakes. For a discussion of the
pitfalls, consult the paper where this lemma /f_irst appeared: Mihir Bellare & Phillip Rogaway: “Code-Based
Game-Playing Proofs and the Security of Triple Encryption,” in Eurocrypt 2006. ia.cr/2004/331
74Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
=
Pr»AL le/f_t)1jBle/f_t¼p+Pr»AL le/f_t)1jBle/f_t¼¹1 pº
 
Pr»AL right)1jBright¼p+Pr»AL right)1jBright¼¹1 pº
=p
Pr»AL le/f_t)1jBle/f_t¼ Pr»AL right)1jBright¼
¹1 pº
Pr»AL le/f_t)1jBle/f_t¼ Pr»AL right)1jBright¼
In both of the expressions Pr»AL le/f_t)1jBle/f_t¼andPr»AL right)1jBright¼, we
are conditioning on badnever being set to 0. In this case, both libraries are executing
the same sequence of instructions, so the probabilities are equal (and the diﬀerence of the
probabilities is zero). Substituting in, we get:
advantageA=pPr»AL le/f_t)1jBle/f_t¼ Pr»AL right)1jBright¼
Intuitively, the proof is con/f_irming the idea that diﬀerences can only be noticed between
Lle/f_tandLrightwhen badis set to 1 (corresponding to our conditioning on Ble/f_tandBright).
The quantity within the absolute value is the diﬀerence of two probabilities, so the
largest it can be is 1. Therefore,
advantageA6pdef=Pr»Ble/f_t¼=Pr»AL le/f_tsetsbad=1¼:
This completes the proof. 
Example ConsiderLle/f_tandLrightfrom the previous example (where the calling program tries to “pre-
dict” the result of uniformly sampling a λ-bit string). We can prove that they are indistin-
guishable with the following sequence of hybrids:
Lle/f_t
/p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc¹xº:
s f0;1gλ
return x?=sLhyb-L
bad:=0
/p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc¹xº:
s f0;1gλ
ifx=s:
bad:=1
return true
return falseLhyb-R
bad:=0
/p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc¹xº:
s f0;1gλ
ifx=s:
bad:=1
return falseLright
/p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc¹xº:
return false
Let us justify each of the steps:
ILle/f_tL hyb-L: The only diﬀerence is that Lhyb-L maintains a variable “ bad.” Since it
never actually reads from this variable, the change can have no eﬀect.
ILhyb-L andLhyb-R diﬀer only in the highlighted line, which can only be reached when
bad=1. Therefore, from the bad-event lemma:
Pr»AL hyb-L)1¼ Pr»AL hyb-R)1¼6Pr»AL hyb-L setsbad=1¼:
75Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
ButAL hyb-L only sets bad=1if the calling program successfully predicts sin one
of the calls to /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc . With qcalls to /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc , the total probability of this happening
is at most q2λ, which is negligible when the calling program runs in polynomial time.
HenceLhyb-LLhyb-R .
ILhyb-RL right: Similar to above, note how the /f_irst 3 lines of /p.sc/r.sc/e.sc/d.sc/i.sc/c.sc/t.sc inLhyb-R don’t
actually do anything. The subroutine is going to return false no matter what. Both
libraries have identical behavior.
SinceLle/f_tL hyb-LLhyb-RL right, this proves thatLle/f_tLright.
4.4 Birthday Probabilities & Sampling With/out Replacement
In many cryptographic schemes, the users repeatedly choose random strings ( e.g., each
time they encrypt a message), and security breaks down if the same string is ever chosen
twice. Hence, it is important that the probability of a repeated sample is negligible. In this
section we compute the probability of such events and express our /f_indings in a modular
way, as a statement about the indistinguishability of two libraries.
Birthday Probabilities
Ifqpeople are in a room, what is the probability that two of them have the same birthday (if
we assume that each person’s birthday is uniformly chosen from among the possible days
in a year)? This question is known as the birthday problem , and it is famous because
the answer is highly unintuitive to most people.9
Let’s make the question more general. Imagine taking qindependent, uniform samples
from a set of Nitems. What is the probability that the same value gets chosen more than
once? In other words, what is the probability that the following program outputs 1?
B¹q;Nº
fori:=1toq:
si f1; : : : ; Ng
forj:=1toi 1:
ifsi=sjthen return 1
return 0
Let’s give a name to this probability:
BirthdayProb¹q;Nºdef=Pr»B¹q;Nºoutputs 1¼:
It is possible to write an exact formula for this probability:
Lemma 4.9 BirthdayProb¹q;Nº=1 q 1Ö
i=1
1 i
N
.
9It is sometimes called the “birthday paradox,” even though it is not really a paradox. The actual birthday
paradox is that the “birthday paradox” is not a paradox.
76Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
Proof Let us instead compute the probability that Boutputs 0, which will allow us to then solve
for the probability that it outputs 1. In order for Bto output 0, it must avoid the early
termination conditions in each iteration of the main loop. Therefore:
Pr»B¹q;Nºoutputs 0¼=Pr»B¹q;Nºdoesn’t terminate early in iteration i=1¼
Pr»B¹q;Nºdoesn’t terminate early in iteration i=2¼
:::
Pr»B¹q;Nºdoesn’t terminate early in iteration i=q¼
In iteration iof the main loop, there are i 1previously chosen values s1; : : : ; si 1. The
program terminates early if any of these are chosen again as si, otherwise it continues to
the next iteration. Put diﬀerently, there are i 1(out of N) ways to choose sithat lead to
early termination — all other choices of siavoid early termination. Since the Npossibilities
forsihappen with equal probability:
Pr»B¹q;Nºdoesn’t terminate early in iteration i¼=1 i 1
N:
Putting everything together:
BirthdayProb¹q;Nº=Pr»B¹q;Nºoutputs 1¼
=1 Pr»B¹q;Nºoutputs 0¼
=1 
1 1
N 
1 2
N

1 q 1
N
=1 q 1Ö
i=1
1 i
N
This completes the proof. 
Example This formula for BirthdayProb¹q;Nºis not easy to understand at a glance. We can get a
better sense of its behavior as a function of qby plotting it. Below is a plot with N=365,
corresponding to the classic birthday problem:
0 10 20 30 40 50 60 7000:51
BirthdayProb¹q;365º
With only q=23people the probability of a shared birthday already exceeds 50%. The graph
could be extended to the right (all the way to q=365), but even at q=70the probability
exceeds 99.9%.
77Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
Asymptotic Bounds on the Birthday Probability
It will be helpful to have an asymptotic formula for how BirthdayProb¹q;Nºgrows as
a function of qandN. We are most interested in the case where qis relatively small
compared to N(e.g., when qis a polynomial function of λbutNis exponential).
Lemma 4.10
(Birthday Bound)Ifq6p
2N, then
0:632q¹q 1º
2N6BirthdayProb¹q;Nº6q¹q 1º
2N:
Since the upper and lower bounds diﬀer by only a constant factor, it makes sense to write
BirthdayProb¹q;Nº=Θ¹q2Nº.
Proof We split the proof into two parts.
ITo prove the upper bound, we use the fact that when xand/y.altare positive,
¹1 xº¹1 /y.altº=1 ¹x+/y.altº+x/y.alt
>1 ¹x+/y.altº:
More generally, when all terms xiare positive,Î
i¹1 xiº>1 Í
ixi. Hence,
1 Î
i¹1 xiº61 ¹1 Í
ixiº=Í
ixi:
Applying that fact,
BirthdayProb¹q;Nºdef=1 q 1Ö
i=1
1 i
N
6q 1Õ
i=1i
N=Íq 1
i=1i
N=q¹q 1º
2N:
ITo prove the lower bound, we use the fact that when 06x61,
1 x6e x61 0:632x:
This fact is illustrated below. The signi/f_icance of 0:632is that 1 1
e=0:63212 : : :
e x
1 0:632x
1 x
We can use both of these upper and lower bounds on e xto show the following:
q 1Ö
i=1
1 i
N
6q 1Ö
i=1e i
N=e Íq 1
i=1i
N=e q¹q 1º
2N61 0:632q¹q 1º
2N:
78Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
With the last inequality we used the fact that q6p
2N, and thereforeq¹q 1º
2N61
(this is necessary to apply the inequality e x61 0:632x). Hence:
BirthdayProb¹q;Nºdef=1 q 1Ö
i=1
1 i
N
>1 
1 0:632q¹q 1º
2N
=0:632q¹q 1º
2N:
This completes the proof. 
Example Below is a plot of these bounds compared to the actual value of BirthdayProb¹q;Nº(forN=
365):
0 10 20 30 40 50 60 7000:51
BirthdayProb¹q;365º
0:632q¹q 1º
2365q¹q 1º
2365
As mentioned previously, BirthdayProb¹q;Nºgrows roughly like q2Nwithin the range of
values we care about ( qsmall relative to N).
The Birthday Problem in Terms of Indistinguishable Libraries
Below are two libraries which will also be useful for future topics.
Lsamp-L
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλ
return rLsamp-R
R:=;
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλnR
R:=R[frg
return r
Both libraries provide a /s.sc/a.sc/m.sc/p.sc subroutine that samples a random element of f0;1gλ. The
implementation in Lsamp-L samples uniformly and independently from f0;1gλeach time.
It samples with replacement, so it is possible (although maybe unlikely) for multiple
calls to /s.sc/a.sc/m.sc/p.sc to return the same value in Lsamp-L .
On the other hand, Lsamp-R samplesλ-bit strings without replacement . It keeps track
of a set R, containing all the values it has previously sampled, and avoids choosing them
again (“f0;1gλnR” is the set of λ-bit strings excluding the ones in R). In this library, /s.sc/a.sc/m.sc/p.sc
will never output the same value twice.
79Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
The “obvious” distinguishing strategy. A natural way (but maybe not the only way)
to distinguish these two libraries, therefore, would be to call /s.sc/a.sc/m.sc/p.sc many times. If you ever
see a repeated output, then you must certainly be linked to Lsamp-L . After some number
of calls to /s.sc/a.sc/m.sc/p.sc , if you still don’t see any repeated outputs, you might eventually stop and
guess that you are linked to Lsamp-R .
LetAqdenote this “obvious” calling program that makes qcalls to /s.sc/a.sc/m.sc/p.sc and returns
1 if it sees a repeated value. Clearly, the program can never return 1 when it is linked to
Lsamp-R . On the other hand, when it is linked to Lsamp-L , it returns 1 with probability ex-
actly BirthdayProb¹q;2λº. Therefore, the advantage ofAqis exactly BirthdayProb¹q;2λº.
This program behaves diﬀerently in the presence of these two libraries, therefore they
are not interchangeable. But are the libraries indistinguishable? We have demonstrated a
calling program with advantage BirthdayProb¹q;2λº. We have not speci/f_ied qexactly, but
ifAqis meant to run in polynomial time (as a function of λ), then qmust be a polynomial
function of λ. Then the advantage of AqisBirthdayProb¹q;2λº=Θ¹q22λº, which is
negligible!
To show that the librares are indistinguishable, we have to show that allcalling pro-
grams have negligible advantage. It is not enough just to show that this particular calling
program has negligible advantage. Perhaps surprisingly, the “obvious” calling program
that we considered is the best possible distinguisher!
Lemma 4.11
(Repl. Sampling)LetLsamp-L andLsamp-R be de/f_ined as above. Then for all calling programs Athat make q
queries to the /s.sc/a.sc/m.sc/p.sc subroutine, the advantage of Ain distinguishing the libraries is at most
BirthdayProb¹q;2λº.
In particular, when Ais polynomial-time (in λ),qgrows as a polynomial in the security
parameter. Hence,Ahas negligible advantage. Since this is true for all polynomial-time A,
we haveLsamp-LLsamp-R .
Proof Consider the following hybrid libraries:
Lhyb-L
R:=;
bad:=0
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλ
ifr2Rthen:
bad:=1
R:=R[frg
return rLhyb-R
R:=;
bad:=0
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλ
ifr2Rthen:
bad:=1
r f0;1gλnR
R:=R[frg
return r
First, let us prove some simple observations about these libraries:
Lhyb-LL samp-L : Note thatLhyb-L simply samples uniformly from f0;1gλ. The extra R
andbadvariables inLhyb-L don’t actually have an eﬀect on its external
behavior (they are used only for convenience later in the proof).
80Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
Lhyb-RL samp-R : WhereasLsamp-R avoids repeats by simply sampling from f0;1gλnR,
this libraryLhyb-R samples runiformly fromf0;1gλand retries if the
result happens to be in R. This method is called rejection sampling , and
it has the same eﬀect10as sampling rdirectly fromf0;1gλnR.
Conveniently,Lhyb-L andLhyb-R diﬀer only in code that is reachable when bad=1(high-
lighted). So, using Lemma 4.8, we can bound the advantage of the calling program:
Pr»AL samp-L)1¼ Pr»AL samp-R)1¼
=Pr»AL hyb-L)1¼ Pr»AL hyb-R)1¼
6Pr»AL hyb-L setsbad:=1¼:
Finally, we can observe that AL hyb-L setsbad:=1only in the event that it sees a repeated
sample fromf0;1gλ. This happens with probability BirthdayProb¹q;2λº.
Discussion
IStating the birthday problem in terms of indistinguishable libraries makes it a useful
tool in future security proofs. For example, when proving the security of a construc-
tion we can replace a uniform sampling step with a sampling-without-replacement
step. This change has only a negligible eﬀect, but now the rest of the proof can take
advantage of the fact that samples are never repeated.
Another way to say this is that, when you are thinking about a cryptographic con-
struction, it is “safe to assume” that randomly sampled long strings do not repeat,
and behave accordingly.
IHowever, if a security proof does use the indistinguishability of the birthday li-
braries, it means that the scheme can likely be broken when a user happens to repeat
a uniformly sampled value. Since this becomes inevitable as the number of samples
approachesp
2λ+12λ2, it means the scheme only oﬀers λ2bits of security. When
a scheme has this property, we say that it has birthday bound security. It is im-
portant to understand when a scheme has this property, since it informs the size of
keys that should be chosen in practice.
A Generalization
A calling program can distinguish between the previous libraries if /s.sc/a.sc/m.sc/p.sc ever returns the
same value twice. In any given call to /s.sc/a.sc/m.sc/p.sc , the variableRdenotes the set of “problematic”
values that cause the libraries to be distinguished. At any point, Rhas only polynomially
many values, so the probability of chosing such a problematic one is negligible.
Suppose we considered a diﬀerent set of values to be problematic. As long as there are
only polynomially many problematic values in each call to /s.sc/a.sc/m.sc/p.sc , the reasoning behind the
proof wouldn’t change much. This idea leads to the following generalization, in which the
calling program explicitly writes down all of the problematic values:
10The two approaches for sampling from f0;1gλnRmay have diﬀerent running times, but our model
considers only the input-output behavior of the library.
81Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
Lemma 4.12 The following two libraries are indistinguishable, provided that the argument Rto/s.sc/a.sc/m.sc/p.sc is
passed as an explicit list of items.
Lsamp-L
/s.sc/a.sc/m.sc/p.sc¹Rf 0;1gλº:
r f0;1gλ
return rLsamp-R
/s.sc/a.sc/m.sc/p.sc¹Rf 0;1gλº:
r f0;1gλnR
return r
Suppose the calling program makes qcalls to /s.sc/a.sc/m.sc/p.sc , and in the ith call it uses an argu-
mentRwith niitems. Then the advantage of the calling program is at most:
1 qÖ
i=1
1 ni
2λ
:
We can bound this advantage as before. IfÍq
i=1ni62λ, then the advantage is between
0:632 Íq
i=1ni2λand Íq
i=1ni2λ. When the calling program runs in polynomial time
and must passRas an explicit list ( i.e., take the time to “write down” the elements of R),Íq
i=1niis a polynomial in the security parameter and the calling program’s advantage is
negligible.
The birthday scenario corresponds to the special case where ni=i 1(in the ith call,
Rconsists of the i 1results from previous calls to /s.sc/a.sc/m.sc/p.sc ). In that case,Íq
i=1ni=q¹q 1º2
and the probabilities collapse to the familiar birthday probabilities.
Exercises
4.1. In Section 4.1 we estimated the monetary cost of large computations, using pricing infor-
mation from Amazon EC2 cloud computing service. This re/f_lects the cost of doing a huge
computation using a general-purpose CPU. For long-lived computations, the dominating
cost is not the one-time cost of the hardware, but rather the cost of electricity powering
the hardware. Because of that, it can be much cheaper to manufacture special-purpose
hardware. Depending on the nature of the computation, special-purpose hardware can be
signi/f_icantly more energy-eﬃcient.
This is the situation with the Bitcoin cryptocurrency. Mining Bitcoin requires evaluat-
ing the SHA-256 cryptographic hash function as many times as possible, as fast as possi-
ble. When mining Bitcoin today, the only economically rational choice is to use special-
purpose hardware that does nothing except evaluate SHA-256, but is millions (maybe bil-
lions) of times more energy eﬃcient than a general-purpose CPU evaluating SHA-256.
(a) The relevant specs for Bitcoin mining hardware are wattage and giga-hashes (or tera-
hashes) per second, which can be converted into raw energy required per hash. Search
online and /f_ind the most energy eﬃcient mining hardware you can ( e.g., least joules
per hash).
(b) Find the cheapest real-world electricity rates you can, anywhere in the world. Use
these to estimate the monetary cost of computing 240;250; : : : ; 2120SHA-256 hashes.
82Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
(c) Money is not the only way to measure the energy cost of a huge computation. Search
online to /f_ind out how much carbon dioxide (CO 2) is placed into the atmosphere per
unit of electrical energy produced, under a typical distribution of power production
methods. Estimate how many tons of CO 2are produced as a side-eﬀect of computing
240;250; : : : ; 2120SHA-256 hashes.
?(d) Estimate the corresponding CO 2concentration (parts per million) in the atmosphere
as a result of computing 240;250; : : : ; 2120SHA-256 hashes. If it is possible without
a PhD in climate science, try to estimate the increase in average global temperature
caused by these computations.
4.2. Which of the following are negligible functions in λ? Justify your answers.
1
2λ21
2log¹λ2º1
λlog¹λº1
λ21
2¹logλº21
¹logλº21
λ1λ1p
λ1
2p
λ
4.3. Suppose fand/afii10069.italare negligible.
(a) Show that f+/afii10069.italis negligible.
(b) Show that f/afii10069.italis negligible.
(c) Give an example fand/afii10069.italwhich are both negligible, but where f¹λº/afii10069.ital¹λºis not negli-
gible.
4.4. Show that when fis negligible, then for every polynomial p, the function p¹λºf¹λºnot
only approaches 0, but it is also negligible itself.
Hint:Use the contrapositive. Suppose that p¹λºf¹λºis non-negligible, where pis a polynomial. Conclude
that fmust also be non-negligible.
4.5. Prove that therelation is transitive. Let f;/afii10069.ital;h:N!Rbe functions. Using the de/f_inition
of therelation, prove that if f/afii10069.italand/afii10069.italhthen fh. You may /f_ind it useful to invoke
thetriangle inequality :ja cj6ja bj+jb cj.
4.6. Prove Lemma 4.6.
4.7. Prove Lemma 4.7.
?4.8. A deterministic program is one that uses no random choices. Suppose L1andL2are two
deterministic libraries with a common interface. Show that either L1L 2, or elseL1&
L2can be distinguished with advantage 1.
4.9. AlgorithmBin Section 4.4 has worst-case running time O¹q2º. Can you suggest a way to
make it run in O¹qlogqºtime? What about O¹qºtime?
4.10. Assume that the last 4 digits of student ID numbers are assigned uniformly at this uni-
versity. In a class of 46 students, what is the exact probability that two students have ID
numbers with the same last 4 digits?
Compare this exact answer to the upper and lower bounds given by Lemma 4.10.
83Draft: January 3, 2021 CHAPTER 4. BASING CRYPTOGRAPHY ON INTRACTABLE COMPUTATIONS
4.11. Write a program that experimentally estimates the BirthdayProb¹q;Nºprobabilities.
Given qandN, generate quniformly chosen samples from ZN, with replacement, and
check whether any element was chosen more than once. Repeat this entire process ttimes
to estimate the true probability of BirthdayProb¹q;Nº.
Generate a plot that compares your experimental /f_indings to the theoretical upper/lower
bounds of 0:632q¹q 1º
2λ+1andq¹q 1º
2λ+1.
4.12. Suppose you want to enforce password rules so that at least 2128passwords satisfy the
rules. How many characters long must the passwords be, in each of these cases?
(a) Passwords consist of lowercase athrough zonly.
(b) Passwords consist of lowercase and uppercase letters a–zandA–Z.
(c) Passwords consist of lower/uppercase letters and digits 0–9.
(d) Passwords consist of lower/uppercase letters, digits, and any symbol characters that
appear on a standard US keyboard (including the space character).
845Pseudorandom Generators
One-time pad requires a key that’s as long as the plaintext. Let’s forget that we know
about this limitation. Suppose Alice & Bob share only a short λ-bit secret k, but they
want to encrypt a 2λ-bit plaintext m. They don’t know that (perfect) one-time secrecy is
impossible in this setting (Exercise 2.11), so they try to get it to work anyway using the
following reasoning:
IThe only encryption scheme they know about is one-time pad, so they decide that
the ciphertext will have the form c=m??. This means that the unknown value
??must be 2λbits long.
IIn order for the security of one-time pad to apply, the unknown value ??should be
uniformly distributed.
IThe process of obtaining the unknown value ??from the shared key kshould be
deterministic , so that the sender and receiver compute the same value and decryption
works correctly.
LetGdenote the process that transforms the key kinto this mystery value. Then G:
f0;1gλ!f0;1g2λ, and the encryption scheme is Enc¹k;mº=mG¹kº.
It is not hard to see that if Gis a deterministic function, then there are only 2λpossible
outputs of G, so the distribution of G¹kºcannot be uniform in f0;1g2λ. We therefore cannot
argue that the scheme is secure in the same way as one-time pad.
However, what if the distribution of G¹kºvalues is not perfectly uniform but only
“close enough” to uniform? Suppose no polynomial-time algorithm can distinguish the
distribution of G¹kºvalues from the uniform distribution. Then surely this ought to be
“close enough” to uniform for practical purposes. This is exactly the idea of pseudoran-
domness. It turns out that if Ghas a pseudorandomness property, then the encryption
scheme described above is actually secure (against polynomial-time adversaries, in the
sense discussed in the previous chapter).
5.1 Definitions
Apseudorandom generator (PRG) is a deterministic function Gwhose outputs are
longer than its inputs. When the input to Gis chosen uniformly at random, it induces a
certain distribution over the possible output. As discussed above, this output distribution
cannot be uniform. However, the distribution is pseudorandom if it is indistinguishable
from the uniform distribution. More formally:
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
Definition 5.1
(PRG security)LetG:f0;1gλ!f0;1gλ+`be a deterministic function with ` >0. We say that Gis asecure
pseudorandom generator (PRG) ifLG
prg-realLG
prg-rand, where:
LG
prg-real
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
s f0;1gλ
return G¹sºLG
prg-rand
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
r f0;1gλ+`
return r
The value `is called the stretch of the PRG. The input to the PRG is typically called a seed.
Below is an illustration of the distributions sampled by these libraries, for a length-
doubling (`=λ) PRG (not drawn to scale) :
f0;1gλ
f0;1g2λ
pseudorandom distributionG
f0;1g2λ
uniform distribution
Lprg-real samples from distribution of red dots, by /f_irst sampling a uniform element of
f0;1gλand performing the action of Gon that value to get a red result in f0;1g2λ. The other
libraryLprg-rand directly samples the uniform distribution on f0;1g2λ(in green above).
To understand PRGs, you must simultaneously appreciate two ways to compare the
PRG’s output distribution with the uniform distribution:
IFrom a relative perspective, the PRG’s output distribution is tiny. Out of the 22λ
strings inf0;1g2λ, only 2λare possible outputs of G. These strings make up a
2λ22λ=12λfraction off0;1g2λ— anegligible fraction!
IFrom an absolute perspective, the PRG’s output distribution is huge. There are 2λ
possible outputs of G, which is an exponential amount!
The illustration above only captures the relative perspective (comparing the red dots to
the entire extent of f0;1g2λ), so it can lead to some misunderstanding. Just looking at this
picture, it is hard to imagine how the two distributions could be indistinguishable. How
could a calling program notnotice whether it’s seeing the whole set or just a negligible
fraction of the whole set? Well, if you run in polynomial-time in λ, then 2λand22λare
both so enormous that it doesn’t really matter that one is vastly bigger than the other.
The relative sizes of the distribution don’t really help distinguish, since it is not a viable
strategy for the distinguisher to “measure” the size of the distribution it’s sampling.
86Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
Consider: there are about 275molecules in a teaspoon of water, and about 2275
molecules of water in Earth’s oceans. Suppose you dump a teaspoon of water into the
ocean and let things mix for a few thousand years. Even though the teaspoon accounts for
only 1275of the ocean’s contents, that doesn’t make it easy to keep track of all 275water
molecules that originated in the teaspoon! If you are small enough to see individual water
molecules, then a teaspoon of water looks as big as the ocean.
Discussion & Pitfalls
IDo not confuse the interface of a PRG (it takes in a seed as input) with the interface
of the security libraries Lprg-?(their /q.sc_u.sc/e.sc/r.sc/y.sc subroutine doesn’t take any input)! A
PRG is indeed an algorithm into which you can feed any string you like. However,
security is only guaranteed when the PRG is being used exactly as described in
the security libraries — in particular, when the seed is chosen uniformly/secretly
and not used for anything else.
Nothing prevents a user from putting an adversarially-chosen sinto a PRG, or re-
vealing a PRG seed to an adversary, etc. You just get no security guarantee from
doing it, since it’s not the situation re/f_lected in the PRG security libraries.
IIt doesn’t really make sense to say that “ 0010110110 is a random string” or
“0000000001 is a pseudorandom string.” Randomness and pseudorandomness are
properties of the process used to generate a string, not properties of the indi-
vidual strings themselves. When we have a value z=G¹sºwhere Gis a PRG and sis
chosen uniformly, you could say that zwas “chosen pseudorandomly.” You could say
that the output of some process is a “pseudorandom distribution.” But it is slightly
sloppy (although common) to say that a string z“is pseudorandom”.
IThere are common statistical tests you can run, which check whether some data
has various properties that you would expect from a uniform distribution.1For
example, are there roughly an equal number of 0s and 1s? Does the substring 01010
occur with roughly the frequency I would expect? If I interpret the string as a series
of points in the unit square »0;1º2, is it true that roughly π4of them are within
Euclidean distance 1 of the origin?
The de/f_inition of pseudorandomness is kind of a “master” de/f_inition that encom-
passes all of these statistical tests and more. After all, what is a statistical test, but a
polynomial-time procedure that obtains samples from a distribution and outputs a
yes/no decision? Pseudorandomness means that every statistical test that “passes”
uniform data will also “pass” pseudorandomly generated data.
5.2 Pseudorandom Generators in Practice
You are probably expecting to now see at least one example of a secure PRG. Unfortunately,
things are not so simple. We have no examples of secure PRGs! If it were possible to prove
1For one list of such tests, see h/t_tp://csrc.nist.gov/publications/nistpubs/800-22-rev1a/SP800-22rev1a.pdf .
87Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
that some function Gis a secure PRG, it would resolve the famous PvsNPproblem —
the most famous unsolved problem in computer science (and arguably, all of mathematics).
The next best thing that cryptographic research can oﬀer are candidate PRGs , which
areconjectured to be secure. The best examples of such PRGs are the ones that have been
subjected to signi/f_icant public scrutiny and resisted all attempts at attacks so far.
In fact, the entire rest of this book is based on cryptography that is only conjectured
to be secure. How is this possible, given the book’s stated focus on provable security? As
you progress through the book, pay attention to how all of the provable security claims
areconditional — if X is secure then Y is secure. You will be able to trace back through
this web of implications and discover that there are only a small number of underlying
cryptographic primitives whose security is merely conjectured (PRGs are one example of
such a primitive). Everything else builds on these primitives in a provably secure way.
With that disclaimer out of the way, surely now you can be shown an example of a
conjectured secure PRG, right? There are indeed some conjectured PRGs that are simple
enough to show you at this point, but you won’t /f_ind them in the book. The problem is that
none of these PRG candidates are really used in practice. When you really need a PRG in
practice, you would actually use a PRG that is built from something called a block cipher
(which we won’t see until Chapter 6). A block cipher is conceptually more complicated
than a PRG, and can even be built from a PRG (in principle). That explains why this book
starts with PRGs. In practice, a block cipher is just a more useful object, so that is what
you would /f_ind easily available (even implemented with specialized CPU instructions in
most CPUs). When we introduce block ciphers (and pseudorandom functions), we will
discuss how they can be used to construct PRGs.
How NOT to Build a PRG
We can appreciate the challenges involved in building a PRG “from scratch” by /f_irst looking
at an obvious idea for a PRG and understanding why it’s insecure.
Example Let’s focus on the case of a length-doubling PRG. It should take in λbits and output 2λbits.
The output should look random when the input is sampled uniformly. A natural idea is for
the candidate PRG to simply repeat the input twice. After all, if the input sis random, then
sksis also random, too, right?
G¹sº:
return sks
To understand why this PRG is insecure, /f_irst let me ask you whether the following strings
look like they were sampled uniformly from f0;1g8:
11011101 ,01010101 ,01110111 ,01000100 ,
Do you see any patterns? Every string has its /f_irst half equal to its second half. That is a
conspicuous pattern because it is relatively rare for a uniformly chosen string to have this
property.
88Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
Of course, this is exactly what is wrong with this simplistic PRG Gde/f_ined above. Every
output of Ghas equal /f_irst/second halves. But it is rare for uniformly sampled strings to have
this property. We can formalize this observation as an attack against the PRG-security of G:
A
xk/y.alt:=/q.sc_u.sc/e.sc/r.sc/y.sc¹º
return x?=/y.alt
The /f_irst line means to obtain the result of /q.sc/u.sc/e.sc/r.sc/y.sc and set its /f_irst half to be the string xand
its second half to be /y.alt. This calling program simply checks whether the output of /q.sc/u.sc/e.sc/r.sc/y.sc has
equal halves.
To complete the attack, we must show that this calling program has non-negligible bias
distinguishing theLprg-?libraries.
IWhen linked toLprg-real , the calling program receives outputs of G, which always have
matching /f_irst/second halves. So Pr»ALG
prg-real)1¼=1. Below we have /f_illed in
Lprg-real with the details of our Galgorithm:
A
xk/y.alt:=/q.sc_u.sc/e.sc/r.sc/y.sc¹º
return x?=/y.altLG
prg-real
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
s f0;1gλ
return sks
IWhen linked toLprg-rand , the calling program receives uniform samples from f0;1g2λ.
A
xk/y.alt:=/q.sc_u.sc/e.sc/r.sc/y.sc¹º
return x?=/y.altLG
prg-rand
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
r f0;1g2λ
return r
Aoutputs 1 whenever we sample a string from f0;1g2λwith equal /f_irst/second halves.
What exactly is the probability of this happening? There are several ways to see that
the probability is 12λ(this is like asking the probability of rolling doubles with two
dice, but each die has 2λsides instead of 6). Therefore, Pr»ALG
prg-rand)1¼=12λ.
The advantage of this adversary is 1 12λwhich is certainly non-negligible — it does not
even approach 0 as λgrows. This shows that Gis not a secure PRG.
This example illustrates how randomness/pseudorandomness is a property of the en-
tire process , not of individual strings. If you take a string of 1s and concatenate it with
another string of 1s, you get a long string of 1s. “Containing only 1s” is a property of
individual strings. If you take a “random string” and concatenate it with another “random
string,” you might not get a “random long string.” Being random is not a property of an
individual string, but of the entire process that generates it.
Outputs from this Ghave equal /f_irst/second halves, which is an obvious pattern. The
challenge of desiging a secure PRG is that its outputs must have no discernable pattern!
Any pattern will lead to an attack similar to the one shown above.
89Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
Related Concept: Random Number Generation
The security of a PRG requires the seed to be chosen uniformly. In practice, the seed has to
come from somewhere. Generally a source of “randomness” is provided by the hardware
or operating system, and the process that generates these random bits is (confusingly)
called a random number generator (RNG).
In this course we won’t cover low-level random number generation, but merely point
out what makes it diﬀerent than the PRGs that we study:
IThe job of a PRG is to take a small amount of “ideal” (in other words, uniform)
randomness and extend it.
IBy contrast, an RNG usually takes many inputs over time and maintains an internal
state. These inputs are often from physical/hardware sources. While these inputs
are “noisy” in some sense, it is hard to imagine that they would be statistically uni-
form. So the job of the RNG is to “re/f_ine” (sometimes many) sources of noisy data
into uniform outputs.
5.3 Application: Shorter Keys in One-Time-Secret Encryption
We revisit the motivating example from the beginning of this chapter. Alice & Bob share
only aλ-bit key but want to encrypt a message of length λ+`. The main idea is to expand
the key kinto a longer string using a PRG G, and use the result as a one-time pad on the
(longer) plaintext. More precisely, let G:f0;1gλ!f 0;1gλ+`be a PRG, and de/f_ine the
following encryption scheme:
Construction 5.2
(Pseudo-OTP)K=f0;1gλ
M=f0;1gλ+`
C=f0;1gλ+`KeyGen :
k K
return kEnc¹k;mº:
return G¹kºmDec¹k;cº:
return G¹kºc
The resulting scheme will not have (perfect) one-time secrecy. That is, encryptions of
mLandmRwill not be identically distributed in general. However, the distributions will
beindistinguishable ifGis a secure PRG. The precise /f_lavor of security obtained by this
construction is the following.
Definition 5.3 LetΣbe an encryption scheme, and let LΣ
ots-LandLΣ
ots-Rbe de/f_ined as in De/f_inition 2.6 (and
repeated below for convenience). Then Σhas(computational) one-time secrecy ifLΣ
ots-L
LΣ
ots-R. That is, if for all polynomial-time distinguishers A, we have Pr»ALΣ
ots-L)1¼
Pr»ALΣ
ots-R)1¼.
LΣ
ots-L
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
k Σ:KeyGen
c Σ:Enc¹k;mLº
return cLΣ
ots-R
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
k Σ:KeyGen
c Σ:Enc¹k;mRº
return c
90Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
This is essentially the same as De/f_inition 2.6, except we are using (indistinguisha-
bility) instead of(interchangeability).
Claim 5.4 LetpOTP denote Construction 5.2. If pOTP is instantiated using a secure PRG Gthen pOTP
has computational one-time secrecy.
Proof We must show that LpOTP
ots-LLpOTP
ots-R. As usual, we will proceed using a sequence of hybrids
that begins atLpOTP
ots-Land ends atLpOTP
ots-R. For each hybrid library, we will demonstrate that
it is indistinguishable from the previous one. Note that we are allowed to use the fact
thatGis a secure PRG. In practical terms, this means that if we can express some hybrid
library in terms of LG
prg-real(one of the libraries in the PRG security de/f_inition), we can
replace it with its counterpart LG
prg-rand(or vice-versa). The PRG security of Gsays that
such a change will be indistinguishable.
LpOTP
ots-L:LpOTP
ots-L
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2f0;1gλ+`º:
k f0;1gλ
c:=G¹kºmL
return cThe starting point is LpOTP
ots-L, shown here with
the details of pOTP /f_illed in.
Lhyb- 1:/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
z /q.sc_u.sc/e.sc/r.sc/y.sc¹º
c:=zmL
return cLG
prg-real
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
s f0;1gλ
return G¹sºThe /f_irst hybrid step is to factor out the
computations involving G, in terms of the
LG
prg-reallibrary.
Lhyb- 2:/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
z /q.sc_u.sc/e.sc/r.sc/y.sc¹º
c:=zmL
return cLG
prg-rand
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
r f0;1gλ+`
return rFrom the PRG security of G, we may re-
place the instance of LG
prg-realwithLG
prg-rand.
The resulting hybrid library Lhyb- 2is indis-
tinguishable from the previous one.
Lhyb- 3:LOTP
ots-L
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
z f0;1gλ+`
c:=zmL
return cA subroutine has been inlined. Note that the
resulting library is precisely LOTP
ots-Linvolv-
ingstandard one-time pad on plaintexts
of sizeλ+`. We have essentially proven
thatpOTP is indistinguishable from standard
OTP, and therefore we can apply the security
ofOTP.
91Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
Lhyb- 4:LOTP
ots-R
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
z f0;1gλ+`
c:=zmR
return cThe (perfect) one-time secrecy of rOTP al-
lows us to replaceLOTP
ots-LwithLOTP
ots-R; they are
interchangeable.
The rest of the proof is essentially a “mirror image” of the previous steps, in which we
perform the same steps but in reverse (and with mRbeing used instead of mL).
Lhyb- 5:/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
z /q.sc_u.sc/e.sc/r.sc/y.sc¹º
c:=zmR
return cLG
prg-rand
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
r f0;1gλ+`
return rA statement has been factored out into a
subroutine, which happens to exactly match
LG
prg-rand.
Lhyb- 6:/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
z /q.sc_u.sc/e.sc/r.sc/y.sc¹º
c:=zmR
return cLG
prg-real
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
s f0;1gλ
return G¹sºFrom the PRG security of G, we can replace
LG
prg-randwithLG
prg-real. The resulting library
is indistinguishable from the previous one.
LpOTP
ots-R:LpOTP
ots-R
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
k f0;1gλ
c:=G¹kº mR
return cA subroutine has been inlined. The result is
LpOTP
ots-R.
Summarizing, we showed a sequence of hybrid libraries satisfying the following:
LpOTP
ots-LL hyb- 1Lhyb- 2L hyb- 3L hyb- 4L hyb- 5Lhyb- 6LpOTP
ots-R:
Hence,LpOTP
ots-LLpOTP
ots-R, and pOTP has (computational) one-time secrecy. 
5.4 Extending the Stretch of a PRG
The stretch of a PRG measures how much longer its output is than its input. Can we use
a PRG with small stretch to construct a PRG with larger stretch? The answer is yes, but
only if you do it the right way!
Two Approaches to Increase Stretch
Suppose G:f0;1gλ!f0;1g2λis a length-doubling PRG ( i.e., a PRG with stretch λ). Below
are two ideas for constructing a PRG with longer stretch:
92Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
H1¹sº:
xk/y.alt:=G¹sº
uk/v.alt:=G¹/y.altº
return xkuk/v.altH1
G Gλ
|     {z     }
3λH2¹sº:
xk/y.alt:=G¹sº
uk/v.alt:=G¹/y.altº
return xk/y.altkuk/v.altH2
G Gλ
|     {z     }
4λ
Although the constructions are similar, only one of them is secure. Before reading any
further, can you guess which of H1;H2is a secure PRG and which is insecure? By carefully
comparing these two approaches, I hope you develop a better understanding of the PRG
security de/f_inition.
A Security Proof
I think it’s helpful to illustrate the “stragey” of security proofs by starting from the desired
conclusion and working backwards. What better way to do this than as a Socratic dialogue
in the style of Galileo?2
S/a.sc/l.sc/v.sc/i.sc/a.sc/t.sc/i.sc: I’m sure that H1is the secure PRG.
S/i.sc/m.sc/p.sc/l.sc/i.sc/c.sc/i.sc/o.sc: If I understand the security de/f_inition for PRGs correctly, you mean that the
output of H1looks indistinguishable from uniform, when the input to H1is
uniform. Why do you say that?
S/a.sc/l.sc/v.sc/i.sc/a.sc/t.sc/i.sc: Simple! H1’s output consists of segments called x,u, and/v.alt. Each of these are
outputs of G, and since Gitself is a PRG its outputs look uniform.
S/i.sc/m.sc/p.sc/l.sc/i.sc/c.sc/i.sc/o.sc: I wish I had your boldness, Salviati. I myself am more cautious. If Gis a secure
PRG, then its outputs are indeed indistinguishable from uniform, but surely
only when its input is uniform! Are you so sure that’s the case here?
S/a.sc/l.sc/v.sc/i.sc/a.sc/t.sc/i.sc: You raise a good point, Simplicio. In these endeavors it is always preferable to
err on the side of caution. When we want to claim that H1is a secure PRG, we
consider the nature of its outputs when its seed sis uniform. Since H1sends that
seedsdirectly into G, your concern is addressed.
S/i.sc/m.sc/p.sc/l.sc/i.sc/c.sc/i.sc/o.sc: Yes, I can see how in the expression xk/y.alt:=G¹sºthe input to Gis uniform, and
so its outputs xand/y.altare indistinguishable from random. Since xis part of
H1’s output, we are making progress towards showing that the entire output of
H1is indistinguishable from random! However, the output of H1also contains
terms uand/v.alt. When I examine how they are generated, as uk/v.alt:=G¹/y.altº, I
become concerned again. Surely /y.altis not uniform, so I see no way to apply the
security if G!
2Don’t answer that.
93Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
S/a.sc/l.sc/v.sc/i.sc/a.sc/t.sc/i.sc: Oh, bless your heart. The answer could not be any more obvious! It is true that
/y.altis not uniformly distributed. But did you not just convince yourself that /y.altis
indistinguishable from uniform? Should that suﬃce?
S/i.sc/m.sc/p.sc/l.sc/i.sc/c.sc/i.sc/o.sc: Incredible! I believe I understand now. Let me try to summarize: We suppose
the input stoH1is chosen uniformly, and examine what happens to H1’s out-
puts. In the expression xk/y.alt:=G¹sº, the input to Gis uniform, and thus x
and/y.altare indistinguishable from uniform. Now, considering the expression
uk/v.alt:=G¹/y.altº, the result is indistinguishable from a scenario in which /y.altis truly
uniform. But if /y.altwere truly uniform, those outputs uand/v.altwould be indistin-
guishable from uniform! Altogether, x,u, and/v.alt(the outputs of H1) are each
indistinguishable from uniform!
I hope that was as fun for you as it was for me.3The formal security proof and its sequence
of hybrids will follow the outline given in Simplicio’s summary. We start by applying the
PRG security de/f_inition to the /f_irst call to G, and replace its outputs with truly uniform
values. After this change, the input to the second call to Gbecomes uniform, allowing us
to apply the PRG security de/f_inition again.
Claim 5.5 IfGis a secure length-doubling PRG, then H1(de/f_ined above) is a secure (length-tripling)
PRG.
Proof One of the trickier aspects of this proof is that we are using a secure PRG Gto prove
the security of another PRG H1. That means both LH1
prg-?andLG
prg-?will appear in this
proof. Both libraries/interfaces have a subroutine named “ /q.sc_u.sc/e.sc/r.sc/y.sc ”, and we will rename
these subroutines /q.sc_u.sc/e.sc/r.sc/y.sc H1and/q.sc_u.sc/e.sc/r.sc/y.sc Gto disambiguate.
We want to show that LH1
prg-realLH1
prg-rand. As usual, we do so with a hybrid sequence.
Since we assume that Gis a secure PRG, we are allowed to use the fact that LG
prg-real
LG
prg-rand.
LH
prg-real:LH1
prg-real
/q.sc_u.sc/e.sc/r.sc/y.sc H1¹º:
s f0;1gλ
xk/y.alt:=G¹sº
uk/v.alt:=G¹/y.altº)
H1¹sº
return xkuk/v.altThe starting point is LH1
prg-real, shown here with
the details of H1/f_illed in.
/q.sc_u.sc/e.sc/r.sc/y.sc H1¹º:
xk/y.alt:=/q.sc_u.sc/e.sc/r.sc/y.sc G¹º
uk/v.alt:=G¹/y.altº
return xkuk/v.altLG
prg-real
/q.sc_u.sc/e.sc/r.sc/y.sc G¹º:
s f0;1gλ
return G¹sºThe /f_irst invocation of Ghas been factored out
into a subroutine. The resulting hybrid library
includes an instance of LG
prg-real.
3If you’re wondering what the hell just happened: In Galileo’s 1632 book Dialogue Concerning the Two
Chief World Systems, he lays out the arguments for heliocentrism using a dialog between Salviati (who advo-
cated the heliocentric model) and Simplicio (who believed the geocentric model).
94Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
/q.sc_u.sc/e.sc/r.sc/y.sc H1¹º:
xk/y.alt:=/q.sc_u.sc/e.sc/r.sc/y.sc G¹º
uk/v.alt:=G¹/y.altº
return xkuk/v.altLG
prg-rand
/q.sc_u.sc/e.sc/r.sc/y.sc G¹º:
r f0;1g2λ
return rFrom the PRG security of G, we can replace the
instance ofLG
prg-realwithLG
prg-rand. The result-
ing hybrid library is indistinguishable.
/q.sc_u.sc/e.sc/r.sc/y.sc H1¹º:
xk/y.alt f0;1g2λ
uk/v.alt:=G¹/y.altº
return xkuk/v.altA subroutine has been inlined.
/q.sc_u.sc/e.sc/r.sc/y.sc H1¹º:
x f0;1gλ
/y.alt f0;1gλ
uk/v.alt:=G¹/y.altº
return xkuk/v.altChoosing 2λuniformly random bits and then
splitting them into two halves has exactly the
same eﬀect as choosing λuniformly random
bits and independently choosing λmore.
/q.sc_u.sc/e.sc/r.sc/y.sc H1¹º:
x f0;1gλ
uk/v.alt:=/q.sc_u.sc/e.sc/r.sc/y.sc G¹º
return xkuk/v.altLG
prg-real
/q.sc_u.sc/e.sc/r.sc/y.sc G¹º:
s f0;1gλ
return G¹sºThe remaining appearance of Ghas been fac-
tored out into a subroutine. Now LG
prg-real
makes its second appearance.
/q.sc_u.sc/e.sc/r.sc/y.sc H1¹º:
x f0;1gλ
uk/v.alt:=/q.sc_u.sc/e.sc/r.sc/y.sc G¹º
return xkuk/v.altLG
prg-rand
/q.sc_u.sc/e.sc/r.sc/y.sc G¹º:
r f0;1g2λ
return rAgain, the PRG security of Glets us replace
LG
prg-realwithLG
prg-rand. The resulting hybrid
library is indistinguishable.
/q.sc_u.sc/e.sc/r.sc/y.sc H1¹º:
x f0;1gλ
uk/v.alt f0;1g2λ
return xkuk/v.altA subroutine has been inlined.
LH1
prg-rand:LH1
prg-rand
/q.sc_u.sc/e.sc/r.sc/y.sc H1¹º:
r f0;1g3λ
return rSimilar to above, concatenating λuniform bits
with 2λindependently uniform bits has the
same eﬀect as sampling 3λuniform bits. The
result of this change is LH1
prg-rand.
95Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
Through this sequence of hybrid libraries, we showed that:
LH1
prg-realL hyb- 1Lhyb- 2L hyb- 3L hyb- 4L hyb- 5Lhyb- 6L hyb- 7LH1
prg-rand:
Hence, H1is a secure PRG. 
Where the Proof Breaks Down for H2
The only diﬀerence between H1andH2is that the variable /y.altis included in the output.
How does that minor change aﬀect the reasoning that we applied to H1?
H2¹sº:
xk/y.alt:=G¹sº
uk/v.alt:=G¹/y.altº
return xk/y.altkuk/v.alt
We argued that outputs uand/v.altare indistinguishable from uniform since its input /y.altis also
indistinguishable from random. But it’s not quite so simple: A PRG’s output is indistin-
guishable from random if (1) its seed is uniform, and (2) the seed is not used for anything
else! This construction H2violates condition (2) because it includes the “seed” /y.altin the
output.
We can see this idea re/f_lected in the formal PRG de/f_inition. In Lprg-real , the seed sis
chosen uniformly, given as input to G, and then goes out of scope! If we try to reproduce
the security proof for H1with H2instead, we’ll get stuck when we are trying to factor out
the second call to Gin terms ofLprg-real :
/q.sc_u.sc/e.sc/r.sc/y.sc H2¹º:
x f0;1gλ
/y.alt f0;1gλ
uk/v.alt:=G¹/y.altº
return xk/y.altkuk/v.alt{/q.sc_u.sc/e.sc/r.sc/y.sc H1¹º:
x f0;1gλ
uk/v.alt:=/q.sc_u.sc/e.sc/r.sc/y.sc G¹º
return xk/y.altkuk/v.altLG
prg-real
/q.sc_u.sc/e.sc/r.sc/y.sc G¹º:
s f0;1gλ
return G¹sº
|                                                 {z                                                 }
scope error! /y.altunde/f_ined
We are trying to factor out the two highlighted lines into a separate library, renaming /y.alt
intosin the process. But scan only exist inside the private scope of the new library, while
there still exists a “dangling reference” /y.altin the original library.
Speaking more generally about PRGs, suppose we have a call to Gsomewhere and
want to argue that its outputs are pseudorandom. We can only express this call to Gin
terms ofLG
prg-realif the input to Gis uniform and is used nowhere else. That’s not true
here – we can’t express one of the calls to Gin terms ofLG
prg-real, so we can’t be sure that
the outputs of that call to Glook random.
These subtle issues are not limited to PRGs. Every hybrid security proof in this course
includes steps where we factor out some statements in terms of some pre-existing library.
Don’t take these steps for granted! They will fail (often because of scoping issues) if the
construction isn’t using the building block correctly. You should always treat such “fac-
toring out” steps as “sanity checks” for your proof.
96Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
A Concrete A/t_tack on H2
So far, we’ve only demonstrated that we get stuck when trying to prove the security of
H2. But that doesn’t necessarily mean that H2is insecure – it could mean that we’re just
not clever enough to see a diﬀerent security proof. To show that H2is actually insecure,
we must demonstrate a successful distinguishing attack.
Attacking a PRG amounts to /f_inding “patterns” in their outputs. Does H2have a pat-
tern in its outputs? Yes, in this case the pattern is that if you write the output in the
form xk/y.altkuk/v.alt, then uk/v.altis always equal to G¹/y.altº. The calling program can check for this
condition, which is unlikely to happen for truly uniform values.
You may wonder, is it legal for the calling program to compute G¹/y.altº? Well, Gis a
publicly known algorithm (Kerckhoﬀs’ principle!), and /y.altis right there as part of the input.
Nothing prevents the calling program from running G“in its head.”4
Claim 5.6 Construction H2isnota secure PRG, even if Gis.
Proof Consider the following distinguisher A:
xk/y.altkuk/v.alt:=/q.sc_u.sc/e.sc/r.sc/y.sc¹º
return G¹/y.altº?=uk/v.alt
WhenAis linked toLH2
prg-real, the outputs indeed satisfy the condition G¹/y.altº=uk/v.alt, soA
outputs true with probability 1.
WhenAis linked toLH2
prg-rand, the outputs are truly uniform. It is helpful to imagine
xand/y.altbeing chosen before uand/v.alt. As soon as /y.altis chosen, the value G¹/y.altºis uniquely
determined, since Gis a deterministic algorithm. Then Awill output true ifuk/v.altis chosen
exactly to equal this G¹/y.altº. Since uand/v.altare chosen uniformly, and are a total of 2κbits
long, this event happens with probability 122κ.
A’s advantage is the diﬀerence in these probabilities: 1 122κ, which is non-
negligible. 
Discussion
In the attack on H2, we never tried to distinguish the output of Gfrom uniform. H2is
insecure even if Gis the best PRG in the world! It’s insecure because of the incorrect way
itusesG.
From now on in this book, we’ll be studying higher-level constructions that are assem-
bled from various building blocks — in this chapter, fancy PRGs constructed from simpler
PRGs. “Security” means: if the building blocks are secure then the construction is secure.
“Insecurity” means: even if the building blocks are secure, the construction can be insecure.
So when you’re showing insecurity, you shouldn’t directly attack the building blocks! You
should assume the building blocks are secure and attack the way that the building blocks
are being used.
4Compare to the case of distinguishing G¹sºfrom uniform, for a secure G. The calling program knows
the algorithm Gbut doesn’t have the seed s— it only knows the output G¹sº. In the case of H2, the calling
program learns both /y.altandG¹/y.altº!
97Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
5.5? Applications: Stream Cipher & Symmetric Ratchet
The PRG-feedback construction can be generalized in a natural way, by continuing to
feed part of G’s output into Gagain. The proof works in the same way as for the previous
construction — the security of Gis applied one at a time to each application of G.
Claim 5.7 IfGis a secure length-doubling PRG, then for any n(polynomial function of λ) the following
construction Hnis a secure PRG with stretch nλ:
Hn¹sº:
s0:=s
fori=1ton:
sikti:=G¹si 1º
return t1kk tnksnG G G G ncopies of Gλbits
|                             {z                             }
λ+nλbits
The fact that this chain of PRGs can be extended inde/f_initely gives another useful
functionality:
Definition 5.8
(Stream cipher)Astream cipher is an algorithm Gthat takes a seed sand length `as input, and outputs a
string. It should satisfy the following requirements:
1.G¹s; `ºis a string of length `.
2. If i<j, then G¹s;iºis a pre/f_ix of G¹s;jº.
3. For each n, the function G¹;nºis a secure PRG.
Because of the 2nd rule, you might want to think about a single in/f_initely long string that is
thelimit ofG¹s;nºasngoes to in/f_inity. The /f_inite-length strings G¹s;nºare all the pre/f_ixes
of this in/f_initely long string.
The PRG-feedback construction can be used to construct a secure stream cipher in the
natural way: given seed sand length `, keep iterating the PRG-feedback main loop until
`bits have been generated.
G G G G
Symmetric Ratchet
Suppose Alice & Bob share a symmetric key kand are using a secure messaging app to
exchange messages over a long period of time. Later in the course we will see techniques
that Alice & Bob could use to securely encrypt many messages using a single key. How-
ever, suppose Bob’s device is compromised and an attacker learns k. Then the attacker
can decrypt all past, present, and future ciphertexts that it saw!
98Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
Alice & Bob can protect against such a key compromise by using the PRG-feedback
stream cipher to constantly “update” their shared key. Suppose they do the following,
starting with their shared key k:
IThey use kto seed a chain of length-doubling PRGs, and both obtain the same stream
of pseudorandom keys t1;t2; : : :.
IThey use tias a key to send/receive the ith message. The details of the encryption
are not relevant to this example.
IAfter making a call to the PRG, they erase the PRG input from memory, and only
remember the PRG’s output. After using tito send/receive a message, they also
erase it from memory.
This way of using and forgetting a sequence of keys is called a symmetric ratchet .
Construction 5.9
(Symm Ratchet)s0=k
fori=1to1:
sikti:=G¹si 1º
erase si 1from memory
usetito encrypt/decrypt the ith message
erase tifrom memoryG G G Gs0s1 s2 s3
t1 t2 t3 t4
Suppose that an attacker compromises Bob’s device after nciphertexts have been sent. The
only value residing in memory is sn, which the attacker learns. Since Gis deterministic, the
attacker can now compute tn+1;tn+2; : : :in the usual way and decrypt all future ciphertexts
that are sent.
However, we can show that the attacker learns no information about t1; : : : ; tnfrom
sn, which implies that the previous ciphertexts remain safe. By compromising the key sn,
the adversary only compromises the security of future messages, but not past messages.
Sometimes this property is called forward secrecy , meaning that messages in the present
are protected against a key-compromise that happens in the future.
This construction is called a ratchet , since it is easy to advance the key sequence in the
forward direction (from sntosn+1) but hard to reverse it (from sn+1tosn). The exercises
explore the problem of explicitly reversing the ratchet, but the more relevant property
for us is whether the attacker learns anything about the ciphertexts that were generated
before the compromise.
Claim 5.10 If the symmetric ratchet (Construction 5.9) is used with a secure PRG Gand an encryption
scheme Σthat has uniform ciphertexts (and Σ:K=f0;1gλ), then the /f_irst nciphertexts are
pseudorandom, even to an eavesdropper who compromises the key sn.
Proof We are considering an attack scenario in which nplaintexts are encrypted, and the adver-
sary sees their ciphertexts as well as the ratchet-key sn. This situation is captured by the
following library:
99Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
/a.sc/t.sc/t.sc/a.sc/c.sc/k.sc¹m1; : : : ; mnº:
s0 f0;1gλ
fori=1ton:
sikti:=G¹si 1º
ci Σ:Enc¹ti;miº
return¹c1; : : : ; cn;snºG G G Gs0
t1
Enc
c1t2
Enc
c2t3
Enc
c3tn
Enc
cn si
As we have seen, the shaded box (the process that computes t1; : : : ; tnfrom s0) is actually
a PRG. Let us rewrite the library in terms of this PRG Hn:
/a.sc/t.sc/t.sc/a.sc/c.sc/k.sc¹m1; : : : ; mnº:
s0 f0;1gλ
t1kk tnksn:=Hn¹s0º
fori=1ton:
ci Σ:Enc¹ti;miº
return¹c1; : : : ; cn;snºG G G Gs0
t1
Enc
c1t2
Enc
c2t3
Enc
c3tn
Enc
cn siHn
Now, we can apply the PRG security of Hnand instead choose t1; : : : ; tnandsnuniformly.
This change is indistinguishable, by the security of the PRG. Note that we have not written
out the standard explicit steps (factor out the /f_irst two lines of /a.sc/t.sc/t.sc/a.sc/c.sc/k.sc in terms ofLprg-real ,
replace withLprg-rand , and inline).
/a.sc/t.sc/t.sc/a.sc/c.sc/k.sc¹m1; : : : ; mnº:
fori=1ton:
ti f0;1gλ
sn f0;1gλ
fori=1ton:
ci Σ:Enc¹ti;miº
return¹c1; : : : ; cn;snº/a.sc/t.sc/t.sc/a.sc/c.sc/k.sc¹m1; : : : ; mnº:
fori=1ton:
ti f0;1gλ
ci Σ:Enc¹ti;miº
sn f0;1gλ
return¹c1; : : : ; cn;snº
At this point, the encryption scheme is being used “as intended,” meaning that we generate
its keys tiuniformly/indepenendtly, and use each key only for one encryption and nothing
else. Formally speaking, this means we can factor out the body of the for-loop in terms of
Lots$-real :
/a.sc/t.sc/t.sc/a.sc/c.sc/k.sc¹m1; : : : ; mnº:
fori=1ton:
ci /c.sc/t.sc/x.sc/t.sc¹miº
sn f0;1gλ
return¹c1; : : : ; cn;snºLΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
k Σ:KeyGen
c Σ:Enc¹k;mº
return c
100Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
We can now replace Lots$-real withLots$-rand and inline the subroutine (without showing
the intermediate library). The result is:
/a.sc/t.sc/t.sc/a.sc/c.sc/k.sc¹m1; : : : ; mnº:
fori=1ton:
ci Σ:C
sn f0;1gλ
return¹c1; : : : ; cn;snº
This /f_inal library is indistinguishable from the /f_irst one. As promised, we showed that the
attacker cannot distinguish the /f_irst nciphertexts from random values, even when seeing
sn. 
This proof used the uniform-ciphertexts property, but the same logic applies to basi-
cally any encryption property you care about — just imagine factoring out the encryption
steps in terms of a diﬀerent library than Lots$-real .
Exercises
5.1. Let G:f0;1gλ! f 0;1gλ+`be an injective ( i.e., 1-to-1) PRG. Consider the following
distinguisher:
A
x:=/q.sc_u.sc/e.sc/r.sc/y.sc¹º
for all s02f0;1gλ:
ifG¹s0º=xthen return 1
return 0
(a) What is the advantage of Ain distinguishingLG
prg-realandLG
prg-rand? Is it negligible?
(b) Does this contradict the fact that Gis a PRG? Why or why not?
(c) What happens to the advantage if Gis not injective?
5.2. Let G:f0;1gλ!f0;1gλ+`be an injective PRG, and consider the following distinguisher:
A
x:=/q.sc_u.sc/e.sc/r.sc/y.sc¹º
s0 f0;1gλ
return G¹s0º?=x
What is the advantage of Ain distinguishingLG
prg-realfromLG
prg-rand?
Hint:When computing Pr»ALG
prg-randoutputs 1¼, separate the probabilities based on whether xis a
possible output of Gor not.
101Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
5.3. For any PRG G:f0;1gλ! f 0;1gλ+`there will be many strings in f0;1gλ+`that are
impossible to get as output of G. Let Sbe any such set of impossible G-outputs, and
consider the following adversary that has Shard-coded:
A
x:=/q.sc_u.sc/e.sc/r.sc/y.sc¹º
return x?2S
What is the advantage of Ain distinguishingLG
prg-realfromLG
prg-rand? Why does an ad-
versary like this one not automatically break every PRG?
5.4. Show that the scheme from Section 5.3 does not have perfect one-time secrecy, by showing
that there must exist two messages m1andm2whose ciphertext distributions diﬀer.
Hint:There must exist strings s1;s22f0;1gλ+`where s12im¹Gº, and s2<im¹Gº. Use these two strings
to /f_ind two messages m1andm2whose ciphertext distributions assign diﬀerent probabilities to s1
ands2. Note that it is legitimate for an attacker to “know” s1ands2, as these are properties of G
alone, and do not depend on the random choices made “at runtime” — when the library executes
the encryption algorithms.
5.5. The proof of Claim 5.5 applies the PRG security rule to both of the calls to G, starting with
the /f_irst one. Describe what happens when you try to apply the PRG security of Gto these
two calls in the opposite order. Does the proof still work, or does it work only in the order
that was presented?
5.6. Let `0> ` > 0. Extend the “PRG feedback” construction to transform any PRG of stretch
`into a PRG of stretch `0. Formally de/f_ine the new PRG and prove its security using the
security of the underlying PRG.
5.7. Prove that if Gis a secure PRG, then so is the function H¹sº=G¹sº.
5.8. Let G:f0;1gλ!f0;1g3λbe a secure length- tripling PRG. For each function below, state
whether it is also a secure PRG. If the function is a secure PRG, give a proof. If not, then
describe a successful distinguisher and explicitly compute its advantage. When we write
akbkc:=G¹sº, each of a;b;chave length λ.
(a)H¹sº:
xk/y.altkz:=G¹sº
return G¹xºkG¹zº
(b)H¹sº:
xk/y.altkz:=G¹sº
return xk/y.alt
(c)H¹sº:
x:=G¹sº
/y.alt:=G¹sº
return xk/y.alt(d)H¹sº:
x:=G¹sº
/y.alt:=G¹0λº
return xk/y.alt
(e)H¹sº:
x:=G¹sº
/y.alt:=G¹0λº
return x/y.alt
102Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
(f)//H:f0;1g2λ!f0;1g3λ
H¹sLksRº:
x:=G¹sLº
/y.alt:=G¹sRº
return x/y.alt(g)//H:f0;1g2λ!f0;1g6λ
H¹sLksRº:
x:=G¹sLº
/y.alt:=G¹sRº
return xk/y.alt
5.9. Let G:f0;1gλ!f0;1g3λbe a secure length- tripling PRG. Prove that each of the follow-
ing functions is also a secure PRG:
(a)//H:f0;1g2λ!f0;1g4λ
H¹sLksRº:
/y.alt:=G¹sRº
return sLk/y.alt
Note that Hincludes half of its input directly in the output. How do you reconcile this
fact with the conclusion of Exercise 5.14(b)?
(b)//H:f0;1g2λ!f0;1g3λ
H¹sLksRº:
return G¹sLº
?5.10. Let Gbe a secure length-doubling PRG. One of the following constructions is a secure PRG
and one is not. Which is which? Give a security proof for one and an attack for the other.
H1¹sº:
xk/y.alt:=G¹sº
uk/v.alt:=G¹/y.altº
return¹x/y.altºkuk/v.altH1
G G
H2¹sº:
xk/y.alt:=G¹sº
uk/v.alt:=G¹/y.altº
return xk¹/y.altuºk/v.altH2
G G

Hint:Usually when something is insecure, it’s insecure for anychoice of building block. In this case, the
attack only works for certain G. Basically, you will need to construct a particular G, prove that it’s
a secure PRG, and then prove that H1/H2is not secure when using this G.
5.11. A frequently asked question in cryptography forums is whether it’s possible to determine
which PRG implementation was used by looking at output samples.
LetG1andG2be two PRGs with matching input/output lengths. De/f_ine two libraries
LG1
which-prgandLG2
which-prgas follows:
LG1
which-prg
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
s f0;1gλ
return G1¹sºLG2
which-prg
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
s f0;1gλ
return G2¹sº
103Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
Prove that if G1andG2are both secure PRGs, then LG1
which-prgLG2
which-prg— that is, it is
infeasible to distinguish which PRG was used simply by receiving output samples.
5.12. Let G1andG2be deterministic functions, each accepting inputs of length λand producing
outputs of length 3λ.
(a) De/f_ine the function H¹s1ks2º=G1¹s1ºG2¹s2º. Prove that if either ofG1orG2(or
both) is a secure PRG, then so is H.
(b) What can you say about the simpler construction H¹sº=G1¹sºG2¹sº, when one of
G1;G2is a secure PRG?
?5.13. Prove that if PRGs exist, then P ,NP.
Hint:f/y.altj9s:G¹sº=/y.altg2NP. Prove the contrapositive! Use the powerful assumption that P = NP to
construct an eﬃcient adversary to attack any candidate PRG.
5.14. (a) Let fbe any function. Show that the following function Gisnota secure PRG, no
matter what fis. Describe a successful distinguisher and explicitly compute its ad-
vantage:
G¹sº:
return skf¹sº
(b) Let G:f0;1gλ!f 0;1gλ+`be a candidate PRG. Suppose there is a polynomial-time
algorithm Vwith the property that it inverts Gwith non-negligible probability. That
is,
Pr
s f0;1gλ
V¹G¹sºº=s
is non-negligible.
Show that if an algorithm Vexists with this property, then Gis not a secure PRG. In
other words, construct a distinguisher contradicting the PRG-security of Gand show
that it achieves non-negligible distinguishing advantage.
Note: Don’t assume anything about the output of Vother than the property shown
above. In particular, Vmight very frequently output the “wrong” thing.
5.15. Let s0;s1; : : :andt1;t2; : : :be de/f_ined as in the symmetric ratchet (Construction 5.9).
(a) Prove that if Gis a secure PRG then the following two libraries are indistinguishable,
for any polynomial-time algorithm A:
Lle/f_t
/t.sc/e.sc/s.sc/t.sc¹º:
sn 1 f0;1gλ
snktn:=G¹sn 1º
˜t=A¹snº
return ˜t?=tnLright
/t.sc/e.sc/s.sc/t.sc¹º:
sn f0;1gλ
˜t=A¹snº
tn f0;1gλ
return ˜t?=tn
(b) What is Pr»/t.sc/e.sc/s.sc/t.sc outputs true¼inLright?
(c) Prove that for any polynomial-time algorithm A,Pr»A¹snº=tn¼is negligible, where
sn;tnare generated as in the symmetric ratchet construction.
104Draft: January 3, 2021 CHAPTER 5. PSEUDORANDOM GENERATORS
(d) Prove that for any polynomial-time algorithm A,Pr»A¹snº=sn 1¼is negligible. In
other words, “turning the ratchet backwards” is a hard problem.
Hint:the proof should be a few lines, a direct corollary of part (c).
1056Pseudorandom Functions & Block
Ciphers
Imagine if Alice & Bob had an in/f_inite amount of shared randomness — not just a short
key. They could split it up into λ-bit chunks and use each one as a one-time pad whenever
they want to send an encrypted message of length λ.
Alice could encrypt by saying, “hey Bob, this message is encrypted with one-time pad
using chunk #674696273 as key.” Bob could decrypt by looking up location #674696273
in his copy of the shared randomness. As long as Alice doesn’t repeat a key/chunk, an
eavesdropper (who doesn’t have the shared randomness) would learn nothing about the
encrypted messages. Although Alice announces (publicly) which location/chunk was used
as each one-time pad key, that information doesn’t help the attacker know the value at that
location.
11100100010
20110000101
::::::
674696273 0011100001
::::::
Alice Bob“this message encrypted under OTP key #674696273”
0111101111
Eve???
It is silly to imagine an in/f_inite amount of shared randomness. However, an expo-
nential amount of something is often just as good as an in/f_inite amount. A shared table
containing “only” 2λone-time pad keys would be quite useful for encrypting as many
messages as you could ever need.
Apseudorandom function (PRF) is a tool that allows Alice & Bob to achieve the
eﬀect of such an exponentially large table of shared randomness in practice. In this chapter
we will explore PRFs and their properties. In a later chapter, after introducing new security
de/f_initions for encryption, we will see that PRFs can be used to securely encrypt many
messages under the same key, following the main idea illustrated above.
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
6.1 Definition
Continuing our example, imagine a huge table of shared data stored as an array T, so the
ith item is referenced as T»i¼. Instead of thinking of ias an integer, we can also think of
ias a binary string. If the array has 2initems, then iwill be an in-bit string. If the array
contains strings of length “ out”, then the notation T»i¼is like a function that takes an input
fromf0;1ginand gives an output from f0;1gout.
A pseudorandom function emulates the functionality of a huge array. It is a function F
that takes an input from f0;1ginand gives an output from f0;1gout. However, Falso takes
an additional argument called the seed , which acts as a kind of secret key.
The goal of a pseudorandom function is to “look like” a uniformly chosen array /
lookup table. Such an array can be accessed through the /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc subroutine of the fol-
lowing library:
forx2f0;1gin:
T»x¼ f 0;1gout
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1ginº:
return T»x¼
As you can see, this library initially /f_ills up the array Twith uniformly random data, and
then allows the calling program to access any position in the array.
A pseudorandom function should produce indistinguishable behavior, when it is used
with a uniformly chosen seed. More formally, the following library should be indistin-
guishable from the one above:
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1ginº:
return F¹k;xº
Note that the /f_irst library samples out2inbits uniformly at random ( outbits for each of
2inentries in the table), while the second library samples only λbits (the same kis used
for all invocations of F). Still, we are asking for the two libraries to be indistinguishable.
This is basically the de/f_inition of a PRF, with one technical caveat. We want to allow
situations like in>λ, but in those cases the /f_irst library runs in exponential time. It is
generally convenient to build our security de/f_initions with libraries that run in polynomial
time.1We /f_ix this by taking advantage of the fact that, no matter how big the table Tis
meant to be, a polynomial-time calling program will only access a polynomial amount of
it. In some sense it is “overkill” to actually populate the entire table Tupfront. Instead, we
can populate Tin a lazy / on-demand way. Tinitially starts uninitialized, and its values
are only assigned as the calling program requests them. This changes when each T»x¼is
sampled (if at all), but does not change howit is sampled ( i.e., uniformly & independently).
This also changes Tfrom being a typical array to being an associative array (“hash table”
or “dictionary” data structure), since it only maps a subset of f0;1ginto values inf0;1gout.
1When we use a pseudorandom function as a component in other constructions, the libraries for PRF
security will show up as calling programs of other libraries. The de/f_inition of indistinguishability requires all
calling programs to run in polynomial time.
107Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
Definition 6.1
(PRF security)LetF:f0;1gλf0;1gin!f 0;1goutbe a deterministic function. We say that Fis a secure
pseudorandom function (PRF) ifLF
prf-realLF
prf-rand, where:
LF
prf-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1ginº:
return F¹k;xºLF
prf-rand
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1ginº:
ifT»x¼unde/f_ined:
T»x¼ f 0;1gout
return T»x¼
Discussion, Pitfalls
The name “pseudorandom function ” comes from the perspective of viewing Tnot as an
(associative) array, but as a function T:f0;1gin!f 0;1gout. There are 2out2inpossible
functions for T(an incredibly large number), and Lprf-rand chooses a “random function”
by uniformly sampling its truth table as needed.
For each possible seed k, the residual function F¹k;ºis also a function from f0;1gin!
f0;1gout. There are “only” 2λpossible functions of this kind (one for each choice of k),
andLprf-real chooses one of these functions randomly. In both cases, the libraries give the
calling program input/output access to the function that was chosen. You can think of this
in terms of the picture from Section 5.1, but instead of strings, the objects are functions.
Note that even in the case of a “random function” ( Lprf-rand ), the function Titself is
stilldeterministic ! To be precise, this library chooses a deterministic function, uniformly,
from the set of all possible deterministic functions. But once it makes this choice, the
input/output behavior of Tis /f_ixed. If the calling program calls /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc twice with the same
x, it receives the same result. The same is true in Lprf-real , since Fis a deterministic function
andkis /f_ixed throughout the entire execution. To avoid this very natural confusion, it
is perhaps better to think in terms of “randomly initialized lookup tables” rather than
“random functions.”
How NOT to Build a PRF
We can appreciate the challenges involved in building a PRF by looking at a natural ap-
proach that doesn’t quite work.
Example Suppose we have a length-doubling PRG G:f0;1gλ!f0;1g2λand try to use it to construct
a PRF Fas follows:
F¹k;xº:
return G¹kºx
You might notice that all we have done is rename the encryption algorithm of “pseudo-OTP”
(Construction 5.2). We have previously argued that this algorithm is a secure method for one-
time encryption, and that the resulting ciphertexts are pseudorandom. Is this enough for a
secure PRF? No, we can attack the security of this PRF.
108Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
Attacking Fmeans designing distinguisher that behaves as diﬀerently as possible in the
presence of the two LF
prf-?libraries. We want to show that Fis insecure even if Gis an
excellent PRG . We should not try to base our attack on distinguishing outputs of Gfrom
random. Instead, we must try to break the inappropriate way that Gis used to construct
a PRF.
The distinguisher must use the interface of the Lprf-?libraries — i.e., make some calls to
the/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc subroutine and output 0 or 1 based on the answers it gets. The /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc subroutine
takes an argument, so the distinguisher has to choose which arguments to use.
One observation we can make is that if a calling program sees only one value of the form
G¹kºx, it will look pseudorandom. This is essentially what we showed in Section 5.3. So we
should be looking for a calling program that makes more than one call to /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc .
If we make two calls to /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc — say, on inputs x1andx2— the responses from Lprf-real
will be G¹kºx1andG¹kºx2. To be a secure PRF, these responses must look independent
and uniform. Do they? They actually have a pattern that the calling program can notice:
their /x.sc/o.sc/r.scis always x1x2, a value that is already known to the calling program.
We can condense all of our observations into the following distinguisher:
A
pick x1;x22f0;1g2λarbitrarily so that x1,x2
z1:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x1º
z2:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2º
return z1z2?=x1x2
Let’s compute its advantage in distinguishing LF
prf-realfromLF
prf-randby consideringA’s be-
havior when linked to these two libraries:
A
pick x1,x22f0;1g2λ
z1:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x1º
z2:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2º
return z1z2?=x1x2LF
prf-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
return G¹kºx//F¹k;xº
WhenAis linked toLF
prf-real, the library will choose a key k. Then z1is set to G¹kºx1and
z2is set to G¹kºx2. Soz1z2isalways equal to x1x2, andAalways outputs 1. That is,
Pr»ALF
prf-real)1¼=1:
A
pick x1,x22f0;1g2λ
z1:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x1º
z2:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2º
return z1z2?=x1x2LF
prf-rand
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifT»x¼unde/f_ined:
T»x¼ f 0;1g2λ
return T»x¼
109Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
WhenAis linked toLF
prf-rand, the responses of the two calls to /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc will be chosen uni-
formly and independently because /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc is being called on distinct inputs. Consider the
moment in time when the second call to /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc is about to happen. At that point, x1,x2, and
z1have all been determined, while z2is about to be chosen uniformly by the library. Using
the properties of /x.sc/o.sc/r.sc, we see thatAwill output 1 if and only if z2is chosen to be exactly the
value x1x2z1. This happens only with probability 122λ. That is,
Pr»ALF
prf-rand)1¼=122λ:
The advantage ofAis therefore 1 122λwhich is certainly non-negligible since it doesn’t
even approach 0. This shows that Fis not a secure PRF.
At a more philosophical level, we wanted to identify exactly how Gis being used in an
inappropriate way. The PRG security libraries guarantee security when G’s seed is chosen
freshly for each call to G. This construction of Fviolates that rule and allows the same seed
to be used twice in diﬀerent calls to G, where the results are supposed to look independent.
This example shows the challenge of building a PRF. Even though we know how to
make any individual output pseudorandom, it is diﬃcult to make all outputs collectively
appear independent , when in reality they are derived from a single short seed.
6.2 PRFs vs PRGs; Variable-Hybrid Proofs
In this section we show that a PRG can be used to construct a PRF, and vice-versa. The
construction of a PRG from PRF is practical, and is one of the more common ways to obtain
a PRG in practice. The construction of a PRF from PRG is more of theoretical interest and
does not re/f_lect how PRFs are designed in practice.
Constructing a PRG from a PRF
As promised, a PRF can be used to construct a PRG. The construction is quite natural. For
simplicity, suppose we have a PRF F:f0;1gλf0;1gλ!f0;1gλ(i.e.,in=out=λ). We
can build a length-doubling PRG in the following way:
Construction 6.2
(Counter PRG)G¹sº:
x:=F¹s;000º
/y.alt:=F¹s;001º
return xk/y.alt
There is nothing particularly special about the inputs 000and001toF. All that
matters is that they are distinct. The construction can be extended to easily give more than
2 blocks of output, by treating the input to Fas a simple counter (hence the name of this
construction).
The guarantee of a PRF is that when its seed is chosen uniformly and it is invoked on
distinct inputs, its outputs look independently uniform. In particular, its output on inputs
000and001are indistinguishable from uniform. Hence, concatenating them gives
a string which is indistinguishable from a uniform 2λ-bit string.
110Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
That really is all there is to the security of this construction, but unfortunately there is
a slight technical issue which makes the security proof more complicated than you might
guess. We will have to introduce a new technique of variable hybrids to cope with it.
Claim 6.3 IfFis a secure PRF, then the counter PRG construction Gabove is a secure PRG.
Proof In order to prove that Gis a secure PRG, we must prove that the following libraries are
indistinguishable:
LG
prg-real
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
s f0;1gλ
x:=F¹s;000º
/y.alt:=F¹s;001º9>> =
>>;//G¹sº
return xk/y.altLG
prg-rand
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
r f0;1g2λ
return r
During the proof, we are allowed to use the fact that Fis a secure PRF. That is, we can use
the fact that the following two libraries are indistinguishable:
LF
prf-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1ginº:
return F¹k;xºLF
prf-rand
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1ginº:
ifT»x¼unde/f_ined:
T»x¼ f 0;1gout
return T»x¼
The inconvenience in the proof stems from a mismatch of the svariable inLprg-real and
thekvariable inLprf-real . InLprg-real ,sis local to the /q.sc_u.sc/e.sc/r.sc/y.sc subroutine. Over the course
of an execution, swill take on many values. Since sis used as the PRF seed, we must write
the calls to Fin terms of the /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc subroutine ofLprf-real . But inLprf-real the PRF seed
is /f_ixed for the entire execution. In other words, we can only use Lprf-real to deal with a
single PRF seed at a time, but Lprg-real deals with many PRG seeds at a time.
To address this, we will have to apply the security of F(i.e., replaceLprf-real with
Lprf-rand )many times during the proof — in fact, once for every call to /q.sc_u.sc/e.sc/r.sc/y.sc made by
the calling program. Previous security proofs had a /f_ixed number of hybrid steps ( e.g., the
proof of Claim 5.5 used 7 hybrid libraries to show Lprg-realLhyb-1Lhyb-7
Lprg-rand ). This proof will have a variable number of hybrids that depends on the
calling program. Speci/f_ically, we will prove
LG
prg-realLhyb-1Lhyb- qLG
prg-rand;
where qis the number of times the calling program calls /q.sc_u.sc/e.sc/r.sc/y.sc .
111Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
Don’t be overwhelmed by all these hybrids. They all follow a simple pattern. In fact,
theith hybrid looks like this:
Lhyb-i:
count :=0
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
count :=count +1
ifcount6i:
r f0;1g2λ
return r
else:
s f0;1gλ
x:=F¹s;000º
/y.alt:=F¹s;001º
return xk/y.alt
In other words, the hybrid libraries all diﬀer in the value ithat is inserted into the code
above. If you’re familiar with C compilers, think of this as adding “ #define i 427 ” to the
top of the code above, to obtain Lhyb-427 .
First note what happens for extreme choices of i:
IInLhyb-0, the if-branch is never taken ( count60is never true). This library behaves
exactly likeLG
prg-realby giving PRG outputs on every call to /q.sc_u.sc/e.sc/r.sc/y.sc .
IIfqis the total number of times that the calling program calls /q.sc_u.sc/e.sc/r.sc/y.sc , then inLhyb-q,
the if-branch is always taken ( count6qis always true). This library behaves exactly
likeLG
prg-randby giving truly uniform output on every call to /q.sc_u.sc/e.sc/r.sc/y.sc .
In general,Lhyb-iwill respond to the /f_irst icalls to /q.sc_u.sc/e.sc/r.sc/y.sc by giving truly random output.
It will respond to all further calls by giving outputs of our PRG construction.
We have argued that LG
prg-realL hyb-0 andLG
prg-randL hyb-q. To complete the proof,
we must show that Lhyb-¹i 1ºLhyb-ifor all i. The main reason for going to all this
trouble of de/f_ining so many hybrid libraries is that Lhyb-¹i 1ºandLhyb-iare completely
identical except in how they respond to the ith call to /q.sc_u.sc/e.sc/r.sc/y.sc . This diﬀerence involves a
single call to the PRG (and hence a single PRF seed), which allows us to apply the security
of the PRF.
In more detail, let ibe arbitrary, and consider the following sequence of steps starting
withLhyb-¹i 1º:
112Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
count :=0
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
count :=count +1
ifcount <i:
r f0;1g2λ
return r
elsif count =i:
s f0;1gλ
x:=F¹s;000º
/y.alt:=F¹s;001º
return xk/y.alt
else:
s f0;1gλ
x:=F¹s;000º
/y.alt:=F¹s;001º
return xk/y.altWe have taken Lhyb-¹i 1º
and simply expanded the
else-branch ( count>i) into
two subcases ( count =iand
count >i). However, both
cases lead to the same block of
code (apart from a change to a
local variable’s name), so the
change has no eﬀect on the
calling program.
count :=0
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
count :=count +1
ifcount <i:
r f0;1g2λ
return r
elsif count =i:
x:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹000º
/y.alt:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹001º
return xk/y.alt
else:
s f0;1gλ
x:=F¹s;000º
/y.alt:=F¹s;001º
return xk/y.altLF
prf-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
return F¹k;xºWe have factored out the calls
toFthat use seed s(corre-
sponding to the count =i
case) in terms ofLprf-real . This
change no eﬀect on the calling
program.
113Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
count :=0
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
count :=count +1
ifcount <i:
r f0;1g2λ
return r
elsif count =i:
x:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹000º
/y.alt:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹001º
return xk/y.alt
else:
s f0;1gλ
x:=F¹s;000º
/y.alt:=F¹s;001º
return xk/y.altLF
prf-rand
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifT»x¼unde/f_ined:
T»x¼ f 0;1gλ
return T»x¼From the fact that Fis a secure
PRF, we can replace LF
prf-real
withLF
prf-rand, and the overall
change is indistinguishable.
count :=0
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
count :=count +1
ifcount <i:
r f0;1g2λ
return r
elsif count =i:
x:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹000º
/y.alt:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹001º
return xk/y.alt
else:
s f0;1gλ
x:=F¹s;000º
/y.alt:=F¹s;001º
return xk/y.alt/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
r f0;1gλ
return rSince count =ihappens only
once, only two calls to /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc
will be made across the entire
lifetime of the library, and they
are on distinct inputs. There-
fore, the if-branch in /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc
will always be taken, and Tis
never needed (it is only needed
to “remember” values and give
the same answer when the
same xis used twice as argu-
ment to /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc ). Simplifying
the library therefore has no ef-
fect on the calling program:
114Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
count :=0
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
count :=count +1
ifcount <i:
r f0;1g2λ
return r
elsif count =i:
x f0;1gλ
/y.alt f0;1gλ
return xk/y.alt
else:
s f0;1gλ
x:=F¹s;000º
/y.alt:=F¹s;001º
return xk/y.altInlining the subroutine has no
eﬀect on the calling program.
The resulting library responds
with uniformly random output
to the /f_irst icalls to /q.sc_u.sc/e.sc/r.sc/y.sc , and
responds with outputs of our
PRG Gto the others. Hence,
this library has identical be-
havior toLhyb-i.
We showed thatLhyb-¹i 1ºLhyb-i, and therefore:
LG
prg-realL hyb-0Lhyb-1Lhyb-qLG
prg-rand
This shows thatLG
prg-realLG
prg-rand, soGis a secure PRG. 
? A Theoretical Construction of a PRF from a PRG
We have already seen that it is possible to feed the output of a PRG back into the PRG
again, to extend its stretch (Claim 5.7). This is done by making a long chain (like a linked
list) of PRGs. The trick to constructing a PRF from a PRG is to chain PRGs together in a
binary tree (similar to Exercise 5.8(a)). The leaves of the tree correspond to /f_inal outputs
of the PRF. If we want a PRF with an exponentially large domain ( e.g.,in=λ), the binary
tree itself is exponentially large! However, it is still possible to compute any individual
leaf eﬃciently by simply traversing the tree from root to leaf. This tree traversal itself is
the PRF algorithm. This construction of a PRF is due to Goldreich, Goldwasser, and Micali,
in the paper that de/f_ined the concept of a PRF.
115Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
G
G G
G G G G
G G G G G G G G0 1
00 01 10 11
000 001 010 011 100 101 110 111/uni03F5
::::::::::::::::::::::::k
length-
doubling PRG
Gλ
λλ GL GR
Imagine a complete binary tree of height in(inwill be the input length of the PRF).
Every node in this tree has a position which can be written as a binary string. Think of
a node’s position as the directions to get there starting at the root, where a 0means “go
left” and 1means “go right.” For example, the root has position /uni03F5(the empty string), the
right child of the root has position 1, etc.
The PRF construction works by assigning a label to every node in the tree, using the
a length-doubling PRG G:f0;1gλ!f0;1g2λ. For convenience, we will write GL¹kºand
GR¹kºto denote the /f_irst λbits and last λbits of G¹kº, respectively. Labels in the tree are
λ-bit strings, computed according to the following two rules:
1. The root node’s label is the PRF seed.
2. If the node at position phas label/v.alt, then its left child (at position pk0) gets label
GL¹/v.altº, and its right child (at position pk1) gets label GR¹/v.altº.
In the picture above, a node’s label is the string being sent on its incoming edge. The tree
has2inleaves, whose positions are the strings f0;1gin. We de/f_ine F¹k;xºto be the label of
node/leaf x. To compute this label, we can traverse the tree from root to leaf, taking left
and right turns at each node according to the bits of xand computing the labels along that
path according to the labeling rule. In the picture above, the highlighted path corresponds
to the computation of F¹k;1001º.
It is important to remember that the binary tree is a useful conceptual tool, but it is ex-
ponentially large in general. Running the PRF on some input does not involve computing
labels for the entire tree, only along a single path from root to leaf.
116Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
Construction 6.4
(GGM PRF)
in=arbitrary
out=λF¹k;x2f0;1ginº:
/v.alt:=k
fori=1toin:
ifxi=0then/v.alt:=GL¹/v.altº
ifxi=1then/v.alt:=GR¹/v.altº
return/v.alt
Claim 6.5 IfGis a secure PRG, then Construction 6.4 is a secure PRF.
Proof We prove the claim using a sequence of hybrids. The number of hybrids in this case
depends on the input-length parameter in. The hybrids are de/f_ined as follows:
Lhyb-d
T:=empty assoc. array
/q.sc_u.sc/e.sc/r.sc/y.sc¹xº:
p:=/f_irst dbits of x
ifT»p¼unde/f_ined:
T»p¼ f 0;1gλ
/v.alt:=T»p¼
fori=d+1toin:
ifxi=0then/v.alt:=GL¹/v.altº
ifxi=1then/v.alt:=GR¹/v.altº
return/v.alt
The hybrids diﬀer only in their hard-coded value of d. We will show that
LF
prf-realL hyb- 0Lhyb- 1Lhyb- inLF
prf-rand:
We /f_irst start by understanding the behavior of Lhyb-dfor extreme choices of d. Simpli-
/f_ications to the code are shown on the right.
Lhyb- 0
T:=empty assoc. array k:=unde/f_ined
//kis alias for T»/uni03F5¼
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
p:=/f_irst 0bits of x p =/uni03F5
ifT»p¼unde/f_ined: if kunde/f_ined:
T»p¼ f 0;1gλk f0;1gλ
/v.alt:=T»p¼
fori=1toin:
ifxi=0then/v.alt:=GL¹/v.altº9>>>> =
>>>>;/v.alt:=F¹k;xº
ifxi=1then/v.alt:=GR¹/v.altº
return/v.alt return F¹k;xºInLhyb- 0, we always have p=/uni03F5,
so the only entry of Tthat is ac-
cessed is T»/uni03F5¼. Then renaming
T»/uni03F5¼tok, we see thatLhyb- 0
LF
prf-real. The only diﬀerence is
when the PRF seed k(T»/uni03F5¼) is
sampled: eagerly at initializa-
tion time inLF
prf-realvs. at the
last possible minute in Lhyb- 0.
117Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
Lhyb- in
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
p:=/f_irst inbits of x p =x
ifT»p¼unde/f_ined: if T»x¼unde/f_ined:
T»p¼ f 0;1gλT»x¼ f 0;1gλ
/v.alt:=T»p¼
fori=in+1toin:
ifxi=0then/v.alt:=GL¹/v.altº9>> =
>>;// unreachable
ifxi=1then/v.alt:=GR¹/v.altº
return/v.alt return T»x¼InLhyb- in, we always have p=
xand the body of the for-
loop is always unreachable. In
that case, it is easy to see that
Lhyb- inhas identical behavior to
LF
prf-rand.
The general pattern is that Lhyb-d“chops oﬀ” the top dlevels of the conceptual binary
tree. When computing the output for some string x, we don’t start traversing the tree from
the root but rather dlevels down the tree, at the node whose position is the d-bit pre/f_ix of
x(called pin the library). We initialize the label of this node as a uniform value (unless it
has already been de/f_ined), and then continue the traversal to the leaf x.
To /f_inish the proof, we show that Lhyb-¹d 1ºandLhyb-dare indistinguishable:
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
p:=/f_irst d 1bits of x
ifT»p¼unde/f_ined:
T»p¼ f 0;1gλ
T»pk0¼:=GL¹T»p¼º
T»pk1¼:=GR¹T»p¼º
p0:=/f_irst dbits of x
/v.alt:=T»p0¼
fori=d+1toin:
ifxi=0then/v.alt:=GL¹/v.altº
ifxi=1then/v.alt:=GR¹/v.altº
return/v.altThe library that is shown here is diﬀerent from
Lhyb-¹d 1ºin the highlighted parts. However, these dif-
ferences have no eﬀect on the calling program. The li-
brary here advances d 1levels down the tree (to the
node at location p), initializes that node’s label as a uni-
form value, then computes the labels for both its chil-
dren, and /f_inally continues computing labels toward the
leaf. The only signi/f_icant diﬀerence from Lhyb-¹d 1ºis
that it computes the labels of both ofp’s children, even
though only one is on the path to x. Since it computes
the label correctly, though, it makes no diﬀerence when
(or if) this extra label is computed.
118Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
p:=/f_irst d 1bits of x
ifT»p¼unde/f_ined:
T»pk0¼T»pk1¼:=/q.sc_u.sc/e.sc/r.sc/y.sc¹º
p0:=/f_irst d+1bits of x
/v.alt:=T»p0¼
fori=d+1toin:
ifxi=0then/v.alt:=GL¹/v.altº
ifxi=1then/v.alt:=GR¹/v.altº
return/v.altLG
prg-real
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
s f0;1gλ
return G¹sºWe have factored out the body
of the if-statement in terms of
LG
prg-realsince it involves an call
toGon uniform input. Impor-
tantly, the seed to G(called T»p¼in
the previous hybrid) was not used
anywhere else — it was a string of
length d 1while the library only
reads T»p0¼forp0of length d. The
change has no eﬀect on the calling
program.
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
p:=/f_irst d 1bits of x
ifT»p¼unde/f_ined:
T»pk0¼T»pk1¼:=/q.sc_u.sc/e.sc/r.sc/y.sc¹º
p0:=/f_irst d+1bits of x
/v.alt:=T»p0¼
fori=d+1toin:
ifxi=0then/v.alt:=GL¹/v.altº
ifxi=1then/v.alt:=GR¹/v.altº
return/v.altLG
prg-rand
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
r f0;1g2λ
return rWe have applied the security
ofGand replacedLprg-real with
Lprg-rand . The change is indistin-
guishable.
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
p:=/f_irst d 1bits of x
ifT»p¼unde/f_ined:
T»pk0¼ f 0;1gλ
T»pk1¼ f 0;1gλ
p0:=/f_irst d+1bits of x
/v.alt:=T»p0¼
fori=d+1toin:
ifxi=0then/v.alt:=GL¹/v.altº
ifxi=1then/v.alt:=GR¹/v.altº
return/v.altWe have inlinedLprg-rand and split the sampling of 2λ
bits into two separate statements sampling λbits each.
In this library, we advance dlevels down the tree, assign
a uniform label to a node (and its sibling), and then pro-
ceed to the leaf applying Gas usual. The only diﬀerence
between this library and Lhyb-dis that we sample the la-
bel of a node that is not on our direct path. But since we
sample it uniformly, it doesn’t matter when (or if) that
extra value is sampled. Hence, this library has identical
behavior toLhyb-d.
We showed thatLhyb-¹d 1ºLhyb-d. Putting everything together, we have:
LF
prf-realL hyb- 0Lhyb- 1Lhyb- inLF
prf-rand:
119Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
Hence, Fis a secure PRF. 
6.3 Block Ciphers (Pseudorandom Permutations)
After /f_ixing the seed of a PRF, it computes a function from f0;1gintof0;1gout. Let’s con-
sider the case where in=out. Some functions from f0;1gintof0;1goutare invertible,
which leads to the question of whether a PRF might realize such a function and be invert-
ible (with knowledge of the seed). In other words, what if it were possible to determine x
when given kandF¹k;xº? While this would be a convenient property, it is not guaranteed
by the PRF security de/f_inition, even in the case of in=out. A function from f0;1ginto
f0;1goutchosen at random is unlikely to have an inverse, therefore a PRF instantiated with
a random key is unlikely to have an inverse.
Apseudorandom permutation (PRP) — also called a block cipher — is essentially
a PRF that is guaranteed to be invertible for every choice of seed. We use both terms (PRP
and block cipher) interchangeably. The term “permutation” refers to the fact that, for ev-
eryk, the function F¹k;ºshould be a permutation of f0;1gin. Instead of requiring a PRP to
be indistinguishable from a randomly chosen function, we require it to be indistinguish-
able from a randomly chosen invertible function.2This means we must modify one of the
libraries from the PRF de/f_inition. Instead of populating the associative array Twith uni-
formly random values, it chooses uniformly random but distinct values. As long as Tgives
distinct outputs on distinct inputs, it is consistent with some invertible function. The li-
brary guarantees distinctness by only sampling values that it has not previously assigned.
Thinking of an associative array Tas a key-value store, we use the notation T:values to
denote the set of values stored in T.
Definition 6.6
(PRP syntax)LetF:f0;1gλf0;1gblen!f 0;1gblenbe a deterministic function. We refer to blen as the
blocklength ofFand any element of f0;1gblenas ablock .
We call Fasecure pseudorandom permutation (PRP) (block cipher ) if the following
two conditions hold:
1. (Invertible given k) There is a function F 1:f0;1gλf0;1gblen!f0;1gblensatisfying
F 1¹k;F¹k;xºº=x;
for all k2f0;1gλand all x2f0;1gblen.
2. (Security)LF
prp-realLF
prp-rand, where:
LF
prp-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1gblenº:
return F¹k;xºLF
prp-rand
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1gblenº:
ifT»x¼unde/f_ined:
T»x¼ f 0;1gblennT:values
return T»x¼
2As we will see later, the distinction between randomly chosen function and randomly chosen invertible
function is not as signi/f_icant as it might seem.
120Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
“T:values ” refers to the setf/v.altj9x:T»x¼=/v.altg.
The changes from the PRF de/f_inition are highlighted in yellow. In particular, the
Lprp-real andLprf-real libraries are identical.
Discussion, Pitfalls
In the de/f_inition, both the functions FandF 1take the seed kas input. Therefore, only
someone with kcan invert the block cipher. Think back to the de/f_inition of a PRF —
without the seed k, it is hard to compute F¹k;xº. A block cipher has a forward and reverse
direction, and computing either of them is hard without k!
6.4 Relating PRFs and Block Ciphers
In this section we discuss how to obtain PRFs from PRPs/block ciphers, and vice-versa.
Switching Lemma (PRPs are PRFs, Too!)
Imagine you can query a PRP on chosen inputs (as in the Lprp-real library), and suppose
the blocklength of the PRP is blen =λ. You would only be able to query that PRP on
anegligible fraction of its exponentially large input domain. It seems unlikely that you
would even be able to tell that it was a PRP ( i.e., an invertible function) rather than a PRF
(an unrestricted function).
This idea can be formalized as follows.
Lemma 6.7
(PRP switching)LetLprf-rand andLprp-rand be de/f_ined as in De/f_initions 6.1 & 6.6, with parameters in=out=
blen=λ(so that the interfaces match up). Then Lprf-randLprp-rand .
Proof Recall the replacement-sampling lemma, Lemma 4.11, which showed that the following
libraries are indistinguishable:
Lsamp-L
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλ
return rLsamp-R
R:=;
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλnR
R:=R[frg
return r
Lsamp-L samples values with replacement, and Lsamp-R samples values without replace-
ment. Now consider the following library L:
L
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1gλº:
ifT»x¼unde/f_ined:
T»x¼ /s.sc/a.sc/m.sc/p.sc¹º
return T»x¼
121Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
When we linkLL samp-L we obtainLprf-rand since the values in T»x¼are sampled uni-
formly. When we link LL samp-R we obtainLprp-rand since the values in T»x¼are sam-
pled uniformly subject to having no repeats (consider Rplaying the role of T:values in
Lprp-rand ). Then from Lemma 4.11, we have:
Lprf-randLL samp-LLL samp-RL prp-rand ;
which completes the proof. 
Using the switching lemma, we can conclude that every PRP (with blen=λ) is also a PRF:
Corollary 6.8 LetF:f0;1gλf0;1gλ!f0;1gλbe a secure PRP (with blen=λ). Then Fis also a secure
PRF.
Proof As we have observed above, LF
prf-realandLF
prp-realare literally the same library. Since Fis
a secure PRP,LF
prp-realLF
prp-rand. Finally, by the switching lemma, LF
prp-randLF
prf-rand.
Putting everything together:
LF
prf-realLF
prp-realLF
prp-randLF
prf-rand;
hence Fis a secure PRF. 
Keep in mind that the switching lemma applies only when the blocklength is suﬃ-
ciently large (at least λbits long). This comes from the fact that Lsamp-L andLsamp-R in the
proof are indistinguishable only when sampling with long (length- λ) strings (look at the
proof of Lemma 4.11 to recall why). Exercise 6.14 asks you to show that a random permu-
tation over a small domain can be distinguished from a random (unconstrained) function;
so, a PRP with a small blocklength is nota PRF.
Constructing a PRP from a PRF: The Feistel Construction
How can you build an invertible block cipher out of a PRF that is not necessarily invertible?
In this section, we show a simple technique called the Feistel construction (named after
IBM cryptographer Horst Feistel).
The main idea in the Feistel construction is to convert a not-necessarily-invertible
function F:f0;1gn!f 0;1gninto an invertible function F:f0;1g2n!f 0;1g2n. The
function Fis called the Feistel round with round function Fand is de/f_ined as follows:
Construction 6.9
(Feistel round) F¹xk/y.altº:
// each of x;/y.altarenbits
return/y.altk¹F¹/y.altºxº
/y.altx
F
É
No matter what Fis, its Feistel round Fis invertible. Not only that, but its inverse is
a kind of “mirror image” of F:
122Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
Feistel inverse Feistel
/y.altx
F
ÉF
ÉF¹/y.altºx/y.alt
/y.altF¹/y.altº
F¹/y.altºx
=x
Note how both the forward and inverse Feistel rounds use Fin the forward direction!
Example Let’s see what happens in the Feistel construction with a trivial round function. Consider the
constant function F¹/y.altº=0n, which is the “least invertible” function imaginable. The Feistel
construction gives:
F¹xk/y.altº=/y.altk¹F¹/y.altºxº
=/y.altk¹0nxº
=/y.altkx
The result is a function that simply switches the order of its halves — clearly invertible.
Example Let’s try another simple round function, this time the identity function F¹/y.altº=/y.alt. The Feistel
construction gives:
F¹xk/y.altº=/y.altk¹F¹/y.altºxº
=/y.altk¹/y.altxº
This function is invertible because given /y.altand/y.altxwe can solve for xas/y.alt¹/y.altxº. You
can verify that this is what happens when you plug Finto the inverse Feistel construction.
We can also consider using a round function Fthat has a key/seed. The result will be
anFthat also takes a seed. For every seed k,F¹k;ºwill have an inverse (which looks
like its mirror image).
Construction 6.10
(Keyed Feistel)F¹k;xk/y.altº:
return/y.altk¹F¹k;/y.altºxº
/y.altx
F¹k;º
É
Now suppose Fis a secure PRF and we use it as a Feistel round function, to obtain a
keyed function F. Since F¹k;ºis invertible for every k, and since Fuses a secure PRF in
some way, you might be tempted to claim that Fis a secure PRP. Unfortunately, it is not!
The output of Fcontains half of its input, making it quite trivial to break the PRP-security
ofF.
We can avoid this trivial attack by performing several Feistel rounds in succession,
resulting in a construction called a Feistel cipher . At each round, we can even use a
diﬀerent key to the round function. If we use k1in the /f_irst round, k2in the second round,
and so on, then k1;k2; : : : is called the key schedule of the Feistel cipher. The formal
de/f_inition of an r-round Feistel cipher is given below:
123Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
Construction 6.11
(Feistel cipher)Fr ¹k1; : : : ; krº;/v.alt0k/v.alt1:
fori=1tor:
/v.alti+1:=F¹ki;/v.altiº/v.alti 1
return/v.altrk/v.altr+1/v.alt1/v.alt0
F¹k1;º
ÉF¹k2;º
ÉF¹k3;º
É
/v.alt1 /v.alt2 /v.alt3
F 1
r ¹k1; : : : ; krº;/v.altrk/v.altr+1:
fori=rdownto 1:
/v.alti 1:=F¹ki;/v.altiº/v.alti+1
return/v.alt0k/v.alt1/v.altr+1/v.altr
F¹kr;º
ÉF¹kr 1;º
ÉF¹kr 2;º
É
/v.altr /v.altr 1/v.altr 2
Because each round is invertible (given the appropriate round key), the overall Feistel
cipher is also invertible. Note that the inverse of the Feistel cipher uses inverse Feistel
rounds and reverses the order of the key schedule.
Surprisingly, a 3-round Feistel cipher can actually be secure, although a 2-round Feistel
cipher is never secure (see the exercises). More precisely: when Fis a secure PRF with
in=out=λ, then using Fas the round function of a 3-round Feistel cipher results in a
secure PRP. The Feistel cipher has blocklength 2λ, and it has a key of length 3λ(3 times
longer than the key for F). Implicitly, this means that the three round keys are chosen
independently.
Theorem 6.12
(Luby-Rackoﬀ)IfF:f0;1gλf0;1gλ!f 0;1gλis a secure PRF, then the 3-round Feistel cipher F3(Con-
struction 6.11) is a secure PRP.
Unfortunately, the proof of this theorem is beyond the scope of this book.
6.5 PRFs and Block Ciphers in Practice
Block ciphers are one of the cornerstones of cryptography in practice today. We have
shown how (at least in principle) block ciphers can be constructed out of simpler primi-
tives: PRGs and PRFs. However, in practice we use block ciphers that are designed “from
scratch,” and then use these block ciphers to construct simpler PRGs and PRFs when we
need them.
We currently have no proof that any secure PRP exists. As we discussed in Section 5.2,
such a proof would resolve the famous PvsNPproblem. Without such proofs, what is our
basis for con/f_idence in the security of block ciphers being used today? The process that led
to the Advanced Encryption Standard (AES) block cipher demonstrates the cryptographic
community’s best eﬀorts at instilling such con/f_idence.
The National Institute of Standards & Technology (NIST) sponsored a competition to
design a block cipher to replace the DES standard from the 1970s. Many teams of cryp-
tographers submitted their block cipher designs, all of which were then subject to years
of intense public scrutiny by the cryptographic research community. The designs were
evaluated on the basis of their performance and resistance to attacks against the PRP se-
curity de/f_inition (and other attacks). Some designs did oﬀer proofs that they resist certain
124Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
classes of attacks , and proofs that justify certain choices in building the block cipher from
simpler components.
The Rijndael cipher, designed by Vincent Rijmen and Joan Daemen, was selected as the
winner and became the AES standard in 2001. There may not be another cryptographic
algorithm that has been the focus of more scrutiny and attempts at attack. So far no
signi/f_icant weaknesses in AES are known.3
The AES block cipher has a blocklength of 128 bits, and oﬀers 3 diﬀerent variants with
128-bit, 192-bit, and 256-bit keys. As a result of its standardization, AES is available in
cryptographic libraries for any programming language. It is even implemented as hard-
ware instructions in most modern processors, allowing millions of AES evaluations per
second. As we have seen, once you have access to a good block cipher, it can be used
directly also as a secure PRF (Corollary 6.8), and it can be used to construct a simple PRG
(Construction 6.2). Even though AES itself is not a provably secure PRP, these construc-
tions of PRFs and PRGs based on AES are secure. Or, more precisely, the PRF-security and
PRG-security of these constructions is guaranteed to be as good as the PRP-security of
AES.
6.6? Strong Pseudorandom Permutations
Since a block cipher Fhas a corresponding inverse F 1, it is natural to think of FandF 1
as interchangeable in some sense. However, the PRP security de/f_inition only guarantees a
security property for Fand not its inverse. In the exercises, you will see that it is possible
to construct Fwhich is a secure PRP, whose inverse F 1is not a secure PRP!
It would be very natural to ask for a PRP whose FandF 1are both secure. We will later
see applications where this property would be convenient. An even stronger requirement
would allow the distinguisher to query both FandF 1in asingle interaction (rather than
one security de/f_inition where the distinguisher queries only F, and another de/f_inition
where the distinguisher queries only F 1). If a PRP is indistinguishable from a random
permutation under that setting, then we say it is a strong PRP (SPRP).
In the formal security de/f_inition, we provide the calling program twosubroutines: one
for forward queries and one for reverse queries. In Lsprp-real , these subroutines are im-
plemented by calling the PRP or its inverse accordingly. In Lsprp-rand , we emulate the
behavior of a randomly chosen permutation that can be queried in both directions. We
maintain two associative arrays TandTinvto hold the truth tables of these permutations,
and sample their values on-demand. The only restriction is that TandTinvmaintain con-
sistency ( T»x¼=/y.altif and only if Tinv»/y.alt¼=x). This also ensures that they always represent
an invertible function. We use the same technique as before to ensure invertibility.
3In all fairness, there is a possibility that government agencies like NSA know of weaknesses in many
cryptographic algorithms, but keep them secret. I know of a rather famous cryptographer (whom I will not
name here) who believes this is likely, based on the fact that NSA has hired more math & cryptography PhDs
than have gone on to do public research.
125Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
Definition 6.13
(SPRP security)LetF:f0;1gλf0;1gblen!f0;1gblenbe a deterministic function. We say that Fis asecure
strong pseudorandom permutation (SPRP) ifLF
sprp-realLF
sprp-rand, where:
LF
sprp-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1gblenº:
return F¹k;xº
/i.sc/n.sc/v.sc/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹/y.alt2f0;1gblenº:
return F 1¹k;/y.altºLF
sprp-rand
T;Tinv:=empty assoc. arrays
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1gblenº:
ifT»x¼unde/f_ined:
/y.alt f0;1gblennT:values
T»x¼:=/y.alt;Tinv»/y.alt¼:=x
return T»x¼
/i.sc/n.sc/v.sc/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹/y.alt2f0;1gblenº:
ifTinv»/y.alt¼unde/f_ined:
x f0;1gblennTinv:values
Tinv»/y.alt¼:=x;T»x¼:=/y.alt
return Tinv»/y.alt¼
Earlier we showed that using a PRF as the round function in a 3-round Feistel cipher
results in a secure PRP. However, that PRP is notastrong PRP. Even more surprisingly,
adding an extra round to the Feistel cipher does make it a strong PRP! We present the
following theorem without proof:
Theorem 6.14
(Luby-Rackoﬀ)IfF:f0;1gλf0;1gλ!f 0;1gλis a secure PRF, then the 4-round Feistel cipher F4(Con-
struction 6.11) is a secure SPRP.
Exercises
6.1. In this problem, you will show that it is hard to determine the key of a PRF by querying
the PRF.
LetFbe a candidate PRF, and suppose there exists a program Asuch that:
Pr»ALF
prf-realoutputs k¼is non-negligible :
In the above expression, krefers to the private variable within Lprf-real .
Prove that if such an Aexists, then Fis not a secure PRF. Use Ato construct a distinguisher
that violates the PRF security de/f_inition.
6.2. Let Fbe a secure PRF.
(a) Let m2f0;1goutbe a /f_ixed (public, hard-coded, known to the adversary) string. De/f_ine:
Fm¹k;xº=F¹k;xºm:
Prove that for every m,Fmis a secure PRF.
126Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
(b) De/f_ine
F0¹k;xº=F¹k;xºx:
Prove that F0is a secure PRF.
6.3. Let Fbe a secure PRF with λ-bit outputs, and let Gbe a PRG with stretch `. De/f_ine
F0¹k;rº=G¹F¹k;rºº:
SoF0has outputs of length λ+`. Prove that F0is a secure PRF.
6.4. Let Fbe a secure PRF with in=2λ, and let Gbe a length-doubling PRG. De/f_ine
F0¹k;xº=F¹k;G¹xºº:
We will see that F0is not necessarily a PRF.
(a) Prove that if Gis injective then F0is a secure PRF.
Hint:
You should not even need to use the fact that Gis a PRG.
?(b) Exercise 5.9(b) constructs a secure length-doubling PRG that ignores half of its input.
Show that F0is insecure when instantiated with such a PRG. Give a distinguisher and
compute its advantage.
Note: You are not attacking the PRF security of F, nor the PRG security of G. You are
attacking the invalid way in which they have been combined.
6.5. Let Fbe a secure PRF, and let m2f0;1ginbe a /f_ixed (therefore known to the adversary)
string. De/f_ine the new function
Fm¹k;xº=F¹k;xºF¹k;mº:
Show that Fmisnota secure PRF. Describe a distinguisher and compute its advantage.
?6.6. In the previous problem, what happens when mis secret and part of the PRF seed? Let F
be a secure PRF, and de/f_ine the new function: De/f_ine the new function
F0
¹k;mº;x
=F¹k;xºF¹k;mº:
The seed of F0is¹k;mº, which you can think of as a λ+inbit string. Show that F0is indeed
a secure PRF.
Hint:Rewrite the F0algorithm to include an “if x=m” clause and argue that the calling program can
rarely satisfy this clause.
6.7. Let Fbe a secure PRF. Let xdenote the bitwise complement of the string x. De/f_ine the
new function:
F0¹k;xº=F¹k;xºkF¹k;xº:
Show that F0isnota secure PRF. Describe a distinguisher and compute its advantage.
6.8. Suppose Fis a secure PRF with input length in, but we want to use it to construct a PRF
with longer input length. Below are some approaches that don’t work. For each one,
describe a successful distinguishing attack and compute its advantage:
127Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
(a)F0¹k;xkx0º=F¹k;xºkF¹k;x0º, where xandx0are each inbits long.
(b)F0¹k;xkx0º=F¹k;xºF¹k;x0º, where xandx0are each inbits long.
(c)F0¹k;xkx0º=F¹k;xºF¹k;xx0º, where xandx0are each inbits long.
(d)F0¹k;xkx0º=F¹k;0kxºF¹k;1kx0º, where xandx0are each in 1bits long.
6.9. De/f_ine a PRF Fwhose key kwe write as¹k1; : : : ; kinº, where each kiis a string of length
out. Then Fis de/f_ined as:
F¹k;xº=Ê
i:xi=1ki:
Show that Fisnota secure PRF. Describe a distinguisher and compute its advantage.
6.10. De/f_ine a PRF Fwhose key kis an in2array of out-bit strings, whose entries we refer to
ask»i;b¼. Then Fis de/f_ined as:
F¹k;xº=inÊ
i=1k»i;xi¼:
Show that Fisnota secure PRF. Describe a distinguisher and compute its advantage.
6.11. A functionf0;1gn!f0;1gnis chosen uniformly at random. What is the probability that
the function is invertible?
6.12. Let Fbe a secure PRP with blocklength blen=128. Then for each k, the function F¹k;º
is a permutation on f0;1g128. Suppose I choose a permutation on f0;1g128uniformly at
random. What is the probability that the permutation I chose agrees with a permutation
of the form F¹k;º? Compute the probability as an actual number — is it a reasonable
probability or a tiny one?
6.13. Suppose R:f0;1gn!f0;1gnis chosen uniformly among all such functions. What is the
probability that there exists an x2f0;1gnsuch that R¹xº=x?
Hint:First /f_ind the probability that R¹xº,xfor all x. Simplify your answer using the approximation
¹1 /y.altºe /y.alt.
6.14. In this problem, you will show that the PRP switching lemma holds only for large domains.
LetLprf-rand andLprp-rand be as in Lemma 6.7. Choose any small value of blen =in=
outthat you like, and show that Lprf-rand6Lprp-rand with those parameters. Describe a
distinguisher and compute its advantage.
Hint: Remember that the distinguisher needs to run in polynomial time in λ, but not necessarily poly-
nomial in blen.
6.15. Let F:f0;1gin!f 0;1goutbe a (not necessarily invertible) function. We showed how to
useFas a round function in the Feistel construction ony when in=out.
Describe a modi/f_ication of the Feistel construction that works even when the round func-
tion satis/f_ies in,out. The result should be an invertible with input/output length in+out.
Be sure to show that your proposed transform is invertible! You are not being asked to
show any security properties of the Feistel construction.
128Draft: January 3, 2021 CHAPTER 6. PSEUDORANDOM FUNCTIONS & BLOCK CIPHERS
6.16. Show that a 1-round keyed Feistel cipher cannot be a secure PRP, no matter what its round
functions are. That is, construct a distinguisher that successfully distinguishes LF
prp-real
andLF
prp-rand, knowing only that Fis a 1-round Feistel cipher. In particular, the purpose is
to attack the Feistel transform and not its round function, so your attack should work no
matter what the round function is.
6.17. Show that a 2-round keyed Feistel cipher cannot be a secure PRP, no matter what its round
functions are. Your attack should work without knowing the round keys, and it should
work even with diﬀerent (independent) round keys.
Hint:A successful attack requires two queries.
6.18. Show that any function Fthat is a 3-round keyed Feistel cipher cannot be a secure strong
PRP. As above, your distinguisher should work without knowing what the round functions
are, and the attack should work with diﬀerent (independent) round functions.
6.19. In this problem you will show that PRPs are hard to invert without the key (if the block-
length is large enough). Let Fbe a candidate PRP with blocklength blen>λ. Suppose
there is a program Awhere:
Pr
/y.alt f0;1gblen
A¹/y.altºLF
prf-realoutputs F 1¹k;/y.altº
is non-negligible :
The notation means that Areceives a random block /y.altas an input (and is also linked to
Lprf-real ).krefers to the private variable within Lprf-real . So, when given the ability to
evaluate Fin the forward direction only (via Lprf-real ),Acan invert a uniformly chosen
block/y.alt.
Prove that if such an Aexists, then Fis not a secure PRP. Use Ato construct a distin-
guisher that violates the PRP security de/f_inition. Where do you use the fact that blen>λ?
How do you deal with the fact that Amay give the wrong answer with high probability?
6.20. Let Fbe a secure PRP with blocklength blen=λ, and consider bF¹k;xº=F¹k;kºF¹k;xº.
(a) Show that bFis not a strong PRP (even if Fis).
?(b) Show that bFis a secure (normal) PRP.
1297Security Against Chosen Plaintext
A/t_tacks
Our previous security de/f_initions for encryption capture the case where a key is used to
encrypt only one plaintext. Clearly it would be more useful to have an encryption scheme
that allows many plaintexts to be encrypted under the same key.
Fortunately we have arranged things so that we get the “correct” security de/f_inition
when we modify the earlier de/f_inition in a natural way. We simply let the libraries choose
a secret key once and for all, which is used to encrypt all plaintexts. More formally:
Definition 7.1
(CPA security)LetΣbe an encryption scheme. We say that Σhassecurity against chosen-plaintext
a/t_tacks (CPA security) ifLΣ
cpa-LLΣ
cpa-R, where:
LΣ
cpa-L
k Σ:KeyGen
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
c:=Σ:Enc¹k;mLº
return cLΣ
cpa-R
k Σ:KeyGen
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
c:=Σ:Enc¹k;mRº
return c
Notice how the key kis chosen at initialization time and is static for all calls to Enc.
CPA security is often called “IND-CPA” security, meaning “indistinguishability of cipher-
texts under chosen-plaintext attack.”
7.1 Limits of Deterministic Encryption
We have already seen block ciphers / PRPs, which seem to satisfy everything needed for
a secure encryption scheme. For a block cipher, Fcorresponds to encryption, F 1corre-
sponds to decryption, and all outputs of Flook pseudorandom. What more could you ask
for in a good encryption scheme?
Example We will see that a block cipher, when used “as-is,” is nota CPA-secure encryption scheme. Let
Fdenote the block cipher and suppose its block length is blen.
Consider the following adversary A, that tries to distinguish the Lcpa-?libraries:
A
c1:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹0blen;0blenº
c2:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹0blen;1blenº
return c1?=c2
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
A
c1:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹0blen;0blenº
c2:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹0blen;1blenº
return c1?=c2LΣ
cpa-L
k f0;1gλ
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=F¹k;mLº
return cWhenAis linked toLcpa-L, the
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc algorithm will en-
crypt its /f_irst argument. So, c1
andc2will both be computed as
F¹k;0blenº. Since Fis a determin-
istic function, this results in iden-
tical outputs from /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc . In
other words c1=c2, andA
Lcpa-Lalways outputs 1.
A
c1:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹0blen;0blenº
c2:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹0blen;1blenº
return c1?=c2LΣ
cpa-R
k f0;1gλ
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=F¹k;mRº
return cWhenAis linked toLcpa-R, the
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc algorithm will en-
crypt its second argument. So,
c1andc2are computed as c1=
F¹k;0blenºandc2=F¹k;1blenº.
Since Fis a permutation, c1,c2,
soAL cpa-Rnever outputs 1.
This adversary has advantage 1 in distinguishing the libraries, so the bare block cipher F
isnota CPA-secure encryption scheme.
Impossibility of Deterministic Encryption
The reason a bare block cipher does not provide CPA security is that it is deterministic .
Calling Enc¹k;mºtwice — with the same key and same plaintext — leads to the same ci-
phertext. Even one-time pad is deterministic.1One of the /f_irst and most important aspects
of CPA security is that it is incompatible with deterministic encryption. Deterministic
encryption can never be CPA-secure! In other words, we can attack the CPA-security
of any scheme Σ, knowing only that it has deterministic encryption. The attack is a simple
generalization of our attack against a bare PRP:
A
arbitrarily choose distinct plaintexts x;/y.alt2M
c1:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹x;xº
c2:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹x;/y.altº
return c1?=c2
A good way to think about what goes wrong with deterministic encryption is that it
leaks whether two ciphertexts encode the same plaintext, and this is not allowed
by CPA security. Think of sealed envelopes as an analogy for encryption. I shouldn’t be
able to tell whether two sealed envelopes contain the same text! We are only now seeing
this issue because this is the /f_irst time our security de/f_inition allows an adversary to see
multiple ciphertexts encrypted under the same key.
1Remember, we can always consider what will happen when running one-time pad encryption twice
with the same key + plaintext. The one-time secrecy de/f_inition doesn’t give us any security guarantees about
using one-time pad in this way, but we can still consider it as a thought experiment.
131Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
Avoiding Deterministic Encryption
Is CPA security even possible? How exactly can we make a non-deterministic encryption
scheme? This sounds challenging! We must design an Encalgorithm such that calling it
twice with the same plaintext and key results in diﬀerent ciphertexts (otherwise the attack
Aabove violates CPA security). What’s more, it must be possible to decrypt all of those
diﬀerent encryptions of the same plaintext to the correct value!
There are 3 general ways to design an encryption scheme that is not deterministic:
IEncryption/decryption can be stateful , meaning that every call to EncorDecwill
actually modify the value of k. The symmetric ratchet construction described in Sec-
tion 5.5 could be thought of as such a stateful construction. The key is updated via
the ratchet mechanism for every encryption. A signi/f_icant drawback with stateful
encryption is that synchronization between sender and receiver is fragile and can
be broken if a ciphertext is lost in transit.
IEncryption can be randomized . Each time a plaintext is encrypted, the Encalgo-
rithm chooses fresh, independent randomness speci/f_ic to that encryption. The main
challenge in designing a randomized encryption method is to incorporate random-
ness into each ciphertext in such a way that decryption is still possible. Although
this sounds quite challenging, we have already seen such a method, and we will
prove its CPA security in the next sections. In this book we will focus almost en-
tirely on randomized encryption.
IEncryption can be nonce-based . A “nonce” stands for “number used only once,”
and it refers to an extra argument that is passed to the EncandDecalgorithms. A
nonce does not need to be chosen randomly; it does not need to be secret; it only
needs to be distinct among all calls made to Enc. By guaranteeing that some input
toEncwill be diﬀerent every time (even when the key and plaintext are repeated),
theEncalgorithm can be deterministic and still provide CPA security.
Nonce-based encryption requires a change to the interface of encryption, and
therefore a change to the correctness & security de/f_initions as well. The encryp-
tion/decryption algorithms syntax is updated to Enc¹k;/v.alt;mºandDec¹k;/v.alt;cº, where
/v.altis a nonce. The correctness property is that Dec¹k;/v.alt;Enc¹k;/v.alt;mºº=mfor all
k;/v.alt;m, so both encryption & decryption algorithms should use the same nonce.
The security de/f_inition allows the adversary to choose the nonce, but gives an error
if the adversary tries to encrypt multiple ciphertexts with the same nonce. In this
way, the de/f_inition enforces that the nonces are distinct.
k Σ:KeyGen
V:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹/v.alt;mL;mR2Σ:Mº:
if/v.alt2V: return err
V:=V[f/v.altg
c:=Σ:Enc¹k;/v.alt;mLº
return ck Σ:KeyGen
V:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹/v.alt;mL;mR2Σ:Mº:
if/v.alt2V: return err
V:=V[f/v.altg
c:=Σ:Enc¹k;/v.alt;mRº
return c
132Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
Note that the calling program provides a single value /v.alt(not a/v.altLand/v.altR). Both
libraries use the nonce /v.altthat is given, and this implies that the encryption scheme
does not need to hide/v.alt. If something is the same between both libraries, then it is
not necessary to hide it in order to make the libraries indistinguishable.
If an encryption scheme does not fall into one of these three categories, it cannot
satisfy our de/f_inition of CPA-security. You can and should use deterministic encryption as
a sanity check against any proposed encryption algorithm.
7.2 Pseudorandom Ciphertexts
When we introduced one-time security of encryption (in Section 2.2), we had two variants
of the de/f_inition. The more general variant said, roughly, that encryptions of mLshould
look like encryptions of mR. The more speci/f_ic variant said that encryptions of every m
should look uniform.
We can do something similar for CPA security, by de/f_ining a security de/f_inition that
says “encryptions of mlook uniform.” Note that it is not suﬃcient to use the same se-
curity libraries from the one-time security de/f_inition. It is important for the library to
allow multiple encryptions under the same key. Just because a single encryption is pseu-
dorandom, it doesn’t mean that multiple encryptions appear jointly pseudorandom. In
particular, they may not look independent (this was an issue we saw when discussing the
diﬃculty of constructing a PRF from a PRG).
Definition 7.2
(CPA$ security)LetΣbe an encryption scheme. We say that Σhaspseudorandom ciphertexts in the
presence of chosen-plaintext a/t_tacks (CPA$ security) ifLΣ
cpa$-realLΣ
cpa$-rand, where:
LΣ
cpa$-real
k Σ:KeyGen
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
c:=Σ:Enc¹k;mº
return cLΣ
cpa$-rand
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
c Σ:C
return c
This de/f_inition is also called “IND$-CPA”, meaning “indistinguishable from random
under chosen plaintext attacks.” This de/f_inition will be useful to use since:
IIt is easier to prove CPA$ security than to prove CPA security. Proofs for CPA secu-
rity tend to be about twice as long and twice as repetitive, since they involve getting
to a “half-way hybrid” and then performing the same sequence of hybrids steps in
reverse. Taking the proof only to the same half-way point is generally enough to
prove CPA$ security
ICPA$ security implies CPA security. We show this below, but the main idea is the
same as in the case of one-time security. If encryptions of all plaintexts look uniform,
then encryptions of mLlook like encryptions of mR.
IMost of the schemes we will consider achieve CPA$ anyway.
133Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
Still, most of our high-level discussion of security properties will be based on CPA security.
It is the “minimal” ( i.e., least restrictive) de/f_inition that appears to capture our security
intuitions.
Claim 7.3 If an encryption scheme has CPA$ security, then it also has CPA security.
Proof We want to prove that LΣ
cpa-LLΣ
cpa-R,using the assumption that LΣ
cpa$-realLΣ
cpa$-rand.
The sequence of hybrids follows:
LΣ
cpa-L:LΣ
cpa-L
k Σ:KeyGen
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=Σ:Enc¹k;mLº
return cThe starting point is LΣ
cpa-L, as expected.
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=/c.sc/t.sc/x.sc/t.sc¹mLº
return cLΣ
cpa$-real
k Σ:KeyGen
/c.sc/t.sc/x.sc/t.sc¹mº:
c:=Σ:Enc¹k;mº
return cIt may look strange, but we have further
factored out the call to Encinto a subrou-
tine. It looks like everything fromLcpa-L
has been factored out, but actually the
original library still “makes the choice” of
which of mL;mRto encrypt.
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=/c.sc/t.sc/x.sc/t.sc¹mLº
return cLΣ
cpa$-rand
/c.sc/t.sc/x.sc/t.sc¹mº:
c Σ:C
return cWe have replaced LΣ
cpa$-realwith
LΣ
cpa$-rand. By our assumption, the
change is indistinguishable.
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=/c.sc/t.sc/x.sc/t.sc¹mRº
return cLΣ
cpa$-rand
/c.sc/t.sc/x.sc/t.sc¹mº:
c Σ:C
return cWe have changed the argument being
passed to /c.sc/t.sc/x.sc/t.sc . This has no eﬀect on the
library’s behavior since /c.sc/t.sc/x.sc/t.sc completely
ignores its argument in these hybrids.
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=/c.sc/t.sc/x.sc/t.sc¹mRº
return cLΣ
cpa$-real
k Σ:KeyGen
/c.sc/t.sc/x.sc/t.sc¹mº:
c:=Σ:Enc¹k;mº
return cThe mirror image of a previous step; we
replaceLcpa$-rand withLcpa$-real .
134Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
LΣ
cpa-R:LΣ
cpa-R
k Σ:KeyGen
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=Σ:Enc¹k;mRº
return cTheLcpa$-real library has been inlined,
and the result isLΣ
cpa-R.
The sequence of hybrids shows that LΣ
cpa-LLΣ
cpa-R, as desired. 
7.3 CPA-Secure Encryption Based On PRFs
CPA security presents a signi/f_icant challenge; its goals seem diﬃcult to reconcile. On the
one hand, we need an encryption method that is randomized, so that each plaintext m
is mapped to a large number of potential ciphertexts. On the other hand, the decryption
method must be able to recognize all of these various ciphertexts as being encryptions of
m.
However, we have already seen a way to do this! In Chapter 6 we motivated the
concept of a PRF with the following encryption technique. If Alice and Bob share a huge
table Tinitialized with uniform data, then Alice can encrypt a plaintext mto Bob by saying
something like “this is encrypted with one-time pad, using key #674696273” and sending
T»674696273¼m. Seeing the number 674696273 doesn’t help the eavesdropper know what
T»674696273¼is. A PRF allows Alice & Bob to do the same encryption while sharing only
a short key k. Instead of a the huge table T, they can instead use a PRF F¹k;ºto derive
a common pseudorandom value. Knowing a value rdoesn’t help the adversary predict
F¹k;rº, when kis secret.
So, translated into more precise PRF notation, an encryption of mwill look like
¹r;F¹k;rºmº. Since Bob also has k, he can decrypt anyciphertext of this form by com-
puting F¹k;rºand/x.sc/o.sc/r.sc’ing the second ciphertext component to recover m.
It remains to decide how exactly Alice will choose rvalues. We argued, informally, that
as long as these rvalues don’t repeat, security is preserved. This is indeed true, and the
distinctness of the rvalues is critical. Recall that there are 3 ways to avoid deterministic
encryption, and all 3 of them would work here:
IIn astateful encryption, rcould be used as a counter. Use r=ito encrypt/decrypt
theith ciphertext.
IIn arandomized encryption, choose runiformly at random for each encryption. If
thervalues are long enough strings, then repeating an rvalue should be negligibly
likely.
IIn anonce-based encryption, we can simply let rbe the nonce. In the nonce-based
setting, it is guaranteed that these values won’t repeat.
In this section we will show the security proof for the case of randomized encryption,
since it is the most traditional setting and also somewhat more robust than the others.
135Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
The exercises explore how the nonce-based approach is more fragile when this scheme is
extended in natural ways.
Construction 7.4 LetFbe a secure PRF with in=λ. De/f_ine the following encryption scheme based on F:
K=f0;1gλ
M=f0;1gout
C=f0;1gλf0;1gout
KeyGen :
k f0;1gλ
return kEnc¹k;mº:
r f0;1gλ
x:=F¹k;rºm
return¹r;xº
Dec¹k;¹r;xºº:
m:=F¹k;rºx
return m
It is easy to check that the scheme satis/f_ies the correctness property.
Claim 7.5 Construction 7.4 has CPA$ security (and therefore CPA security) if Fis a secure PRF.
The proof has more steps than other proofs we have seen before, and some steps are
subtle. So let us use a Socratic dialogue to illustrate the strategy behind the proof:
S/a.sc/l.sc/v.sc/i.sc/a.sc/t.sc/i.sc: The ciphertexts of Construction 7.4 are indistinguishable from uniform random-
ness.
S/i.sc/m.sc/p.sc/l.sc/i.sc/c.sc/i.sc/o.sc: Salviati, you speak with such con/f_idence! Do tell me why you say that these
ciphertexts appear pseudorandom.
S/a.sc/l.sc/v.sc/i.sc/a.sc/t.sc/i.sc: Simple! The ciphertexts have the form ¹r;F¹k;rºmº. By its very de/f_inition, r
is chosen uniformly, while F¹k;rºmis like a one-time pad ciphertext which is
also uniformly distributed.
S/i.sc/m.sc/p.sc/l.sc/i.sc/c.sc/i.sc/o.sc: Your statement about ris self-evident but F¹k;rºmconfuses me. This does
not look like the one-time pad that we have discussed. For one thing, the same
kis used “every time,” not “one-time.”
S/a.sc/l.sc/v.sc/i.sc/a.sc/t.sc/i.sc: I did say it was merely “like” one-time pad. The one-time pad “key” is not k
butF¹k;rº. And since Fis a pseudorandom function, all its outputs will appear
independently uniform (not to mention uncorrelated with their respective r), even
when the same seed is used every time. Is this not what we require from a one-time
pad key?
S/i.sc/m.sc/p.sc/l.sc/i.sc/c.sc/i.sc/o.sc: I see, but surely the outputs of Fappear independent only when its inputs are
distinct? I know that Fis deterministic, and this may lead to the same “one-
time pad key” being used on diﬀerent occasions.
S/a.sc/l.sc/v.sc/i.sc/a.sc/t.sc/i.sc: Your skepticism serves you well in this endeavor, Simplicio. Indeed, the heart of
your concern is that Alice may choose rsuch that it repeats. I say that this is
negligibly likely, so that we can safely ignore such a bothersome event.
S/i.sc/m.sc/p.sc/l.sc/i.sc/c.sc/i.sc/o.sc: Bothersome indeed, but why do you say that ris unlikely to repeat?
136Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
S/a.sc/l.sc/v.sc/i.sc/a.sc/t.sc/i.sc: Oh Simplicio, now you are becoming bothersome! This value risλbits long and
chosen uniformly at random each time. Do you not recall our agonizingly long
discussion about the birthday paradox?
S/i.sc/m.sc/p.sc/l.sc/i.sc/c.sc/i.sc/o.sc: Oh yes, now I remember it well. Now I believe I understand all of your reason-
ing: Across all ciphertexts that are generated, ris unlikely to repeat because
of the birthday paradox. Now, provided that rnever repeats, Alice invokes the
PRF on distinct inputs. A PRF invoked on distinct inputs provides outputs that
are uniformly random for all intents and purposes. Hence, using these outputs
as one-time pads completely hides the plaintext. Is that right, Salviati?
S/a.sc/l.sc/v.sc/i.sc/a.sc/t.sc/i.sc: Excellent! Now we may return to discussing the motion of the Sun and Earth : : :
Look for Simplicio’s /f_inal summary to be re/f_lected in the sequence of hybrids used in
the formal proof:
Proof We prove thatLΣ
cpa$-realLΣ
cpa$-randusing the hybrid technique:
LΣ
cpa$-real:LΣ
cpa$-real
k f0;1gλ
/c.sc/t.sc/x.sc/t.sc¹mº:
r f0;1gλ
x:=F¹k;rºm
return¹r;xºThe starting point is LΣ
cpa$-real. The details
ofΣhave been /f_illed in and highlighted.
/c.sc/t.sc/x.sc/t.sc¹mº:
r f0;1gλ
z:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
x:=zm
return¹r;xºLF
prf-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº:
return F¹k;rºThe statements pertaining to the PRF have
been factored out in terms of the LF
prf-real
library.
/c.sc/t.sc/x.sc/t.sc¹mº:
r f0;1gλ
z:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
x:=zm
return¹r;xºLF
prf-rand
T:=empty
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº:
ifT»r¼unde/f_ined:
T»r¼ f 0;1gout
return T»r¼We have replaced LF
prf-realwithLF
prf-rand.
From the PRF security of F, these two hy-
brids are indistinguishable.
At this point in the proof, it is easy to imagine that we are done. Ciphertexts have the
form¹r;xº, where ris chosen uniformly and xis the result of encrypting the plaintext with
what appears to be a one-time pad. Looking more carefully, however, the “one-time pad
137Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
key” is T»r¼— a value that could potentially be used more than once if ris ever repeated!
As Simplicio rightly pointed out, a PRF gives independently random(-looking) outputs
when called on distinct inputs . But in our current hybrid there is no guarantee that PRF
inputs are distinct! Our proof must explicitly contain reasoning about why PRF inputs are
unlikely to be repeated. We do so by appealing to the sampling-with-replacement lemma
of Lemma 4.11.
We /f_irst factor out the sampling of rvalues into a subroutine. The subroutine corre-
sponds to theLsamp-L library of Lemma 4.11:
/c.sc/t.sc/x.sc/t.sc¹mº:
r /s.sc/a.sc/m.sc/p.sc¹º
z:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
x:=zm
return¹r;xºLF
prf-rand
T:=empty
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº:
ifT»r¼unde/f_ined:
T»r¼ f 0;1gout
return T»r¼Lsamp-L
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλ
return r
Next,Lsamp-L is replaced byLsamp-R . By Lemma 4.11, the diﬀerence is indistinguishable:
/c.sc/t.sc/x.sc/t.sc¹mº:
r /s.sc/a.sc/m.sc/p.sc¹º
z:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
x:=zm
return¹r;xºLF
prf-rand
T:=empty
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº:
ifT»r¼unde/f_ined:
T»r¼ f 0;1gout
return T»r¼Lsamp-R
R:=;
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλnR
R:=R[frg
return r
Inspecting the previous hybrid, we can reason that the arguments to /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc areguaran-
teedto never repeat. Therefore the Lprf-rand library can be greatly simpli/f_ied. In particular,
the if-condition inLprf-rand is always true. Simplifying has no eﬀect on the library’s output
behavior:
/c.sc/t.sc/x.sc/t.sc¹mº:
r /s.sc/a.sc/m.sc/p.sc¹º
z:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
x:=zm
return¹r;xº/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº:
t f0;1gout
return tLsamp-R
R:=;
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλnR
R:=R[frg
return r
Now we are indeed using unique one-time pads to mask the plaintext. We are in much
better shape than before. Recall that our goal is to arrive at a hybrid in which the outputs
of/c.sc/t.sc/x.sc/t.sc are chosen uniformly. These outputs include the value r, but now risno longer
being chosen uniformly! We must revert rback to being sampled uniformly, and then we
are nearly to the /f_inish line.
138Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
/c.sc/t.sc/x.sc/t.sc¹mº:
r /s.sc/a.sc/m.sc/p.sc¹º
z:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
x:=zm
return¹r;xº/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº:
t f0;1gout
return tLsamp-L
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλ
return rAs promised,Lsamp-R has been
replaced byLsamp-L . The
diﬀerence is indistinguishable
due to Lemma 4.11.
/c.sc/t.sc/x.sc/t.sc¹mº:
r f0;1gλ
z f0;1gout
x:=zm
return¹r;xºAll of the subroutine calls have
been inlined; no eﬀect on the
library’s output behavior.
LΣ
cpa$-rand:LΣ
cpa$-rand
/c.sc/t.sc/x.sc/t.sc¹mº:
r f0;1gλ
x f0;1gout
return¹r;xºWe have applied the one-time pad rule with respect to variables z
andx, but omitted the very familiar steps (factor out, replace library,
inline) that we have seen several times before. The resulting library is
preciselyLΣ
cpa$-randsince it samples uniformly from Σ:C=f0;1gλ
f0;1gout.
The sequence of hybrids shows that LΣ
cpa$-realLΣ
cpa$-rand, soΣhas pseudorandom
ciphertexts. 
Exercises
7.1. Let Σbe an encryption scheme, and suppose there is a program Athat recovers the key
from a chosen plaintext attack. More precisely, Pr»AL outputs k¼is non-negligible,
whereLis de/f_ined as:
L
k Σ:KeyGen
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m2Σ:Mº:
c:=Σ:Enc¹k;mº
return c
Prove that if such an Aexists, then Σdoes not have CPA security. Use Aas a subroutine
in a distinguisher that violates the CPA security de/f_inition.
In other words, CPA security implies that it should be hard to determine the key from
seeing encryptions of chosen plaintexts.
7.2. Let Σbe an encryption scheme with CPA$ security. Let Σ0be the encryption scheme
de/f_ined by:
Σ0:Enc¹k;mº=00kΣ:Enc¹k;mº
139Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
The decryption algorithm in Σ0simply throws away the /f_irst two bits of the ciphertext and
then calls Σ:Dec.
(a) Does Σ0have CPA$ security? Prove or disprove (if disproving, show a distinguisher
and calculate its advantage).
(b) Does Σ0have CPA security? Prove or disprove (if disproving, show a distinguisher and
calculate its advantage).
7.3. Suppose a user is using Construction 7.4 and an adversary observes two ciphertexts that
have the same rvalue.
(a) What exactly does the adversary learn about the plaintexts in this case?
(b) How do you reconcile this with the fact that in the proof of Claim 7.5 there is a hybrid
where rvalues are never repeated?
7.4. Construction 7.4 is a randomized encryption scheme, but we could also consider de/f_ining
it as a nonce-based scheme, interpreting ras the nonce: Enc¹k;r;mº=¹r;F¹k;rºmº.
Formally prove that it is secure as a deterministic, nonce-based scheme. In other words,
show that the following two libraries are indistinguishable, where Σrefers to Construc-
tion 7.4.
k Σ:KeyGen
V:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹/v.alt;mL;mR2Σ:Mº:
if/v.alt2V: return err
V:=V[f/v.altg
c:=Σ:Enc¹k;/v.alt;mLº
return ck Σ:KeyGen
V:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹/v.alt;mL;mR2Σ:Mº:
if/v.alt2V: return err
V:=V[f/v.altg
c:=Σ:Enc¹k;/v.alt;mRº
return c
7.5. Let Fbe a secure PRP with blocklength blen =λ. Consider the following randomized
encryption scheme:
K=f0;1gλ
M=f0;1gλ
C=¹f0;1gλº2KeyGen :
k f0;1gλ
return kEnc¹k;mº:
/v.alt f0;1gλ
x:=F¹k;/v.altmº
return¹/v.alt;xº
(a) Give the decryption algorithm for this scheme.
(b) Prove that the scheme has CPA$ security.
(c) Suppose that we interpret this scheme as a nonce-based scheme, where /v.altis the nonce.
Show that the scheme does nothave nonce-based CPA security. The libraries for this
de/f_inition are given in the previous problem.
Note: Even in the standard CPA libraries, /v.altis given to the adversary and it is unlikely
to repeat. However, in the nonce-based libraries the adversary can choose/v.alt, and this
is what leads to problems.
140Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
7.6. Let Fbe a secure PRP with blocklength blen =λ. Show the the following scheme has
pseudorandom ciphertexts:
K=f0;1gλ
M=f0;1gλ
C=¹f0;1gλº2
KeyGen :
k f0;1gλ
return kEnc¹k;mº:
s f0;1gλ
z:=F¹k;smºm
return¹sm;zº
Dec¹k;¹r;zºº:
return F¹k;rºz
Hint:Rewrite Encto include a new variable r:=smand write the output in terms of rinstead of s.
You might then recognize a familiar face.
7.7. Let Fbe a secure PRP with blocklength blen=λ. Below are several encryption schemes,
each withK=M=f0;1gλandC=¹f0;1gλº2. For each one:
IGive the corresponding Decalgorithm.
IState whether the scheme has CPA security. (Assume KeyGen samples the key uni-
formly fromf0;1gλ.) If so, then give a security proof. If not, then describe a success-
ful adversary and compute its distinguishing bias.
(a)Enc¹k;mº:
r f0;1gλ
z:=F¹k;mºr
return¹r;zº
(b)Enc¹k;mº:
r f0;1gλ
s:=rm
x:=F¹k;rº
return¹s;xº
(c)Enc¹k;mº:
r f0;1gλ
x:=F¹k;rº
/y.alt:=rm
return¹x;/y.altº
(d)Enc¹k;mº:
r f0;1gλ
x:=F¹k;rº
/y.alt:=F¹k;rºm
return¹x;/y.altº(e)Enc¹k;mº:
r f0;1gλ
x:=F¹k;rº
/y.alt:=rF¹k;mº
return¹x;/y.altº
(f)Enc¹k;mº:
s1 f0;1gλ
s2:=s1m
x:=F¹k;s1º
/y.alt:=F¹k;s2º
return¹x;/y.altº
?(g)Enc¹k;mº:
r f0;1gλ
x:=F¹k;mrºr
return¹r;xº
Hint: In all security proofs, you can use the PRP switching lemma (Lemma 6.7) to start with the assump-
tion that Fis a PRF.
141Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
7.8. Suppose Fis a secure PRP with blocklength n+λ. Below is the encryption algorithm for
a scheme that supports plaintext space M=f0;1gn:
Enc¹k;mº:
r f0;1gλ
return F¹k;mkrº
(a) Describe the corresponding decryption algorithm.
(b) Prove that the scheme satis/f_ies CPA$ security.
?7.9. Suppose Fis a secure PRP with blocklength λ. Give the decryption algorithm for the
following scheme and prove that it does nothave CPA security:
K=f0;1gλ
M=f0;1g2λ
C=¹f0;1gλº3KeyGen :
k f0;1gλ
return kEnc¹k;m1km2º:
r f0;1gλ
s:=F¹k;rm1º
t:=F k;rm1F¹k;m1ºm2
return¹r;s;tº
?7.10. Suppose Fis a secure PRP with blocklength λ. Give the decryption algorithm for the
following scheme and prove that it satis/f_ies CPA$ security:
K=¹f0;1gλº2
M=f0;1gλ
C=¹f0;1gλº2KeyGen :
k f0;1gλ
r f0;1gλ
return¹k;rºEnc¹¹k;rº;mº:
s f0;1gλ
x:=F¹k;sº
/y.alt:=F¹k;smrº
return¹x;/y.altº
Hint: You may /f_ind it useful to divide the Encalgorithm into two cases by introducing an “if m=r”
statement.
Note: Ifr=0λthen the scheme reduces to Exercise 7.7 (f). So it is important that ris secret
and random.
7.11. Let Σbe an encryption scheme with plaintext space M=f0;1gnand ciphertext space
C=f0;1gn. Prove that Σcannot have CPA security.
Conclude that direct application of a PRP to the plaintext is not a good choice for an
encryption scheme.
?7.12. In all of the CPA-secure encryption schemes that we’ll ever see, ciphertexts are at least
λbits longer than plaintexts. This problem shows that such ciphertext expansion is
essentially unavoidable for CPA security.
LetΣbe an encryption scheme with plaintext space M=f0;1gnand ciphertext space
C=f0;1gn+`. Show that there exists a distinguisher that distinguishes the two CPA
libraries with advantage Ω¹12`º.
Hint:As a warmup, consider the case where each plaintext has exactly 2`possible ciphertexts. However,
this need not be true in general. For the general case, choose a random plaintext mand argue that
with “good probability” (that you should precisely quantify) mhas at most 2`+1possible ciphertexts.
142Draft: January 3, 2021 CHAPTER 7. SECURITY AGAINST CHOSEN PLAINTEXT ATTACKS
7.13. Show that an encryption scheme Σhas CPA security if and only if the following two
libraries are indistinguishable:
LΣ
le/f_t
k Σ:KeyGen
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m2Σ:Mº:
return Σ:Enc¹k;mºLΣ
right
k Σ:KeyGen
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m2Σ:Mº:
m0 Σ:M
return Σ:Enc¹k;m0º
In plain language: if these libraries are indistinguishable, then encryptions of chosen plain-
texts are indistinguishable from encryptions of random plaintexts. You must prove both
directions!
7.14. Let Σ1andΣ2be encryption schemes with Σ1:M=Σ2:M=f0;1gn.
Consider the following approach for encrypting plaintext m2f0;1gn: First, secret-share
musing any 2-out-of-2 secret-sharing scheme. Then encrypt one share under Σ1and the
other share under Σ2. Release both ciphertexts.
(a) Formally describe the algorithms of this encryption method.
(b) Prove that the scheme has CPA security if at least one offΣ1;Σ2ghas CPA security.
In other words, it is not necessary that bothΣ1andΣ2are secure. This involves proving
two cases (assuming Σ1is secure, and assuming Σ2is secure).
1438Block Cipher Modes of Operation
One of the drawbacks of the previous CPA-secure encryption scheme is that its ciphertexts
areλbits longer than its plaintexts. In the common case that we are using a block cipher
with blocklength blen=λ, this means that ciphertexts are twice as long as plaintexts. Is
there any way to encrypt data (especially lots of it) without requiring such a signi/f_icant
overhead?
Ablock cipher mode refers to a way to use a block cipher to eﬃciently encrypt a
large amount of data (more than a single block). In this chapter, we will see the most
common modes for CPA-secure encryption of long plaintexts.
8.1 A Tour of Common Modes
As usual, blen will denote the blocklength of a block cipher F. In our diagrams, we’ll write
Fkas shorthand for F¹k;º. When mis the plaintext, we will write m=m1km2kk m`,
where each miis a single block (so `is the length of the plaintext measured in blocks). For
now, we will assume that mis an exact multiple of the block length.
ECB: Electronic Codebook ( /n.sc/e.sc/v.sc/e.sc/r.sc /n.sc/e.sc/v.sc/e.sc/r.sc /u.sc/s.sc/e.sc /t.sc/h.sc/i.sc/s.sc! /n.sc/e.sc/v.sc/e.sc/r.sc‼ )
The most obvious way to use a block cipher to encrypt a long message is to just apply the
block cipher independently to each block. The only reason to know about this mode is to
know never to use it (and to publicly shame anyone who does). It can’t be said enough
times: never use ECB mode! It does not provide security of encryption; can you see
why?
Construction 8.1
(ECB Mode)
NEVER USE THIS!Enc¹k;m1kk m`º:
fori=1to`:
ci:=F¹k;miº
return c1kk c`
Dec¹k;c1kk c`º:
fori=1to`:
mi:=F 1¹k;ciº
return m1kk m`Fk Fk Fkm1 m2 m3
c1 c2 c3
8>>>>>>>> <
>>>>>>>>:
F 1
kF 1
kF 1
kc1 c2 c3
m1 m2 m3
8>>>>>>>> <
>>>>>>>>:
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
CBC: Cipher Block Chaining
CBC (which stands for cipher block chaining) is the most common mode in practice. The
CBC encryption of an `-block plaintext is `+1blocks long. The /f_irst ciphertext block is
called an initialization vector (IV). Here we have described CBC mode as a randomized
encryption, with the IV of each ciphertext being chosen uniformly. As you know, random-
ization is necessary (but not suﬃcient) for achieving CPA security, and indeed CBC mode
provides CPA security.
Construction 8.2
(CBC Mode)Enc¹k;m1kk m`º:
c0 f0;1gblen:
fori=1to`:
ci:=F¹k;mici 1º
return c0kc1kk c`
Dec¹k;c0kk c`º:
fori=1to`:
mi:=F 1¹k;ciºci 1
return m1kk m`Fk Fk$
m1 m2
c0 c1 c2
8>>>>>>>>>>>> <
>>>>>>>>>>>>:
F 1
kF 1
k
c0 c1 c2
m1 m2
8>>>>>>>>>>>> <
>>>>>>>>>>>>:
CTR: Counter
The next most common mode in practice is counter mode (usually abbreviated as CTR
mode). Just like CBC mode, it involves an additional IV block rthat is chosen uniformly.
The idea is to then use the sequence
F¹k;rº;F¹k;r+1º;F¹k;r+2º;
as a long one-time pad to mask the plaintext. Since ris a block of bits, the addition ex-
pressions like r+1refer to addition modulo 2blen(this is the typical behavior of unsigned
addition in a processor).
145Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
Construction 8.3
(CTR Mode) Enc¹k;m1kk m`º:
r f0;1gblen
c0:=r
fori=1to`:
ci:=F¹k;rºmi
r:=r+1 % 2blen
return c0kk c`Fk Fk Fk$
m1 m2 m3
c0 c1 c2 c3+1 +1 +1


OFB: Output Feedback
OFB (output feedback) mode is rarely used in practice. We’ll include it in our discussion
because it has the easiest security proof. As with CBC and CTR modes, OFB starts with a
random IV r, and then uses the sequence:
F¹k;rº;F¹k;F¹k;rºº;F¹k;F¹k;F¹k;rººº;
as a one-time pad to mask the plaintext.
Construction 8.4
(OFB Mode) Enc¹k;m1kk m`º:
r f0;1gblen
c0:=r
fori=1to`:
r:=F¹k;rº
ci:=rmi
return c0kk c`Fk Fk Fk$
m1 m2 m3
c0 c1 c2 c3

Compare & Contrast
CBC and CTR modes are essentially the only two modes that are ever considered in prac-
tice for CPA security. Both provide the same security guarantees, and so any comparison
between the two must be based on factors outside of the CPA security de/f_inition. Here are
a few properties that are often considered when choosing between these modes:
IAlthough we have not shown the decryption algorithm for CTR mode, it does not
even use the block cipher’s inverse F 1. This is similar to our PRF-based encryption
scheme from the previous chapter (in fact, CTR mode collapses to that construction
when restricted to 1-block plaintexts). Strictly speaking, this means CTR mode can
be instantiated from a PRF; it doesn’t need a PRP. However, in practice it is rare to
encounter an eﬃcient PRF that is not a PRP.
ICTR mode encryption can be parallelized. Once the IV has been chosen, the ith
block of ciphertext can be computed without /f_irst computing the previous i 1
146Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
blocks. CBC mode does not have this property, as it is inherently sequential. Both
modes have a parallelizable decryption algorithm, though.
IIf calls to the block cipher are expensive, it might be desirable to pre-compute and
store them before the plaintext is known. CTR mode allows this, since only the IV
aﬀects the input given to the block cipher. In CBC mode, the plaintext in/f_luences the
inputs to the block cipher, so these calls cannot be pre-computed before the plaintext
is known.
IIt is relatively easy to modify CTR to support plaintexts that are not an exact multiple
of the blocklength. (This is left as an exercise.) We will see a way to make CBC mode
support such plaintexts as well, but it is far from trivial.
ISo far all of the comparisons have favored CTR mode, so here is one important
property that favors CBC mode. It is common for implementers to misunderstand
the security implications of the IV in these modes. Many careless implementations
allow an IV to be reused. Technically speaking, reusing an IV (other than by acci-
dent, as the birthday bound allows) means that the scheme was not implemented
correctly. But rather than dumping the blame on the developer, it is good design
practice to anticipate likely misuses of a system and, when possible, try to make
them non-catastrophic.
The eﬀects of IV-reuse in CTR mode are quite devastating to message privacy (see
the exercises). In CBC mode, reusing an IV can actually be safe, if the two plaintexts
have diﬀerent /f_irst blocks!
8.2 CPA Security and Variable-Length Plaintexts
Here’s a big surprise: none of these block cipher modes achieve CPA security, or at least
CPA security as we have been de/f_ining it.
Example Consider a block cipher with blen=λ, used in CBC mode. As you will see, there is nothing
particularly speci/f_ic to CBC mode, and the same observations apply to the other modes.
In CBC mode, a plaintext consisting of `blocks is encrypted into a ciphertext of `+1
blocks. In other words, the ciphertext leaks the number of blocks in the plaintext. We
can leverage this observation into the following attack:
A:
c:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹0λ;02λº
returnjcj?=2λ
The distinguisher chooses a 1-block plaintext and a 2-block plaintext. If this distinguisher is
linked toLcpa-L, the 1-block plaintext is encrypted and the resulting ciphertext is 2 blocks ( 2λ
bits) long. If the distinguisher is linked to Lcpa-R, the 2-block plaintext is encrypted and the
resulting ciphertext is 3 blocks ( 3λbits) long. By simply checking the length of the ciphertext,
this distinguisher can tell the diﬀerence and achieve advantage 1.
147Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
So, technically speaking, these block cipher modes do not provide CPA security, since
ciphertexts leak the length (measured in blocks) of the plaintext. But suppose we don’t re-
ally care about hiding the length of plaintexts.1Is there a way to make a security de/f_inition
that says: ciphertexts hide everything about the plaintext, except their length ?
It is clear from the previous example that a distinguisher can successfully distinguish
the CPA libraries if it makes a query /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRºwithjmLj,jmRj. A simple
way to change the CPA security de/f_inition is to just disallow this kind of query. The
libraries will give an error message if jmLj,jmRj. This would allow the adversary to
make the challenge plaintexts diﬀer in any way of his/her choice, except in their length. It
doesn’t really matter whether jmjrefers to the length of the plaintext in bits or in blocks
— whichever makes the most sense for a particular scheme.
From now on, when discussing encryption schemes that support variable-length plain-
texts, CPA security will refer to the following updated libraries:
LΣ
cpa-L
k Σ:KeyGen
/c.sc/t.sc/x.sc/t.sc¹mL;mR2Σ:Mº:
ifjmLj,jmRjreturn err
c:=Σ:Enc¹k;mLº
return cLΣ
cpa-R
k Σ:KeyGen
/c.sc/t.sc/x.sc/t.sc¹mL;mR2Σ:Mº:
ifjmLj,jmRjreturn err
c:=Σ:Enc¹k;mRº
return c
In the de/f_inition of CPA$ security (pseudorandom ciphertexts), the Lcpa$-rand library re-
sponds to queries with uniform responses. Since these responses must look like cipher-
texts, they must have the appropriate length. For example, for the modes discussed in this
chapter, an `-block plaintext is expected to be encrypted to an ¹`+1º-block ciphertext. So,
based on the length of the plaintext that is provided, the library must choose the appropri-
ate ciphertext length. We are already using Σ:Cto denote the set of possible ciphertexts of
an encryption scheme Σ. So let’s extend the notation slightly and write Σ:C¹`ºto denote
the set of possible ciphertexts for plaintexts of length `. Then when discussing encryption
schemes supporting variable-length plaintexts, CPA$ security will refer to the following
libraries:
LΣ
cpa$-real
k Σ:KeyGen
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m2Σ:Mº:
c:=Σ:Enc¹k;mº
return cLΣ
cpa$-rand
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m2Σ:Mº:
c Σ:C¹jmjº
return c
Note that theLcpa$-rand library does not use any information about mother than its
length. This again re/f_lects the idea that ciphertexts leak nothing about plaintexts other
than their length.
1Indeed, hiding the length of communication (in the extreme, hiding the existence of communication) is
a very hard problem.
148Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
In the exercises, you are asked to prove that, with respect to these updated security
de/f_initions, CPA$ security implies CPA security as before.
Don’t Take Length-Leaking for Granted!
We have just gone from requiring encryption to leak no partial information to casually
allowing some speci/f_ic information to leak. Let us not be too hasty about this!
If we want to truly support plaintexts of arbitrary length, then leaking the length is in
fact unavoidable. But “unavoidable” doesn’t mean “free of consequences.” By observing
only the length of encrypted network traﬃc, many serious attacks are possible. Here are
several examples:
IWhen accessing Google maps, your browser receives many image tiles that comprise
the map that you see. Each image tile has the same pixel dimensions. However, they
are compressed to save resources, and not all images compress as signi/f_icantly as
others. Every region of the world has its own rather unique “/f_ingerprint” of image-
tile lengths. So even though traﬃc to and from Google maps is encrypted, the sizes of
the image tiles are leaked. This can indeed be used to determine the region for which
a user is requesting a map.2The same idea applies to auto-complete suggestions in
a search form.
IVariable-bit-rate (VBR) encoding is a common technique in audio/video encoding.
When the data stream is carrying less information ( e.g., a scene with a /f_ixed camera
position, or a quiet section of audio), it is encoded at a lower bit rate, meaning that
each unit of time is encoded in fewer bits. In an encrypted video stream, the changes
in bit rate are re/f_lected as changes in packet length. When a user is watching a movie
on Net/f_lix or a Youtube video (as opposed to a live event stream), the bit-rate changes
are consistent and predictable. It is therefore rather straight-forward to determine
which video is being watched, even on an encrypted connection, just by observing
the packet lengths.
IVBR is also used in many encrypted voice chat programs. Attacks on these tools
have been increasing in sophistication. The /f_irst attacks on encrypted voice pro-
grams showed how to identify who was speaking (from a set of candidates), just by
observing the stream of ciphertext sizes. Later attacks could determine the language
being spoken. Eventually, when combined with sophisticated linguistic models, it
was shown possible to even identify individual words to some extent!
It’s worth emphasizing again that none of these attacks involve any attempt to break the
encryption. The attacks rely solely on the fact that encryption leaks the length of the
plaintexts.
8.3 Security of OFB Mode
In this section we will prove that OFB mode has pseudorandom ciphertexts (when the
blocklength is blen=λbits). OFB encryption and decryption both use the forward direc-
2h/t_tp://blog.ioactive.com/2012/02/ssl-traﬀic-analysis-on-google-maps.html
149Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
tion of F, so OFB provides security even when Fis not invertible. Therefore we will prove
security assuming Fis simply a PRF.
Claim 8.5 OFB mode (Construction 8.4) has CPA$ security, if its underlying block cipher Fis a secure
PRF with parameters in=out=λ.
Proof The general structure of the proof is very similar to the proof used for the PRF-based
encryption scheme in the previous chapter (Construction 7.4). This is no coincidence: if
OFB mode is restricted to plaintexts of a single block, we obtain exactly Construction 7.4!
The idea is that each ciphertext block (apart from the IV) is computed as ci:=rmi.
By the one-time pad rule, it suﬃces to show that the rvalues are independently pseudo-
random. Each rvalue is the result of a call to the PRF. These PRF outputs will be inde-
pendently pseudorandom only if all of the inputs to the PRF are distinct. In OFB mode,
we use the output rof a previous PRF call as input to the next, so it is highly unlikely
that this PRF output rmatches a past PRF-input value. To argue this more precisely, the
proof includes hybrids in which ris chosen without replacement (before changing rback
to uniform sampling).
The formal sequence of hybrid libraries is given below:
LOFB
cpa$-real:LOFB
cpa$-real
k f0;1gλ
/c.sc/t.sc/x.sc/t.sc¹m1kk m`º:
r f0;1gλ
c0:=r
fori=1to`:
r:=F¹k;rº
ci:=rmi
return c0kc1kk c`The starting point is LOFB
cpa$-real, shown
here with the details of OFB /f_illed in.
/c.sc/t.sc/x.sc/t.sc¹m1kk m`º:
r f0;1gλ
c0:=r
fori=1to`:
r:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
ci:=rmi
return c0kc1kk c`LF
prf-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº:
return F¹k;rºThe statements pertaining to the PRF
Fhave been factored out in terms of
LF
prf-real.
150Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
/c.sc/t.sc/x.sc/t.sc¹m1kk m`º:
r f0;1gλ
c0:=r
fori=1to`:
r:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
ci:=rmi
return c0kc1kk c`LF
prf-rand
T:=empty
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifT»x¼unde/f_ined:
T»x¼ f 0;1gλ
return T»x¼LF
prf-realhas been replaced by
LF
prf-rand. By the PRF security of F,
the change is indistinguishable.
Next, all of the statements that involve sampling values for the variable rare factored out
in terms of theLsamp-L library from Lemma 4.11:
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m1kk m`º:
r:=/s.sc/a.sc/m.sc/p.sc¹º
c0:=r
fori=1to`:
r:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
ci:=rmi
return c0kc1kk c`T:=empty
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifT»x¼unde/f_ined:
T»x¼:=/s.sc/a.sc/m.sc/p.sc¹º
return T»x¼Lsamp-L
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλ
return r
Lsamp-L is then replaced by Lsamp-R . By Lemma 4.11, this change is indistinguishable:
/c.sc/t.sc/x.sc/t.sc¹m1kk m`º:
r:=/s.sc/a.sc/m.sc/p.sc¹º
c0:=r
fori=1to`:
r:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
ci:=rmi
return c0kc1kk c`T:=empty
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifT»x¼unde/f_ined:
T»x¼:=/s.sc/a.sc/m.sc/p.sc¹º
return T»x¼Lsamp-R
R:=;
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλnR
R:=R[frg
return r
Arguments to /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc are never repeated in this hybrid, so the middle library can be sig-
ni/f_icantly simpli/f_ied:
/c.sc/t.sc/x.sc/t.sc¹m1kk m`º:
r:=/s.sc/a.sc/m.sc/p.sc¹º
c0:=r
fori=1to`:
r:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
ci:=rmi
return c0kc1kk c`/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
t:=/s.sc/a.sc/m.sc/p.sc¹º
return tLsamp-R
R:=;
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλnR
R:=R[frg
return r
151Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
Next,Lsamp-R is replaced byLsamp-L . By Lemma 4.11, this change is indistinguishable:
/c.sc/t.sc/x.sc/t.sc¹m1kk m`º:
r:=/s.sc/a.sc/m.sc/p.sc¹º
c0:=r
fori=1to`:
r:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹rº
ci:=rmi
return c0kc1kk c`/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
t:=/s.sc/a.sc/m.sc/p.sc¹º
return tLsamp-L
/s.sc/a.sc/m.sc/p.sc¹º:
r f0;1gλ
return r
Subroutine calls to /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc and/s.sc/a.sc/m.sc/p.sc are inlined:
/c.sc/t.sc/x.sc/t.sc¹m1kk m`º:
r f0;1gλ
c0:=r
fori=1to`:
r f0;1gλ
ci:=rmi
return c0kc1kk c`
Finally, the one-time pad rule is applied within the for-loop (omitting some common steps).
Note that in the previous hybrid, each value of ris used only once as a one-time pad. The
i=0case has also been absorbed into the for-loop. The result is LOFB
cpa$-rand, since OFB
encrypts plaintexts of `blocks into `+1blocks.
LOFB
cpa$-rand
/c.sc/t.sc/x.sc/t.sc¹m1kk m`º:
fori=0to`:
ci f0;1gλ
return c0kc1kk c`
The sequence of hybrids shows that LOFB
cpa$-realLOFB
cpa$-rand, and so OFB mode has
pseudorandom ciphertexts. 
We proved the claim assuming Fis a PRF only, since OFB mode does not require Fto
be invertible. Since we assume a PRF with parameters in=out=λ, the PRP switching
lemma (Lemma 6.7) shows that OFB is secure also when Fis a PRP with blocklength n=λ.
8.4 Padding & Ciphertext Stealing
So far we have assumed that all plaintexts are exact multiples of the blocklength. But data
in the real world is not always so accommodating. How are block ciphers used in practice
with data that has arbitrary length?
152Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
Padding
Padding just refers to any approach to encode arbitrary-length data into data that is a
multiple of the blocklength. The only requirement is that this encoding is reversible. More
formally, a padding scheme should consist of two algorithms:
Ipad: takes as input a string of any length, and outputs a string whose length is a
multiple of the blocklength
Iunpad : the inverse of pad. We require that unpad¹pad¹xºº=xfor all strings x.
The idea is that the sender can encrypt pad¹xº, which is guaranteed to be a multiple of the
blocklength; the receiver can decrypt and run unpad on the result to obtain x.
In the real world, data almost always comes in bytes and not bits, so that will be our
assumption here. In this section we will write bytes in hex, for example 8f. Typical
blocklengths are 128 bits (16 bytes) or 256 bits (32 bytes).
Here are a few common approaches for padding:
Null padding: The simplest padding approach is to just /f_ill the /f_inal block with null
bytes ( 00). The problem with this approach is that it is not always reversible. For exam-
ple,pad¹314159ºandpad¹31415900ºwill give the same result. It is not possible to
distinguish between a null byte that was added for padding and one that was intentionally
the last byte of the data.
ANSI X.923 standard: Data is padded with null bytes, except for the last byte of padding
which indicates how many padding bytes there are. In essence, the last byte of the padded
message tells the receiver how many bytes to remove to recover the original message.
Note that in this padding scheme (and indeed in all of them), if the original unpadded
data is already a multiple of the block length, then an entire extra block of padding
must be added. This is necessary because it is possible for the original data to end with
some bytes that look like valid padding ( e.g.,000003), and we do not want these bytes
to be removed erroneously.
Example Below are some examples of valid and invalid X.923 padding (using 16-byte blocks):
013411d9818805571d73c30000000005)valid
9551054ad65aa344afb3850000000003)valid
71da775a5e77eba873c550b581d59601)valid
5b1c01415d53864ee49413e87a89c471)invalid
d40dd87b5324c6d1af5fd6f600c00004)invalid
PKCS#7 standard: Ifbbytes of padding are needed, then the data is padded not with
null bytes but with bbytes. Again, the last byte of the padded message tells the receiver
how many bytes to remove.
153Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
Example Below are some examples of valid and invalid PKCS#7 padding (using 16-byte blocks):
013411d9818805571d73c30505050505)valid
9551054ad65aa344afb3850303030303)valid
71da775a5e77eba873c550b581d59601)valid
5b1c01415d53864ee49413e87a89c471)invalid
d40dd87b5324c6d1af5fd6f604c00404)invalid
ISO/IEC 7816-4 standard: The data is padded with a 80byte followed by null bytes.
To remove the padding, remove all trailing null bytes and ensure that the last byte is 80
(and then remove it too).
The signi/f_icance of 80is clearer when you write it in binary as 10000000 . So another
way to describe this padding scheme is: append a 1bit, and then pad with 0bits until
reaching the blocklength. To remove the padding, remove all trailing 0bits as well as
the rightmost 1bit. Hence, this approach generalizes easily to padding data that is not a
multiple of a byte.
Example Below are some examples of valid and invalid ISO/IEC 7816-4 padding (using 16-byte blocks):
013411d9818805571d73c38000000000)valid
9551054ad65aa344afb3850303800000)valid
71da775a5e77eba873c550b581d59680)valid
5b1c01415d53864ee49413e87a89c471)invalid
d40dd87b5324c6d1af5fd6f6c4000000)invalid
The choice of padding scheme is not terribly important, and any of these is generally
/f_ine. Just remember that padding schemes are not a security feature! Padding is a
public method for encoding data, and it does not involve any secret keys. The only purpose
of padding is to enable functionality — using block cipher modes like CBC with data that
is not a multiple of the block length.
Furthermore, as we will see in the next chapter, padding is associated with certain
attacks against improper use of encryption. Even though this is not really the fault of the
padding (rather, it is the fault of using the wrong /f_lavor of encryption), it is such a common
pitfall that it is always worth considering in a discussion about padding.
Ciphertext Stealing
Another approach with a provocative name is ciphertext stealing (CTS, if you are not
yet tired of three-leter acronyms), which results in ciphertexts that are not a multiple of
the blocklength. The main idea behind ciphertext stealing is to use a standard block-cipher
mode that only supports full blocks ( e.g., CBC mode), and then simply throw away some
bits of the ciphertext , in such a way that decryption is still possible. If the last plaintext
blocks is jbits short of being a full block, it is generally possible to throw away jbits of
the ciphertext. In this way, a plaintext of nbits will be encrypted to a ciphertext of blen+n
bits, where blen is the length of the extra IV block.
154Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
As an example, let’s see ciphertext stealing as applied to CBC mode. Suppose the
blocklength is blen and the last plaintext block m`isjbits short of being a full block. We
start by extending m`with jzeroes ( i.e., null-padding the plaintext) and performing CBC
encryption as usual.
Now our goal is to identify jbits of the CBC ciphertext that can be thrown away while
still making decryption possible. In this case, the appropriate bits to throw away are the
lastjbits of c` 1(the next-to-last block of the CBC ciphertext). The reason is illustrated
in the /f_igure below:
Fk Fk Fkm` 2 m` 1 m`
c` 2 c` 1 c`
c` 2 c0
` 1c`

usual CBC encryption8>>>>>>>>>>>>>>>>>>>>>>>>> <
>>>>>>>>>>>>>>>>>>>>>>>>>:
/f_inal ciphertext:zero-padding
identical!
Suppose the receiver obtains this CBC ciphertext but the last jbits of c` 1have been
deleted. How can he/she decrypt? The important idea is that those missing jbits were
redundant, because there is another way to compute them.
In CBC encryption, the last value given as input into the block cipher is c` 1m`. Let
us give this value a name x:=c` 1m`. Since the last jbits of m`are0’s,3the last jbits
ofxare the last jbits of c` 1— the missing bits. Even though these bits are missing from
c` 1, the receiver has a diﬀerent way of computing them as x:=F 1¹k;c`º.
Putting it all together, the receiver does the following: First, it observes that the ci-
phertext is jbits short of a full block. It computes F 1¹k;c`ºand takes the last jbits of this
value to be the missing bits from c` 1. With the missing bits recovered, the receiver does
CBC decryption as usual. The result is a plaintext consisting of `full blocks, but we know
that the last jbits of that plaintext are 0padding that the receiver can remove.
It is convenient in an implementation for the boundaries between blocks to be in pre-
dictable places. For that reason, it is slightly awkward to remove jbits from the middle of
the ciphertext during encryption (or add them during decryption), as we have done here.
So in practice, the last two blocks of the ciphertext are often interchanged. In the example
above, the resulting ciphertext (after ciphertext stealing) would be:
c0kc1kc2c` 3kc` 2kc`kc0
` 1;where c0
` 1is the /f_irst blen jbits of c` 1.
3The receiver knows this fact, because the ciphertext is jbits short of a full block. The length of the
(shortened) ciphertext is a signal about how many 0-bits of padding were used during encryption.
155Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
That way, all ciphertext blocks except the last one are the full blen bits long, and the
boundaries between blocks appear consistently every blen bits. This “optimization” does
add some signi/f_icant edge cases to any implementation. One must also decide what to do
when the plaintext is already an exact multiple of the blocklength — should the /f_inal two
ciphertext blocks be swapped even in this case? Below we present an implementation of
ciphertext stealing (CTS) that does notswap the /f_inal two blocks in this case. This means
that it collapses to plain CBC mode when the plaintext is an exact multiple of the block
length.
Construction 8.6
(CBC-CTS)Enc¹k;m1kk m`º:
// each miisblen bits,
// except possibly m`
j:=blen jm`j
m`:=m`k0j
c0 f0;1gblen:
fori=1to`:
ci:=F¹k;mici 1º
ifj,0:
remove /f_inal jbits of c` 1
swap c` 1andc`
return c0kc1kk c`Dec¹k;c0kk c`º:
// each ciisblen bits,
// except possibly c`
j:=blen jc`j
ifj,0:
swap c` 1andc`
x:=lastjbits of F 1¹k;c`º
c` 1:=c` 1kx
fori=1to`:
mi:=F 1¹k;ciºci 1
remove /f_inal jbits of m`
return m1kk m`
The marked lines correspond to plain CBC mode.
Exercises
8.1. Prove that a block cipher in ECB mode does not provide CPA security. Describe a distin-
guisher and compute its advantage.
8.2. Describe OFB decryption mode.
8.3. Describe CTR decryption mode.
8.4. CBC mode:
(a) In CBC-mode encryption, if a single bit of the plaintext is changed, which ciphertext
blocks are aﬀected (assume the same IV is used)?
(b) In CBC-mode decryption, if a single bit of the ciphertext is changed, which plaintext
blocks are aﬀected?
8.5. Prove that CPA$ security for variable-length plaintexts implies CPA security for variable-
length plaintexts. Where in the proof do you use the fact that jmLj=jmRj?
8.6. Suppose that instead of applying CBC mode to a block cipher, we apply it to one-time pad.
In other words, we replace every occurrence of F¹k;?ºwith k?in the code for CBC
encryption. Show that the result does not have CPA security. Describe a distinguisher
and compute its advantage.
156Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
8.7. Prove that there is an attacker that runs in time O¹2λ2ºand that can break CPA security
of CBC mode encryption with constant probability.
8.8. Below are several block cipher modes for encryption, applied to a PRP Fwith blocklength
blen=λ. For each of the modes:
IDescribe the corresponding decryption procedure.
IShow that the mode does not have CPA-security. That means describe a distin-
guisher and compute its advantage.
(a)Enc¹k;m1kk m`º:
r0 f0;1gλ
c0:=r0
fori=1to`:
ri:=F¹k;miº
ci:=riri 1
return c0kk c`
(b)Enc¹k;m1kk m`º:
c0 f0;1gλ
fori=1to`:
ci:=F¹k;miºci 1
return c0kk c`(c)Enc¹k;m1kk m`º:
c0 f0;1gλ
m0:=c0
fori=1to`:
ci:=F¹k;miºmi 1
return c0kk c`
(d)Enc¹k;m1kk m`º:
c0 f0;1gλ
r0:=c0
fori=1to`:
ri:=ri 1mi
ci:=F¹k;riº
return c0kk c`
Mode (a) is similar to CBC, except the /x.sc/o.sc/r.sc happens after, rather than before, the block
cipher application. Mode (c) is essentially the same as CBC decryption.
8.9. Suppose you observe a CBC ciphertext and two of its blocks happen to be identical. What
can you deduce about the plaintext? State some non-trivial property of the plaintext that
doesn’t depend on the encryption key.
8.10. The CPA$-security proof for CBC encryption has a slight complication compared to the
proof of OFB encryption. Recall that an important part of the proof is arguing that all
inputs to the PRF are distinct.
In OFB, outputs of the PRF were fed directly into the PRF as inputs. The adversary had no
in/f_luence over this process, so it wasn’t so bad to argue that all PRF inputs were distinct
(with probability negligibly close to 1).
By contrast, CBC mode takes an output block from the PRF, /x.sc/o.sc/r.sc’s it with a plaintext block
(which is after all chosen by the adversary ), and uses the result as input to the next PRF
call. This means we have to be a little more careful when arguing that CBC mode gives
distinct inputs to all PRF calls (with probability negligibly close to 1).
157Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
(a) Prove that the following two libraries are indistinguishable:
Lle/f_t
/s.sc/a.sc/m.sc/p.sc¹m2f0;1gλº:
r f0;1gλ
return rLright
R:=;
/s.sc/a.sc/m.sc/p.sc¹m2f0;1gλº:
r fr02f0;1gλjr0m<Rg
R:=R[frmg
return r
Hint:
Use Lemma 4.12.
(b) Using part (a), and the security of the underlying PRF, prove the CPA$-security of CBC
mode.
Hint:InLright, letRcorrespond to the set of all inputs sent to the PRF. Let mcorrespond to the next
plaintext block. Instead of sampling r(the output of the PRF) uniformly as in Lle/f_t, we sample
rso that rmhas never been used as a PRF-input before. This guarantees that the next PRF
call will be on a “fresh” input.
Note: Appreciate how important it is that the adversary chooses plaintext block m
before “seeing” the output rfrom the PRF (which is included in the ciphertext).
?8.11. Prove that CTR mode achieves CPA$ security.
Hint:Use Lemma 4.12 to show that there is only negligible probability of chosing the IV so that the block
cipher gets called on the same value twice.
8.12. Let Fbe a secure PRF with out=in=λand let F¹2ºdenote the function F¹2º¹k;rº=
F¹k;F¹k;rºº.
(a) Prove that F¹2ºis also a secure PRF.
(b) What if Fis a secure PRP with blocklength blen? IsF¹2ºalso a secure PRP?
8.13. This question refers to the nonce-based notion of CPA security.
(a) Show a de/f_inition for CPA$ security that incorporates both the nonce-based syntax of
Section 7.1 and the variable-length plaintexts of Section 8.2.
(b) Show that CBC mode notsecure as a nonce-based scheme (where the IV is used as a
nonce).
(c) Show that CTR mode is notsecure as a nonce-based scheme (where the IV is used as a
nonce). Note that if we restrict (randomized) CTR mode to a single plaintext block, we
get the CPA-secure scheme of Construction 7.4, which isis secure as a nonce-based
scheme. The attack must therefore use the fact that plaintexts can be longer than one
block. (Does the attack in part (b) work with single-block plaintexts?)
8.14. One way to convert a randomized-IV-based construction into a nonce-based construction
is called the synthetic IV approach.
158Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
(a) The synthetic-IV (SIV) approach applied to CBC mode is shown below. Prove that it is
CPA/CPA$ secure as a nonce-based scheme (refer to the security de/f_initions from the
previous problem):
SIV-CBC :Enc
¹k1;k2º;/v.alt;m1kk m`
:
c0:=F¹k1;/v.altº
fori=1to`:
ci:=F¹k2;mici 1º
return c0kc1kk c`
Instead of chosing a random IV c0, it is generated deterministically from the nonce /v.alt
using the block cipher F. In your proof, you can use the fact that randomized CBC
mode has CPA$ security, and that Fis also a secure PRF.
(b) It is important that the SIV construction uses two keys for diﬀerent purposes. Suppose
that we instead used the same key throughout:
BadSIV-CBC :Enc¹k;/v.alt;m1kk m`º:
c0:=F¹k;/v.altº
fori=1to`:
ci:=F¹k;mici 1º
return c0kc1kk c`
Show that the resulting scheme does not have CPA$ security (in the nonce-based
sense). Ignore the complication of padding, and only consider plaintexts that are a
multiple of the blocklength. Describe a successful distinguisher and compute its ad-
vantage.
(c) For randomized encryption, it is necessary to include the IV in the ciphertext; oth-
erwise the receiver cannot decrypt. In the nonce-based setting we assume that the
receiver knows the correct nonce ( e.g., from some out-of-band communication). With
that in mind, we could modify the scheme from part (b) to remove c0, since the receiver
could reconstruct it anyway from /v.alt.
Show that even with this modi/f_ication, the scheme still fails to be CPA-secure under
the nonce-based de/f_inition.
8.15. Implementers are sometimes cautious about IVs in block cipher modes and may attempt
to “protect” them. One idea for protecting an IV is to prevent it from directly appearing in
the ciphertext. The modi/f_ied CBC encryption below sends the IV through the block cipher
before including it in the ciphertext:
Enc¹k;m1kk m`º:
c0 f0;1gblen
c0
0:=F¹k;c0º
fori=1to`:
ci:=F¹k;mici 1º
return c0
0kc1kk c`
159Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
This ciphertext can be decrypted by /f_irst computing c0:=F 1¹k;c0
0ºand then doing usual
CBC decryption on c0kk c`.
Show that this new scheme is notCPA-secure (under the traditional de/f_initions for ran-
domized encryption).
8.16. Suppose a bad implementation leads to two ciphertexts being encrypted with the same IV,
rather than a random IV each time.
(a) Characterize as thoroughly as you can what information is leaked about the plaintexts
when CBC mode was used and an IV is repeated.
(b) Characterize as thoroughly as you can what information is leaked about the plaintexts
when CTR mode was used and an IV is repeated.
8.17. Describe how to extend CTR and OFB modes to deal with plaintexts of arbitrary length
(without using padding). Why is it so much simpler than CBC ciphertext stealing?
8.18. The following technique for ciphertext stealing in CBC was proposed in the 1980s and was
even adopted into commercial products. Unfortunately, it’s insecure.
Suppose the /f_inal plaintext block m`isblen jbits long. Rather than padding the /f_inal
block with zeroes, it is padded with the last jbits of ciphertext block c` 1.Then the padded
block m`is sent through the PRP to produce the /f_inal ciphertext block c`. Since the /f_inal
jbits of c` 1are recoverable from c`, they can be discarded.
If the /f_inal block of plaintext is already blen bits long, then standard CBC mode is used.
Fk Fk Fkm` 2 m` 1 m`
c` 2 c` 1 c`
pad with these bits
discard
Show that the scheme does notsatisfy CPA$ security. Describe a distinguisher and com-
pute its advantage.
Hint:Ask for several encryptions of plaintexts whose last block is blen 1bits long.
8.19. Prove that anyCPA-secure encryption remains CPA-secure when augmented by padding
the input.
8.20. Prove that CBC with ciphertext stealing has CPA$ security. You may use the fact that CBC
mode has CPA$ security when restricted to plaintexts whose length is an exact multiple
of the blocklength ( i.e., CBC mode without padding or ciphertext stealing).
160Draft: January 3, 2021 CHAPTER 8. BLOCK CIPHER MODES OF OPERATION
Hint:LetCBC denote standard CBC mode restricted to plaintext space M=¹f0;1gblenº, and let
CBC-CTS denote CBC mode with ciphertext stealing (so M=f0;1g). Observe that it is easy
to implement a call to LCBC-CTS
cpa$-realby a related call to LCBC
cpa$-realplus a small amount of additional
processing.
8.21. Propagating CBC (PCBC) mode refers to the following variant of CBC mode:
Enc¹k;m1kk m`º:
c0 f0;1gblen:
m0:=0blen
fori=1to`:
ci:=F¹k;mici 1mi 1º
return c0kc1kk c`Fk Fk$
m1 m2
c0 c1 c2

(a) Describe PCBC decryption.
(b) Assuming that standard CBC mode has CPA$-security (for plaintexts that are exact
multiple of the block length), prove that PCBC mode also has CPA$-security (for the
same plaintext space).
Hint:Write PCBC encryption using plain CBC encryption as a subroutine.
(c) Consider the problem of adapting CBC ciphertext stealing to PCBC mode. Suppose
the /f_inal plaintext block m`hasblen jbits, and we pad it with the /f_inal jbits of the
previous plaintext block m` 1. Show that discarding the last jbits of c` 1still allows
for correct decryption and results in CPA$ security.
Hint:
See Exercise 8.20.
(d) Suppose the /f_inal plaintext block is padded using the /f_inal jbits of the previous cipher-
textblock c` 1. Although correct decryption is still possible, the construction is no
longer secure. Show an attack violating the CPA$-security of this construction. Why
doesn’t the proof approach from part (c) work?
Hint:Ask for several encryptions of plaintexts whose last block is 1 bit long.
1619Chosen Ciphertext A/t_tacks
In this chapter we discuss the limitations of the CPA security de/f_inition. In short, the CPA
security de/f_inition considers only the information leaked to the adversary by honestly-
generated ciphertexts. It does not, however, consider what happens when an adversary
is allowed to inject its own maliciously crafted ciphertexts into an honest system. If that
happens, then even a CPA-secure encryption scheme can fail in spectacular ways. We
begin by seeing such an example of spectacular and surprising failure, called a padding
oracle attack:
9.1 Padding Oracle A/t_tacks
Imagine a webserver that receives CBC-encrypted ciphertexts for processing. When re-
ceiving a ciphertext, the webserver decrypts it under the appropriate key and then checks
whether the plaintext has valid X.923 padding (Section 8.4).
Importantly, suppose that the observable behavior of the webserver changes depending
on whether the padding is valid. You can imagine that the webserver gives a special error
message in the case of invalid padding. Or, even more cleverly (but still realistic), the
diﬀerence in response time when processing a ciphertext with invalid padding is enough to
allow the attack to work.1Themechanism for learning padding validity is not important —
what is important is simply the fact that an attacker has some way to determine whether
a ciphertext encodes a plaintext with valid padding. No matter how the attacker comes
by this information, we say that the attacker has access to a padding oracle , which gives
the same information as the following subroutine:
/p.sc/a.sc/d.sc/d.sc/i.sc/n.sc/g.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc¹cº:
m:=Dec¹k;cº
return /v.sc/a.sc/l.sc/i.sc/d.sc/p.sc/a.sc/d.sc¹mº
We call this a padding oracle because it answers only one speci/f_ic kind of question about
the input. In this case, the answer that it gives is always a single boolean value.
It does not seem like a padding oracle is leaking useful information, and that there is no
cause for concern. Surprisingly, we can show that an attacker who doesn’t know the en-
cryption key kcan use a padding oracle alone to decrypt any ciphertext of its choice! This is
true no matter what else the webserver does. As long as it leaks this one bit of information
on ciphertexts that the attacker can choose, it might as well be leaking everything.
1For this reason, it is necessary to write the unpadding algorithm so that every execution path through
the subroutine takes the same number of CPU cycles.
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
Malleability of CBC Encryption
Recall the de/f_inition of CBC decryption. If the ciphertext is c=c0c`then the ith
plaintext block is computed as:
mi:=F 1¹k;ciºci 1:
From this we can deduce two important facts:
ITwo consecutive blocks ¹ci 1;ciºtaken in isolation are a valid encryption of mi.
Looking ahead, this fact allows the attacker to focus on decrypting a single block at
a time.
I/x.sc/o.sc/r.scing a ciphertext block with a known value (say, x) has the eﬀect of /x.sc/o.sc/r.scing the
corresponding plaintext block by the same value. In other words, for all x, the ci-
phertext¹ci 1x;ciºdecrypts to mix:
Dec¹k;¹ci 1x;ciºº=F 1¹k;ciº¹ci 1xº=¹F 1¹k;ciºci 1ºx=mix:
If we send such a ciphertext ¹ci 1x;ciºto the padding oracle, we would therefore learn
whether mixis a (single block) with valid padding. Instead of thinking in terms of
padding, it might be best to think of the oracle as telling you whether mixends in one
of the suﬃxes 01,0002,000003, etc.
By carefully choosing diﬀerent values xand asking questions of this form to the
padding oracle, we will show how it is possible to learn all of mi.We summarize the
capability so far with the following subroutine:
// suppose cencrypts an (unknown) plaintext m1kk m`
// does mixend in one of the valid pading strings?
/c.sc/h.sc/e.sc/c.sc/k.sc/x.sc/o.sc/r.sc¹c;i;xº:
return /p.sc/a.sc/d.sc/d.sc/i.sc/n.sc/g.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc¹ci 1x;ciº
Given a ciphertext cthat encrypts an unknown message m, we can see that an adver-
sary can generate another ciphertext whose contents are related to min a predictable way.
This property of an encryption scheme is called malleability.
Learning the Last Byte of a Block
We now show how to use the /c.sc/h.sc/e.sc/c.sc/k.sc/x.sc/o.sc/r.sc subroutine to determine the last byte of a plaintext
block m. There are two cases to consider, depending on the contents of m. The attacker
does not initially know which case holds:
For the /f_irst (and easier) of the two cases, suppose the second-to-last byte of mis
nonzero. We will try every possible byte band ask whether mbhas valid padding. Since
mis a block and bis a single byte, when we write mbwe mean that bis extended on
the left with zeroes. Since the second-to-last byte of m(and hence mb) is nonzero, only
one of these possibilities will have valid padding — the one in which mbends in byte
01. Therefore, if bis the candidate byte that succeeds ( i.e.,mbhas valid padding) then
the last byte of mmust be b01.
163Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
Example Using /l.sc/e.sc/a.sc/r.sc/n.sc/l.sc/a.sc/s.sc/t.sc/b.sc/y.sc/t.sc/e.sc to learn the last byte of a plaintext block:
a042?? m=unknown plaintext block
0000b b=byte that causes oracle to return true 
=a04201 valid padding,b??=01
,??=01b
For the other case, suppose the second-to-last byte of mis zero. Then mbwill have
valid padding for several candidate values of b:
Example Using /l.sc/e.sc/a.sc/r.sc/n.sc/l.sc/a.sc/s.sc/t.sc/b.sc/y.sc/t.sc/e.sc to learn the last byte of a plaintext block:
a000??a000?? m=unknown plaintext
0000b10000b2bi=candidate bytes 
=
=a00001a00002 two candidates cause oracle to return true
a000??a000??
0001b10001b2same b1;b2, but change next-to-last byte 
=
=a00101a00102 only one causes oracle to return true
)??=b101
Whenever more than one candidate bvalue yields valid padding, we know that the
second-to-last byte of mis zero (in fact, by counting the number of successful candidates,
we can know exactly how many zeroes precede the last byte of m).
If the second-to-last byte of mis zero, then the second-to-last byte of m01bis
nonzero. The only way for both strings m01bandmbto have valid padding is
when mbends in byte 01. We can re-try all of the successful candidate bvalues again,
this time with an extra nonzero byte in front. There will be a unique candidate bthat is
successful in both rounds, and this will tell us that the last byte of misb01.
The overall approach for learning the last byte of a plaintext block is summarized in
the/l.sc/e.sc/a.sc/r.sc/n.sc/l.sc/a.sc/s.sc/t.sc/b.sc/y.sc/t.sc/e.sc subroutine in Figure 9.1. The set Bcontains the successful candidate
bytes from the /f_irst round. There are at most 16 elements in Bafter the /f_irst round, since
there are only 16 valid possibilities for the last byte of a properly padded block. In the worst
case, /l.sc/e.sc/a.sc/r.sc/n.sc/l.sc/a.sc/s.sc/t.sc/b.sc/y.sc/t.sc/e.sc makes 256+16=272calls to the padding oracle (via /c.sc/h.sc/e.sc/c.sc/k.sc/x.sc/o.sc/r.sc ).
Learning Other Bytes of a Block
Once we have learned one of the trailing bytes of a plaintext block, it is slightly easier
to learn additional ones. Suppose we know the last 3 bytes of a plaintext block, as in the
example below. We would like to use the padding oracle to discover the 4th-to-last byte.
164Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
Example Using /l.sc/e.sc/a.sc/r.sc/n.sc/p.sc/r.sc/e.sc/v.sc/b.sc/y.sc/t.sc/e.sc to learn the 4th-to-last byte when the last 3 bytes of the block are
already known.
??a0423c m=partially unknown plaintext block
00000004 p=string ending in 04
00a0423c s=known bytes of m
 b000000/y.alt=candidate byte bshifted into place 
=00000004 valid padding,??=b
Since we know the last 3 bytes of m, we can calculate a string xsuch that mxends in
000004. Now we can try /x.sc/o.sc/r.sc’ing the 4th-to-last byte of mxwith diﬀerent candidate
bytes b, and asking the padding oracle whether the result has valid padding. Valid padding
only occurs when the result has 00in its 4th-to-last byte, and this happens exactly when
the 4th-to-last byte of mexactly matches our candidate byte b.
The process is summarized in the /l.sc/e.sc/a.sc/r.sc/n.sc/p.sc/r.sc/e.sc/v.sc/b.sc/y.sc/t.sc/e.sc subroutine in Figure 9.1. In the
worst case, this subroutine makes 256 queries to the padding oracle.
Putting it all together. We now have all the tools required to decrypt any ciphertext
using only the padding oracle. The process is summarized below in the /l.sc/e.sc/a.sc/r.sc/n.sc/a.sc/l.sc/l.sc subrou-
tine.
In the worst case, 256 queries to the padding oracle are required to learn each byte of
the plaintext.2However, in practice the number can be much lower. The example in this
section was inspired by a real-life padding oracle attack3which includes optimizations that
allow an attacker to recover each plaintext byte with only 14 oracle queries on average.
9.2 What Went Wrong?
CBC encryption provides CPA security, so why didn’t it save us from padding oracle at-
tacks? How was an attacker able to completely obliterate the privacy of encryption?
1. First, CBC encryption (in fact, every encryption scheme we’ve seen so far) has a
property called malleability. Given an encryption cof an unknown plaintext m,
it is possible to generate another ciphertext c0whose contents are related to min
a predictable way. In the case of CBC encryption, if ciphertext c0kk c`encrypts
a plaintext m1kk m`, then ciphertext¹ci 1x;ciºencrypts the related plaintext
mix.
In short, if an encryption scheme is malleable, then it allows information contained
in one ciphertext to be “transferred” to another ciphertext.
2It might take more than 256 queries to learn the last byte. But whenever /l.sc/e.sc/a.sc/r.sc/n.sc/l.sc/a.sc/s.sc/t.sc/b.sc/y.sc/t.sc/e.sc uses more than
256 queries, the side eﬀect is that you’ve also learned that some other bytes of the block are zero. This saves
you from querying the padding oracle altogether to learn those bytes.
3How to Break XML Encryption , Tibor Jager and Juraj Somorovsky. ACM CCS 2011.
165Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
/c.sc/h.sc/e.sc/c.sc/k.sc/x.sc/o.sc/r.sc¹c;i;xº:
// ifcencrypts (unknown)
// plaintext m1m`; then
// does mix(by itself)
// have valid padding?
return /p.sc/a.sc/d.sc/d.sc/i.sc/n.sc/g.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc¹ci 1x;ciº
/l.sc/e.sc/a.sc/r.sc/n.sc/l.sc/a.sc/s.sc/t.sc/b.sc/y.sc/t.sc/e.sc¹c;iº:
// deduce the last byte of
// plaintext block mi
B:=;
forb=00toff:
if/c.sc/h.sc/e.sc/c.sc/k.sc/x.sc/o.sc/r.sc¹c;i;bº:
B:=B[fbg
ifjBj=1:
b:=only element of B
return b01
else:
for each b2B:
if/c.sc/h.sc/e.sc/c.sc/k.sc/x.sc/o.sc/r.sc¹c;i;01bº:
return b01/l.sc/e.sc/a.sc/r.sc/n.sc/p.sc/r.sc/e.sc/v.sc/b.sc/y.sc/t.sc/e.sc¹c;i;sº:
// knowing that miends in s,
// /f_ind rightmost unknown
// byte of mi
p:=jsj+1
forb=00toff:
/y.alt:=b0000|      {z      }
jsj
if/c.sc/h.sc/e.sc/c.sc/k.sc/x.sc/o.sc/r.sc¹c;i;ps/y.altº:
return b
/l.sc/e.sc/a.sc/r.sc/n.sc/b.sc/l.sc/o.sc/c.sc/k.sc¹c;iº:
// learn entire plaintext block mi
s:=/l.sc/e.sc/a.sc/r.sc/n.sc/l.sc/a.sc/s.sc/t.sc/b.sc/y.sc/t.sc/e.sc¹c;iº
do 15 times:
b:=/l.sc/e.sc/a.sc/r.sc/n.sc/p.sc/r.sc/e.sc/v.sc/b.sc/y.sc/t.sc/e.sc¹c;i;sº
s:=bks
return s
/l.sc/e.sc/a.sc/r.sc/n.sc/a.sc/l.sc/l.sc¹cº:
// learn entire plaintext m1m`
m:=/uni03F5
`:=number of non-IV blocks in c
fori=1to`:
m:=mk/l.sc/e.sc/a.sc/r.sc/n.sc/b.sc/l.sc/o.sc/c.sc/k.sc¹c;iº
return m
Figure 9.1: Summary of padding oracle a/t_tack.
2. Second, you may have noticed that the CPA security de/f_inition makes no mention
of the Decalgorithm. The Decalgorithm shows up in our de/f_inition for correctness ,
but it is nowhere to be found in the Lcpa-?libraries. Decryption has no impact on
CPA security!
But the padding oracle setting involved the Dec algorithm — in particular, the ad-
versary was allowed to see some information about the result of Dec applied to
adversarially-chosen ciphertexts. Because of that, the CPA security de/f_inition does
not capture the padding oracle attack scenario.
The bottom line is: give an attacker a malleable encryption scheme and access to any
partial information related to decryption, and he/she can get information to leak out in
surprising ways. As the padding-oracle attack demonstrates, even if only a single bit of
information (i.e., the answer to a yes/no question about a plaintext) is leaked about the
result of decryption, this is frequently enough to extract the entire plaintext.
166Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
If we want security even under the padding-oracle scenario, we need a better security
de/f_inition and encryption schemes that achieve it. That’s what the rest of this chapter is
about.
Discussion
IIs this a realistic concern? You may wonder whether this whole situation is some-
what contrived just to give cryptographers harder problems to solve. That was prob-
ably a common attitude towards the security de/f_initions introduced in this chapter.
However, in 1998, Daniel Bleichenbacher demonstrated a devastating attack against
early versions of the SSL protocol. By presenting millions of carefully crafted ci-
phertexts to a webserver, an attacker could eventually recover arbitrary SSL session
keys.
In practice, it is hard to make the external behavior of a server notdepend on the
result of decryption. This makes CPA security rather fragile in the real world. In
the case of padding oracle attacks, mistakes in implementation can lead to diﬀer-
ent error messages for invalid padding. In other cases, even an otherwise careful
implementation can provide a padding oracle through a timing side-channel (if the
server’s response time is diﬀerent for valid/invalid padded plaintexts).
As we will see, it isin fact possible to provide security in these kinds of settings, and
with low additional overhead. These days there is rarely a good excuse for using
encryption which is only CPA-secure.
IPadding is in the name of the attack. But padding is not the culprit. The culprit is
using a (merely) CPA-secure encryption scheme while allowing some information
to leak about the result of decryption. The exercises expand on this idea further.
IIf padding is added to only the last block of the plaintext, how can this at-
tack recover the entire plaintext? This common confusion is another reason to
not place so much blame on the padding scheme. A padding oracle has the following
behavior: “give me an encryption of m1kk m`and I’ll tell you some information
about m`(whether it ends with a certain suﬃx).” Indeed, the padding oracle checks
only the last block. However, CBC mode has the property that if you have an en-
cryption of m1kk m`, then you can easily construct a diﬀerent ciphertext that
encrypts m1kk m` 1. If you send thisciphertext to the padding oracle, you will
get information about m` 1. By modifying the ciphertext (via the malleability of
CBC), you give diﬀerent plaintext blocks the chance to be the “last block” that the
padding oracle looks at.
IThe attack seems super/f_icially like brute force, but it is not: The attack makes 256
queries per byte of plaintext, so it costs about 256`queries for a plaintext of `bytes.
Brute-forcing the entire plaintext would cost 256`since that’s how many `-byte
plaintexts there are. So the attack is exponentially better than brute force. The
lesson is: brute-forcing small pieces at a time is much better then brute-forcing the
entire thing.
167Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
9.3 Defining CCA Security
Our goal now is to develop a new security de/f_inition — one that considers an adversary that
can construct malicious ciphertexts and observe the eﬀects caused by their decryption. We
will start with the basic approach of CPA security, with left and right libraries that diﬀer
only in which of two plaintexts they encrypt.
In a typical system, an adversary might be able to learn only some speci/f_ic partial
information about the Dec process. In the padding oracle attack, the adversary was able
to learn only whether the result of decryption had valid padding.
However, we are trying to come up with a security de/f_inition that is useful no mat-
ter how the encryption scheme is deployed. How can we possibly anticipate every kind of
partial information that might make its way to the adversary in every possible usage of the
encryption scheme? The safest choice is to be as pessimistic as possible, as long as we end
up with a security notion that we can actually achieve in the end. So let’s just allow the
adversary to totally decrypt arbitrary ciphertexts of its choice. In other words, if we
can guarantee security when the adversary has fullinformation about decrypted cipher-
texts, then we certainly have security when the adversary learns only partial information
about decrypted ciphertexts (as in a typical real-world system).
But this presents a signi/f_icant problem. An adversary can do c:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº
to obtain a challenge ciphertext, and then immediately ask for that ciphertext cto be
decrypted. This will obviously reveal to the adversary whether it is linked to the left or
right library.
So, simply providing unrestricted Decaccess to the adversary cannot lead to a reason-
able security de/f_inition (it is a security de/f_inition that can never be satis/f_ied). The simplest
way to patch this obvious problem with the de/f_inition is to allow the adversary to ask for
the decryption of any ciphertext, except those produced in response to /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc
queries. In doing so, we arrive at the /f_inal security de/f_inition: security against chosen-
ciphertext attacks, or CCA-security:
Definition 9.1
(CCA security)LetΣbe an encryption scheme. We say that Σhassecurity against chosen-ciphertext
a/t_tacks (CCA security) ifLΣ
cca-LLΣ
cca-R, where:
LΣ
cca-L
k Σ:KeyGen
S:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
ifjmLj,jmRjreturn err
c:=Σ:Enc¹k;mLº
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
return Σ:Dec¹k;cºLΣ
cca-R
k Σ:KeyGen
S:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
ifjmLj,jmRjreturn err
c:=Σ:Enc¹k;mRº
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
return Σ:Dec¹k;cº
168Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
In this de/f_inition, the set Skeeps track of the ciphertexts that have been generated by
the/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc subroutine. The /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc subroutine refuses to decrypt these ciphertexts,
but will gladly decrypt any other ciphertext of the adversary’s choice.
An Example
The padding oracle attack already demonstrates that CBC mode does not provide secu-
rity in the presence of chosen ciphertext attacks. But that attack was quite complicated
since the adversary was restricted to learn just 1 bit of information at a time about a de-
crypted ciphertext. An attack against full CCA security can be much more direct, since
the adversary has full access to decrypted ciphertexts.
Example Consider the adversary below attacking the CCA security of CBC mode (with block length
blen)
A
c=c0kc1kc2:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹02blen;12blenº
m:=/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c0kc1º
return m?=0blen
It can easily be veri/f_ied that this adversary achieves advantage 1 distinguishing Lcca-L from
Lcca-R. The attack uses the fact (also used in the padding oracle attack) that if c0kc1kc2
encrypts m1km2, then c0kc1encrypts m1. To us, it is obvious that ciphertext c0kc1isrelated
toc0kc1kc2. Unfortunately for CBC mode, the security de/f_inition is not very clever — since
c0kc1is simply diﬀerent than c0kc1kc2, the/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc subroutine happily decrypts it.
Example Perhaps unsurprisingly, there are many very simple ways to catastrophically attack the CCA
security of CBC-mode encryption. Here are some more (where xdenotes the result of /f_lipping
every bit in x):
A0
c0kc1kc2:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹02blen;12blenº
m:=/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c0kc1kc2º
ifmbegins with 0blenreturn 1 else return 0
A00
c0kc1kc2:=/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹02blen;12blenº
m:=/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c0kc1kc2º
return m?=1blenk0blen
The /f_irst attack uses the fact that modifying c2has no eﬀect on the /f_irst plaintext block. The
second attack uses the fact that /f_lipping every bit in the IV /f_lips every bit in m1.
Again, in all of these cases, the /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc subroutine is being called on a diﬀerent (but
related) ciphertext than the one returned by /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc .
169Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
Discussion
So if I use a CCA-secure encryption scheme, I should never decrypt a ciphertext
that I encrypted myself?
Remember: when we de/f_ine the EncandDec algorithms of an encryption scheme,
we are describing things from the normal user’s perspective. As a user of an encryption
scheme, you can encrypt and decrypt whatever you like. It would indeed be strange if you
encrypted something knowing that it should never be decrypted. What’s the point?
The security de/f_inition describes things from the attacker’s perspective. TheLcca-?
libraries tell us what are the circumstances under which the encryption scheme provides se-
curity? They say (roughly):
an attacker can’t tell what’s inside a ciphertext c, even if she has some partial
information about that plaintext, even if she had some partial in/f_luence over
the choice of that plaintext, and even if she is allowed to decrypt any other
ciphertext she wants.
Of course, if a real-world system allows an attacker to learn the result of decrypting c,
then by de/f_inition the attacker learns what’s inside that ciphertext.
CCA security is deeply connected with the concept of malleability. Malleability
means that, given a ciphertext that encrypts an unknown plaintext m, it is possible to gen-
erate a diﬀerent ciphertext that encrypts a plaintext that is related tomin a predictable
way. For example:
IIfc0kc1kc2is a CBC encryption of m1km2, then c0kc1is a CBC encryption of m1.
IIfc0kc1kc2is a CBC encryption of m1km2, then c0kc1kc2k0blenis a CBC encryption
ofsome plaintext that begins with m1km2.
IIfc0kc1is a CBC encryption of m1, then¹c0xºkc1is a CBC encryption of m1x.
Note from the second example that we don’t need to know exactly the relationship between
the old and new ciphertexts.
If an encryption scheme is malleable, then a typical attack against its CCA security
would work as follows:
1. Request an encryption cof some plaintext.
2. Applying the malleability of the scheme, modify cto some other ciphertext c0.
3. Ask for c0to be decrypted.
Since c0,c, the security library allows c0to be decrypted. The malleability of the scheme
says that the contents of c0should be related to the contents of c. In other words, seeing
the contents of c0should allow the attacker to determine what was initially encrypted in
c.
170Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
Pseudorandom Ciphertexts
We can also modify the pseudorandom-ciphertexts security de/f_inition (CPA$ security) in
a similar way:
Definition 9.2
(CCA$ security)LetΣbe an encryption scheme. We say that Σhaspseudorandom ciphertexts in the
presence of chosen-ciphertext a/t_tacks (CCA$ security) ifLΣ
cca$-realLΣ
cca$-rand, where:
LΣ
cca$-real
k Σ:KeyGen
S:=;
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
c:=Σ:Enc¹k;mº
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
return Σ:Dec¹k;cºLΣ
cca$-rand
k Σ:KeyGen
S:=;
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
c Σ:C¹jmjº
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
return Σ:Dec¹k;cº
Just like for CPA security, if a scheme has CCA$ security, then it also has CCA security,
but not vice-versa. See the exercises.
9.4? A Simple CCA-Secure Scheme
Recall the de/f_inition of a strong pseudorandom permutation (PRP) (De/f_inition 6.13). A
strong PRP is one that is indistinguishable from a randomly chosen permutation, even to
an adversary that can make both forward (i.e., toF) and reverse (i.e., toF 1) queries.
This concept has some similarity to the de/f_inition of CCA security, in which the ad-
versary can make queries to both Encand its inverse Dec. Indeed, a strong PRP can be
used to construct a CCA-secure encryption scheme in a natural way:
Construction 9.3 LetFbe a pseudorandom permutation with block length blen=n+λ. De/f_ine the following
encryption scheme with message space M=f0;1gn:
KeyGen :
k f0;1gλ
return kEnc¹k;mº:
r f0;1gλ
return F¹k;mkrºDec¹k;cº:
/v.alt:=F 1¹k;cº
return /f_irst nbits of/v.alt
In this scheme, mis encrypted by appending a random value rto it, then applying a
PRP. While this scheme is conceptually quite simple, it is generally not used in practice
since it requires a block cipher with a fairly large block size, and these are rarely encoun-
tered.
We can informally reason about the security of this scheme as follows:
171Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
IImagine an adversary linked to one of the CCA libraries. As long as the random
value rdoes not repeat, all inputs to the PRP are distinct. The guarantee of a pseu-
dorandom function/permutation is that its outputs (which are the ciphertexts in this
scheme) will therefore all look independently uniform.
IThe CCA library prevents the adversary from asking for cto be decrypted, if cwas
itself generated by the library. For any other value c0that the adversary asks to be
decrypted, the guarantee of a strong PRP is that the result will look independently
random. In particular, the result will not depend on the choice of plaintexts used to
generate challenge ciphertexts. Since this choice of plaintexts is the only diﬀerence
between the two CCA libraries, these decryption queries (intuitively) do not help
the adversary.
We now prove the CCA security of Construction 9.3 formally:
Claim 9.4 IfFis a strong PRP (De/f_inition 6.13) then Construction 9.3 has CCA$ security (and therefore
CCA security).
Proof As usual, we prove the claim in a sequence of hybrids.
LΣ
cca$-real:LΣ
cca$-real
k f0;1gλ
S:=;
/c.sc/t.sc/x.sc/t.sc¹mº:
r f0;1gλ
c:=F¹k;mkrº
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
return /f_irst nbits of F 1¹k;cºThe starting point is LΣ
cca$-real, as expected, where
Σrefers to Construction 9.3.
172Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
S:=;
T;Tinv:=empty assoc. arrays
/c.sc/t.sc/x.sc/t.sc¹mº:
r f0;1gλ
ifT»mkr¼unde/f_ined:
c f0;1gblennT:values
T»mkr¼:=c;Tinv»c¼:=mkr
c:=T»mkr¼
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
ifTinv»c¼unde/f_ined:
mkr f0;1gblennTinv:values
Tinv»c¼:=mkr;T»mkr¼:=c
return /f_irst nbits of Tinv»c¼We have applied the strong PRP security (De/f_ini-
tion 6.13) of F, skipping some standard intermedi-
ate steps. We factored out all invocations of Fand
F 1in terms of theLsprp-real library, replaced that
library withLsprp-rand , and /f_inally inlined it.
This proof has some subtleties, so it’s a good time to stop and think about what needs to
be done. To prove CCA$-security, we must reach a hybrid in which the responses of /c.sc/t.sc/x.sc/t.sc
are uniform. In the current hybrid there are two properties in the way of this goal:
IThe ciphertext values care sampled fromf0;1gblennT:values , rather thanf0;1gblen.
IWhen the if-condition in /c.sc/t.sc/x.sc/t.sc isfalse , the return value of /c.sc/t.sc/x.sc/t.sc is not a fresh ran-
dom value but an old, repeated one. This happens when T»mkr¼is already de/f_ined.
Note that both /c.sc/t.sc/x.sc/t.sc and/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc assign to T, so either one of these subroutines
may be the cause of a pre-existing T»mkr¼value.
Perhaps the most subtle fact about our current hybrid is that arguments of /c.sc/t.sc/x.sc/t.sc can
aﬀect responses from /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc ! In/c.sc/t.sc/x.sc/t.sc , the library assigns mkrto a value Tinv»c¼. Later
calls to /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc will not read this value directly ; these values of care oﬀ-limits due to
the guard condition in the /f_irst line of /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc . However, /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc samples a value from
f0;1gblennTinv:values , which indeed uses the values Tinv»c¼. To show CCA$ security, we
must remove this dependence of /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc on previous values given to /c.sc/t.sc/x.sc/t.sc .
173Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
S:=;;R:=;
T;Tinv:=empty assoc. arrays
/c.sc/t.sc/x.sc/t.sc¹mº:
r f0;1gλ
ifT»mkr¼unde/f_ined:
c f0;1gblennT:values
T»mkr¼:=c;Tinv»c¼:=mkr
R:=R[f rg
c:=T»mkr¼
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
ifTinv»c¼unde/f_ined:
mkr f0;1gblennTinv:values
Tinv»c¼:=mkr;T»mkr¼:=c
R:=R[f rg
return /f_irst nbits of Tinv»c¼We have added some book-keeping that is not used
anywhere. Every time an assignment of the form
T»mkr¼happens, we add rto the setR. Looking
ahead, we eventually want to ensure that ris cho-
sen so that the if-statement in /c.sc/t.sc/x.sc/t.sc is always taken,
and the return value of /c.sc/t.sc/x.sc/t.sc is always a fresh ran-
dom value.
S:=;;R:=;
T;Tinv:=empty assoc. arrays
/c.sc/t.sc/x.sc/t.sc¹mº:
r f0;1gλnR
ifT»mkr¼unde/f_ined:
c f0;1gblen
T»mkr¼:=c;Tinv»c¼:=mkr
R:=R[f rg
c:=T»mkr¼
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
ifTinv»c¼unde/f_ined:
mkr f0;1gblen
Tinv»c¼:=mkr;T»mkr¼:=c
R:=R[f rg
return /f_irst nbits of Tinv»c¼We have applied Lemma 4.12 three separate times.
The standard intermediate steps (factor out, swap
library, inline) have been skipped, and this shows
only the /f_inal result.
In/c.sc/t.sc/x.sc/t.sc , we’ve added a restriction to how ris sam-
pled. Looking ahead, sampling rin this way means
that the if-statement in /c.sc/t.sc/x.sc/t.sc is always taken.
In/c.sc/t.sc/x.sc/t.sc , we’ve removed the restriction in how cis
sampled. Since cis the /f_inal return value of /c.sc/t.sc/x.sc/t.sc ,
this gets us closer to our goal of this return value
being uniformly random.
In/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc , we have removed the restriction in
how mkris sampled. As described above, this is
because Tinv:values contains previous arguments of
/c.sc/t.sc/x.sc/t.sc , and we don’t want these arguments to aﬀect
the result of /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc in any way.
174Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
S:=;;R:=;
T;Tinv:=empty assoc. arrays
/c.sc/t.sc/x.sc/t.sc¹mº:
r f0;1gλnR
c f0;1gblen
T»mkr¼:=c;Tinv»c¼:=mkr
R:=R[f rg
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
ifTinv»c¼unde/f_ined:
mkr f0;1gblen
Tinv»c¼:=mkr;T»mkr¼:=c
R:=R[f rg
return /f_irst nbits of Tinv»c¼In the previous hybrid, the if-statement in /c.sc/t.sc/x.sc/t.sc is
always taken. This is because if T»mkr¼is already
de/f_ined, then rwould already be in R, but we are
sampling rto avoid everything in R. We can there-
fore simply execute the body of the if-statement
without actually checking the condition.
S:=;;R:=;
T;Tinv:=empty assoc. arrays
/c.sc/t.sc/x.sc/t.sc¹mº:
r f0;1gλnR
c f0;1gblen
//T»mkr¼:=c;Tinv»c¼:=mkr
R:=R[f rg
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
ifTinv»c¼unde/f_ined:
mkr f0;1gblen
Tinv»c¼:=mkr;T»mkr¼:=c
R:=R[f rg
return /f_irst nbits of Tinv»c¼In the previous hybrid, no line of code ever reads
from T; they only write toT. It has no eﬀect to re-
move a line that assigns to T, so we do so in /c.sc/t.sc/x.sc/t.sc .
/c.sc/t.sc/x.sc/t.sc also writes to Tinv»c¼, but for a value c2S.
The only line that reads from Tinvis in /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc ,
but the /f_irst line of /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc prevents it from be-
ing reached for such a c2S. It therefore has no
eﬀect to remove this assignment to Tinv.
175Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
S:=;;//R:=;
T;Tinv:=empty assoc. arrays
/c.sc/t.sc/x.sc/t.sc¹mº:
//r f0;1gλnR
c f0;1gblen
//R:=R[f rg
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
ifTinv»c¼unde/f_ined:
mkr f0;1gblen
Tinv»c¼:=mkr;T»mkr¼:=c
//R:=R[f rg
return /f_irst nbits of Tinv»c¼Consider all the ways that Ris used in the previous
hybrid. The /f_irst line of /c.sc/t.sc/x.sc/t.sc usesRto sample r, but
then ris subsequently used only to further update
Rand nowhere else. Both subroutines use Ronly
to update the value of R. It has no eﬀect to simply
remove all lines that refer to variable R.
S:=;
T;Tinv:=empty assoc. arrays
/c.sc/t.sc/x.sc/t.sc¹mº:
c f0;1gblen
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
ifTinv»c¼unde/f_ined:
mkr f0;1gblennTinv:values
Tinv»c¼:=mkr;T»mkr¼:=c
return /f_irst nbits of Tinv»c¼We have applied Lemma 4.12 to the sampling step
in/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc . The standard intermediate steps have
been skipped. Now the second if-statement in
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc exactly matchesLsprp-rand .
LΣ
cca$-rand:LΣ
cca$-rand
k f0;1gλ
S:=;
/c.sc/t.sc/x.sc/t.sc¹mº:
c f0;1gblen
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
return /f_irst nbits of F 1¹k;cºWe have applied the strong PRP security of Fto
replaceLsprp-rand withLsprp-real . The standard in-
termediate steps have been skipped. The result is
Lcca$-rand .
176Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
We showed thatLΣ
cca$-realLΣ
cca$-rand, so the scheme has CCA$ security. 
Exercises
9.1. There is nothing particularly bad about padding schemes. They are only a target because
padding is a commonly used structure in plaintexts that is veri/f_ied at the time of decryp-
tion.
Anull character is simply the byte 00. We say that a string is properly null terminated
if its last character is null, but no other characters are null. Suppose you have access to
the following oracle:
/n.sc/u.sc/l.sc/l.sc/t.sc/e.sc/r.sc/m.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc¹cº:
m:=Dec¹k;cº
ifmis properly null terminated:
return true
else return false
Suppose you are given a CTR-mode encryption of an unknown (but properly null termi-
nated) plaintext munder unknown key k. Suppose that plaintexts of arbitrary length are
supported by truncating the CTR-stream to the appropriate length before /x.sc/o.sc/r.scing with the
plaintext.
Show how to completely recover min the presence of this null-termination oracle.
9.2. Show how to completely recover the plaintext of an arbitrary CBC-mode ciphertext in the
presence of the following oracle:
/n.sc/u.sc/l.sc/l.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc¹cº:
m:=Dec¹k;cº
ifmcontains a null character:
return true
else return false
Assume that the victim ciphertext encodes a plaintext that does not use any padding (its
plaintext is an exact multiple of the blocklength).
9.3. Show how to perform a padding oracle attack, to decrypt arbitrary messages that use
PKCS#7 padding (where all padded strings end with 01,0202,030303, etc.).
9.4. Sometimes encryption is as good as decryption, to an adversary.
(a) Suppose you have access to the following encryption oracle, where sis a secret that
is consistent across all calls:
/e.sc/c.sc/b.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc¹mº:
//k,sare secret
return ECB:Enc¹k;mksº
177Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
Yes, this question is referring to the awful ECB encryption mode (Construction 8.1).
Describe an attack that eﬃciently recovers all of susing access to /e.sc/c.sc/b.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc . Assume
that if the length of mksis not a multiple of the blocklength, then ECB mode will pad
it with null bytes.
Hint:By varying the length of m, you can control where the block-division boundaries are in s.
(b) Now suppose you have access to a CBC encryption oracle, where you can control the
IV that is used:
/c.sc/b.sc/c.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc¹i/v.alt;mº:
//k,sare secret
return CBC:Enc¹k;i/v.alt;mksº
Describe an attack that eﬃciently recovers all of susing access to /c.sc/b.sc/c.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc . As
above, assume that mksis padded to a multiple of the blocklength in some way. It is
possible to carry out the attack no matter what the padding method is, as long as the
padding method is known to the adversary.
?9.5. Show how a padding oracle (for CBC-mode encryption with X.923 padding) can be used
togenerate a valid encryption of any chosen plaintext, under the same (secret) key
that the padding oracle uses. In this problem, you are not given access to an encryption
subroutine, or any valid ciphertexts — only the padding oracle subroutine.
9.6. Prove formally that CCA$ security implies CCA security.
9.7. Let Σbe an encryption scheme with message space f0;1gnand de/f_ine Σ2to be the follow-
ing encryption scheme with message space f0;1g2n:
KeyGen :
k Σ:KeyGen
return kEnc¹k;mº:
c1:=Σ:Enc¹k;mle/f_tº
c2:=Σ:Enc¹k;mrightº
return¹c1;c2ºDec¹k;¹c1;c2ºº:
m1:=Σ:Dec¹k;c1º
m2:=Σ:Dec¹k;c2º
iferr2fm1;m2g:
return err
else return m1km2
(a) Prove that if Σhas CPA security, then so does Σ2.
(b) Show that even if Σhas CCA security, Σ2does not. Describe a successful distinguisher
and compute its distinguishing advantage.
9.8. Show that the following block cipher modes do not have CCA security. For each one,
describe a successful distinguisher and compute its distinguishing advantage.
(a) OFB mode (b) CBC mode (c) CTR mode
9.9. Show that none of the schemes in Exercise 7.7 have CCA security. For each one, describe
a successful distinguisher and compute its distinguishing advantage.
178Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
9.10. Let Fbe a secure block cipher with blocklength λ. Below is an encryption scheme for
plaintextsM=f0;1gλ. Formally describe its decryption algorithm and show that it does
nothave CCA security.
KeyGen :
k f0;1gλ
return kEnc¹k;mº:
r f0;1gλ
c1:=F¹k;rº
c2:=rF¹k;mº
return¹c1;c2º
9.11. Let Fbe a secure block cipher with blocklength λ. Below is an encryption scheme for
plaintextsM=f0;1gλ. Formally describe its decryption algorithm and show that it does
nothave CCA security.
KeyGen :
k1 f0;1gλ
k2 f0;1gλ
return¹k1;k2ºEnc
¹k1;k2º;m
:
r f0;1gλ
c1:=F¹k1;rº
c2:=F¹k1;rmk2º
return¹c1;c2º
9.12. Alice has the following idea for a CCA-secure encryption. To encrypt a single plaintext
block m, do normal CBC encryption of 0blenkm. To decrypt, do normal CBC decryption
but give an error if the /f_irst plaintext block is not all zeroes. Her reasoning is:
IThe ciphertext has 3 blocks (including the IV). If an adversary tampers with the IV
or the middle block of a ciphertext, then the /f_irst plaintext block will no longer be all
zeroes and the ciphertext is rejected.
IIf an adversary tampers with the last block of a ciphertext, then the CBC decryption
results in 0blenkm0where m0is unpredictable from the adversary’s point of view.
Hence the result of decryption ( m0) will leak no information about the original m.
More formally, let CBC denote the encryption scheme obtained by using a secure PRF in
CBC mode. Below we de/f_ine an encryption scheme Σ0with message space f0;1gblenand
ciphertext spacef0;1g3blen:
Σ0:KeyGen :
k CBC:KeyGen
return k
Σ0:Enc¹k;mº:
return CBC:Enc¹k;0blenkmºΣ0:Dec¹k;cº:
m1km2:=CBC:Dec¹k;cº
ifm1=0blen:
return m2
else return err
Show that Σ0does nothave CCA security. Describe a distinguisher and compute its dis-
tinguishing advantage. What part of Alice’s reasoning was not quite right?
Hint:Obtain a ciphertext c=c0kc1kc2and another ciphertext c0=c0
0kc0
1kc0
2, both with known plaintexts.
Ask the library to decrypt c0kc1kc0
2.
179Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
9.13. CBC and OFB modes are malleable in very diﬀerent ways. For that reason, Mallory claims
that encrypting a plaintext (independently) with both modes results in CCA security, when
theDec algorithm rejects ciphertexts whose OFB and CBC plaintexts don’t match. The
reasoning is that it will be hard to tamper with both ciphertexts in a way that achieves the
same eﬀect on the plaintext.
LetCBC denote the encryption scheme obtained by using a secure PRF in CBC mode. Let
OFB denote the encryption scheme obtained by using a secure PRF in OFB mode. Below
we de/f_ine an encryption scheme Σ0:
Σ0:KeyGen :
kcbc CBC:KeyGen
kofb OFB:KeyGen
return¹kcbc;kofbº
Σ0:Enc¹¹kcbc;kofbº;mº:
c:=CBC:Enc¹kcbc;mº
c0:=OFB:Enc¹kofb;mº
return¹c;c0ºΣ0:Dec¹¹kcbc;kofbº;¹c;c0ºº:
m:=CBC:Dec¹kcbc;cº
m0:=OFB:Dec¹kofb;c0º
ifm=m0:
return m
else return err
Show that Σ0does nothave CCA security. Describe a distinguisher and compute its dis-
tinguishing advantage.
9.14. This problem is a generalization of the previous one. Let Σ1andΣ2be two (possibly diﬀer-
ent) encryption schemes with the same message space M. Below we de/f_ine an encryption
scheme Σ0:
Σ0:KeyGen :
k1 Σ1:KeyGen
k2 Σ2:KeyGen
return¹k1;k2ºΣ0:Enc¹¹k1;k2º;mº:
c1:=Σ1:Enc¹k1;mº
c2:=Σ2:Enc¹k2;mº
return¹c1;c2ºΣ0:Dec¹¹k1;k2º;¹c1;c2ºº:
m1:=Σ1:Dec¹k1;c1º
m2:=Σ2:Dec¹k2;c2º
ifm1=m2:
return m1
else return err
Show that Σ0does nothave CCA security, even if both Σ1andΣ2have CCA (yes, C CA)
security. Describe a distinguisher and compute its distinguishing advantage.
9.15. Consider any padding scheme consisting of subroutines /p.sc/a.sc/d.sc (which adds valid padding
to its argument) and /v.sc/a.sc/l.sc/i.sc/d.sc/p.sc/a.sc/d.sc (which checks its argument for valid padding and returns
true /false ). Assume that /v.sc/a.sc/l.sc/i.sc/d.sc/p.sc/a.sc/d.sc¹/p.sc/a.sc/d.sc¹xºº=true for all strings x.
Show that if an encryption scheme Σhas CCA security, then the following two libraries
are indistinguishable:
180Draft: January 3, 2021 CHAPTER 9. CHOSEN CIPHERTEXT ATTACKS
LΣ
pad-L
k Σ:KeyGen
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
ifjmLj,jmRjreturn err
return Σ:Enc¹k;/p.sc/a.sc/d.sc¹mLºº
/p.sc/a.sc/d.sc/d.sc/i.sc/n.sc/g.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc¹c2Σ:Cº:
return /v.sc/a.sc/l.sc/i.sc/d.sc/p.sc/a.sc/d.sc¹Σ:Dec¹k;cººLΣ
pad-R
k Σ:KeyGen
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
ifjmLj,jmRjreturn err
return Σ:Enc¹k;/p.sc/a.sc/d.sc¹mRºº
/p.sc/a.sc/d.sc/d.sc/i.sc/n.sc/g.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc¹c2Σ:Cº:
return /v.sc/a.sc/l.sc/i.sc/d.sc/p.sc/a.sc/d.sc¹Σ:Dec¹k;cºº
That is, a CCA-secure encryption scheme hides underlying plaintexts in the presence of
padding-oracle attacks.
Note: The distinguisher can even send a ciphertext cobtained from /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc as an ar-
gument to /p.sc/a.sc/d.sc/d.sc/i.sc/n.sc/g.sc/o.sc/r.sc/a.sc/c.sc/l.sc/e.sc . Your proof should somehow account for this when reducing
to the CCA security of Σ.
9.16. Show that an encryption scheme Σhas CCA$ security if and only if the following two
libraries are indistinguishable:
LΣ
le/f_t
k Σ:KeyGen
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹m2Σ:Mº:
return Σ:Enc¹k;mº
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
return Σ:Dec¹k;cºLΣ
right
k Σ:KeyGen
D:=empty assoc. array
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹m2Σ:Mº:
c Σ:C¹jmjº
D»c¼:=m
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifD»c¼exists: return D»c¼
else: return Σ:Dec¹k;cº
Note: InLle/f_t, the adversary can obtain the decryption of anyciphertext via /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc . In
Lright, the /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc subroutine is “patched” (via D) to give reasonable answers to cipher-
texts generated in /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc .
18110Message Authentication Codes
The challenge of CCA-secure encryption is dealing with ciphertexts that were generated
by an adversary. Imagine there was a way to “certify” that a ciphertext was not adversar-
ially generated — i.e., it was generated by someone who knows the secret key. We could
include such a certi/f_ication in the ciphertext, and the Dec algorithm could raise an error
if it asked to decrypt something with invalid certi/f_ication.
What we are asking for is not to hide the ciphertext but to authenticate it: to ensure
that it was generated by someone who knows the secret key. The tool for the job is called
amessage authentication code . One of the most important applications of a message
authentication code is to transform a CPA-secure encryption scheme into a CCA-secure
one.
As you read this chapter, keep in mind that privacy and authentication are indeed
diﬀerent properties. It is possible to have one or the other or indeed both simultaneously.
But one does not imply the other, and it is crucial to think about them separately.
10.1 Definition
A MAC is like a signature that can be added to a piece of data, which certi/f_ies that someone
who knows the secret key attests to this particular data. In cryptography, the term “signa-
ture” means something speci/f_ic, and slightly diﬀerent than a MAC. Instead of calling the
output of a MAC algorithm a signature, we call it a “tag” (or, confusingly, just “a MAC”).
Our security requirement for a MAC scheme is that only someone with the secret key
can generate a valid tag. To check whether a tag is valid, you just recompute the tag
for a given message and see whether it matches the claimed tag. This implies that both
generating and verifying a MAC tag requires the secret key.
Definition 10.1
(MAC scheme)Amessage authentication code (MAC) scheme for message spaceMconsists of the fol-
lowing algorithms:
IKeyGen : samples a key.
IMAC : takes a key kand message m2M as input, and outputs a tagt. The MAC
algorithm is deterministic.
How to Think About Authenticity Properties
Every security de/f_inition we’ve seen so far is about hiding information, so how do we
make a formal de/f_inition about authenticity?
Before we see the security de/f_inition for MACs, let’s start with a much simpler (poten-
tially obvious?) statement: “an adversary should not be able to guess a uniformly chosen
λ-bit value.” We can formalize this idea with the following two libraries:
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
Lle/f_t
r f0;1gλ
/g.sc/u.sc/e.sc/s.sc/s.sc¹/afii10069.italº:
return/afii10069.ital?=rLright
/g.sc/u.sc/e.sc/s.sc/s.sc¹/afii10069.italº:
return false
The left library allows the calling program to attempt to guess a uniformly chosen “target”
string. The right library doesn’t even bother to verify the calling program’s guess — in fact
it doesn’t even bother to sample a random target string!
The /g.sc/u.sc/e.sc/s.sc/s.sc subroutines of these libraries give the same output on nearly all inputs.
There is only one input ron which they disagree. If a calling program can manage to /f_ind
the value r, then it can easily distinguish the libraries. Therefore, by saying that these
libraries are indistinguishable, we are really saying that it’s hard for an adversary to
/f_ind/generate this special value! That’s the kind of property we want to express.
Indeed, in this case, an adversary who makes qqueries to the /g.sc/u.sc/e.sc/s.sc/s.sc subroutine
achieves an advantage of at most q2λ. For polynomial-time adversaries, this is a neg-
ligible advantage (since qis a polynomial function of λ).
More generally, suppose we have two libraries, and a subroutine in one library checks
some condition (and could return either true orfalse ), while in the other library this
subroutine always returns false . If the two libraries are indistinguishable, the calling
program can’t tell whether the library is actually checking the condition or always saying
false . This means it must be very hard to /f_ind an input for which the “correct” answer is
true .
The MAC Security Definition
We want to say that only someone who knows the secret key can come up with valid MAC
tags. In other words, the adversary cannot come up with valid MAC tags.
Actually, that property is not quite enough to be useful. A more useful property is:
even if the adversary knows valid MAC tags corresponding to various messages, she cannot
produce a valid MAC tag for a diﬀerent message. We call it a forgery if the adversary can
produce a “new” valid MAC tag.
To translate this security property to a formal de/f_inition, we de/f_ine two libraries that
allow the adversary to request MAC tags on chosen messages. The libraries also provide
a mechanism to let the adversary check whether it has successfully found a forgery (since
there is no way of checking this property without the secret key). One library will actually
perform the check, and the other library will simply assume that forgeries are impossible.
The two libraries are diﬀerent only in how they behave when the adversary calls this veri-
/f_ication subroutine on a forgery. By demanding that the two libraries be indistinguishable,
we are actually demanding that it is diﬃcult for the calling program to generate a forgery.
Definition 10.2
(MAC security)LetΣbe a MAC scheme. We say that Σis asecure MAC ifLΣ
mac-realLΣ
mac-fake, where:
183Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
LΣ
mac-real
k Σ:KeyGen
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹m2Σ:Mº:
return Σ:MAC¹k;mº
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m2Σ:M;tº:
return t?=Σ:MAC¹k;mºLΣ
mac-fake
k Σ:KeyGen
T:=;
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹m2Σ:Mº:
t:=Σ:MAC¹k;mº
T:=T[f¹ m;tºg
return t
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m2Σ:M;tº:
return¹m;tº?2T
Discussion:
IThe adversary can see valid tags of chosen messages, from the /g.sc/e.sc/t.sc/t.sc/a.sc/g.sc subroutine.
However, these tags shouldn’t count as a successful forgery. The way this is enforced
is in the /c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc subroutine ofLmac-fake — instead of always responding false , it
gives the correct answer ( true ) for any tags generated by /g.sc/e.sc/t.sc/t.sc/a.sc/g.sc .
In order for the two libraries to behave diﬀerently, the adversary must call /c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc
on input¹m;tºsuch that mwas never used as an argument to /g.sc/e.sc/t.sc/t.sc/a.sc/g.sc (so that
Lmac-fake responds false ) but where the tag is actually correct (so that Lmac-real
responds true ).
IThe adversary can successfully distinguish if it /f_inds anyforgery — a valid MAC
tag of any“fresh” message. The de/f_inition doesn’t care whether it’s the tag of any
particular meaningful message.
MAC Applications
Although MACs are less embedded in public awareness than encryption, they are ex-
tremely useful. A frequent application of MACs is to store some information in an un-
trusted place, where we don’t intend to hide the data, only ensure that the data is not
changed.
IAbrowser cookie is a small piece of data that a webserver stores in a user’s web
browser. The browser presents the cookie data to the server upon each request.
Imagine a webserver that stores a cookie when a user logs in, containing that user’s
account name. What stops an attacker from modifying their cookie to contain a
diﬀerent user’s account name? Adding a MAC tag of the cookie data (using a key
known only to the server) ensures that such an attack will not succeed. The server
can trust any cookie data whose MAC tag is correct.
IWhen Alice initiates a network connection to Bob, they must perform a TCP hand-
shake:
184Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
1. Alice sends a special SYN packet containing her initial sequence number A. In
TCP, all packets from Alice to Bob include a sequence number, which helps the
parties detect when packets are missing or out of order. It is important that
the initial sequence number be random, to prevent other parties from injecting
false packets.
2. Bob sends a special SYN+ACK packet containing A+1(to acknowledge Alice’s
Avalue) and the initial sequence number Bfor his packets.
3. Alice sends a special ACK packet containing B+1, and then the connection is
established.
When Bob is waiting for step 3, the connection is considered “half-open.” While
waiting, Bob must remember Bso that he can compare to the B+1that Alice is
supposed to send in her /f_inal ACK. Typically the operating system allocates only a
very limited amount of resources for these half-open connections.
In the past, it was possible to perform a denial of service attack by starting a huge
number of TCP connections with a server, but never sending the /f_inal ACK packet.
The server’s queue for half-open connections /f_ills up, which prevents other legiti-
mate connections from starting.
A clever backwards-compatible solution to this problem is called SYN cookies. The
idea is to let Bob choose his initial sequence number Bto be a MAC of the client’s
IP address, port number, and some other values. Now there is nothing to store for
half-open connections. When Alice sends the /f_inal ACK of the handshake, Bob can
recompute the initial sequence number from his MAC key.
These are all cases where the person who generates the MAC is the same person who later
veri/f_ies the MAC. You can think of this person as choosing not to store some information,
but rather leaving the information with someone else as a “note to self.”
There are other useful settings where one party generates a MAC while the other
veri/f_ies.
IIntwo-factor authentication , a user logs into a service using something they know
(e.g., a password) and something they have (e.g., a mobile phone). The most common
two-factor authentication mechanism is called timed one-time passwords (TOTP).
When you (as a user) enable two-factor authentication, you generate a secret key
kand store it both on your phone and with the service provider. When you wish
to log in, you open a simple app on your phone which computes p=MAC¹k;Tº,
where Tis the current date + time (usually rounded to the nearest 30 seconds). The
value pis the “timed one-time password.” You then log into the service using your
usual (long-term) password and the one-time password p. The service provider has
kand also knows the current time, so can verify the MAC p.
From the service provider’s point of view, the only other place kexists is in the
phone of this particular user. Intuitively, the only way to generate a valid one-time
password at time Tis to be in posession of this phone at time T. Even if an attacker
sees both your long-term and one-time password over your shoulder, this does not
help him gain access to your account in the future (well, not after 30 seconds in the
future).
185Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
10.2? A PRF is a MAC
The de/f_inition of a PRF says (more or less) that even if you’ve seen the output of the
PRF on several chosen inputs, all other outputs look independently & uniformly random.
Furthermore, uniformly chosen values are hard to guess, as long as they are suﬃciently
long ( e.g.,λbits).
In other words, after seeing some outputs of a PRF, any other PRF output will be hard
to guess. This is exactly the intuitive property we require from a MAC. And indeed, we
will prove in this section that a PRF is a secure MAC. While the claim makes intuitive
sense, proving it formally is a little tedious. This is due to the fact that that in the MAC
security game, the adversary can make many veri/f_ication queries /c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tºbefore
asking to see the correct MAC of m. Dealing with this event is the source of all the technical
diﬃculty in the proof.
We start with a technical claim that captures the idea that “if you can blindly guess
at uniformly chosen values and can also ask to see the values, then it is hard to guess a
random value before you have seen it.”
Claim 10.3 The following two libraries are indistinguishable:
Lguess-L
T:=empty assoc. array
/g.sc/u.sc/e.sc/s.sc/s.sc¹m2f0;1gin;/afii10069.ital2f0;1gλº:
ifT»m¼unde/f_ined:
T»m¼ f 0;1gλ
return/afii10069.ital?=T»m¼
/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹m2f0;1ginº:
ifT»m¼unde/f_ined:
T»m¼ f 0;1gλ
return T»m¼Lguess-R
T:=empty assoc. array
/g.sc/u.sc/e.sc/s.sc/s.sc¹m2f0;1gin;/afii10069.ital2f0;1gλº:
// returns false ifT»m¼unde/f_ined
return/afii10069.ital?=T»m¼
/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹m2f0;1ginº:
ifT»m¼unde/f_ined:
T»m¼ f 0;1gλ
return T»m¼
Both libraries maintain an associative array Twhose values are sampled uniformly the /f_irst
time they are needed. Calling programs can try to guess these values via the /g.sc/u.sc/e.sc/s.sc/s.sc subrou-
tine, or simply learn them via /r.sc/e.sc/v.sc/e.sc/a.sc/l.sc . Note that the calling program can call /g.sc/u.sc/e.sc/s.sc/s.sc¹m;º
both before and after calling /r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº.
Intuitively, since the values in Tareλbits long, it should be hard to guess T»m¼before
calling /r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº. That is exactly what we formalize in Lguess-R . In fact, this library
doesn’t bother to even choose T»m¼until /r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mºis called. All calls to /g.sc/u.sc/e.sc/s.sc/s.sc¹m;º
made before the /f_irst call to /r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mºwill return false .
Proof Letqbe the number of queries that the calling program makes to /g.sc/u.sc/e.sc/s.sc/s.sc . We will show
that the libraries are indistinguishable with a hybrid sequence of the form:
Lguess-LL hyb- 0Lhyb- 1Lhyb-qL guess-R
186Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
Thehth hybrid library in the sequence is de/f_ined as:
Lhyb-h
count :=0
T:=empty assoc. array
/g.sc/u.sc/e.sc/s.sc/s.sc¹m;/afii10069.italº:
count :=count +1
ifT»m¼unde/f_ined and count >h:
T»m¼ f 0;1gλ
return/afii10069.ital?=T»m¼
// returns false ifT»m¼unde/f_ined
/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº:
ifT»m¼unde/f_ined:
T»m¼ f 0;1gλ
return T»m¼
This hybrid library behaves like Lguess-R for the /f_irst hqueries to /g.sc/u.sc/e.sc/s.sc/s.sc , in the sense
that it will always just return false when T»m¼is unde/f_ined. After hqueries, it will behave
likeLguess-L by actually sampling T»m¼in these cases.
InLhyb- 0, the clause “ count >0” is always true so this clause can be removed from
the if-condition. This modi/f_ication results in Lguess-L , so we haveLguess-LL hyb- 0.
InLhyb-q, the clause “ count >q” in the if-statement is always false since the call-
ing program makes only qqueries. Removing the unreachable if-statement it results in
Lguess-R , so we haveLguess-RL hyb-q.
It remains to show that Lhyb-hLhyb-¹h+1ºfor all h. We can do so by rewriting these
two libraries as follows:
Lhyb-h
count :=0
T:=empty assoc. array
/g.sc/u.sc/e.sc/s.sc/s.sc¹m;/afii10069.italº:
count :=count +1
ifT»m¼unde/f_ined and count >h:
T»m¼ f 0;1gλ
if/afii10069.ital=T»m¼andcount =h+1:
bad:=1
return/afii10069.ital?=T»m¼
// returns false ifT»m¼unde/f_ined
/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº:
ifT»m¼unde/f_ined:
T»m¼ f 0;1gλ
return T»m¼Lhyb-¹h+1º
count :=0
T:=empty assoc. array
/g.sc/u.sc/e.sc/s.sc/s.sc¹m;/afii10069.italº:
count :=count +1
ifT»m¼unde/f_ined and count >h:
T»m¼ f 0;1gλ
if/afii10069.ital=T»m¼andcount =h+1:
bad:=1; return false
return/afii10069.ital?=T»m¼
// returns false ifT»m¼unde/f_ined
/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº:
ifT»m¼unde/f_ined:
T»m¼ f 0;1gλ
return T»m¼
187Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
The library on the left is equivalent to Lhyb-hsince the only change is the highlighted
lines, which don’t actually aﬀect anything. In the library on the right, if T»m¼is unde/f_ined
during the /f_irst h+1calls to /g.sc/u.sc/e.sc/s.sc/s.sc , the subroutine will return false (either by avoiding
the if-statement altogether or by triggering the highlighted lines). This matches the be-
havior ofLhyb-¹h+1º, except that the library shown above samples the value T»m¼which in
Lhyb-¹h+1ºwould not be sampled until the next call of the form /g.sc/u.sc/e.sc/s.sc/s.sc¹m;ºor/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº.
But the method of sampling is the same, only the timing is diﬀerent. This diﬀerence has
no eﬀect on the calling program.
So the two libraries above are indeed equivalent to Lhyb-handLhyb-¹h+1º. They diﬀer
only in code that is reachable when bad=1. From Lemma 4.8, we know that these two
libraries are indistinguishable if Pr»bad=1¼is negligible. In these libraries there is only
one chance to set bad=1, and that is by guessing/predicting uniform T»m¼on the¹h+1ºth
call to /g.sc/u.sc/e.sc/s.sc/s.sc . This happens with probability 12λ, which is indeed negligible.
This shows thatLhyb-hLhyb-¹h+1º, and completes the proof. 
We now return to the problem of proving that a PRF is a MAC.
Claim 10.4 LetFbe a secure PRF with input length inand output length out=λ. Then the scheme
MAC¹k;mº=F¹k;mºis a secure MAC for message space f0;1gin.
Proof We show thatLF
mac-realLF
mac-fake, using a standard sequence of hybrids.
LF
mac-real
k f0;1gλ
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹mº:
return F¹k;mº
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tº:
return t?=F¹k;mºThe starting point is the
Lmac-real library, with the
details of this MAC scheme
/f_illed in.
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹mº:
return /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹mº
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tº:
return t?=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹mºLF
prf-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
return F¹k;xºWe have factored out the PRF
operations in terms of the li-
braryLprf-real from the PRF se-
curity de/f_inition.
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹mº:
return /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹mº
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tº:
return t?=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹mºLF
prf-rand
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifT»x¼unde/f_ined:
T»x¼ f 0;1gout
return T»x¼We have applied the PRF-
security of Fand replaced
Lprf-real withLprf-rand .
188Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹mº:
return /r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tº:
return /g.sc/u.sc/e.sc/s.sc/s.sc¹m;tºLguess-L
T:=empty assoc. array
/g.sc/u.sc/e.sc/s.sc/s.sc¹m;/afii10069.italº:
ifT»m¼unde/f_ined:
T»m¼ f 0;1gλ
return/afii10069.ital?=T»m¼
/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº:
ifT»m¼unde/f_ined:
T»m¼ f 0;1gλ
return T»m¼We can express the previous
hybrid in terms of the Lguess-L
library from Claim 10.3. The
change has no eﬀect on the
calling program.
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹mº:
return /r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tº:
return /g.sc/u.sc/e.sc/s.sc/s.sc¹m;tºLguess-R
T:=empty assoc. array
/g.sc/u.sc/e.sc/s.sc/s.sc¹m;/afii10069.italº:
return/afii10069.ital?=T»m¼
/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº:
ifT»m¼unde/f_ined:
T»m¼ f 0;1gλ
return T»m¼We have applied Claim 10.3 to
replaceLguess-L withLguess-R .
This involves simply removing
the if-statement from /g.sc/u.sc/e.sc/s.sc/s.sc .
As a result, /g.sc/u.sc/e.sc/s.sc/s.sc¹m;/afii10069.italºwill re-
turn false ifT»m¼is unde/f_ined.
T:=;
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹mº:
t:=/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº
T:=T[f¹ m;tºg
return t
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tº:
return /g.sc/u.sc/e.sc/s.sc/s.sc¹m;tºLguess-R
T:=empty assoc. array
/g.sc/u.sc/e.sc/s.sc/s.sc¹m;/afii10069.italº:
return/afii10069.ital?=T»m¼
/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº:
ifT»m¼unde/f_ined:
T»m¼ f 0;1gλ
return T»m¼Extra bookkeeping informa-
tion is added, but not used
anywhere. There is no eﬀect
on the calling program.
Consider the hybrid experiment above, and suppose the calling program makes a call to
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tº. There are two cases:
ICase 1: there was a previous call to /g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹mº. In this case, the value T»m¼is de/f_ined
inLguess-R and¹m;T»m¼ºalready exists inT. In this case, the result of /g.sc/u.sc/e.sc/s.sc/s.sc¹m;tº
(and hence, of /c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tº) will be t?=T»m¼.
ICase 2: there was no previous call to /g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹mº. Then there is no value of the form
¹m;?ºinT. Furthermore, T»m¼is unde/f_ined inLguess-R . The call to /g.sc/u.sc/e.sc/s.sc/s.sc¹m;tºwill
189Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
return false , and so will the call to /c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tºthat we consider.
In both cases, the result of /c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tºistrue if and only if¹m;tº2T .
T:=;
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹mº:
t:=/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº
T:=T[f¹ m;tºg
return t
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tº:
return¹m;tº?2TLguess-R
T:=empty assoc. array
/g.sc/u.sc/e.sc/s.sc/s.sc¹m;/afii10069.italº:
return/afii10069.ital?=T»m¼
/r.sc/e.sc/v.sc/e.sc/a.sc/l.sc¹mº:
ifT»m¼unde/f_ined:
T»m¼ f 0;1gλ
return T»m¼We have modi/f_ied /c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc ac-
cording to the discussion above.
T:=;
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹mº:
t:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc (m)
T:=T[f¹ m;tºg
return t
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tº:
return¹m;tº?2TLF
prf-rand
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifT»x¼unde/f_ined:
T»x¼ f 0;1gout
return T»x¼In the previous hybrid, the /g.sc/u.sc/e.sc/s.sc/s.sc
subroutine is never called. Remov-
ing that unused subroutine and re-
naming /r.sc/e.sc/v.sc/e.sc/a.sc/l.sc to/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc results in
theLprf-ideal library from the PRF se-
curity de/f_inition.
T:=;
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹mº:
t:=/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹mº
T:=T[f¹ m;tºg
return t
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m;tº:
return¹m;tº?2TLF
prf-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
return F¹k;xºWe have applied the PRF security
ofFagain, replacingLprf-ideal with
Lprf-real .
InliningLprf-real in the /f_inal hybrid, we see that the result is exactly LF
mac-fake. Hence, we
have shown thatLF
mac-realLF
mac-fake, which completes the proof. 
Discussion
If PRFs are MACs, why do we even need a de/f_inition for MACs? The simplest answer
to this question is that the concepts of PRF and MAC are indeed diﬀerent:
INot every PRF is a MAC. Only suﬃciently long random values are hard to
guess , so only PRFs with long outputs ( out>λ) are MACs. It is perfectly reasonable
to consider a PRF with short outputs.
190Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
INot every MAC is a PRF. Just like not every encryption scheme has pseudorandom
ciphertexts, not every MAC scheme has pseudorandom tags. Imagine taking a se-
cure MAC scheme and modifying it as MAC0¹k;mº=MAC¹k;mºk0λ. Adding 0s to
every tag prevents the tags from looking pseudorandom, but does not make the tags
any easier to guess. Something doesn’t have to be uniformly random in order
to be hard to guess.
It is true that in the vast majority of cases we will encounter MAC schemes with random
tags, and PRFs with long outputs ( out>λ). But it is good practice to know whether you
really need something that is pseudorandom orhard to guess .
10.3 MACs for Long Messages
Using a PRF as a MAC is useful only for short, /f_ixed-length messages, since most PRFs that
exist in practice are limited to such inputs. Can we somehow extend a PRF to construct a
MAC scheme for long messages, similar to how we used block cipher modes to construct
encryption for long messages?
How NOT to do it
To understand the challenges of constructing a MAC for long messages, we /f_irst explore
some approaches that don’t work. The things that can go wrong in an insecure MAC are
quite diﬀerent in character to the things that can go wrong in a block cipher mode, so pay
attention closely!
Example LetFbe a PRF with in=out=λ. Below is a MAC approach for messages of length 2λ. It is
inspired by ECB mode, so you know it’s going to be a disaster:
ECBMAC¹k;m1km2º:
t1:=F¹k;m1º
t2:=F¹k;m2º
return t1kt2
One problem with this approach is that, although the PRF authenticates each block m1;m2
individually, it does nothing to authenticate that m1is the /f_irst block but m2is the second one.
Translating this observation into an attack, an adversary can ask for the MAC tag of m1km2
and then predict/forge the tag for m2km1:
A:
t1kt2:=/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹0λk1λº
return /c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹1λk0λ;t2kt1º
WhenAis linked toLmac-real , it always return true , since we can tell that t2kt1is indeed the
valid tag for 1λk0λ. WhenAis linked toLmac-fake , it always return false , since the calling
program never called /g.sc/e.sc/t.sc/t.sc/a.sc/g.sc with input 1λk0λ. Hence,Adistinguishes the libraries with
advantage 1.
191Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
This silly MAC construction treats both m1andm2identically, and an obvious way to
try to /f_ix the problem is to treat the diﬀerent blocks diﬀerently somehow:
Example LetFbe a PRF with in=λ+1andout=λ. Below is another MAC approach for messages of
length 2λ:
ECB++MAC¹k;m1km2º:
t1:=F¹k;0km1º
t2:=F¹k;1km2º
return t1kt2
This MAC construction does better, as it treats the two message blocks m1andm2dif-
ferently. Certainly the previous attack of swapping the order of m1andm2doesn’t work
anymore. (Can you see why?)
The construction authenticates (in some sense) the fact that m1is the /f_irst message block,
andm2is the second block. However, this construction doesn’t authenticate the fact that
this particular m1and m2belong together . More concretely, we can “mix and match”
blocks of the tag corresponding to diﬀerent messages:
A:
t1kt2:=/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹02λº
t0
1kt0
2:=/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹12λº
return /c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹0λk1λ;t1kt0
2º
In this attack, we combine the t1block from the /f_irst tag and the t2block from the second tag.
We are starting to see the challenges involved in constructing a MAC scheme for long
messages. A secure MAC should authenticate each message block, the order of the mes-
sage blocks, and the fact that these particular message blocks are appearing in a single mes-
sage. In short, it must authenticate the entirety of the message.
Think about how authentication is signi/f_icantly diﬀerent than privacy/hiding in this
respect. At least for CPA security, we can hide an entire plaintext by hiding each in-
dividual piece of the plaintext separately (encrypting it with a CPA-secure encryption).
Authentication is fundamentally diﬀerent.
How to do it: CBC-MAC
We have seen some insecure ways to construct a MAC for longer messages. Now let’s see
a secure way. A common approach to constructing a MAC for long messages involves the
CBC block cipher mode.
Construction 10.5
(CBC-MAC)LetFbe a PRF with in=out=λ. CBC-MAC refers to the following MAC scheme:
192Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
/c.sc/b.sc/c.sc/m.sc/a.sc/c.scF¹k;m1m`º:
t:=0λ
fori=1to`:
t:=F¹k;mitº
return tFk Fk Fk m1 m2 m`
t
Unlike CBC encryption, CBC-MAC uses no initialization vector (or, you can think of
it as using the all-zeroes IV), and it outputs only the last block.
Theorem 10.6 IfFis a secure PRF with in=out=λ, then for any /f_ixed `, CBC-MAC is a secure MAC when
used with message space M=f0;1gλ`.
Pay close attention to the security statement. It says that if you only ever authenticate
4-block messages, CBC-MAC is secure. If you only ever authenticate 24-block messages,
CBC-MAC is secure. However, if you want to authenticate both 4-block and 24-block
messages ( i.e., under the same key), then CBC-MAC is not secure. In particular, seeing
the CBC-MAC of several 4-block messages allows an attacker to generate a forgery of a
24-block message. The exercises explore this property.
More Robust CBC-MAC
If CBC-MAC is so fragile, is there a way to extend it to work for messages of mixed lengths?
One approach is called ECBC-MAC, and is shown below. It works by treating the last
block diﬀerently — speci/f_ically, it uses an independent PRF key for the last block in the
CBC chain.
Construction 10.7
(ECBC-MAC)LetFbe a PRF with in=out=λ. ECBC-MAC refers to the following scheme:
/e.sc/c.sc/b.sc/c.sc/m.sc/a.sc/c.scF
¹k1;k2º;m1m`
:
t:=0λ
fori=1to` 1:
t:=F¹k1;mitº
return F¹k2;m`tºFk1 Fk1 Fk2 m1 m2 m`
t
Theorem 10.8 IfFis a secure PRF with in=out=λ, then ECBC-MAC is a secure MAC for message space
M=¹f0;1gλº.
In other words, ECBC-MAC is safe to use with messages of any length (that is a mul-
tiple of the block length).
193Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
To extend ECBC-MAC to messages of anylength (not necessarily a multiple of the
block length), one can use a padding scheme as in the case of encryption.1
10.4 Encrypt-Then-MAC
Our motivation for studying MACs is that they seem useful in constructing a CCA-secure
encryption scheme. The idea is to add a MAC to a CPA-secure encryption scheme. The
decryption algorithm can raise an error if the MAC is invalid, thereby ensuring that
adversarially-generated (or adversarially-modi/f_ied) ciphertexts are not accepted. There
are several natural ways to combine a MAC and encryption scheme, but not all are secure!
(See the exercises.) The safest way is known as encrypt-then-MAC:
Construction 10.9
(Enc-then-MAC)LetEdenote an encryption scheme, and Mdenote a MAC scheme where E:C M:M(i.e.,
the MAC scheme is capable of generating MACs of ciphertexts in the Escheme). Then let EtM
denote the encrypt-then-MAC construction given below:
K=E:K M:K
M=E:M
C=E:CM:T
KeyGen :
ke E:KeyGen
km M:KeyGen
return¹ke;kmºEnc¹¹ke;kmº;mº:
c:=E:Enc¹ke;mº
t:=M:MAC¹km;cº
return¹c;tº
Dec¹¹ke;kmº;¹c;tºº:
ift,M:MAC¹km;cº:
return err
return E:Dec¹ke;cº
Importantly, the scheme computes a MAC of the CPA ciphertext , and not of the plain-
text! The result is a CCA-secure encryption scheme:
Claim 10.10 IfEhas CPA security and Mis a secure MAC, then EtM (Construction 10.9) has CCA security.
Proof As usual, we prove the claim with a sequence of hybrid libraries:
1Note that if the message is already a multiple of the block length, then padding adds an extra block.
There exist clever ways to avoid an extra padding block in the case of MACs, which we don’t discuss further.
194Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
LEtM
cca-L
ke E:KeyGen
km M:KeyGen
S:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
ifjmLj,jmRj
return null
c:=E:Enc¹ke;mLº
t M:MAC¹km;cº
S:=S[f¹c;tºg
return¹c;tº
/d.sc/e.sc/c.sc¹c;tº:
if¹c;tº2S return null
ift,M:MAC¹km;cº:
return err
return E:Dec¹ke;cºThe starting point is LEtM
cca-L, shown here with the details of
the encrypt-then-MAC construction highlighted. Our goal is
to eventually swap mLwith mR. But the CPA security of E
should allow us to do just that, so what’s the catch?
To apply the CPA-security of E, we must factor out the rel-
evant call to E:Encin terms of the CPA library LE
cpa-L. This
means that kebecomes private to the Lcpa-L library. But ke
is also used in the last line of the library as E:Dec¹ke;cº. The
CPA security library for Eprovides no way to carry out such
E:Decstatements!
ke E:KeyGen
S:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
ifjmLj,jmRj
return null
c:=E:Enc¹ke;mLº
t:=/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹cº
S:=S[f¹ c;tºg
return¹c;tº
/d.sc/e.sc/c.sc¹c;tº:
if¹c;tº2S
return null
ifnot/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹c;tº:
return err
return E:Dec¹ke;cºLM
mac-real
km M:KeyGen
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹cº:
return M:MAC¹km;cº
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹c;tº:
return t?=M:MAC¹km;cºThe operations of the
MAC scheme have been
factored out in terms of
LM
mac-real. Notably, in the
/d.sc/e.sc/c.scsubroutine the condi-
tion “ t,M:MAC¹k/m.sc;cº”
has been replaced with
“not /c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹c;tº.”
195Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
ke E:KeyGen
S:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
ifjmLj,jmRj
return null
c:=E:Enc¹ke;mLº
t:=/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹cº
S:=S[f¹ c;tºg
return¹c;tº
/d.sc/e.sc/c.sc¹c;tº:
if¹c;tº2S
return null
if not /c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹c;tº:
return err
return E:Dec¹ke;cºLM
mac-fake
km M:KeyGen
T:=;
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹cº:
t:=M:MAC¹km;cº
T:=T[f¹ c;tºg
return t
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹c;tº:
return¹c;tº?2TWe have applied the security of the
MAC scheme, and replaced Lmac-real
withLmac-fake .
ke E:KeyGen
km M:KeyGen
T:=;
S:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
ifjmLj,jmRj
return null
c:=E:Enc¹ke;mLº
t:=M:MAC¹km;cº
T:=T[f¹ c;tºg
S:=S[f¹ c;tºg
return¹c;tº
/d.sc/e.sc/c.sc¹c;tº:
if¹c;tº2S
return null
if¹c;tº<T:
return err
return E:Dec¹ke;cºWe have inlined the Lmac-fake library. This library keeps track
of a setSof values for the purpose of the CCA interface, but
also a setTof values for the purposes of the MAC. However, it
is clear from the code of this library that SandTalways have
the same contents.
Therefore, the two conditions “ ¹c;tº2S ” and “¹c;tº<T” in the
/d.sc/e.sc/c.scsubroutine are exhaustive! The /f_inal line of /d.sc/e.sc/c.scisunreach-
able. This hybrid highlights the intuitive idea that an adversary
can either query /d.sc/e.sc/c.scwith a ciphertext generated by /e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc
(the¹c;tº2S case) — in which case the response is null — or
with a diﬀerent ciphertext — in which case the response will be
errsince the MAC will not verify.
196Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
ke E:KeyGen
km M:KeyGen
S:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
ifjmLj,jmRj
return null
c:=E:Enc¹ke;mLº
t:=M:MAC¹km;cº
S:=S[f¹ c;tºg
return¹c;tº
/d.sc/e.sc/c.sc¹c;tº:
if¹c;tº2S
return null
if¹c;tº<S:
return err
// unreachableThe unreachable statement has been removed and the redundant
variablesSandThave been uni/f_ied. Note that this hybrid li-
brary never uses E:Dec, making it possible to express its use of
theEencryption scheme in terms of Lcpa-L.
km M:KeyGen
S:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
ifjmLj,jmRj
return null
c:=/c.sc/p.sc/a.sc./e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº
t:=M:MAC¹km;cº
S:=S[f¹ c;tºg
return¹c;tº
/d.sc/e.sc/c.sc¹c;tº:
if¹c;tº2S
return null
if¹c;tº<S:
return errLE
cpa-L
ke E:KeyGen
/c.sc/p.sc/a.sc./e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mRº:
c:=E:Enc¹ke;mLº
return cThe statements in-
volving the encryption
scheme Ehave been
factored out in terms
ofLcpa-L.
We have now reached the half-way point of the proof. The proof proceeds by re-
placingLcpa-L withLcpa-R (so that mRrather than mLis encrypted), applying the same
modi/f_ications as before (but in reverse order), to /f_inally arrive at Lcca-R. The repetitive
details have been omitted, but we mention that when listing the same steps in reverse,
the changes appear very bizarre indeed. For instance, we add an unreachable statement
to the /d.sc/e.sc/c.scsubroutine; we create a redundant variable Twhose contents are the same as
S; we mysteriously change one instance of S(the condition of the second if-statement in
/d.sc/e.sc/c.sc) to refer to the other variable T. Of course, all of this is so that we can factor out the
statements referring to the MAC scheme (along with T) in terms ofLmac-fake and /f_inally
197Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
replaceLmac-fake withLmac-real . 
Exercises
10.1. Consider the following MAC scheme, where Fis a secure PRF with in=out=λ:
KeyGen :
k f0;1gλ
return kMAC¹k;m1kk m`º:// each miisλbits
m:=0λ
fori=1to`:
m:=mmi
return F¹k;mº
Show that the scheme is not a secure MAC. Describe a distinguisher and compute its
advantage.
10.2. Consider the following MAC scheme, where Fis a secure PRF with in=out=λ:
KeyGen :
k f0;1gλ
return kMAC¹k;m1kk m`º:// each miisλbits
t:=0λ
fori=1to`:
t:=tF¹k;miº
return t
Show that the scheme is not a secure MAC. Describe a distinguisher and compute its
advantage.
10.3. Suppose MAC is a secure MAC algorithm. De/f_ine a new algorithm MAC0¹k;mº=
MAC¹k;mºkMAC¹k;mº. Prove that MAC0is also a secure MAC algorithm.
Note: MAC0cannot be a secure PRF. This shows that MAC security is diﬀerent than PRF
security.
10.4. Suppose MAC is a secure MAC scheme, whose outputs are `bits long. Show that there is
an eﬃcient adversary that breaks MAC security ( i.e., distinguishes the relevant libraries)
with advantage Θ¹12`º. This implies that MAC tags must be reasonably long in order to
be secure.
10.5. Suppose we use CBC-MAC with message space M=¹f0;1gλº. In other words, a single
MAC key will be used on messages of anylength that is an exact multiple of the block
length. Show that the result is nota secure MAC. Construct a distinguisher and compute
its advantage.
Hint:Request a MAC on two single-block messages, then use the result to forge the MAC of a two-block
message.
?10.6. Here is a diﬀerent way to extend CBC-MAC for mixed-length messages, when the length
of each message is known in advance. Assume that Fis a secure PRF with in=out=λ.
/n.sc/e.sc/w.sc/m.sc/a.sc/c.scF¹k;m1kk m`º:
k:=F¹k; `º
return /c.sc/b.sc/c.sc/m.sc/a.sc/c.scF¹k;m1kk m`º
198Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
Prove that this scheme is a secure MAC for message space M=¹f0;1gλº. You can use
the fact that CBC-MAC is secure for messages of /f_ixed-length.
10.7. Let Ebe a CPA-secure encryption scheme and Mbe a secure MAC. Show that the following
encryption scheme (called encrypt & MAC) is notCCA-secure:
E&M:KeyGen :
ke E:KeyGen
km M:KeyGen
return¹ke;kmºE&M:Enc¹¹ke;kmº;mº:
c:=E:Enc¹ke;mº
t:=M:MAC¹km;mº
return¹c;tºE&M:Dec¹¹ke;kmº;¹c;tºº:
m:=E:Dec¹ke;cº
ift,M:MAC¹km;mº:
return err
return m
Describe a distinguisher and compute its advantage.
10.8. Let Ebe a CPA-secure encryption scheme and Mbe a secure MAC. Show that the following
encryption scheme Σ(which I call encrypt-and-encrypted-MAC) is notCCA-secure:
Σ:KeyGen :
ke E:KeyGen
km M:KeyGen
return¹ke;kmºΣ:Enc¹¹ke;kmº;mº:
c:=E:Enc¹ke;mº
t:=M:MAC¹km;mº
c0 E:Enc¹ke;tº
return¹c;c0ºΣ:Dec¹¹ke;kmº;¹c;c0ºº:
m:=E:Dec¹ke;cº
t:=E:Dec¹ke;c0º
ift,M:MAC¹km;mº:
return err
return m
Describe a distinguisher and compute its advantage.
?10.9. In Construction 7.4, we encrypt one plaintext block into two ciphertext blocks. Imagine
applying the Encrypt-then-MAC paradigm to this encryption scheme, but (erroneously)
computing a MAC of only the second ciphertext block.
In other words, let Fbe a PRF with in=out=λ, and let Mbe a MAC scheme for message
spacef0;1gλ. De/f_ine the following encryption scheme:
KeyGen :
ke f0;1gλ
km M:KeyGen
return¹ke;kmºEnc¹¹ke;kmº;mº:
r f0;1gλ
x:=F¹ke;rºm
t:=M:MAC¹km;xº
return¹r;x;tºDec¹¹ke;kmº;¹r;x;tºº:
ift,M:MAC¹km;xº:
return err
else return F¹ke;rºx
Show that the scheme does nothave CCA security. Describe a successful attack and com-
pute its advantage.
Hint:Suppose¹r;x;tºand¹r0;x0;t0ºare valid encryptions, and consider Dec¹¹ke;kmº;¹r0;x;tººxx0:
10.10. When we combine diﬀerent cryptographic ingredients ( e.g., combining a CPA-secure en-
cryption scheme with a MAC to obtain a CCA-secure scheme) we generally require the
two ingredients to use separate, independent keys. It would be more convenient if the entire
scheme just used a single λ-bit key.
(a) Suppose we are using Encrypt-then-MAC, where both the encryption scheme and
MAC have keys that are λbits long. Refer to the proof of security of Claim 12.5 and
199Draft: January 3, 2021 CHAPTER 10. MESSAGE AUTHENTICATION CODES
describe where it breaks down when we modify Encrypt-then-MAC to use the same
key for both the encryption & MAC components:
KeyGen :
k f0;1gλ
return kEnc¹k;mº:
c:=E:Enc¹k;mº
t:=M:MAC¹k;cº
return¹c;tºDec¹k;¹c;tºº:
ift,M:MAC¹k;cº:
return err
return E:Dec¹k;cº
(b) While Encrypt-then-MAC requires independent keys keandkmfor the two compo-
nents, show that they can both be derived from a single key using a PRF.
In more detail, let Fbe a PRF with in=1andout=λ. Prove that the following
modi/f_ied Encrypt-then-MAC construction is CCA-secure:
KeyGen :
k f0;1gλ
return kEnc¹k;mº:
ke:=F¹k;0º
km:=F¹k;1º
c:=E:Enc¹ke;mº
t:=M:MAC¹km;cº
return¹c;tºDec¹k;¹c;tºº:
ke:=F¹k;0º
km:=F¹k;1º
ift,M:MAC¹km;cº:
return err
return E:Dec¹ke;cº
You should not have to re-prove all the tedious steps of the Encrypt-then-MAC security
proof. Rather, you should apply the security of the PRF in order to reach the original
Encrypt-then-MAC construction, whose security we already proved (so you don’t have
to repeat).
20011Hash Functions
Suppose you share a huge /f_ile with a friend, but you are not sure whether you both have
the same version of the /f_ile. You could send your version of the /f_ile to your friend and they
could compare to their version. Is there any way to check that involves less communication
than this?
Let’s call your version of the /f_ile x(a string) and your friend’s version /y.alt. The goal
is to determine whether x=/y.alt. A natural approach is to agree on some deterministic
function H, compute H¹xº, and send it to your friend. Your friend can compute H¹/y.altºand,
since His deterministic, compare the result to your H¹xº. In order for this method to be
fool-proof, we need Hto have the property that diﬀerent inputs always map to diﬀerent
outputs — in other words, Hmust be injective (1-to-1). Unfortunately, if His injective
andH:f0;1gin!f 0;1goutis injective, then out>in. This means that sending H¹xºis
no better/shorter than sending xitself!
Let us call a pair¹x;/y.altºacollision inHifx,/y.altandH¹xº=H¹/y.altº. An injective
function has no collisions. One common theme in cryptography is that you don’t always
need something to be impossible ; it’s often enough for that thing to be just highly unlikely.
Instead of saying that Hshould have nocollisions, what if we just say that collisions should
be hard (for polynomial-time algorithms) to /f_ind? An Hwith this property will probably
be good enough for anything we care about. It might also be possible to construct such an
Hwith outputs that are shorter than its inputs!
What we have been describing is exactly a cryptographic hash function. A hash
function has long inputs and short outputs — typically H:f0;1g!f 0;1gn. Such an H
must necessarily have many collisions. The security property of a hash function is that it
is hard to /f_ind any such collision. Another good name for a hash function (which I just
made up, and no one else uses) would be a “pseudo-injective” function. Although it is not
injective, it behaves like one for our purposes.
11.1 Security Properties for Hash Functions
There are two common security properties of hash functions:
Collision resistance. It should be hard to compute any collision x,x0such that H¹xº=
H¹x0º.
Second-preimage resistance. Given x, it should be hard to compute any collision in-
volving x. In other words, it should be hard to compute x0,xsuch that H¹xº=
H¹x0º.
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
Brute Force A/t_tacks on Hash Functions
There is an important diﬀerence between collision resistance and second-preimage resis-
tance, which is re/f_lected in the diﬃculty of their respective brute force attacks. Suppose
His a hash function whose outputs are nbits long. Let’s make a simplifying assumption
that for any m>n, the following distribution is roughly uniform over f0;1gn:
x f0;1gm
return H¹xº
This is quite a realistic assumption for practical hash functions. If this were not true, then
Hwould introduce some bias towards some outputs and away from other outputs, which
would be perceived as suspicious. Also, as the output of Hdeviates farther from a uniform
distribution, it only makes /f_inding collisions easier.
Below are straight-forward brute-force attacks for collision resistance (left) and
second-preimage resistance (right):
Collision brute force:
Acr¹º:
fori=1; : : ::
xi f0;1gm
/y.alti:=H¹xiº
if there is some j<iwith xi,xj
but/y.alti=/y.altj:
return¹xi;xjºSecond preimage brute force:
A2pi¹xº:
while true :
x0 f0;1gm
/y.alt0:=H¹x0º
if/y.alt0=H¹xº: return x0
Under the simplifying assumption on H, the collision-resistance brute force attack Acris
essentially choosing each /y.altiuniformly at random. Since each /y.alti2f0;1gn, the probability
of /f_inding a repeated value after qtimes through the main loop is roughly Θ¹q22nºby
the birthday bound. While in the worst case it could take 2nsteps to /f_ind a collision in
H, the birthday bound implies that it takes only 2n2attempts to /f_ind a collision with 99%
probability (or any constant probability).
On the other hand, the second-preimage brute force attack A2piis given/y.altas input
and (under our simplifying assumption on H) essentially samples /y.alt0uniformly at random
until/y.altis the result. It will therefore take Θ¹2nºattempts in expectation to terminate
successfully.1
There is a fundamental diﬀerence in how hard it is to break collision resistance and
second-preimage resistance. Breaking collision-resistance is like inviting more people into
the room until the room contains 2 people with the same birthday. Breaking second-
preimage resistance is like inviting more people into the room until the room contains
another person with your birthday. One of these fundamentally takes longer than the
other.
1A well-known and useful fact from probability theory is that if an event happens with probability p,
then the expected number of times to repeat before seeing the event is 1p. For example, the probability of
rolling a 1 on a /d.sc6die is 1/6, so it takes 6 rolls in expectation before seeing a 1. The probability of sampling a
particular/y.altfromf0;1gnin one try is 12n, so the expected number of trials before seeing /y.altis2n.
202Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
This diﬀerence explains why you will typically see cryptographic hash functions in
practice that have 256- to 512-bit output length (but not 128-bit output length), while you
only typically see block ciphers with 128-bit or 256-bit keys. In order to make brute force
attacks cost 2n, a block cipher needs only an n-bit key while a collision-resistant hash
function needs a 2n-bit output.
to-do Discussion of these attacks in terms of graphs, where # of edges is the “number of chances”
to get a collision. Collision-resistance brute force is a complete graph (needp
Nvertices to
have Nedges / chances for a collision) . Second-preimage brute force is a star graph (need N
vertices to Nedges). Can generalize to consider complete bipartite graph betweenp
N+p
N
vertices.
Hash Function Security In Practice
We will focus on developing a formal de/f_inition for collision resistance. We can take some
inspiration from the security de/f_inition for MACs. Security for a MAC means that it should
be hard to produce a forgery. The MAC security de/f_inition formalized that idea with one
library that checks for a forgery and another library that assumes a forgery is impossible.
If the two libraries are indistinguishable, then it must be hard to /f_ind a forgery.
We can take a similar approach to say that it should be hard to produce a collision.
Here is an attempt:
/t.sc/e.sc/s.sc/t.sc¹x;x0º:
ifx,x0andH¹xº=H¹x0º: return true
else: return false/t.sc/e.sc/s.sc/t.sc¹x;x0º:
return false
This corresponds to what I would call the “folk de/f_inition” of collision resistance. It makes
intuitive sense (as long as you’re comfortable with our style of security de/f_inition), but
unfortunately the de/f_inition suﬀers from a very subtle technical problem.
Because of Kerckhoﬀs’ principle, we allow calling programs to depend arbitrarily on
the source code of the two libraries. This is a way of formalizing the idea that “the attacker
knows everything about the algorithms.” Our security de/f_initions restrict calling programs
to be polynomial-time algorithms, but they never consider the eﬀort that goes into /f_inding
the source code of the calling program!
This strange loophole leads to the following valid attack. When we consider the se-
curity of some function H, we know that there exists many collisions ¹x;x0ºinH. These
collisions may be hard to /f_ind, but they certainly exist. With exponential time, we could
/f_ind such an¹x;x0ºpair and write down the code of an attacker:
A:
return /t.sc/e.sc/s.sc/t.sc¹x;x0º
Here, the values xandx0are hard-coded into A. The algorithmAis clearly polynomial-
time (in fact, constant time). The “loophoole” is that the de/f_inition considers only the cost
ofrunning the algorithmA, and not the cost of /f_inding the source code of A.
203Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
The way this kind of situation is avoided in other security de/f_initions is that the li-
braries have some secret randomness. While the attacker is allowed to depend arbitrarily
on the source code of the libraries, it is not allowed to depend on the choice of outcomes
for random events in the libraries, like sampling a secret key. Since the calling program
can’t “prepare” for the random choice that it will be faced with, we don’t have such trivial
attacks. On the other hand, these two libraries for collision resistance are totally deter-
ministic. There are no “surprises” about which function Hthe calling program will be
asked to compute a collision for, so there is nothing to prevent a calling program from
being “prepared” with a pre-computed collision in H.
Hash Function Security In Theory
The way around this technical issue is to introduce some randomness into the libraries
and into the inputs of H. We de/f_ine hash functions to take two arguments: a randomly
chosen, public value scalled a salt, and an adversarially chosen input x.
Definition 11.1 A hash function Hiscollision-resistant ifLH
cr-realLH
cr-fake, where:
LH
cr-real
s f0;1gλ
/g.sc/e.sc/t.sc/s.sc/a.sc/l.sc/t.sc¹º:
return s
/t.sc/e.sc/s.sc/t.sc¹x;x02f0;1gº:
ifx,x0andH¹s;xº=H¹s;x0º: return true
return falseLH
cr-fake
s f0;1gλ
/g.sc/e.sc/t.sc/s.sc/a.sc/l.sc/t.sc¹º:
return s
/t.sc/e.sc/s.sc/t.sc¹x;x02f0;1gº:
return false
The library initially samples the salt s. Unlike in other libraries, this value sis meant
to be provided to the calling program, and so the library provides a way ( /g.sc/e.sc/t.sc/s.sc/a.sc/l.sc/t.sc ) for the
calling program to learn it. The calling program then attempts to /f_ind a collision x,x0
where H¹s;xº=H¹s;x0º.
I don’t know why the term “salt” is used with hash functions. The reason appears to be
a mystery to the Internet.2Think of salt as an extra value that “personalizes” the hash
function for a given application. Here is a good analogy: an encryption scheme can be
thought of as a diﬀerent encryption algorithm Enc¹k;ºfor each choice of key k. When I
choose a random k, I get a personalized encryption algorithm Enc¹k;ºthat is unrelated
to the algorithm Enc¹k0;ºthat someone else would get when they choose their own k.
When I choose a salt s, I get a personalized hash function H¹s;ºthat is unrelated to other
H¹s0;ºfunctions. Because the salt is chosen uniformly from f0;1gλ, a calling program
cannot predict what salt (which personalized hash function) it will be challenged with.
De/f_inition 11.1 is a valid de/f_inition for collision resistance, free of strange loopholes
like the “folklore” de/f_inition. However, it is not a particularly useful de/f_inition to use
in security proofs, when a hash function is used as a building block in a bigger system.
2If you have an additional random argument to a hash function, but you keep it secret, it is called a
“pepper.” I’m serious, this is a real thing.
204Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
It becomes cumbersome to use in those cases, because when you use a hash function,
you typically don’t explicitly check whether you’ve seen a collision. Instead, you simply
proceed as if collisions are not going to happen.
In this chapter, we won’t see provable statements of security referring to this de/f_ini-
tion.
Salts in Practice
When we de/f_ine hash functions in theory, we require that the hash function accept two
inputs, the /f_irst of which is interpreted as a salt. The hash functions that you see in practice
have only one input, a string of arbitrary length. You can simulate the eﬀect of a salt for
such a hash function by simply concatenating the two inputs — e.g.,H¹skxºinstead of
H¹s;xº.
The concept of a salted hash is not just useful to make a coherent security de/f_inition, it
is also just good practice. Hash functions are commonly used to store passwords. A server
may store user records of the form ¹username ;h=H¹passwordºº. When a user attempts
to login with password p0, the server computes H¹p0ºand compares it to h. Storing hashed
passwords means that, in the event that the password /f_ile is stolen, an attacker would need
to /f_ind a preimage of hin order to impersonate the user.
Best practice is to use a separate salt for each user. Instead of stor-
ing¹username ;H¹passwordºº, choose a random salt sfor each user and store
¹username ;s;H¹s;passwordºº. The security properties of a hash function do not require s
to be secret, although there is also no good reason to broadcast a user’s salt publicly. The
salt is only needed by the server, when it veri/f_ies a password during a login attempt.
A user-speci/f_ic salt means that each user gets their own “personalized” hash function
to store their password. Salts oﬀer the following bene/f_its:
IWithout salts, it would be evident when two users have the same password — they
would have the same password hashes. The same password hashed with diﬀerent
salts will result in unrelated hash outputs.
IAn attacker can compute a dictionary of ¹p;H¹pººfor common passwords. Without
salts, this dictionary makes it easy to attack all users at once, since all users are using
the same hash function. With salts, each user has a personalized hash function, each
of which would require its own dictionary. Salt makes an attacker’s eﬀort scale with
the number of victims.
11.2 Merkle-Damgård Construction
Building a hash function, especially one that accepts inputs of arbitrary length, seems like
a challenging task. In this section, we’ll see one approach for constructing hash functions,
called the Merkle-Damgård construction.
Instead of a full-/f_ledged hash function, imagine that we had a collision-resistant func-
tion whose inputs were of a single /f_ixed length, but longer than its outputs. In other words,
h:f0;1gn+t!f0;1gn, where t>0. We call such an hacompression function . This is
not compression in the usual sense of the word — we are not concerned about recovering
205Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
the input from the output. We call it a compression function because it “compresses” its
input by tbits (analogous to how a pseudorandom generator “stretches” its input by some
amount).
The following construction is one way to build a full-/f_ledged hash function (supporting
inputs of arbitrary length) out of such a compression function:
Construction 11.2
(Merkle-Damgård)Leth:f0;1gn+t!f0;1gnbe a compression function. Then the Merkle-Damgård trans-
formation ofhisMDh:f0;1g!f0;1gn, where:
/m.sc/d.sc/p.sc/a.sc/d.sc t¹xº
`:=jxj, as length- tbinary number
whilejxjnot a multiple of t:
x:=xk0
return xk`MD h¹xº:
x1kk xk+1:=/m.sc/d.sc/p.sc/a.sc/d.sc t¹xº
// each xiistbits
/y.alt0:=0n
fori=1tok+1:
/y.alti:=h¹/y.alti 1kxiº
output/y.altk+1
h h h h h  MDh¹xº/y.alt0x= x1 x2 x3 xkjxj
The idea of the Merkle-Damgård construction is to split the input xinto blocks of size
t. The end of the string is /f_illed out with 0s if necessary. A /f_inal block called the “padding
block” is added, which encodes the (original) length of xin binary.
Example Suppose we have a compression function h:f0;1g48!f 0;1g32, so that t=16. We build
a Merkle-Damgård hash function out of this compression function and wish to compute the
hash of the following 5-byte (40-bit) string:
x=01100011 11001101 01000011 10010111 01010000
We must /f_irst pad xappropriately ( /m.sc/d.sc/p.sc/a.sc/d.sc¹xº):
ISince xis not a multiple of t=16bits, we need to add 8 bits to make it so.
ISincejxj=40, we need to add an extra 16-bit block that encodes the number 40 in
binary ( 101000 ).
After this padding, and splitting the result into blocks of length 16, we have the following:
01100011 11001101|                    {z                    }
x101000011 10010111|                    {z                    }
x201010000 00000000|                    {z                    }
x300000000 00101000|                    {z                    }
x4
The /f_inal hash of xis computed as follows:
206Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
h h h h MDh¹xº
03201100011 11001101 01000011 10010111 01010000 00000000 00000000 00101000xz                                               }|                                               {MD paddingz                        }|                        {
We are presenting a simpli/f_ied version, in which MD haccepts inputs whose maxi-
mum length is 2t 1bits (the length of the input must /f_it into tbits). By using multiple
padding blocks (when necessary) and a suitable encoding of the original string length, the
construction can be made to accommodate inputs of arbitrary length (see the exercises).
The value/y.alt0is called the initialization vector (IV), and it is a hard-coded part of the
algorithm.
As discussed above, we will not be making provable security claims using the library-
style de/f_initions. However, we can justify the Merkle-Damgård construction with the fol-
lowing claim:
Claim 11.3 Suppose his a compression function and MDhis the Merkle-Damgård construction applied
toh. Given a collision x;x0inMDh, it is easy to /f_ind a collision in h. In other words, if it is
hard to /f_ind a collision in h, then it must also be hard to /f_ind a collision in MDh.
Proof Suppose that x;x0are a collision under MD h. De/f_ine the values x1; : : : ; xk+1and
/y.alt1; : : : ;/y.altk+1as in the computation of MD h¹xº. Similarly, de/f_ine x0
1; : : : ; x0
k0+1and
/y.alt0
1; : : : ;/y.alt0
k0+1as in the computation of MD h¹x0º. Note that, in general, kmay not equal
k0.
Recall that:
MD h¹xº=/y.altk+1=h¹/y.altkkxk+1º
MD h¹x0º=/y.alt0
k0+1=h¹/y.alt0
k0kx0
k0+1º
Since we are assuming MD h¹xº=MD h¹x0º, we have/y.altk+1=/y.alt0
k0+1. We consider two cases:
Case 1: Ifjxj,jx0j, then the padding blocks xk+1andx0
k0+1which encodejxjandjx0jare
not equal. Hence we have /y.altkkxk+1,/y.alt0
k0kx0
k0+1, so/y.altkkxk+1and/y.alt0
k0kx0
k0+1are a collision
under hand we are done.
Case 2: Ifjxj=jx0j, then xandx0are broken into the same number of blocks, so k=k0.
Let us work backwards from the /f_inal step in the computations of MD h¹xºandMD h¹x0º.
We know that:
/y.altk+1=h¹/y.altkkxk+1º
=
/y.alt0
k+1=h¹/y.alt0
kkx0
k+1º
If/y.altkkxk+1and/y.alt0
kkx0
k+1are not equal, then they are a collision under hand we are done.
Otherwise, we can apply the same logic again to /y.altkand/y.alt0
k, which are equal by our as-
sumption.
More generally, if /y.alti=/y.alt0
i, then either /y.alti 1kxiand/y.alt0
i 1kx0
iare a collision under h(and
we say we are “lucky”), or else /y.alti 1=/y.alt0
i 1(and we say we are “unlucky”). We start with the
207Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
premise that /y.altk=/y.alt0
k. Can we ever get “unlucky” every time, and not encounter a collision
when propagating this logic back through the computations of MD h¹xºandMD h¹x0º? The
answer is no, because encountering the unlucky case every time would imply that xi=x0
i
foralli. That is, x=x0. But this contradicts our original assumption that x,x0. Hence
we must encounter some “lucky” case and therefore a collision in h. 
11.3 Hash Functions vs. MACs: Length-Extension A/t_tacks
When we discuss hash functions, we generally consider the salt sto be public. A natural
question is, what happens when we make the salt private? Of all the cryptographic
primitives we have discussed so far, a hash function with secret salt most closely resembles
a MAC. So, do we get a secure MAC by using a hash function with private salt?
Unfortunately, the answer is no in general (although it can be yes in some cases, de-
pending on the hash function). In particular, the method is insecure when His constructed
using the Merkle-Damgård approach. The key observation is that:
knowing H¹xºallows you to predict the hash of any string that begins with
/m.sc/d.sc/p.sc/a.sc/d.sc¹xº.
This concept is best illustrated by example.
Example Let’s return to our previous example, with a compression function h:f0;1g48!f 0;1g32.
Suppose we construct a Merkle-Damgård hash out of this compression function, and use the
construction MAC¹k;mº=H¹kkmºas a MAC.
Suppose the MAC key is chosen as k=01100011 11001101 , and an attacker sees the MAC
tagtof the message m=01000011 10010111 01010000 . Then t=H¹kkmºcorresponds
exactly to the example from before:
h h h h t
03201100011 11001101 01000011 10010111 01010000 00000000 00000000 00101000kz             }|             {mz                        }|                        {MD paddingz                        }|                        {
The only diﬀerence from before is that the /f_irst block contains the MAC key, so its value
is not known to the attacker. We have shaded it in gray here. The attacker knows all other
inputs as well as the output tag t.
I claim that the attacker can now exactly predict the tag of:
m0=01000011 10010111 01010000 00000000 00000000 00101000
The correct MAC tag t0of this value would be computed by someone with the key as:
208Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
same computation as in MAC¹k;mºh h h h h
(t)t0
03201100011 11001101 01000011 10010111 01010000 00000000 00000000 00101000 00000000 01000000kz             }|             {m0
z                                                          }|                                                          {MD paddingz             }|             {
The attacker can compute the output t0in a diﬀerent way, without knowing the key. In
particular, the attacker knows all inputs to the last instance of h. Since the hfunction itself is
public, the attacker can compute this value herself as t0=h¹tk00000000 01000000 º. Since
she can predict the tag of m0, having seen only the tag of m, she has broken the MAC scheme.
Discussion
IIn our example, the attacker sees the MAC tag for m(computed as H¹kkmº) and then
forges the tag for m0=mkp, where pis the padding you must add when hashing
kkm. Note that the padding depends only on the length ofk, which we assume is
public.
IThe same attack works to forge the tag of any m0thatbegins with mkp. The attacker
would simply have to compute the last several rounds (not just one round) of Merkle-
Damgård herself.
IThis is not an attack on collision resistance! Length-extension does not result
in collisions! We are not saying that kkmandkkmkphave the same hash under H,
only that knowing the hash of kkmallows you to also compute the hash of kkmkp.
Knowing how H¹kkmºfails to be a MAC helps us understand better ways to build a
secure MAC from a hash function:
IThe Merkle-Damgård approach suﬀers from length-extension attacks because it out-
puts its entire internal state . In the example picture above, the value tis both the
output of H¹kkmºas well as the only information about kkmneeded to compute the
last call to hin the computation H¹kkmkpº.
One way to avoid this problem is to only output part of the internal state. In Merkle-
Damgård, we compute /y.alti:=h¹/y.alti 1kxiºuntil reaching the /f_inal output /y.altk+1. Suppose
instead that we only output half of /y.altk+1(the/y.altivalues may need to be made longer
in order for this to make sense). Then just knowing half of /y.altk+1is not enough to
predict what the hash output will be in a length-extension scenario.
The hash function SHA-3 was designed in this way (often called a “wide pipe” con-
struction). One of the explicit design criteria of SHA-3 was that H¹kkmºwould be a
secure MAC.
ILength extension with Merkle-Damgård is possible because the computation of
H¹kkmºexactly appears during the computation of H¹kkmkpº. Similar problems
209Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
appear in plain CBC-MAC when used with messages of mixed lengths. To avoid
this, we can “do something diﬀerent” to mark the end of the input. In a “wide pipe”
construction, we throw away half of the internal state at the end. In ECBC-MAC,
we use a diﬀerent key for the last block of CBC chaining.
We can do something similar to the H¹kkmºconstruction, by doing H¹k2kH¹k1kmºº,
with independent keys. This change is enough to mark the end of the input.
This construction is known as NMAC , and it can be proven secure for Merkle-
Damgård hash functions, under certain assumptions about their underlying com-
pression function. A closely related (and popular) construction called HMAC allows
k1andk2to even be related in some way.
Exercises
11.1. Sometimes when I verify an MD5 hash visually, I just check the /f_irst few and the last few
hex digits, and don’t really look at the middle of the hash.
Generate two /f_iles with opposite meanings, whose MD5 hashes agree in their /f_irst 16 bits
(4 hex digits) and in their last 16 bits (4 hex digits). It could be two text /f_iles that say
opposite things. It could be an image of Mario and an image of Bowser. I don’t know, be
creative.
As an example, the strings “ subtitle illusive planes ” and “ wantings premises
forego ” actually agree in the /f_irst 20 and last 20 bits (/f_irst and last 5 hex digits) of their
MD5 hashes, but it’s not clear that they’re very meaningful.
$ echo -n "subtitle illusive planes" | md5sum
4188d 4cdcf2be92a112bdb8ce4500243 -
$ echo -n "wantings premises forego" | md5sum
4188d 209a75e1a9b90c6fe3efe300243 -
Describe how you generated the /f_iles, and how many MD5 evaluations you had to make.
11.2. Let h:f0;1gn+t!f 0;1gnbe a /f_ixed-length compression function. Suppose we forgot
a few of the important features of the Merkle-Damgård transformation, and construct a
hash function Hfrom has follows:
ILetxbe the input.
ISplit xinto pieces /y.alt0;x1;x2; : : : ; xk, where/y.alt0isnbits, and each xiistbits. The last
piece xkshould be padded with zeroes if necessary.
IFori=1tok, set/y.alti=h¹/y.alti 1kxiº.
IOutput/y.altk.
Basically, it is similar to the Merkle-Damgård except we lost the IV and we lost the /f_inal
padding block.
1. Describe an easy way to /f_ind two messages that are broken up into the same number
of pieces, which have the same hash value under H.
210Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
2. Describe an easy way to /f_ind two messages that are broken up into diﬀerent number
of pieces, which have the same hash value under H.
Hint:Pick any string of length n+2t, then /f_ind a shorter string that collides with it.
Neither of your collisions above should involve /f_inding a collision in h.
11.3. I’ve designed a hash function H:f0;1g!f0;1gn. One of my ideas is to make H¹xº=x
ifxis an n-bit string (assume the behavior of His much more complicated on inputs of
other lengths). That way, we know with certainty that there are no collisions among n-bit
strings. Have I made a good design decision?
11.4. Same as above, but now if xisnbits long, then H¹xº=xm, where mis a /f_ixed, public
string. Can this be a good hash function?
11.5. Let Hbe a hash function and let tbe a /f_ixed constant. De/f_ine H¹tºas:
H¹tº¹xº=H¹H¹H|      {z      }
ttimes¹xººº :
Show that if you are given a collision under H¹tºthen you can eﬃciently /f_ind a collision
under H.
11.6. In this problem, if xand/y.altare strings of the same length, then we write xv/y.altifx=/y.altor
xcomes before /y.altin standard dictionary ordering.
Suppose a function H:f0;1g!f0;1gnhas the following property. For all strings xand
/y.altof the same length, if xv/y.altthen H¹xºvH¹/y.altº. Show that Hisnotcollision resistant
(describe how to eﬃciently /f_ind a collision in such a function).
Hint:Binary search, always recursing on a range that is guaranteed to contain a collision.
?11.7. Suppose a function H:f0;1g!f 0;1gnhas the following property. For all strings x
and/y.altof the same length, H¹x/y.altº=H¹xºH¹/y.altº. Show that Hisnotcollision resistant
(describe how to eﬃciently /f_ind a collision in such a function).
?11.8. Let Hbe a salted hash function with nbits of output, and de/f_ine the following function:
H¹x1kx2kx3kk xkº:
return H¹1;x1ºH¹2;x2º H¹k;xkº
Note that Hcan take inputs of any length ( k). Show how to /f_ind collisions in Hwhen
k>n.
11.9. Generalize the Merkle-Damgård construction so that it works for arbitrary input lengths
(and arbitrary values of tin the compression function). Extend the proof of Claim 11.3 to
your new construction.
?11.10. Let Fbe a secure PRF with n-bit inputs, and let Hbe a collision-resistant (salted) hash
function with n-bit outputs. De/f_ine the new function F0¹¹k;sº;xº=F¹k;H¹s;xºº, where
we interpret¹k;sºto be its key. Prove that F0is a secure PRF with arbitrary-length inputs.
211Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
?11.11. Let MAC be a secure MAC algorithm with n-bit inputs, and let Hbe a collision-resistant
(salted) hash function with n-bit outputs. De/f_ine the new function MAC0¹¹k;sº;xº=
MAC¹k;H¹s;xºº, where we interpret ¹k;sºto be its key. Prove that MAC0is a secure MAC
with arbitrary-length inputs.
11.12. More exotic issues with the Merkle-Damgård construction:
(a) Let Hbe a hash function with n-bit output, based on the Merkle-Damgård construc-
tion. Show how to compute (with high probability) 4 messages that all hash to the
same value under H, using only22n2calls to H.
Hint:The 4 messages that collide will have the form xk/y.alt,xk/y.alt0,x0k/y.altandx0k/y.alt0. Use a length-
extension idea and perform 2 birthday attacks.
(b) Show how to construct 2dmessages that all hash to the same value under H, using
only O¹d2n2ºevaluations of H.
(c) Suppose H1andH2are (diﬀerent) hash functions, both with n-bit output. Consider the
function H¹xº=H1¹xºkH2¹xº. Since Hhas2n-bit output, it is tempting to think that
/f_inding a collision in Hwill take 2¹2nº2=2neﬀort.
However, this intuition is not true when H1is a Merkle-Damgård hash. Show that
when H1is Merkle-Damgård, then it is possible to /f_ind collisions in Hwith only
O¹n2n2ºeﬀort. The attack should assume nothing about H2(i.e., H2need not be
Merkle-Damgård).
Hint:Applying part (b), /f_irst /f_ind a set of 2n2messages that all have the same hash under H1. Among
them, /f_ind 2 that also collide under H2.
11.13. Let Hbe a collision-resistant hash function with output length n. Let Hdenote iterating
Hin a manner similar to CBC-MAC:
H¹x1x`º:
// each xiisnbits
/y.alt0:=0n
fori=1to`:
/y.alti:=H¹xi/y.alti 1º
return/y.altiH H H x1 x2 x`
H¹xº

Show that Hisnotcollision-resistant. Describe a successful attack.
11.14. Show that a bare PRP is not collision resistant. In other words, if Fis a secure PRP, then
show how to eﬃciently /f_ind collisions in H¹xk/y.altº=F¹x;/y.altº.
11.15. Show that the CBC-MAC construction applied to a PRP is not collision-resistant. More
precisely, let Fbe a secure PRP. Show how to eﬃciently /f_ind collisions in the following
212Draft: January 3, 2021 CHAPTER 11. HASH FUNCTIONS
salted hash function H:
H¹k;m1km2km3º:
c1:=F¹k;m1º
c2:=F¹k;m2c1º
c3:=F¹k;m3c2º
return c3
Here we are interpreting kas the salt. This is yet another example of how collision-
resistance is diﬀerent than authenticity (MAC).
11.16. Let H:f0;1gλ! f 0;1gλbe any function, and de/f_ine the following function H:
f0;1g2λ!f0;1gλ:
H¹xk/y.altº:
z:=H¹xº/y.alt
return H¹zºx
Show how to succeed in an eﬃcient second-preimage attack on H.
11.17. Adding a plain hash to a plaintext does not result in CCA security. Consider the following
approach for encryption, that uses a plain (unsalted) hash function H. To encrypt plaintext
m, simply encrypt mkH¹mºunder CTR mode. To decrypt, use normal CTR mode decryp-
tion but return errif the plaintext does not have the form mkH¹mº(i.e., if the last nbits
are not a hash of the rest of the CTR-plaintext).
Show that the scheme does nothave CCA security.
11.18. In the discussion of length-extension attacks, we noted that a natural way to stop them is to
“do something diﬀerent” for the last block of Merkle-Damgård. Suppose after performing
the /f_inal call to hin Merkle-Damgård, we complement the value ( /y.altk+1º. Does this modi/f_ied
scheme still have length-extension properties?
21312Authenticated Encryption & AEAD
to-do Disclaimer: This chapter is in rough draft stage.
It can be helpful to think of encryption as providing a secure logical channel between
two users who only have access to an insecure physical channel. Below are a few things
that an attacker might do to the insecure physical channel:
IAn attacker may passively eavesdrop ;i.e., simply observe the channel. A CPA-
secure encryption scheme provides con/f_identiality and prevents the attacker from
learning anything by eavesdropping.
IAn attacker may drop messages sent along the channel, resulting in a denial of
service. If the attacker can do this on the underlying physical channel, then it cannot
be overcome through cryptography.
IAn attacker may try to modify messages that are sent along the channel, by tamper-
ing with their ciphertexts. This sounds like what CCA-secure encryption protects
against, right?
IAn attacker may try to inject new messages into the channel. If successful, Bob
might receive a message and mistake it for something that Alice meant to send.
Does CCA security protect against this? If it is indeed possible to inject new mes-
sages into the channel, then an attacker can delete Alice’s ciphertexts and replace
them with their own. This would seem to fall under the category of “modifying”
messages on the channel, so message-injection and message-modi/f_ication are some-
what connected.
IAn attacker may try to replay messages that were sent. For example, if Bob was
convinced that a ciphertext ccame from Alice, then an attacker can re-send the
same cmany times, and Bob may interpret this as Alice wanting to re-send the
same plaintext many times. Does CCA security protect against this?
Although it might seem that CCA-secure encryption guarantees protection against many
of these kinds of attacks, it does not!
To see why, consider the SPRP-based encryption scheme of Construction 9.3. We
proved that this scheme has CCA security. However, it never raises any errors during
decryption. Every ciphertext is interpreted as a valid encryption of some plaintext. An at-
tacker can choose an arbitrary ciphertext, and when Bob decrypts it he might think Alice
was trying to send some (presumably garbled) message. The only thing that CCA security
guarantees is that ifan attacker is able to make a ciphertext that decrypts without error,
then it must decrypt to something that is unrelated to the contents of other ciphertexts.
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
In order to achieve protection against message-modi/f_ication and message-injection
on the secure channel, we need a stronger/better security de/f_inition. Authenticated en-
cryption (AE) formalizes the extra property that only someone with the secret key can
/f_ind ciphertexts that decrypt without error. For example, encrypt-then-MAC (Construc-
tion 10.9) already has this property.
In this chapter we will discuss authenticated encryption and a closely-related concept
of encryption with associated data (AD) , which is designed to help prevent message-
replay attacks. These two concepts are the “gold standard” for encryption.
12.1 Definitions
Authenticated Encryption
As with CPA and CCA /f_lavors of security, we can de/f_ine AE security in both a “left-vs-
right” style or a “pseudorandom ciphertexts” style. Both are reasonable choices. To make
life simpler we will only de/f_ine the pseudorandom-ciphertexts-style of AE security in this
chapter.
In CCA$ security, the attacker has access to the decryption algorithm (except for ci-
phertexts generated by the library itself). This captures the idea that the result of de-
crypting adversarially-generated ciphertexts cannot help distinguish the contents of other
ciphertexts. For AE security, we want a stronger condition that Dec¹k;cº=errfor ev-
ery adversarially-generated ciphertext c. Using the same ideas used to de/f_ine security
for MACs, we express this requirement by saying that the attacker shouldn’t be able to
distinguish access to the “real” Decalgorithm, or one that always outputs err:
Definition 12.1
(AE)LetΣbe an encryption scheme. We say that Σhasauthenticated encryption (AE) security
ifLΣ
ae$-realLΣ
ae$-rand, where:
LΣ
ae$-real
k Σ:KeyGen
S:=;
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
c:=Σ:Enc¹k;mº
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2S: return err
return Σ:Dec¹k;cºLΣ
ae$-fake
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
c Σ:C¹jmjº
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
return err
Discussion
The two libraries are diﬀerent from each other in two major ways: whether the calling
program sees real ciphertexts or random strings (that have nothing to do with the given
plaintext), and whether the calling program sees the true result of decryption or an error
215Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
message. With these two diﬀerences, we are demanding that two conditions be true: the
calling program can’t tell whether it is seeing real or fake ciphertexts, it also cannot gener-
ate a ciphertext (other than the ones it has seen) that would cause Decto output anything
except err.
Whenever the calling program calls /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹cºfor a ciphertext cthat was produced
by the library (in /c.sc/t.sc/x.sc/t.sc ), both libraries will return errby construction. Importantly, the
diﬀerence in the libraries is the behavior of /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc on ciphertexts that were notgenerated
by the library ( i.e., generated by the attacker).
Associated Data
AE provides a secure channel between Alice and Bob that is safe from message-
modi/f_ication and message-injection by the attacker (in addition to providing con/f_iden-
tiality). However, AE still does not protect from replay of messages. If Alice sends a
ciphertext cto Bob, we know that Bob will decrypt cwithout error. The guarantee of AE
security is that Bob can be sure that the message originated from Alice in this case. If an
attacker re-sends the same cat a later time, Bob will likely interpret that as a sign that
Alice wanted to say the same thing again, even though this was not Alice’s intent. It is
still true that Alice was the originator of the message, but just not at this time.
You may wonder how it is possible to prevent this sort of attack. If a ciphertext cis
a valid ciphertext when Alice sends it, then it will always be a valid ciphertext, right?
A clever way around this problem is for Alice to not only authenticate the ciphertext as
coming from her, but to authenticate it also to a speci/f_ic context. For example, suppose
that Alice & Bob are exchanging encrypted messages, and the 5th ciphertext is c, sent by
Alice. The main idea is to let Alice authenticate the fact that “I meant to send cas the 5th
ciphertext in the conversation." If an attacker re-sends clater ( e.g., as the 11th ciphertext,
a diﬀerent context), Bob will attempt to authenticate the fact that “Alice meant to send c
as the 11th ciphertext,” and this authentication will fail.
What I have called “context” is called associated data in an encryption scheme. In
order to support associated data, we modify the syntax of the encryption and decryption
algorithms to take an additional argument d. The ciphertext c=Enc¹k;d;mºis an encryp-
tion of mwith associated data d. In an application, dcould be a sequence number of a
conversation, a hash of the entire conversation up to this point, an IP address + port num-
ber, etc. — basically, as much information as you can think of regarding this ciphertext’s
intended context. Decrypting cwith the “correct” associated data dviaDec¹k;d;cºshould
result in the correct plaintext m. Decrypting cwith any other associated data should result
in an error, since that re/f_lects a mismatch between the sender’s and receiver’s contexts.
The intuitive security requirement for authenticated encryption with associated
data (AEAD) is that an attacker who sees many encryptions ciof chosen plaintexts, each
authenticated to a particular associated data di, cannot generate a diﬀerent ¹c;dºthat
decrypts successfully. The security de/f_inition rules out attempts to modify some ciunder
the same di, or modify some difor the same ci, or produce a completely new ¹c;dº.
Definition 12.2
(AEAD)LetΣbe an encryption scheme. We write Σ:Dto denote the space of supported associated
data signi/f_iers (“contexts”). We say that Σhasauthenticated encryption with associated
data (AEAD) security ifLΣ
aead$-realLΣ
aead$-rand, where:
216Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
LΣ
aead$-real
k Σ:KeyGen
S:=;
/c.sc/t.sc/x.sc/t.sc¹d2Σ:D;m2Σ:Mº:
c:=Σ:Enc¹k;d;mº
S:=S[f¹ d;cºg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹d2Σ:D;c2Σ:Mº:
if¹d;cº2S : return err
return Σ:Dec¹k;d;cºLΣ
aead$-fake
/c.sc/t.sc/x.sc/t.sc¹c2Σ:D;m2Σ:Mº:
c Σ:C¹jmjº
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹d2Σ:D;c2Σ:Mº:
return err
Discussion
One way to “authenticate a message to some context d” is to encrypt mkdinstead of just
m(in an AE scheme). This would indeed work! Including das part of the plaintext would
indeed authenticate it, but it would also hide it. The point of diﬀerentiating between plain-
text and associated data is that we assume the associated data is shared context between
both participants. In other words, we assume that the sender and receiver both already
know the context d. Therefore, hiding dis overkill — only authentication is needed. By
making a distinction between plaintext and associated data separately in AEAD, the ci-
phertext length can depend only on the length of the plaintext , and not depend on
the length of the associated data.
The fact that associated data dis public is re/f_lected in the fact that the calling program
chooses it in the security de/f_inition.
“Standard” AE corresponds to the case where dis always empty: all ciphertexts are
authenticated to the same context.
12.2 Achieving AE/AEAD
The Encrypt-then-MAC construction (Construction 10.9) has the property that the at-
tacker cannot generate ciphertexts that decrypt correctly. Even though we introduced
encrypt-then-MAC to achieve CCA security, it also achieves the stronger requirement of
AE.
Claim 12.3 IfEhas CPA security and Mis a secure MAC, then EtM (Construction 10.9) has AE security.
to-do There is a slight mismatch here, since I de/f_ined AE/AEAD security as a “pseudorandom cipher-
texts” style de/f_inition. So you actually need CPA$+PRF instead of CPA+MAC. But CPA+MAC
is enough for the left-vs-right style of AE/AEAD security.
The security proof is essentially the same as the proof of CCA security (Claim 12.5).
In that proof, there is a hybrid in which the /d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc subroutine always returns an error.
Stopping the proof at that point would result in a proof of AE security.
217Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
Encrypt-then-MAC with Associated Data
Recall that the encrypt-then-MAC construction computes a MAC of the ciphertext. To
incorporate associated data, we simply need to compute a MAC of the ciphertext along
with the associated data.
Recall that most MACs in practice support variable-length inputs, but the length of
the MAC tag does not depend on the length of the message. Hence, this new variant of
encrypt-then-MAC has ciphertexts whose length does not depend on the length of the
associated data.
Construction 12.4
(Enc+MAC+AD)Enc¹¹ke;kmº;d;mº:
c E:Enc¹ke;mº
t:=M:MAC¹km;dkcº
return¹c;tºDec¹¹ke;kmº;d;¹c;tºº:
ift,M:MAC¹km;dkcº:
return err
return E:Dec¹ke;cº
Claim 12.5 IfEhas CPA security and Mis a secure MAC, then Construction 12.4 has AEAD security,
when the associated data has /f_ixed length ( i.e.,D=f0;1gnfor some /f_ixed n).
to-do This construction is insecure for variable-length associated data. It is not terribly hard to /f_ix
this; see exercises.
12.3 Carter-Wegman MACs
Suppose we construct an AE[AD] scheme using the encrypt-then-MAC paradigm. A good
choice for the CPA-secure encryption scheme would be CBC mode; a good choice for the
MAC scheme would be ECBC-MAC. Combining these two building blocks would result in
an AE[AD] scheme that invokes the block cipher twice for each plaintext block — once for
the CBC encryption (applied to the plaintext) and once more for the ECBC-MAC (applied
to that ciphertext block).
Is it possible to achieve AE[AD] with less cost? In this section we will explore a more
eﬃcient technique for variable-length MACs, which requires only one multiplication op-
eration per message block along with a single invocation of a block cipher.
Universal Hash Functions
The main building block in Carter-Wegman-style MACs is a kind of hash function called
auniversal hash function (UHF). While the name “universal hash function” sounds like
it must be an incredibly strong primitive, a UHF actually gives a much weaker security
guarantee than a collision-resistant or second-preimage-resistant hash function.
Recall that¹x;x0ºis acollision under salt sifx,x0andH¹s;xº=H¹s;x0º. A universal
hash function has the property that it is hard to /f_ind such a collision : : :
: : :when xandx0are chosen without knowledge of the salt,
: : :and when the attacker has only one attempt at /f_inding a collision for a particular salt
value.
218Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
These constraints are equivalent to choosing the salt after xandx0are chosen, and a
collision should be negligibly likely under such circumstances.
The de/f_inition can be stated more formally:
Definition 12.6
(UHF)A hash function Hwith set of saltsSis called a universal hash function (UHF) if
LH
uhf-realLH
uhf-fake, where:
LH
uhf-real
/t.sc/e.sc/s.sc/t.sc¹x;x02f0;1gº:
s S
b:=h
H¹s;xº?=H¹s;x0ºi
return¹s;bºLH
uhf-fake
/t.sc/e.sc/s.sc/t.sc¹x;x02f0;1gº:
s S
return¹s;falseº
This de/f_inition is similar in spirit to the formal de/f_inition of collision resistance (Def-
inition 11.1). Just like that de/f_inition, this one is cumbersome to use in a security proof.
When using a hash function, one typically does not explicitly check for collisions, but
instead just proceeds as if there was no collision.
In the case of UHFs, there is a diﬀerent and helpful way of thinking about security.
Consider a “ blind collision-resistance ” game, where you try to /f_ind a collision under H
without access to the salt, and even without seeing the outputs of H!It turns out that if H
is a UHF, then it is hard to /f_ind collisions in such a game:
Claim 12.7 IfHis a UHF, then the following libraries are indistinguishable:
LH
bcr-real
s S
Hinv:=empty assoc. array
/t.sc/e.sc/s.sc/t.sc¹x2f0;1gº:
/y.alt:=H¹s;xº
ifHinv»/y.alt¼de/f_ined and Hinv»/y.alt¼,x:
return Hinv»/y.alt¼
Hinv»/y.alt¼:=x
return falseLH
bcr-fake
/t.sc/e.sc/s.sc/t.sc¹x2f0;1gº:
return false
In these libraries, the calling program chooses inputs xto the UHF. TheLbcr-real library
maintains a private record of all of the xvalues and their hashes, in the form of a reverse
lookup table. Hinv»/y.alt¼will hold the value xthat was hashed to result in /y.alt.
If the calling program calls /t.sc/e.sc/s.sc/t.sc¹xºon a value that collides with a previous x0, then
Lbcr-real will respond with this x0value (the purpose of this is just to be helpful to security
proofs that use these libraries); otherwise it will respond with false , giving no information
about sorH¹s;xº. The other library always responds with false . Hence, the two are
indistinguishable only if /f_inding collisions is hard.
to-do Proof to come. It’s not hard but tedious.
219Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
Constructing UHFs using Polynomials
UHFs have much weaker security than other kinds of hashing, and they can in fact be
constructed unconditionally. One of the mathematically simplest constructions has to do
with polynomials.
Claim 12.8 Letpbe a prime and /afii10069.italbe a nonzero polynomial with coeﬃcients in Zpand degree at most d.
Then/afii10069.italhas at most dzeroes from Zp.
This observation leads to a simple UHF construction, whose idea is to interpret the
string xas the coeﬃcients of a polynomial, and evaluate that polynomial at point s(the
salt of the UHF). In more detail, let pbe a prime with p>2λ, and let the salt sbe a uniformly
chosen element of Zp. To compute the hash of x, /f_irst split xintoλ-bit blocks, which will
be convenient to index as xd 1kxd 2k: : :kx0. Interpret each xias a number mod p. Then,
the value of the hash H¹s;xºis:
sd+xd 1sd 1+xd 2sd 2++x0¹mod pº
This is the result of evaluating a polynomial with coeﬃcients ¹1;xd 1;xd 2; : : : ; x0ºat the
point s. A convenient way to evaluate this polynomial is by using Horner’s rule:
s¹s¹s+xd 1º+xd 2º+xd 3
Horner’s rule can be expressed visually as follows:
sxd 1 xd 2 xd 3
 + + +
The UHF construction is described formally below.
Construction 12.9
(Poly-UHF)
p=a prime >2λ
S=ZpH¹s;xº:
write x=xd 1kxd 2kk x0,
where eachjxij=λ
/y.alt:=1
fori=d 1downto 0:
/y.alt:=s/y.alt+xi%p
return/y.alt
Claim 12.10 The Poly-UHF construction is a secure UHF.
Proof It suﬃces to show that, for any x,x0, the probability that H¹s;xº=H¹s;x0º(taken over
random choice of s) is negligible. Note that H¹s;xº=/afii10069.ital¹sº, where/afii10069.italis a polynomial whose
coeﬃcients are¹1;xd 1; : : : ; x0º, and H¹s;x0º=/afii10069.ital0¹sº, where/afii10069.ital0is a similar polynomial
derived from x0. Note that xandx0may be split into a diﬀerent number of blocks, leading
to diﬀerent degrees ( dandd0) for the two polynomials.
220Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
In order to have a collision H¹s;xº=H¹s;x0º, we must have
/afii10069.ital¹sºp/afii10069.ital0¹sº
()/afii10069.ital¹sº /afii10069.ital0¹sºp0
Note that the left-hand side in this equation is a polynomial of degree at most d=
maxfd;d0g. Furthermore, that polynomial /afii10069.ital /afii10069.ital0is not the zero polynomial because /afii10069.ital
and/afii10069.ital0are diﬀerent polynomials. Even if the original strings xandx0diﬀer only in blocks
of0s, the resulting /afii10069.italand/afii10069.ital0will be diﬀerent polynomials because they include an extra
leading coeﬃcient of 1.
A collision happens if and only if sis chosen to be one of the roots of /afii10069.ital /afii10069.ital0. From
Claim 12.8, the polynomial has at most droots, so the probability of choosing one of them
is at most:
dp6d2λ:
This probability is negligible since dis polynomial in λ(it is the number of blocks in a
string that was written down by the attacker, who runs in polynomial time in λ).
to-do Fine print: this works but modular multiplication is not fast. If you want this to be fast, you
would use a binary /f_inite /f_ield. It is not so bad to describe what /f_inite /f_ields are, but doing so
involves more polynomials. Then when you make polynomials whose coeﬃcients are /f_inite
/f_ield elements, it runs the risk of feeling like polynomials over polynomials (because at some
level it is). Not sure how I will eventually deal with this.
Carter-Wegman UHF-based MAC
A UHF by itself is not a good MAC, even when its salt sis kept secret. This is because
the security of a MAC must hold even when the attacker sees the function’s outputs, but
a UHF provides security (blind collision-resistance) only when the attacker does not see
the UHF outputs.
The Carter-Wegman MAC technique augments a UHF by sending its output through
a PRF, so the MAC of misF¹k;H¹s;mººwhere His a UHF and Fis a PRF.
Construction 12.11
(Carter-Wegman)LetHbe a UHF with nbits of output, and let Fbe a secure PRF with in=n. The Carter-
Wegman construction combines them as follows:
KeyGen :
k f0;1gλ
s S
return¹k;sºMAC
¹k;sº;x
:
/y.alt:=H¹s;xº
return F¹k;/y.altº
We will show that the Carter-Wegman construction is a secure PRF. Recall that this
implies that the construction is also a secure MAC (Claim 10.4). Note that the Carter-
Wegman construction also usesa PRF as a building block. However, it uses a PRF for short
messages, to construct a PRF for arbitrary-length messages. Furthermore, it only calls the
underlying PRF once, and all other computations involving the UHF are comparitively
“cheap.”
221Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
To understand the security of Carter-Wegman, we work backwards. The output
F¹k;H¹s;xººcomes directly from a PRF. These outputs will look random as long as the
inputs to the PRF are distinct . In this construction, the only way for PRF inputs to repeat
is for there to be a collision in the UHF H. However, we have to be careful. We can only
reason about the collision-resistance of Hwhen its salt is secret and its outputs are hidden
from the attacker. The salt is indeed hidden in this case (kept as part of the Carter-Wegman
key), but its outputs are being used as PRF inputs. Fortunately, the guarantee of a PRF is
that its outputs appear unrelated to its inputs. In other words, the PRF outputs leak no in-
formation about the PRF inputs ( H-outputs). Indeed, this appears to be a situation where
the UHF outputs are hidden from the attacker, so we can argue that collisions in Hare
negligibly likely.
Claim 12.12 IfHis a secure UHF and Fis a secure PRF, then the Carter-Wegman construction (Construc-
tion 12.11) is a secure PRF, and hence a secure MAC as well.
Proof We will show that LCW
prf-realLCW
prf-randusing a standard hybrid technique.
LCW
prf-real
k f0;1gλ
s S
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
/y.alt:=H¹s;xº
return F¹k;/y.altºThe starting point is LCW
prf-real.
T:=empty assoc. array
s S
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
/y.alt:=H¹s;xº
ifT»/y.alt¼unde/f_ined:
T»/y.alt¼ f 0;1gout
return T»/y.alt¼We have applied the security of F, by factoring out in
terms ofLF
prf-real, replacing it withLF
prf-rand, and inlining
the result.
222Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
cache :=empty assoc. array
T:=empty assoc. array
s S
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifcache»x¼unde/f_ined:
/y.alt:=H¹s;xº
ifT»/y.alt¼unde/f_ined:
T»/y.alt¼ f 0;1gout
cache»x¼:=T»/y.alt¼
return cache»x¼The/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc subroutine has the property that if it is called
on the same xtwice, it will return the same result. It
therefore does no harm to cache the answer every time.
The second time /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc is called on the same value x,
the previous value is loaded from cache rather than re-
computed. This change has no eﬀect on the calling pro-
gram.
cache :=empty assoc. array
Hinv:=empty assoc. array
T:=empty assoc. array
s S
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifcache»x¼unde/f_ined:
/y.alt:=H¹s;xº
ifHinv»/y.alt¼de/f_ined:
x0:=Hinv»/y.alt¼
return cache»x0¼
ifT»/y.alt¼unde/f_ined:
T»/y.alt¼ f 0;1gout
Hinv»/y.alt¼:=x
cache»x¼:=T»/y.alt¼
return cache»x¼Note that if /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc is /f_irst called on x0and then later on
x, where H¹s;xº=H¹s;x0º,/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc will return the same
result. We therefore modify the library to keep track of
H-outputs and inputs. Whenever the library computes
/y.alt=H¹s;xº, it stores Hinv»/y.alt¼=x. However, if Hinv»/y.alt¼
already exists, it means that this xandx0=Hinv»/y.alt¼are
a collision under H. In that case, the library directly re-
turns whatever it previously returned on input x0. This
change has no eﬀect on the calling program.
223Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
cache :=empty assoc. array
Hinv:=empty assoc. array
T:=empty assoc. array
s S
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifcache»x¼unde/f_ined:
/y.alt:=H¹s;xº
ifHinv»/y.alt¼de/f_ined:
x0:=Hinv»/y.alt¼
return cache»x0¼
ifHinv»/y.alt¼unde/f_ined:
T»/y.alt¼ f 0;1gout
Hinv»/y.alt¼:=x
cache»x¼:=T»/y.alt¼
return cache»x¼In the previous hybrid, T»/y.alt¼is set at the same time Hinv»/y.alt¼
is set — on the /f_irst call /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xºsuch that H¹s;xº=
/y.alt. Therefore, it has no eﬀect on the calling program to
check whether T»/y.alt¼is de/f_ined or check whether Hinv»/y.alt¼
is de/f_ined.
cache :=empty assoc. array
Hinv:=empty assoc. array
s S
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifcache»x¼unde/f_ined:
/y.alt:=H¹s;xº
ifHinv»/y.alt¼de/f_ined:
x0:=Hinv»/y.alt¼
return cache»x0¼
ifHinv»/y.alt¼unde/f_ined:
cache»x¼  f 0;1gout
Hinv»/y.alt¼:=x
return cache»x¼Note that if Hinv»/y.alt¼is de/f_ined, then /l.sc/o.sc/o.sc/k.sc/u.sc/p.sc returns
within that if-statement. The line cache»x¼:=T»/y.alt¼is
therefore only executed in the case that Hinv»/y.alt¼was not
initially de/f_ined. Instead of choosing T»/y.alt¼only to imme-
diately assign it to cache»x¼, we just assign directly to
cache»x¼. This change has no eﬀect on the calling pro-
gram, and it does away with the Tassociative array en-
tirely.
The if-statements involving Hinvin this hybrid are checking whether xhas collided
with any previous x0under H. All of this logic, including the evaluation of H, can be
factored out in terms of LH
bcr-real. At this point in the sequence of hybrids, the output of H
is not needed, except to check whether a collision has been encountered (and if so, what
the oﬀending inputs are). Again, this change has no eﬀect on the calling program. The
224Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
result is:
cache :=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifcache»x¼unde/f_ined:
if/t.sc/e.sc/s.sc/t.sc¹xº=x0,false :
return cache»x0¼
else:
cache»x¼ f 0;1gout
return cache»x¼LH
bcr-real
s S
Hinv:=empty assoc. array
/t.sc/e.sc/s.sc/t.sc¹xº:
/y.alt:=H¹s;xº
ifHinv»/y.alt¼de/f_ined:
return Hinv»/y.alt¼
Hinv»/y.alt¼:=x
return false
The security of His that we can swap LH
bcr-realforLH
bcr-fake, with negligible eﬀect on the
calling program. Note that /t.sc/e.sc/s.sc/t.sc algorithm inLbcr-fake always returns false . This leads us
to simply remove the “if /t.sc/e.sc/s.sc/t.sc¹xº,false ” clause, resulting in the following:
LCW
prf-rand
cache :=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹xº:
ifcache»x¼unde/f_ined:
cache»x¼ f 0;1gout
return cache»x¼
Since this is exactly LCW
prf-rand, we are done. We have shown that LCW
prf-randLCW
prf-rand.
12.4 Galois Counter Mode for AEAD
The most common block cipher mode for AEAD is called Galois Counter Mode (GCM) .
GCM is essentially an instance of encrypt-then-MAC, combining CTR mode for encryption
and the polynomial-based Carter-Wegman MAC for authentication. GCM is relatively
inexpensive since it requires only one call to the block cipher per plaintext block, plus one
multiplication for each block of ciphertext + associated data.
Rather than using polynomials over Zp, GCM mode uses polynomials de/f_ined over a
/f_inite /f_ield with 2λelements. Such /f_ields are often called “Galois /f_ields,” which leads to the
name Galois counter mode.
to-do More information about GCM will go here. Again, would be nice to have a crash course in
/f_inite /f_ields.
225Draft: January 3, 2021 CHAPTER 12. AUTHENTICATED ENCRYPTION & AEAD
CTR encryption
Carter-Wegman MAC of CTR ciphertextFk1 Fk1 Fk1 Fk1$
 m1 m2 m3 m`
c0 c1 c2 c3 c`+1 +1 +1


c`+1
Fk3
k2  
Exercises
to-do : : :more on the way : : :
12.1. Suppose Enc-then-MAC+AD is instantiated with CBC mode and any secure MAC, as de-
scribed in Construction 12.4. The scheme is secure for /f_ixed-length associated data. Show
that if variable-length associated data is allowed, then the scheme does notprovide AEAD
security.
Note: you are not attacking the MAC! Take advantage of the fact that dkcis ambiguous
when the length of dis not /f_ixed and publicly known.
12.2. Suggest a way to make Construction 12.4 secure for variable-length associated data. Prove
that your construction is secure.
12.3. Show that if you know the salt sof the Poly-UHF construction (Construction 12.9), you
can eﬃciently /f_ind a collision.
12.4. Show that if you are allowed to see only the output of Poly-UHF ( i.e., the salt remains
hidden), on chosen inputs then you can compute the salt.
22613RSA & Digital Signatures
RSA was among the /f_irst public-key cryptography developed. It was /f_irst described in
1978, and is named after its creators, Ron Rivest, Adi Shamir, and Len Adleman.1RSA
can be used as a building block for public-key encryption and digital signatures. In this
chapter we discuss only the application of RSA for digital signatures.
13.1 “Dividing” Mod n
to-do I’m considering moving some of this material to Chapter 3 (secret sharing) — enough to un-
derstand that every nonzero element has a multiplicative inverses modulo a prime (totients,
etc can stay here). That way, I don’t have to say “trust me, this can be made to work” when de-
scribing Lagrange interpolation over a prime /f_ield, and students can play around with secret
sharing using Sage. Also, students will see that there is “serious math” in the course already in
chapter 3 so they don’t get blindsided as we transition into public-key crypto. (Not to mention,
this chapter is too long.)
Please review the material from Section 0.2, to make sure your understanding of ba-
sic modular arithmetic is fresh. You should be comfortable with the de/f_initions of Zn,
congruence (n), the modulus operator ( %), and how to do addition, multiplication, and
subtraction mod n.
Note that we haven’t mentioned division mod n. Does it even make sense to talk about
division mod n?
Example Consider the following facts which hold mod 15:
28151 10 8155
48152 12 8156
68153 14 8157
88154
Now imagine replacing “ 8” with “2” in each of these examples:
22151 10 2155
42152 12 2156
62153 14 2157
82154
1Cliﬀord Cocks developed an equivalent scheme in 1973, but it was classi/f_ied since he was working for
British intelligence.
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
Everything still makes sense! Somehow, multiplying by 8 mod 15 seems to be the same thing
as “dividing by 2” mod 15.
The previous examples all used x8(x2) where xwas an even number. What happens
when xis an odd number?
38159() “32159” ??
This might seem non-sensical, but if we make the substitutions 315 12and915 6, then
we do indeed get something that makes sense:
 12815 6()   12215 6
This example shows that there is surely some interesting relationship among the num-
bers 2, 8, and 15. It seems reasonable to interpret “multiplication by 8” as “division by 2”
when working mod 15.
Is there a way we can do something similar for “division by 3” mod 15? Can we /f_ind
some/y.altwhere “multiplication by /y.altmod 15” has the same behavior as “division by 3 mod
15?” In particular, we would seek a value /y.altthat satis/f_ies 3/y.alt151, but you can check for
yourself that no such value of /y.altexists.
Why can we “divide by 2” mod 15 but we apparently cannot “divide by 3” mod 15? We
will explore this question in the remainder of this section.
Multiplicative Inverses
We usually don’t directly use the terminology of “division” with modular arithmetic. In-
stead of saying “division by 2”, we say “multiplication by 2 1”, where 2 1is just another
name for 8.
Definition 13.1
(x 1mod n)Themultiplicative inverse ofxmod nis the integer /y.altthat satis/f_ies x/y.altn1(if such a
number exists). We usually refer to the multiplicative inverse of xas “x 1.”
Example Contuining to work mod 15, we have:
I4 1154since 44=16151. Hence 4 is its own multiplicative inverse! You can also
understand this as:
4 1=¹22º 1=¹2 1º21582=64154
I7 11513since 713=91151.
We are interested in which numbers have a multiplicative inverse mod n.
Definition 13.2
(Z
n)Themultiplicative group2modulo nis de/f_ined as:
Z
n=fx2Znjxhas a multiplicative inverse mod ng
2“Group” is a technical term from abstract algebra.
228Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
For example, we have seen that Z
ncontains the numbers 2, 4, and 7 (and perhaps
others), but it doesn’t contain the number 3 since 3 does not have a multiplicative inverse.
So which numbers have a multiplicative inverse mod n, in general? (Which numbers
belong to Zn?) The answer is quite simple:
Theorem 13.3 xhas a multiplicative inverse mod nif and only if gcd¹x;nº=1. In other words, Z
n=fx2
Znjgcd¹x;nº=1g.
We prove the theorem using another fact from abstract algebra which is often useful:
Theorem 13.4
(Bezout’s Theorem)For all integers xand/y.alt, there exist integers aandbsuch that ax+b/y.alt=gcd¹x;/y.altº. In fact,
gcd¹x;/y.altºis the smallest positive integer that can be written as an integral linear combination
ofxand/y.alt.
We won’t prove Bezout’s theorem, but we will show how it is used to prove Theo-
rem 13.3:
Proof
(of Theorem 13.3)(() Suppose gcd¹x;nº=1. We will show that xhas a multiplicative inverse mod n. From
Bezout’s theorem, there exist integers a;bsatisfying ax+bn=1. By reducing both sides
of this equation modulo n, we have
1=ax+bnnax+b0=ax:
Thus the integer athat falls out of Bezout’s theorem is the multiplicative inverse of x
modulo n.
()) Suppose xhas a multiplicative inverse mod n, soxx 1n1. We need to show
that gcd¹x;nº=1. From the de/f_inition of n, we know that ndivides xx 1 1, so we can
write xx 1 1=kn(as an expression over the integers) for some integer k. Rearranging,
we have xx 1 kn=1. Since we can write 1 as an integral linear combination of xandn,
Bezout’s theorem says that we must have gcd¹x;nº=1. 
Example Z15=f0;1; : : : ; 14g, and to obtain Z
15we exclude any of the numbers that share a common
factor with 15. In other words, we exclude the multiples of 3 and multiples of 5. The remaining
numbers are Z
15=f1;2;4;7;8;11;13;14g.
Since 11 is a prime, 0 is the only number in Z11that shares a common factor with 11. All
the rest satisfy gcd¹x;11º=1. Hence, Z
11=f1;2;;10g.
Example We can use Sage3to play around with these concepts. Sage supports the %operator for mod-
ulus:
sage: 2 *8 % 15
1
It also supports a convenient way to generate “ Zn-objects,” or Mod-objects as they are called.
An object like Mod(2,15) represents the value 22Z15, and all of its operations are overloaded
to be the mod-15 operations:
3h/t_tps://www.sagemath.org
229Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
sage: Mod(2,15) *8
1
sage: Mod(2,15)+31415926
3
sage: Mod(-1,15)
14
In Sage, you can compute multiplicative inverses in a few diﬀerent ways:
sage: Mod(2,15)^-1
8
sage: 1/Mod(2,15)
8
sage: 2.inverse _mod(15)
8
sage: (1/2) % 15
8
Sage is smart enough to know when a multiplicative inverse doesn’t exist:
sage: Mod(3,15)^-1
ZeroDivisionError: inverse of Mod(3, 15) does not exist
Sage supports huge integers, with no problem:
sage: n = 3141592653589793238462643383279502884197169399375105820974944
sage: x = 1234567890123456789012345678901234567890123456789012345678901
sage: 1/Mod(x,n)
2234412539909122491686747985730075304931040310346724620855837
The relationship between multiplicative inverses and GCD goes even farther than The-
orem 13.3. Recall that we can compute gcd¹x;nºeﬃciently using Euclid’s algorithm. There
is a relatively simple modi/f_ication to Euclid’s algorithm that also computes the corresop-
nding Bezout coeﬃcients with little extra work. In other words, given xandn, it is possible
to eﬃciently compute integers a,b, and dsuch that
ax+bn=d=gcd¹x;nº
In the case where gcd¹x;nº=d=1, the integer ais a multiplicative inverse of xmod n.
The “extended Euclidean algorithm” for GCD is given below:
/e.sc/x.sc/t.sc/g.sc/c.sc/d.sc¹x;/y.altº:
//returns¹d;a;bºsuch that gcd¹x;/y.altº=d=ax+b/y.alt
if/y.alt=0:
return¹x;1;0º
else:
¹d;a;bº:=/e.sc/x.sc/t.sc/g.sc/c.sc/d.sc¹/y.alt;x%/y.altº
return¹d;b;a bbx/y.altcº
230Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
Example Sage implements the extended Euclidean algorithm as “ xgcd ”:
sage: xgcd(427,529)
(1, 223, -180)
sage: 223 *427 + (-180) *529
1
You can then see that 223 and 427 are multiplicative inverses mod 529:
sage: 427 *223 % 529
1
The Totient Function
Euler’s totient function is de/f_ined as ϕ¹nºdef=jZ
nj; that is, the number of elements of Zn
that have multiplicative inverses.
As an example, if nis a prime, then Z
n=Znnf0gbecause every integer in Znapart
from zero is relatively prime to n. Therefore, ϕ¹nº=n 1in this case.
RSA involves a modulus nthat is the product of two distinct primes n=pq. In that
case,ϕ¹nº=¹p 1º¹q 1º. To see why, let’s count how many elements in Zpqshare a
common divisor with pq(i.e., are notinZ
pq).
IThe multiples of pshare a common divisor with pq. These include
0;p;2p;3p; : : : ;¹q 1ºp. There are qelements in this list.
IThe multiples of qshare a common divisor with pq. These include
0;q;2q;3q; : : : ;¹p 1ºq. There are pelements in this list.
We have clearly double-counted element 0 in these lists. But no other element is double
counted. Any item that occurs in both lists would be a common multiple of both pandq,
but since pandqare relatively prime, their least common multiple is pq, which is larger
than any item in these lists.
We count p+q 1elements of Zpqwhich share a common divisor with pq. The rest
belong to Z
pq, and there are pq ¹p+q 1º=¹p 1º¹q 1ºof them. Hence ϕ¹pqº=
¹p 1º¹q 1º.
General formulas for ϕ¹nºexist, but they typically rely on knowing the prime factor-
ization of n. We will see more connections between the diﬃculty of computing ϕ¹nºand
the diﬃculty of factoring nlater in this part of the course.
The reason we consider ϕ¹nºat all is this fundamental theorem from abstract algebra:
Theorem 13.5
(Euler’s Theorem)Ifx2Z
nthen xϕ¹nºn1.
Example Using the formula for ϕ¹nº, we can see that ϕ¹15º=ϕ¹35º=¹3 1º¹5 1º=8. Euler’s
theorem says that raising any element of Z
15to the 8 power results in 1: We can use Sage to
verify this:
231Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
sage: for i in range(15):
....: if gcd(i,15) == 1:
....: print("%d^8 mod 15 = %d" % (i, i^8 % 15))
....:
1^8 mod 15 = 1
2^8 mod 15 = 1
4^8 mod 15 = 1
7^8 mod 15 = 1
8^8 mod 15 = 1
11^8 mod 15 = 1
13^8 mod 15 = 1
14^8 mod 15 = 1
13.2 The RSA Function
The RSA function is de/f_ined as follows:
ILetpandqbe distinct primes (later we will say more about how they are chosen),
and let N=pq.Nis called the RSA modulus .
ILeteanddbe integers such that edϕ¹Nº1. That is, eanddare multiplicative
inverses mod ϕ¹Nº— not mod N!
IThe RSA function is: x7!xe%N, where x2ZN.
IThe inverse RSA function is: /y.alt7!/y.altd%N, where x2ZN.
Essentially, the RSA function (and its inverse) is a simple modular exponentiation. The
most confusing thing to remember about RSA is that eandd“live” in Z
ϕ¹Nº, while xand
/y.alt“live” in ZN.
x /y.altraise to epower (mod N)
raise to dpower (mod N)
Let’s make sure the function we called the “inverse RSA function” is actually an inverse
of the RSA function. Let’s start with an example:
Example In Sage, we can sample a random prime between 1 and kby using random _prime (k). We use
it to sample the prime factors pandq:
sage: p = random _prime(10^5)
sage: q = random _prime(10^5)
sage: N = p *q
sage: N
36486589
232Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
Then we can compute the exponents eandd. Recall that they must be multiplicative inverses
modϕ¹Nº, so they cannot share any common factors with ϕ¹Nº. An easy way to ensure this
is to choose eto be a prime:
sage: phi = (p-1) *(q-1)
sage: e = random _prime(phi)
sage: e
28931431
sage: d = 1/Mod(e,phi)
sage: d
31549271
We can now raise something to the epower and again to the dpower:
sage: x = 31415926
sage: y = x^e % N
sage: y
1798996
sage: y^d % N
31415926
As you can see, raising to the epower and then dpower (mod N) seems to bring us back to
where we started ( x).
We can argue that raising-to-the- e-power and raising-to-the- d-power are inverses in
general: Since edϕ¹Nº1, we can write ed=tϕ¹Nº+1for some integer t. Then:
¹xeºd=xed=xtϕ¹Nº+1=¹xϕ¹NººtxN1tx=x
Note that we have used the fact that xϕ¹NºN1from Euler’s theorem.4
How [Not] to Exponentiate Huge Numbers
When you see an expression like “ xe%N”, you might be tempted to implement it with the
following algorithm:
N/a.sc/i.sc/v.sc/e.scE/x.sc/p.sc/o.sc/n.sc/e.sc/n.sc/t.sc/i.sc/a.sc/t.sc/e.sc ¹x;e;Nº:
result =1
fori=1toe:// compute xe
result =resultx
return result %N
While this algorithm would indeed give the correct answer, it is a really bad way of doing
it. In practice, we use RSA with numbers that are thousands of bits long. Suppose we
run the N/a.sc/i.sc/v.sc/e.scE/x.sc/p.sc/o.sc/n.sc/e.sc/n.sc/t.sc/i.sc/a.sc/t.sc/e.sc algorithm with arguments x,e, and Nwhich are around a
thousand bits each (so the magnitude of these numbers is close to 21000):
4However, see Exercise 13.15.
233Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
1. The algorithm will spend approximately 21000iterations in the for-loop!
2. The algorithm computes xeas an integer /f_irst, and then reduces that integer mod
N. Observe that x2is roughly 2000 bits long, x3is roughly 3000 bits long, etc. So it
would take about 210001000 bits just to write down the integer xe.
As you can see, there is neither enough time nor storage capacity in the universe to use
this algorithm. So how can we actually compute values like xe%Non huge numbers?
1. Suppose you were given an integer xand were asked to compute x17. You can com-
pute it as:
x17= xxxx|         {z         }
16 multiplications:
But a more clever way is to observe that:
x17=x16x=¹¹¹x2º2º2º2x:
This expression can be evaluated with only 5 multiplications (squaring is just muli-
plying a number by itself).
More generally, you can compute an expression like xeby following the recurrence
below. The method is called exponentiation by repeated squaring , for reasons
that are hopefully clear:
xe=8>>> <
>>>:1 ife=0
¹xe
2º2ifeeven
¹xe 1
2º2xifeoddB/e.sc/t.sc/t.sc/e.sc/r.scE/x.sc/p.sc¹x;eº:
ife=0: return 1
ifeeven:
return B/e.sc/t.sc/t.sc/e.sc/r.scE/x.sc/p.sc¹x;e
2º2
ifeodd:
return B/e.sc/t.sc/t.sc/e.sc/r.scE/x.sc/p.sc¹x;e 1
2º2x
B/e.sc/t.sc/t.sc/e.sc/r.scE/x.sc/p.sc divides the eargument by two (more or less) each time it recurses, until
reaching the base case. Hence, the number of recursive calls is O¹logeº. In each
recursive call there are only a constant number of multiplications (including squar-
ings). So overall this algorithm requires only O¹logeºmultiplications (compared to
e 1multiplications by just multiplying mby itself etimes). In the case where
e21000, this means only a few thousand multiplications.
2. We care about only xe%N, not the intermediate integer value xe. One of the most
fundamental features of modular arithmetic is that you can reduce any interme-
diate values mod Nif you care about the /f_inal result only mod N.
Revisiting our previous example:
x17%N=x16x%N=¹¹¹x2%Nº2%Nº2%Nº2x%N:
More generally, we can reduce all intermediate value mod N:
234Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
M/o.sc/d.scE/x.sc/p.sc¹x;e;Nº:// compute xe%N
ife=0: return 1
ifeeven:
return M/o.sc/d.scE/x.sc/p.sc¹x;e
2;Nº2%N
ifeodd:
return M/o.sc/d.scE/x.sc/p.sc¹x;e 1
2;Nº2x%N
This algorithm avoids the problem of computing the astronomically huge integer
xe. It never needs to store any value (much) larger than N.
Warning: Even this M/o.sc/d.scE/x.sc/p.sc algorithm isn’t an ideal way to implement exponentiation for
cryptographic purposes. Exercise 13.10 explores some unfortunate properties of this exponen-
tiation algorithm.
Example Most math libraries implement exponentiation using repeated squaring. For example, you
can use Sage to easily calculate numbers with huge exponents:
sage: 427^31415926 % 100
89
However, this expression still tells Sage to compute 42731415926as an integer , before reducing
it mod 100. As such, it takes some time to perform this computation.
If you try an expression like x^e % N with a larger exponent, Sage will give a memory
error. How can we tell Sage to perform modular reduction at every intermediate step during
repeated squaring? The answer is to use Sage’s Modobjects, for example:
sage: Mod(427,100)^314159265358979
63
This expression performs repeated squaring on the object Mod(427,100) . Since a Mod-object’s
operations are all overloaded (to give the answer only mod n), this has the result of doing a
modular reduction after every squaring and multiplication. This expression runs instanta-
neously, even with very large numbers.
Security Properties & Discussion
RSA is what is called a trapdoor function.
IOne user generates the RSA parameters (primarily N,e, and d) and makes Nande
public, while keeping dprivate.
IFunctionality properties: Given only the public information Nande, it is easy to
compute the RSA function ( x7!xe%N). Given the private information ( d) it clearly
easy to compute the RSA inverse ( /y.alt7!/y.altd%N).
ISecurity property: Given only the public information, it should be hard to compute
the RSA inverse ( /y.alt7!/y.altd%N) on randomly chosen values. In other words, the only
person who is able to compute the RSA inverse function is the person who generated
the RSA parameters.
235Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
to-do The security property is not natural to express in our language of security de/f_initions (li-
braries).
Currently the best known attacks against RSA ( i.e., ways to compute the inverse RSA
function given only the public information) involve factoring the modulus. If we want to
ensure that RSA is secure as a trapdoor function, we must understand the state of the art
for factoring large numbers.
Before discussing the performance of factoring algorithms, remember that we measure
performance as a function of the length of the input — how many bits it takes to write
the input. In a factoring algorithm, the input is a large number N, and it takes roughly
n=log2Nbits to write down that number. We will discuss the running time of algorithms
as a function of n, not N. Just keep in mind the diﬀerence in cost between writing down a
1000-bit number ( n=1000) vscounting up to a 1000-bit number ( N=21000)
Everyone knows the “trial division” method of factoring: given a number N, check
whether idivides N, for every i2f2; : : :p
Ng. This algorithm requiresp
N=2n2divi-
sions in the worst case. It is an exponential-time algorithm since we measure performance
in terms of the bit-length n.
If this were the best-known factoring algorithm, then we would need to make Nonly
as large as 2256to make factoring require 2128eﬀort. But there are much better factoring
algorithms than trial division. The fastest factoring algorithm today is called the General-
ized Number Field Sieve (GNFS), and its complexity is something like O
n¹n
lognº1
3
. This is
not a polynomial-time algorithm, but it’s much faster than trial division.
Example Sage can easily factor reasonably large numbers. Factoring the following 200-bit RSA modulus
on my modest computer takes about 10 seconds:
sage: p = random _prime(2^100)
sage: q = random _prime(2^100)
sage: N = p *q
sage: factor(N)
206533721079613722225064934611 *517582080563726621130111418123
As of January 2020, the largest RSA modulus that has been (publically) factored is a
795-bit modulus.5Factoring this number required the equivalent of 900 CPU-core-years,
or roughly 266total clock cycles.
All of this is to say, the numbers involved in RSA need to be quite large to resist
factoring attacks ( i.e., require 2128eﬀort for state-of-the-art factoring algorithms). Current
best practices suggest to use 2048- or 4096-bit RSA moduli, meaning that pandqare each
1024 or 2048 bits.
to-do “What about quantum computers?” is a common FAQ that I should address here.
5h/t_tps://en.wikipedia.org/wiki/RSA_numbers#RSA-240
236Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
13.3 Digital Signatures
MACs are a cryptographic primitive that provide authenticity. A valid MAC tag on mis
“proof” that someone who knows the key has vouched for m. MACs are a symmetric-key
primitive, in the sense that generating a MAC tag and verifying a MAC tag both require
the same key (in fact, a tag is veri/f_ied by re-computing it).
Digital signatures are similar to MACs, but with separate keys for signing and veri-
/f_ication. A digital signature scheme consists of the following algorithms:
IKeyGen : outputs a pair of keys¹sk;/v.altkº, where skis the signing key and/v.altkis the
veri/f_ication key .
ISign: takes the signing key skand a message mas input, and outputs a signature
σ.
IVer: takes the veri/f_ication key /v.altk, message m, and a potential signature σas input;
outputs a boolean.
If indeedσis an output of Sign¹sk;mº, then Ver¹/v.altk;m;σºshould output true . Intuitively,
it should be hard for an attacker to /f_ind any other ¹m;σºpairs that cause Verto output
true .
The idea behind digital signatures is to make /v.altkpublic. In other words, anyone (even
the attacker) should be able to verify signatures. But only the holder of sk(the person who
generated/v.altkandsk) should be able to generate valid signatures. Furthermore, this guar-
antee should hold even against an attacker who sees many examples of valid signatures.
The attacker should not be able to generate newvalid signatures.
We formalize this security property in a similar way that we formalized the security
of MACs: “only the secret-key holder can generate valid tags, even after seeing chosen
examples of valid tags.”
Definition 13.6 LetΣbe a signature scheme. We say that Σis asecure signature ifLΣ
sig-realLΣ
sig-fake,
where:
LΣ
sig-real
¹/v.altk;skº Σ:KeyGen
/g.sc/e.sc/t.sc/v.sc/k.sc¹º:
return/v.altk
/g.sc/e.sc/t.sc/s.sc/i.sc/g.sc¹mº:
return Σ:Sign¹sk;mº
/v.sc/e.sc/r.sc/s.sc/i.sc/g.sc¹m;σº:
return Σ:Ver¹/v.altk;m;σºLΣ
sig-fake
¹/v.altk;skº Σ:KeyGen
S:=;
/g.sc/e.sc/t.sc/v.sc/k.sc¹º:
return/v.altk
/g.sc/e.sc/t.sc/s.sc/i.sc/g.sc¹mº:
σ:=Σ:Sign¹sk;mº
S:=S[f¹ m;σºg
returnσ
/v.sc/e.sc/r.sc/s.sc/i.sc/g.sc¹m;σº:
return¹m;σº?2S
237Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
Similar to the security de/f_inition for MACs, the libraries diﬀer only in how they ver-
ify signatures provided by the attacker ( /v.sc/e.sc/r.sc/s.sc/i.sc/g.sc ). If the attacker can generate a message-
signature pair¹m;σºthat (1) veri/f_ies correctly, but (2) was not generated previously by the
library itself, then /v.sc/e.sc/r.sc/s.sc/i.sc/g.sc from theLsig-real library will return true , while theLsig-fake li-
brary would return false . By asking for the libraries to be indistinguishable, we are really
asking that the attacker cannot /f_ind any such message-signature pair (forgery).
The main diﬀerence to the MAC de/f_inition is that, unlike for the MAC setting, we
intend to make a veri/f_ication key public. The library can run ¹/v.altk;skº KeyGen , but these
values remain private by default. To make /v.altkpublic, we explicitly provide an accessor
/g.sc/e.sc/t.sc/v.sc/k.sc to the attacker.
“Textbook” RSA Signatures
Signatures have an asymmetry: everyone should be able to verify a signature, but only the
holder of the signing key should be able to generate a valid signature. The RSA function
has a similar asymmetry: if Nandeare public, then anyone can raise things to the epower,
but only someone with dcan raise things to the dpower.
This similarity suggests that we can use RSA for signatures in the following way:
IThe veri/f_ication key is ¹N;eºand the signing key is ¹N;dº, where these values have
the appropriate RSA relationship.
IA signature of message m(here mis an element of ZN) is the value σ=md%N.
Intuitively, only someone with the signing key can generate this value for a given
m.
ITo verify a signature σon a message m, our goal is to check whether σNmd.
However, we are given only Nande, not d. Consider raising both sides of this
equation to the epower:
σeN¹mdºeNm
The second equality is from the standard RSA property. Now this check can be done
given only the public information Nande.
A formal description of this scheme is given below:
Construction 13.7
(Textbook RSA)The key generation algorithm is not listed here, but N;e;dare generated in the usual way for
RSA. The signing key is sk=¹N;dºand the veri/f_ication key is /v.altk=¹N;eº.
Sign
sk=¹N;dº;m
:
return md%NVer
/v.altk=¹N;eº;m;σ
:
m0:=σe%N
return m?=m0
Unfortunately, textbook RSA signatures are useful only as a /f_irst intuition. They are
not secure ! A simple attack is the following:
Suppose an attacker knows the veri/f_ication key ¹N;eºand sees a valid signature σN
mdfor some message m. Thenσ2is also a valid signature for the message m2, since:
σ2n¹mdº2=¹m2ºd
238Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
The attacker can easily generate a forged signature on a new message m2, making the
scheme insecure.
Hashed RSA Signatures
The problem with textbook RSA signatures is that the signatures and plaintexts had a
very strong algebraic relationship. Squaring the signature had the eﬀect of squaring the
underlying message. One way to /f_ix the problem is to “break” this algebraic relationship.
Hashed RSA signatures break the algebraic structure by applying the RSA function not to
mdirectly, but to H¹mº, where His a suitable hash function (with outputs interpreted as
elements of ZN).
Construction 13.8
(Textbook RSA) Sign
sk=¹N;dº;m
:
return H¹mºd%NVer
/v.altk=¹N;eº;m;σ
:
/y.alt:=σe%N
return H¹mº?=/y.alt
Let’s see how this change thwarts the attack on textbook signatures. If σis a valid
signature of m, we haveσNH¹mºd. Squaring both sides leads to σ2N¹H¹mº2ºd. Is
this the valid signature of any m0? An attacker would have to identify some m0that has
H¹m0º=H¹mº2. If the hash function is a good one, then this should be hard.
Of course, this is not a formal proof. It is possible to formally prove the security of
hashed RSA signatures. The precise statement of security is: “if RSA is a secure trap-
door function and His modeled as a random oracle, then hashed RSA signatures are a
secure signature scheme.” Since we have not given formal de/f_initions for either trapdoor
functions or random oracles, we won’t see the proof in this book.
to-do Write a chapter on random oracle and other idealized models.
239Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
13.4 Chinese Remainder Theorem
When doing arithmetic mod N, we can sometimes use knowledge of the factors N=pq
to speed things up. This section discusses the math behind these speedups.
History. In the Sunzi Suanjing , written some time around the 4th century /c.sc/e.sc, Chinese
mathematician Sunzi posed an interesting puzzle involving remainders:
“We have a number of things, but we do not know exactly how many. If we count
them by threes we have two left over. If we count them by /f_ives we have three
left over. If we count them by sevens we have two left over. How many things are
there?”6
Sunzi’s puzzle is the /f_irst known instance of a system of simultaneous equations involving
modular arithmetic: In our notation, he is asking us to solve for xin the following system
of congruences:
x32
x53
x72
We can solve such systems of equations using what is called (in the West) the Chinese
Remainder Theorem (CRT). Below is one of the simpler formations of the Chinese Re-
mainder Theorem, involving only two equations/moduli (unlike the example above, which
has three moduli 3, 5, and 7):
Theorem 13.9
(CRT)Suppose gcd¹r;sº=1. Then for all integers u;/v.alt, there is a solution for xin the following
system of equations:
xru
xs/v.alt
Furthermore, this solution is unique modulo rs.
Proof Since gcd¹r;sº=1, we have by Bezout’s theorem that 1=ar+bsfor some integers aand
b. Furthermore, bandsare multiplicative inverses modulo r. Now choose x=/v.altar+ubs.
Then,
x=/v.altar+ubsr¹/v.altaº0+u¹s 1sº=u
Soxru, as desired. Using similar reasoning mod s, we can see that xs/v.alt, soxis a
solution to both equations.
Now we argue that this solution is unique modulo rs. Suppose xandx0are two solu-
tions to the system of equations, so we have:
xrx0ru
6Chinese text is from an old manuscript of Sunzi Suanjing , but my inability to speak the language prevents
me from identifying the manuscript more precisely. English translation is from Joseph Needham, Science and
Civilisation in China, vol. 3: Mathematics and Sciences of the Heavens and Earth , 1959.
240Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
xsx0s/v.alt
Since xrx0andxsx0, it must be that x x0is a multiple of rand a multiple of s. Since
randsare relatively prime, their least common multiple is rs, sox x0must be a multiple
ofrs. Hence, xrsx0. So any two solutions to this system of equations are congruent
mod rs. 
Example Sage implements the crtfunction to solve for xin these kinds of systems of equations. Suppose
we want to solve for x:
x42742
x529123
In Sage, the solution can be found as follows:
sage: crt( 42,123, 427,529 )
32921
We can check the solution:
sage: 32921 % 427
42
sage: 32921 % 529
123
CRT Encodings Preserve Structure
Let’s call¹u;/v.altº2ZrZstheCRT encoding ofx2Zrsif they satisfy the usual relation-
ship:
xru
xs/v.alt
We can convert any x2Zrsinto its CRT encoding quite easily, via x7!¹x%r;x%sº.
The Chinese Remainder Theorem says that any ¹u;/v.altº2ZrZsis a valid CRT encoding
of a unique x2Zrs; and the proof of the theorem shows how to convert from the CRT
encoding into the “usual Zrsencoding.”
The amazing thing about these CRT encodings is that they preserve all sorts of arith-
metic structure.
Claim 13.10 If¹u;/v.altºis the CRT encoding of x, and¹u0;/v.alt0ºis the CRT encoding of x0, then¹u+u0%r;/v.alt+/v.alt0%sº
is the CRT encoding of x+x0%rs.
Example Taking r=3ands=5, let’s write down the CRT encodings of every element in Z15. In this
table, every column contains xand its CRT encoding ¹u;/v.altº:
x0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
u0 1 2 0 1 2 0 1 2 0 1 2 0 1 2
/v.alt0 1 2 3 4 0 1 2 3 4 0 1 2 3 4
241Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
Highlight the columns for x=3andx0=7and their sum x+x0=10.
x0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
u0 1 2 0 1 2 0 1 2 0 1 2 0 1 2
/v.alt0 1 2 3 4 0 1 2 3 4 0 1 2 3 4
Focusing on only the highlighted cells, the top row shows a true addition expression 3+715
10; the second row shows a true addition expression 0+131; the third row shows a true
addition expression 3+250.
This pattern holds for any xandx0, and I encourage you to try it!
As if that weren’t amazing enough, the same thing holds for multiplication:
Claim 13.11 If¹u;/v.altºis the CRT encoding of x, and¹u0;/v.alt0ºis the CRT encoding of x0, then¹uu0%r;/v.alt/v.alt0%sº
is the CRT encoding of xx0%rs.
Example Let’s return to the r=3,s=5setting for CRT and highlight x=6,x0=7, and their product
xx01512.
x0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
u0 1 2 0 1 2 0 1 2 0 1 2 0 1 2
/v.alt0 1 2 3 4 0 1 2 3 4 0 1 2 3 4
The top row shows a true multiplication expression 671512; the second row shows a true
multiplication expression 0130; the third row shows a true multiplication expression
1252.
This pattern holds for any xandx0, and I encourage you to try it!
The CRT suggests a diﬀerent, perhaps more indirect, way to do things mod rs. Suppose
xhas CRT encoding¹u;/v.altºandx0has CRT encoding¹u0;/v.alt0º, and we want to compute x+/y.alt
mod rs. One wild idea is to /f_irst directly compute the CRT encoding of this answer , and then
convert that encoding to the normal integer representation in Zrs.
In this case, we know that the answer x+x0has the CRT encoding ¹u+u0%r;/v.alt+/v.alt0%sº.
But this is the same as ¹x+x0%r;x+x0%sº— do you see why? So, to add x+x0mod rs, we
just need to add x+x0mod r, and then add x+x0mod s. This gives us the CRT encoding
of the answer we want, and we can convert that CRT encoding back into a normal Zrs-
integer.
The same idea works for multiplication as well, giving us the following:
CRT method for doing some operation[s] mod rs
1. Do the operation[s] you want, but mod rinstead of mod rs.
2. Do the operation[s] you want, but mod sinstead of mod rs.
3. Those two results are the CRT encoding of the /f_inal answer, so convert them
back to the normal representation.
242Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
Example Let’s take the example r=3359 ands=2953 , which are relatively prime (so the CRT applies).
Suppose we want to compute 3141592 +6535897 % rs. Doing it the usual way in Sage looks
like this:
sage: r = 3359
sage: s = 2953
sage: (3141592 + 6535897) % (r *s)
9677489
Doing it in the CRT way looks like this.
sage: u = (3141592 + 6535897) % r
sage: v = (3141592 + 6535897) % s
sage: crt( u,v, r,s )
9677489
Both methods give the same answer!
Application to RSA
You might be wondering what the point of all of this is.7The CRT method seems like a
very indirect and wasteful way to compute anything. This impression might be true for
simple operations like addition and single multiplications. However, the CRT method is
faster for exponentiation mod N, which is the main operation in RSA!
Example In Sage, we can do basic exponentiation mod nas follows:
sage: def modexp(x,e,n): # x^e mod n
....: return Mod(x,n)^e
If we are working over an RSA modulus and know its factorization pq, then we use the CRT
method for exponentiation mod pqas follows. We simply do the exponentiation mod pand
(separately) mod q, then use the crtfunction to convert back to Zpq.
sage: def crtmodexp(x,e,p,q): # x^e mod pq, using CRT speedup
....: u = Mod(x,p)^e
....: v = Mod(x,q)^e
....: return crt(u.lift(),v.lift(),p,q)
We need to use u.lift() andv.lift() to convert uand/v.altfrom Mod-objects into integers,
because that is what crtexpects.
We can use both methods to perform an exponentiation, and measure how long it takes
with the timeit function. In this example, Nis about 2000 bits long, and the diﬀerence in
speed is noticeable:
7I’m talking about the CRT method for arithmetic mod rs, not life in general.
243Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
sage: p = random _prime(2^1000)
sage: q = random _prime(2^1000)
sage: N = p *q
sage: x = 12345678901234567
sage: e = randint(0,N) # random integer between 0 & N-1
sage: timeit(’modexp(x,e,N)’)
125 loops, best of 3: 5.34 ms per loop
sage: timeit(’crtmodexp(x,e,p,q)’)
125 loops, best of 3: 2.86 ms per loop
And just for good measure, we can check that both approaches give the same answer:
sage: modexp(x,e,N) == crtmodexp(x,e,p,q)
True
To understand why the CRT method is faster, it’s important to know that the cost
of standard modular exponentiation over a k-bit modulus is O¹k3º. For simplicity, let’s
pretend that exponentiation takes exactly k3steps. Suppose pandqare each kbits long,
so that the RSA modulus Nis2kbits long. Hence, a standard exponentiation mod Ntakes
¹2kº3=8k3steps.
With the CRT method, we do an exponentiation mod pand an exponentiation mod q.
Each of these exponentiations takes k3steps, since pandqare only kbits long. Overall,
we are only doing 2k3steps in this approach, which is 4faster than the standard expo-
nentiation mod N. In this simple analysis, we are not counting the cost of converting the
CRT encoding back to the typical mod- Nrepresentation. But this cost is much smaller
than the cost of an exponentiation (both in practice and asymptotically).
It’s worth pointing out that this speedup can only be done for RSA signing , and not
veri/f_ication . In order to take advantage of the CRT method to speed up exponentiation
mod N, it’s necessary to know the prime factors pandq. Only the person who knows the
signing key knows these factors.
13.5 The Hardness of Factoring N
As previously mentioned, the best known way to break the security of RSA as a trapdoor
function ( i.e., to compute the inverse RSA function given only the public information N
ande) involves factoring the RSA modulus.
Factoring integers (or, more speci/f_ically, factoring RSA moduli) is believed to be a hard
problem for classical computers. In this section we show that some other problems related
to RSA are “as hard as factoring.” What does it mean for a computational problem to be
“as hard as factoring?” More formally, in this section we will show the following:
Theorem 13.12 Either allof the following problems can be solved in polynomial-time, or none of them can:
1. Given an RSA modulus N=pq, compute its factors pandq.
2. Given an RSA modulus N=pqcomputeϕ¹Nº=¹p 1º¹q 1º.
244Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
3. Given an RSA modulus N=pqand value e, compute the corresponding d(satisfying
edϕ¹Nº1).
4. Given an RSA modulus N=pq, /f_ind any x.N1such that x2N1.
To prove the theorem, we will show:
Iifthere is an eﬃcient algorithm for (1), then we can use it as a subroutine to con-
struct an eﬃcient algorithm for (2). This is straight-forward: if you have a subrou-
tine factoring Nintopandq, then you can call the subroutine and then compute
¹p 1º¹q 1º.
Iifthere is an eﬃcient algorithm for (2), then we can use it as a subroutine to con-
struct an eﬃcient algorithm for (3). This is also straight-forward: if you have a
subroutine computing ϕ¹Nºgiven N, then you can compute dexactly how it is
computed in the key generation algorithm.
Iifthere is an eﬃcient algorithm for (3), then we can use it as a subroutine to con-
struct an eﬃcient algorithm for (4).
Iifthere is an eﬃcient algorithm for (4), then we can use it as a subroutine to con-
struct an eﬃcient algorithm for (1).
Below we focus on the /f_inal two implications.
Using square roots of unity to factor N
Problem (4) of Theorem 13.12 concerns a new concept known as square roots of unity:
Definition 13.13
(Sqrt of unity)xis asquare root of unity modulo Nifx2N1. Ifx.N1andx.N 1, then we say
thatxis anon-trivial square root of unity.
Since¹1º2=1over the integers , it is also true that ¹1º2N1. In other words,1are
always square roots of unity modulo N, for any N. But some values of Nhave even more
square roots of unity. If Nis the product of distinct odd primes, then Nhas 4 square roots
of unity: two trivial and two non-trivial ones (and you are asked to prove this fact in an
exercise).
Claim 13.14 Suppose there is an eﬃcient algorithm for computing nontrivial square roots of unity mod-
uloN. Then there is an eﬃcient algorithm for factoring N. (This is the (4))(1) step in
Theorem 13.12.)
Proof The reduction is rather simple. Suppose /n.sc/t.sc/s.sc/r.sc/u.sc is an algorithm that on input Nreturns
a non-trivial square root of unity modulo N. Then we can factor Nwith the following
algorithm:
/f.sc/a.sc/c.sc/t.sc/o.sc/r.sc¹Nº:
x:=/n.sc/t.sc/s.sc/r.sc/u.sc¹Nº
return gcd¹N;x+1ºandgcd¹N;x 1º
245Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
The algorithm is simple, but we must argue that it is correct. When xis a nontrivial square
root of unity modulo N, we have the following:
x2pq1)pqjx2 1)pqj¹x+1º¹x 1º;
x.pq1 )pq-¹x 1º;
x.pq 1 )pq-¹x+1º:
The prime factorization of ¹x+1º¹x 1ºcontains a factor of pand a factor of q. But neither
x+1norx 1contain factors of both pandq. Hence x+1andx 1must each contain
factors of exactly one of fp;qg. In other words,fgcd¹pq;x 1º;gcd¹pq;x+1ºg=fp;qg.
Finding square roots of unity
Claim 13.15 If there is an eﬃcient algorithm for computing dϕ¹Nºe 1given Nande, then there is an
eﬃcient algorithm for computing nontrivial square roots of unity modulo N. (This is the (3)
)(4) step in Theorem 13.12.)
Proof Suppose we have an algorithm /f.sc/i.sc/n.sc/d.sc_/d.sc that on input¹N;eºreturns the corresponding
exponent d. Then consider the following algorithm which uses /f.sc/i.sc/n.sc/d.sc_/d.sc as a subroutine:
/s.sc/r.sc/u.sc¹Nº:
choose eas a random n-bit prime
d:=/f.sc/i.sc/n.sc/d.sc_/d.sc¹N;eº
write ed 1=2sr, with rodd
// i.e., factor out as many 2s as possible
w ZN
ifgcd¹w;Nº,1://w<Z
N
usegcd¹w;Nºto factor N=pq
compute a nontrivial square root of unity using p&q
x:=wr%N
ifxN1then return 1
fori=0tos:
ifx2N1then return x
x:=x2%N
There are several return statements in this algorithm, and it should be clear that all of
them indeed return a square root of unity. Furthermore, the algorithm does eventually
return within the main for-loop, because xtakes on the sequence of values:
wr;w2r;w4r;w8r; : : : ; w2sr
and the /f_inal value of that sequence satis/f_ies
w2sr=wed 1Nw¹ed 1º%ϕ¹Nº=w1 1=1:
Although we don’t prove it here, it is possible to show that the algorithm returns a square
root of unity chosen uniformly at random from among the four possible square roots of
unity. So with probability 1/2 the output is a nontrivial square root. We can repeat this
basic process ntimes, and eventually encounter a nontrivial square root of unity with
probability 1 2 n. 
246Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
Exercises
13.1. Prove by induction the correctness of the /e.sc/x.sc/t.sc/g.sc/c.sc/d.sc algorithm. That is, whenever
/e.sc/x.sc/t.sc/g.sc/c.sc/d.sc¹x;/y.altºoutputs¹d;a;bº, we have gcd¹x;/y.altº=d=ax+b/y.alt. You may use the fact
that the original Euclidean algorithm correctly computes the GCD.
13.2. Prove that if /afii10069.italan1and/afii10069.italbn1, then/afii10069.italgcd¹a;bºn1.
13.3. Prove that gcd¹2a 1;2b 1º=2gcd¹a;bº 1.
13.4. Prove that xa%n=xa%ϕ¹nº%nfor any x2Z
n. In other words, when working modulo n,
you can reduce exponents modulo ϕ¹nº.
13.5. How many fractions abin lowest terms are there, where 0<ab<1andb6n? For
n=5the answer is 9 since the relevant fractions are:
1
5;1
4;1
3;2
5;1
2;3
5;2
3;3
4;4
5
Write a formula in terms of n. What is the answer for n=100?
Hint:How many are there with denominator exactly equal to n(in terms of n)?
13.6. In this problem we determine the eﬃciency of Euclid’s GCD algorithm. Since its input
is a pair of numbers ¹x;/y.altº, let’s call x+/y.altthesizeof the input. Let Fkdenote the kth
Fibonacci number, using the indexing convention F0=1;F1=2. Prove that¹Fk;Fk 1ºis
the smallest- sizeinput on which Euclid’s algorithm makes krecursive calls.
Hint:
Use induction on k.
Note that the sizeof input¹Fk;Fk 1ºisFk+1, and recall that Fk+1ϕk+1, whereϕ
1:618: : :is the golden ratio. Thus, for any inputs of sizeN2»Fk;Fk+1º, Euclid’s algorithm
will make less than k6logϕNrecursive calls. In other words, the worst-case number
of recursive calls made by Euclid’s algorithm on an input of sizeNisO¹logNº, which is
linear in the number of bits needed to write such an input.8
13.7. Consider the following symmetric-key encryption scheme with plaintext space M=
f0;1gλ. To encrypt a message m, we “pad” minto a prime number by appending a zero
and then random non-zero bytes. We then mulitply by the secret key. To decrypt, we
divide oﬀ the key and then strip away the “padding.”
The idea is that decrypting a ciphertext without knowledge of the secret key requires
factoring the product of two large primes, which is a hard problem.
8A more involved calculation that incorporates the cost of each division (modulus) operation shows the
worst-case overall eﬃciency of the algorithm to be O¹log2Nº— quadratic in the number of bits needed to
write the input.
247Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
KeyGen :
choose random λ-bit prime k
return k
Dec¹k;cº:
m0:=ck
while m0not a multiple of 10:
m0:=bm010c
return m010Enc¹k;m2f0;1gλº:
m0:=10m
while m0not prime:
d f1; : : : ; 9g
m0:=10m0+d
return km0
Show an attack breaking CPA-security of the scheme. That is, describe a distinguisher and
compute its bias.
Hint:Ask for any two ciphertexts.
13.8. Explain why the RSA exponents eanddmust always be odd numbers.
13.9. Why must pandqbedistinct primes? Why is it a bad idea to choose p=q?
13.10. A simple power analysis (SPA) attack is a physical attack on a computer, where the
attacker monitors precisely how much electrical current the processor consumes while
performing a cryptographic algorithm. In this exercise, we will consider an SPA attack
against the M/o.sc/d.scE/x.sc/p.sc algorithm shown in Section 13.2.
TheM/o.sc/d.scE/x.sc/p.sc algorithm consists mainly of squarings and multiplications. Suppose that by
monitoring a computer it is easy to tell when the processor is running a squaring vs. a
multiplication step (this is a very realistic assumption). This assumption is analogous to
having access to the printed output of this modi/f_ied algorithm:
M/o.sc/d.scE/x.sc/p.sc¹m;e;Nº:// compute me%N
ife=0: return 1
ifeeven:
res:=M/o.sc/d.scE/x.sc/p.sc¹m;e
2;Nº2%N
print “square”
ifeodd:
res:=M/o.sc/d.scE/x.sc/p.sc¹m;e 1
2;Nº2m%N
print “square”
print “mult”
return res
Describe how the printed output of this algorithm lets the attacker completely learn the
value e. Remember that in RSA it is indeed the exponent that is secret, so this attack leads
to key recovery for RSA.
Hint:Think about what “ e2,” “¹e 1º2,” and “ eis odd” mean, in terms of the bitsofe.
13.11. The Chinese Remainder Theorem states that there is always a solution for xin the follow-
ing system of equations, when gcd¹r;sº=1:
xru
248Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
xs/v.alt
Give an example u,/v.alt,r,s, with gcd¹r;sº,1for which the equations have no solution.
Explain why there is no solution.
13.12. Prove Claims 13.10 and 13.11.
13.13. Consider a rectangular grid of points, with width wand height h. Starting in the lower-
left of the grid, start walking diagonally northeast. When you fall oﬀ end the grid, wrap
around to the opposite side ( i.e., Pac-Man topology). Below is an example of the /f_irst few
steps you take on a grid with w=3andh=5:
123 345
5
Show that if gcd¹w;hº=1then you will eventually visit every point in the grid.
Hint:Derive a formula for the coordinates of the point you reach after nsteps.
13.14. Suppose¹u;/v.altº2ZrZsis a CRT encoding of x2Zrs. Prove that x2Z
rsif and only if
u2Z
rand/v.alt2Z
s.
Note: this problem implies that ϕ¹rsº=ϕ¹rºϕ¹sºwhen gcd¹r;sº=1. A special case of this
identity is the familiar expression ϕ¹pqº=¹p 1º¹q 1ºwhen pandqare distinct primes.
13.15. There is a bug (or at least an oversight) in the proof that x7!xe%Nand/y.alt7!/y.altd%Nare
inverses. We used the fact that xϕ¹NºN1, but this is only necessarily true for x2Z
N.
Using the Chinese Remainder Theorem, show that the RSA function and its inverse are
truly inverses, even when applied to x<Z
N.
13.16. We are supposed to choose RSA exponents eanddsuch that edϕ¹Nº1. Let N=pqand
de/f_ine the value L=lcm¹p 1;q 1º. Suppose we choose eanddsuch that edL1.
Show that RSA still works for this choice of eandd— in other words, x7!xe%Nand
/y.alt7!/y.altd%Nare inverses.
Hint:
You’ll have to use the Chinese Remainder Theorem.
?13.17. If/y.alteNxthen we call /y.altan “e-th root” of x. One way to think about RSA is that raising
something to the dpower is equivalent to computing an e-th root. Our assumption about
RSA is that it’s hard to compute e-th roots given only public eandN.
In this problem, show that if you are given an a-th root of xandb-th root of the same x,
andgcd¹a;bº=1, then you can easily compute an ab-th root of x.
More formally, given x;/y.alt;zandNwhere/y.altaNxandzbNx, show how to eﬃciently
compute a value wsuch that wabNx.
249Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
Compute wfor the following values (after verifying that /y.altis an a-th root and zis ab-th
root of xmod N):
N = 318753895014839414391833197387495582828703628009180678460009
x = 183418622076108277295248802695684859123490073011079896375192
a = 56685394747281296805145649774065693442016512301628946051059
b = 178205100585526989632998577959780764157496762062661723119813
y = 185575838649944725271855413520846311652963277243867273346885
z = 20697550065842164169278024507041536884260713996371572807344
Hint:It is important that gcd¹a;bº=1. Use Bezout’s theorem.
13.18. Suppose Alice uses the CRT method to sign some message min textbook RSA. In other
words, she computes md%p, then md%q, and /f_inally converts this CRT encoding back to
ZN. But suppose Alice is using faulty hardware (or Eve is bombarding her hardware with
electromagnetic pulses), so that she computes the wrong value mod q. The rest of the
computation happens correctly, and Alice publishes mand the (incorrect) signature σ.
Show that, no matter what mis, and no matter what Alice’s computational error was, Eve
can factor N(upon seeing m,σ, and the public RSA information Nande).
Hint:mpσebutm.qσe.
13.19. (a) Show that given an RSA modulus Nandϕ¹Nº, it is possible to factor Neasily.
Hint:You have two equations (involving ϕ¹NºandN) and two unknowns ( pandq).
(b) Write a Sage function that takes as input an RSA modulus Nandϕ¹Nºand outputs
the prime factors of N. Use it to factor the following 2048-bit RSA modulus. Note: take
care that there are no precision issues in how you solve the problem; double-check
your factorization!
N = 133140272889335192922108409260662174476303831652383671688547009484
253235940586917140482669182256368285260992829447207980183170174867
620358952230969986447559330583492429636627298640338596531894556546
013113154346823212271748927859647994534586133553218022983848108421
465442089919090610542344768294481725103757222421917115971063026806
587141287587037265150653669094323116686574536558866591647361053311
046516013069669036866734126558017744393751161611219195769578488559
882902397248309033911661475005854696820021069072502248533328754832
698616238405221381252145137439919090800085955274389382721844956661
1138745095472005761807
phi = 133140272889335192922108409260662174476303831652383671688547009484
253235940586917140482669182256368285260992829447207980183170174867
620358952230969986447559330583492429636627298640338596531894556546
013113154346823212271748927859647994534586133553218022983848108421
465442089919090610542344768294481725103757214932292046538867218497
635256772227370109066785312096589779622355495419006049974567895189
687318110498058692315630856693672069320529062399681563590382015177
322909744749330702607931428154183726552004527201956226396835500346
779062494259638983191178915027835134527751607017859064511731520440
2981816860178885028680
250Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
13.20. True or false: if x2N1then x2Z
N. Prove or give a counterexample.
13.21. Discuss the computational diﬃculty of the following problem:
Given an integer N, /f_ind a nonzero element of ZNnZ
N.
If you can, relate its diﬃculty to that of other problems we’ve discussed (factoring Nor
inverting RSA).
13.22. (a) Show that it is possible to eﬃciently compute all four square roots of unity modulo
pq, given pandq.
Hint:
CRT!
(b) Implement a Sage function that takes distinct primes pandqas input and returns the
four square roots of unity modulo pq. Use it to compute the four square roots of unity
modulo
1052954986442271985875778192663 611174539744122090068393470777 :
?13.23. Show that, conditioned on w2Z
N, the SqrtUnity subroutine outputs a square root of
unity chosen uniformly at random from the 4 possible square roots of unity.
Hint:
Use the Chinese Remainder Theorem.
13.24. Suppose Nis an RSA modulus, and x2N/y.alt2, but x.N/y.alt. Show that Ncan be eﬃciently
factored if such a pair xand/y.altare known.
13.25. Why are1the only square roots of unity modulo p, when pis an odd prime?
13.26. When Nis an RSA modulus, why is squaring modulo Na 4-to-1 function, but raising to
theethpower modulo Nis 1-to-1?
13.27. Implement a Sage function that eﬃciently factors an RSA modulus N, given only N,e,
andd. Use your function to factor the following 2048-bit RSA modulus.
N = 157713892705550064909750632475691896977526767652833932128735618711
213662561319634033137058267272367265499003291937716454788882499492
311117065951077245304317542978715216577264400048278064574204140564
709253009840166821302184014310192765595015483588878761062406993721
851190041888790873152584082212461847511180066690936944585390792304
663763886417861546718283897613617078370412411019301687497005038294
389148932398661048471814117247898148030982257697888167001010511378
647288478239379740416388270380035364271593609513220655573614212415
962670795230819103845127007912428958291134064942068225836213242131
15022256956985205924967
e = 327598866483920224268285375349315001772252982661926675504591773242
501030864502336359508677092544631083799700755236766113095163469666
905258066495934057774395712118774014408282455244138409433389314036
198045263991986560198273156037233588691392913730537367184867549274
682884119866630822924707702796323546327425328705958528315517584489
590815901470874024949798420173098581333151755836650797037848765578
433873141626191257009250151327378074817106208930064676608134109788
251Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
601067077103742326030259629322458620311949453584045538305945217564
027461013225009980998673160144967719374426764116721861138496780008
6366258360757218165973
d = 138476999734263775498100443567132759182144573474474014195021091272
755207803162019484487127866675422608401990888942659393419384528257
462434633738686176601555755842189986431725335031620097854962295968
391161090826380458969236418585963384717406704714837349503808786086
701573765714825783042297344050528898259745757741233099297952332012
749897281090378398001337057869189488734951853748327631883502135139
523664990296334020327713900408683264232664645438899178442633342438
198329983121207315436447041915897544445402505558420138506655106015
215450140256129977382476062366519087386576874886938585789874186326
69265500594424847344765
13.28. In this problem we’ll see that it’s bad to choose RSA prime factors pandqtoo close to-
gether.
(a) Let N=pqbe an RSA modulus. Show that if you know Nandδ=jp qjthen you
can eﬃciently factor N.
(b) Alice generated the following RSA modulus N=pqand lets you know that jp qj<
10000 . Factor N:
N = 874677518388996663638698301429866315858010681593301504361505917406
679600338654753978646639928231278257025792316921962329748948203153
633013718175380969169006125249183547099230845322374618855425387176
952865483432804575895177869626746459878695728149786382697571962961
898331255405534657194681056148437649091612403258304084081171824215
469594984981192162710052121535309254024720635781955739713239334398
494465828323810812843582187587256744901184016546638718414715249093
757039375585896257839327987501216755865353444704506441078034811012
930282857089819030160822729139768982546143104625315700571887037795
31855302859423676881
13.29. Here is a slightly better method to factor RSA moduli whose factors are too close together.
As before, let N=pq.
(a) De/f_ine t=¹p+qº2. Note that when pandqare close, tis not much larger thanp
N.
Show that:
It2 Nis a perfect square.
IGiven t, it is possible to eﬃciently factor N.
Hint:
Write t2 N=s2for some s.
(b) Write a Sage function that factors RSA moduli whose prime factors are close. Use it
to factor the following 2048-bit number. How close were the factors (how large was
jp qj)?
Hint: Sage has an is_square method. Also, be sure to do exact square roots over the integers, not
the reals.
N = 514202868664266501986736340226343880193216864011643244558701956114
553317880043289827487456460284103951463512024249329243228109624011
252Draft: January 3, 2021 CHAPTER 13. RSA & DIGITAL SIGNATURES
915392411888724026403127686707255825056081890692595715828380690811
131686383180282330775572385822102181209569411961125753242467971879
131305986986525600110340790595987975345573842266766492356686762134
653833064511337433089249621257629107825681429573934949101301135200
918606211394413498735486599678541369375887840013842439026159037108
043724221865116794034194812236381299786395457277559879575752254116
612726596118528071785474551058540599198869986780286733916614335663
3723003246569630373323
25314Diﬀie-Hellman Key Agreement
14.1 Cyclic Groups
Definition 14.1 Let/afii10069.ital2Z
n. De/f_ineh/afii10069.italin=f/afii10069.itali%nji2Zg, the set of all powers of /afii10069.italreduced mod n. Then/afii10069.ital
is called a generator ofh/afii10069.italin, andh/afii10069.italinis called the cyclic group generated by /afii10069.italmod n.
Ifh/afii10069.italin=Z
n, then we say that /afii10069.italis aprimitive root mod n.
The de/f_inition allows the generator /afii10069.italto be raised to a negative integer. Since /afii10069.ital2Z
n,
it is guaranteed that /afii10069.italhas a multiplicative inverse mod n, which we can call /afii10069.ital 1. Then/afii10069.ital i
can be de/f_ined as /afii10069.ital idef=¹/afii10069.ital 1ºi. All of the usual laws of exponents hold with respect to
this de/f_inition of negative exponents.
Example Taking n=13, we have:
h1i13=f1g
h2i13=f1;2;4;8;3;6;12;11;9;5;10;7g=Z
13
h3i13=f1;3;9g
Thus 2 is a primitive root modulo 13. Each of the groups f1g,Z
13,f1;3;9gis a cyclic group
under multiplication mod 13.
A cyclic group may have more than one generator, for example:
h3i13=h9i13=f1;3;9g
Similarly, there are four primitive roots modulo 13 (equivalently, Z
13has four diﬀerent gen-
erators); they are 2, 6, 7, and 11.
Not every integer has a primitive root. For example, there is no primitive root modulo
15. However, when pis a prime, there is always a primitive root modulo p(and so Z
pis a
cyclic group).
Let us write G=h/afii10069.itali=f/afii10069.italiji2Zgto denote an unspeci/f_ied cyclic group generated by
/afii10069.ital. The de/f_ining property of Gis that each of its elements can be written as a power of /afii10069.ital.
From this we can conclude that:
IAny cyclic group is closed under multiplication. That is, take any X;Y2G; then
it must be possible to write X=/afii10069.italxandY=/afii10069.ital/y.altfor some integers x;/y.alt. Using the
multiplication operation of G, the product is XY=/afii10069.italx+/y.alt, which is also in G.
IAny cyclic group is closed under inverses. Take any X2G; then it must be possible
to write X=/afii10069.italxfor some integer x. We can then see that /afii10069.ital x2Gby de/f_inition, and
/afii10069.ital xX=/afii10069.ital x+x=/afii10069.ital0is the identity element. So Xhas a multiplicative inverse ( /afii10069.ital x)
inG.
These facts demonstrate that Gis indeed a group in the terminology of abstract algebra.
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 14. DIFFIE-HELLMAN KEY AGREEMENT
Discrete Logarithms
It is typically easy to compute the value of /afii10069.italxin a cyclic group, given /afii10069.italandx. For ex-
ample, when using a cyclic group of the form Z
n, we can easily compute the modular
exponentiation /afii10069.italx%nusing repeated squaring.
The inverse operation in a cyclic group is called the discrete logarithm problem:
Definition 14.2
(Discrete Log)Thediscrete logarithm problem is: given X2h/afii10069.itali, determine a number xsuch that/afii10069.italx=X.
Here the exponentiation is with respect to the multiplication operation in G=h/afii10069.itali.
The discrete logarithm problem is conjectured to be hard (that is, no polynomial-time
algorithm exists for the problem) in certain kinds of cyclic groups.
14.2 Diﬀie-Hellman Key Agreement
Key agreement refers to the problem of establishing a private channel using public com-
munication. Suppose Alice & Bob have never spoken before and have no shared secrets.
By exchanging public messages ( i.e., that can be seen by any external observer), they would
like to establish a secret that is known only to the two of them.
TheDiﬃe-Hellman protocol is such a key-agreement protocol, and it was the /f_irst
published instance of public-key cryptography:
Construction 14.3
(Diﬀie-Hellman)Both parties agree (publicly) on a cyclic group Gwith generator /afii10069.ital. Let n=jGj. All exponen-
tiations are with respect to the group operation in G.
1. Alice chooses a Zn. She sends A=/afii10069.italato Bob.
2. Bob chooses b Zn. He sends B=/afii10069.italbto Alice.
3. Bob locally outputs K:=Ab. Alice locally outputs K:=Ba.
Alice Bob
a Zn
b ZnA=/afii10069.itala
B=/afii10069.italb
return Bareturn Ab
By substituting and applying standard rules of exponents, we see that both parties
output a common value, namely K=/afii10069.italab2G.
Defining Security for Key Agreement
Executing a key agreement protocol leaves two artifacts behind. First, we have the col-
lection of messages that are exchanged between the two parties. We call this collection a
transcript. We envision two parties executing a key agreement protocol in the presence
of an eavesdropper, and hence we imagine that the transcript is public. Second, we have
thekey that is output by the parties, which is private.
255Draft: January 3, 2021 CHAPTER 14. DIFFIE-HELLMAN KEY AGREEMENT
To de/f_ine security of key agreement, we would like to require that the transcript leaks
no (useful) information to the eavesdropper about the key. There are a few ways to ap-
proach the de/f_inition:
IWe could require that it is hard to compute the key given the transcript. However,
this turns out to be a rather weak de/f_inition. For example, it does not rule out the
possibility that an eavesdropper could guess the /f_irst half of the bits of the key.
IWe could require that the key is pseudorandom given the transcript. This is a better
de/f_inition, and the one we use. To formalize this idea, we de/f_ine two libraries. In both
libraries the adversary / calling program can obtain the transcript of an execution
of the key agreement protocol. In one library the adversary obtains the key that
resulted from the protocol execution, while in the other library the adversary obtains
a totally unrelated key (chosen uniformly from the set Σ:Kof possible keys).
Definition 14.4
(KA security)LetΣbe a key-agreement protocol. We write Σ:Kfor the keyspace of the protocol ( i.e., the
set of possible keys it produces). We write ¹t;Kº /e.sc/x.sc/e.sc/c.sc/p.sc/r.sc/o.sc/t.sc¹Σºto denote the process of
executing the protocol between two honest parties, where tdenotes the resulting transcript, and
Kis resulting key. Note that this process is randomized, and that Kis presumably correlated
tot.
We say that Σissecure ifLΣ
ka-realLΣ
ka-rand, where:
LΣ
ka-real
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
¹t;Kº /e.sc/x.sc/e.sc/c.sc/p.sc/r.sc/o.sc/t.sc¹Σº
return¹t;KºLΣ
ka-rand
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
¹t;Kº /e.sc/x.sc/e.sc/c.sc/p.sc/r.sc/o.sc/t.sc¹Σº
K0 Σ:K
return¹t;K0º
14.3 Decisional Diﬀie-Hellman Problem
The Diﬃe Hellman protocol is parameterized by the choice of cyclic group G(and genera-
tor/afii10069.ital). Transcripts in the protocol consist of ¹/afii10069.itala;/afii10069.italbº, where aandbare chosen uniformly.
The key corresponding to such a transcript is /afii10069.italab. The set of possible keys is the cyclic
group G.
Let us substitute the details of the Diﬃe-Hellman protocol into the KA security li-
braries. After simplifying, we see that the security of the Diﬃe Hellman protocol is equiv-
alent to the following statement:
LG
dh-real
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
a;b Zn
return¹/afii10069.itala;/afii10069.italb;/afii10069.italabºLG
dh-rand
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
a;b;c Zn
return¹/afii10069.itala;/afii10069.italb;/afii10069.italcº
We have renamed the libraries to Ldh-real andLdh-rand . InLdh-real the response to /q.sc_u.sc/e.sc/r.sc/y.sc
corresponds to a DHKA transcript ¹/afii10069.itala;/afii10069.italbºalong with the corresponding “correct” key
256Draft: January 3, 2021 CHAPTER 14. DIFFIE-HELLMAN KEY AGREEMENT
/afii10069.italab. The response inLdh-rand corresponds to a DHKA transcript along with a completely
independent random key /afii10069.italc.
Definition 14.5
(DDH)Thedecisional Diﬃe-Hellman (DDH) assumption in a cyclic group Gis thatLG
dh-real
LG
dh-rand(libraries de/f_ined above).
Since we have de/f_ined the DDH assumption by simply renaming the security de/f_inition
for DHKA, we immediately have:
Claim 14.6 The DHKA protocol is a secure KA protocol if and only if the DDH assumption is true for
the choice of Gused in the protocol.
For Which Groups does the DDH Assumption Hold?
So far our only example of a cyclic group is Z
p, where pis a prime. Although many
textbooks describe DHKA in terms of this cyclic group, it is not a good choice because the
DDH assumption is demonstrably false inZ
p. To see why, we introduce a new concept:
Claim 14.7
(Euler criterion)Ifpis a prime and X=/afii10069.italx2Z
p, then Xp 1
2p¹ 1ºx.
Note that¹ 1ºxis 1 if xis even and 1ifxis odd. So, while in general it is hard to
determine xgiven/afii10069.italx, Euler’s criterion says that it is possible to determine the parity of x
(i.e., whether xis even or odd) given /afii10069.italx.
To see how these observations lead to an attack against the Diﬃe-Hellman protocol,
consider the following attack:
A:
¹A;B;Cº /q.sc_u.sc/e.sc/r.sc/y.sc¹º
return 1?pCp 1
2
Roughly speaking, the adversary returns true whenever Ccan be written as /afii10069.italraised to
aneven exponent. When linked to Ldh-real ,C=/afii10069.italabwhere aandbare chosen uniformly.
Hence abwill be even with probability 3/4. When linked to Ldh-rand ,C=/afii10069.italcfor an indepen-
dent random c. Socis even only with probability 1/2. Hence the adversary distinguishes
the libraries with advantage 1/4.
Concretely, with this choice of group, the key /afii10069.italabwill never be uniformly distributed.
See the exercises for a slightly better attack which correlates the key to the transcript.
Quadratic Residues. Several better choices of cyclic groups have been proposed in the
literature. Arguably the simplest one is based on the following de/f_inition:
Definition 14.8 A number X2Z
nis aquadratic residue modulo nif there exists some integer Ysuch that
Y2nX. That is, if Xcan be obtained by squaring a number mod n. LetQR
nZ
ndenote
the set of quadratic residues mod n.
For our purposes it is enough to know that, when pis prime, QR
pis a cyclic group with
¹p 1º2elements (see the exercises). When both pand¹p 1º2are prime, we call pa
safe prime (and call¹p 1º2aSophie Germain prime ). To the best of our knowledge the
DDH assumption is true in QR
pwhen pis a safe prime.
257Draft: January 3, 2021 CHAPTER 14. DIFFIE-HELLMAN KEY AGREEMENT
Exercises
14.1. Let pbe an odd prime, as usual. Recall that QR
pis the set of quadratic residues mod p
— that is, QR
p=fx2Z
pj9/y.alt:xp/y.alt2g. Show that if /afii10069.italis a primitive root of Z
pthen
h/afii10069.ital2i=QR
p.
Note: This means that /afii10069.itala2QR
pif and only if ais even — and in particular, the choice of
generator/afii10069.italdoesn’t matter.
14.2. Suppose N=pqwhere pandqare distinct primes. Show that jQR
Nj=jQR
pjjQR
qj.
Hint:
Chinese remainder theorem.
14.3. Suppose you are given X2 h/afii10069.itali. You are allowed to choose any X0,Xand learn the
discrete log of X0(with respect to base /afii10069.ital). Show that you can use this ability to learn the
discrete log of X.
14.4. Leth/afii10069.italibe a cyclic group with nelements and generator /afii10069.ital. Show that for all integers a, it
is true that /afii10069.itala=/afii10069.itala%n.
Note: As a result,h/afii10069.italiis isomorphic to the additive group Zn.
14.5. Let/afii10069.italbe a primitive root of Z
n. Recall that Z
nhasϕ¹nºelements. Show that /afii10069.italais a primitive
root of Z
nif and only if gcd¹a;ϕ¹nºº=1.
Note: It follows that, for every n, there are either 0 or ϕ¹ϕ¹nººprimitive roots mod n.
14.6. Leth/afii10069.italibe a cyclic group with nelements. Show that for all x;/y.alt2 h/afii10069.itali, it is true that
xn=/y.altn.
Hint:Every x2h/afii10069.italican be written as x=/afii10069.italafor some appropriate a. What is¹/afii10069.italaºn?
14.7. (a) Prove the following variant of Lemma 4.10: Suppose you /f_ix a value x2ZN. Then
when sampling q=p
2Nvalues r1; : : : ; rquniformly from ZN, with probability at
least 0.6 there exist i,jwith riNrj+x.
(b) Let/afii10069.italbe a primitive root of Z
p(for some prime p). Consider the problem of computing
the discrete log of X2Z
pwith respect to /afii10069.ital— that is, /f_inding xsuch that Xp/afii10069.italx.
Argue that if one can /f_ind integers randssuch that/afii10069.italrpX/afii10069.italsthen one can compute
the discrete log of X.
(c) Combine the above two observations to describe a O¹ppº-time algorithm for the dis-
crete logarithm problem in Z
p.
14.8. In an execution of DHKA, the eavesdropper observes the following values:
p=461733370363 A=114088419126
/afii10069.ital=2 B=276312808197
What will be Alice & Bob’s shared key?
14.9. Explain what is wrong in the following argument:
258Draft: January 3, 2021 CHAPTER 14. DIFFIE-HELLMAN KEY AGREEMENT
In Diﬃe-Hellman key agreement, Alice sends A=/afii10069.italaand Bob sends B=/afii10069.italb. Their
shared key is /afii10069.italab. To break the scheme, the eavesdropper can simply compute
AB=¹/afii10069.italaº¹/afii10069.italbº=/afii10069.italab.
14.10. Let Gbe a cyclic group with nelements and generator /afii10069.ital. Consider the following algorithm:
/r.sc/a.sc/n.sc/d.sc¹A;B;Cº:
r;s;t Zn
A0:=At/afii10069.italr
B0:=B/afii10069.itals
C0:=CtBrAst/afii10069.italrs
return¹A0;B0;C0º
LetDH=f¹/afii10069.itala;/afii10069.italb;/afii10069.italabº2G3ja;b;2Zng.
(a) Suppose¹A;B;Cº 2DH. Show that the output distribution of /r.sc/a.sc/n.sc/d.sc¹A;B;Cºis the
uniform distribution over DH
(b) Suppose¹A;B;Cº<DH. Show that the output distribution of /r.sc/a.sc/n.sc/d.sc¹A;B;Cºis the
uniform distribution over G3.
?(c) Consider the problem of determining whether a given triple ¹A;B;Cºis in the set DH.
Suppose you have an algorithm Athat solves this problem on average slightly better
than chance. That is:
Pr»A¹A;B;Cº=1¼>0:51when¹A;B;Cºchosen uniformly in DH
Pr»A¹A;B;Cº=0¼>0:51when¹A;B;Cºchosen uniformly in G3
The algorithmAdoes not seem very useful if you have a particular triple¹A;B;Cºand
you really want to know whether it is in DH. You might have one of the triples for
whichAgives the wrong answer, and there’s no real way to know.
Show how to construct a randomized algorithm A0such that: for every ¹A;B;Cº2G3:
Prh
A0¹A;B;Cº=»¹A;B;Cº?2DH¼i
>0:99
Here the input A;B;Cis /f_ixed and the probability is over the internal randomness in
A0. So on every possible input,A0gives a very reliable answer.
to-do better attack against Z
pinstantiation of DHKA
25915Public-Key Encryption
So far, the encryption schemes that we’ve seen are symmetric-key schemes. The same
key is used to encrypt and decrypt. In this chapter we introduce public-key (sometimes
called asymmetric ) encryption schemes, which use diﬀerent keys for encryption and de-
cryption. The idea is that the encryption key can be made public , so that anyone can send
an encryption to the owner of that key, even if the two users have never spoken before
and have no shared secrets. The decryption key is private, so that only the designated
owner can decrypt.
We modify the syntax of an encryption scheme in the following way. A public-key
encryption scheme consists of the following three algorithms:
KeyGen : Outputs a pair¹pk;skºwhere pkis a public key and skis a private/secret key.
Enc: Takes the public key pkand a plaintext mas input, and outputs a ciphertext c.
Dec: Takes the secret key skand a ciphertext cas input, and outputs a plaintext m.
We modify the correctness condition similarly. A public-key encryption scheme satis/f_ies
correctness if, for all m2M and all¹pk;skº KeyGen , we have Dec¹sk;Enc¹pk;mºº=m
(with probability 1 over the randomness of Enc).
15.1 Security Definitions
We now modify the de/f_inition of CPA security to /f_it the setting of public-key encryption.
As before, the adversary calls a /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc subroutine with two plaintexts — the diﬀer-
ence between the two libraries is which plaintext is actually encrypted. Of course, the
encryption operation now takes the public key.
Then the biggest change is that we would like to make the public key public. In other
words, the calling program should have a way to learn the public key (otherwise the library
cannot model a situation where the public key is known to the adversary). To do this, we
simply add another subroutine that returns the public key.
Definition 15.1 LetΣbe a public-key encryption scheme. Then Σissecure against chosen-plaintext at-
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 CHAPTER 15. PUBLIC-KEY ENCRYPTION
tacks (CPA secure) ifLΣ
pk-cpa-LLΣ
pk-cpa-R, where:
LΣ
pk-cpa-L
¹pk;skº Σ:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mR2Σ:Mº:
return Σ:Enc¹pk;mLºLΣ
pk-cpa-R
¹pk;skº Σ:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mR2Σ:Mº:
return Σ:Enc¹pk;mRº
to-do Re-iterate how deterministic encryption still can’t be CPA-secure in the public-key setting.
Pseudorandom Ciphertexts
We can modify/adapt the de/f_inition of pseudorandom ciphertexts to public-key encryption
in a similar way:
Definition 15.2 LetΣbe a public-key encryption scheme. Then Σhaspseudorandom ciphertexts in the
presence of chosen-plaintext a/t_tacks (CPA$ security) ifLΣ
pk-cpa$-realLΣ
pk-cpa$-rand,
where:
LΣ
pk-cpa$-real
¹pk;skº Σ:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m2Σ:Mº:
return Σ:Enc¹pk;mºLΣ
pk-cpa$-rand
¹pk;skº Σ:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m2Σ:Mº:
c Σ:C
return c
As in the symmetric-key setting, CPA$ security (for public-key encryption) implies
CPA security:
Claim 15.3 LetΣbe a public-key encryption scheme. If Σhas CPA$ security, then Σhas CPA security.
The proof is extremely similar to the proof of the analogous statement for symmetric-
key encryption (Theorem 7.3), and is left as an exercise.
15.2 One-Time Security Implies Many-Time Security
So far, everything about public-key encryption has been directly analogous to what we’ve
seen about symmetric-key encryption. We now discuss a peculiar property that is diﬀerent
between the two settings.
261Draft: January 3, 2021 CHAPTER 15. PUBLIC-KEY ENCRYPTION
In symmetric-key encryption, we saw examples of encryption schemes that are secure
when the adversary sees only one ciphertext, but insecure when the adversary sees more
ciphertexts. One-time pad is the standard example of such an encryption scheme.
Surprisingly, if a public-key encryption scheme is secure when the adversary sees just
one ciphertext, then it is also secure for many ciphertexts! In short, there is no public-key
one-time pad that is weaker than full-/f_ledged public-key encryption — there is public-key
encryption or nothing.
To show this property formally, we /f_irst adapt the de/f_inition of one-time secrecy (Def-
inition 2.6) to the public-key setting. There is one small but important technical subtlety:
in De/f_inition 2.6 the encryption key is chosen at the last possible moment in the body of
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc . This ensures that the key is local to this scope, and therefore each value of
the key is only used to encrypt one plaintext.
In the public-key setting, however, it turns out to be important to allow the adver-
sary to see the public key before deciding which plaintexts to encrypt. (This concern is
not present in the symmetric-key setting precisely because there is nothing public upon
which the adversary’s choice of plaintexts can depend.) For that reason, in the public-key
setting we must sample the keys at initialization time so that the adversary can obtain the
public key via /g.sc/e.sc/t.sc/p.sc/k.sc . To ensure that the key is used to encrypt only one plaintext, we
add a counter and a guard condition to /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc , so that it only responds once with a
ciphertext.
Definition 15.4 LetΣbe a public-key encryption scheme. Then Σhasone-time secrecy ifLΣ
pk-ots-L
LΣ
pk-ots-R, where:
LΣ
pk-ots-L
¹pk;skº Σ:KeyGen
count :=0
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mR2Σ:Mº:
count :=count +1
ifcount >1: return null
return Σ:Enc¹pk;mLºLΣ
pk-ots-R
¹pk;skº Σ:KeyGen
count :=0
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mR2Σ:Mº:
count :=count +1
ifcount >1: return null
return Σ:Enc¹pk;mRº
Claim 15.5 LetΣbe a public-key encryption scheme. If Σhas one-time secrecy, then Σis CPA-secure.
Proof SupposeLΣ
pk-ots-LLΣ
pk-ots-R. Our goal is to show that LΣ
pk-cpa-LLΣ
pk-cpa-R. The proof
centers around the following hybrid library Lhyb-h, which is designed to be linked to either
262Draft: January 3, 2021 CHAPTER 15. PUBLIC-KEY ENCRYPTION
Lpk-ots-L orLpk-ots-R :
Lhyb-h
count =0
pk:=/g.sc/e.sc/t.sc/p.sc/k.sc¹º
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mR2Σ:Mº:
count :=count +1
ifcount <h:
return Σ:Enc¹pk;mRº
elsifcount =h:
return /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc0¹mL;mRº
else:
return Σ:Enc¹pk;mLº
Here the value his an unspeci/f_ied value that will be a hard-coded constant, and
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc0(called by the “elsif” branch) and /g.sc/e.sc/t.sc/p.sc/k.sc refer to the subroutine in Lpk-ots- ?.
Note thatLhyb-his designed so that it only makes one call to /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc0— in particular,
only when its own /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc subroutine is called for the hthtime.
We now make a few observations:
Lhyb- 1L pk-ots-LL pk-cpa-L : In both libraries, every call to /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc en-
crypts the left plaintext. In particular, the /f_irst
call to /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc inLhyb- 1triggers the “elsif”
branch, so the challenge is routed to Lpk-ots-L ,
which encrypts the left plaintext. In all other
calls to /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc , the “else” branch is trig-
gered and the left plaintext is encrypted explic-
itly.
Lhyb-hL pk-ots-RL hyb-¹h+1ºL pk-ots-L , for all h. In both of these libraries, the /f_irst h
calls to /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc encrypt the right plaintext,
and all subsequent calls encrypt the left plain-
text.
Lhyb-hL pk-ots-LLhyb-hL pk-ots-R , for all h. This simply follows from the fact
thatLpk-ots-LLpk-ots-R .
Lhyb-qL pk-ots-RL pk-cpa-R , where qis the number of times the calling pro-
gram calls /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc . In particular, every call
to/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc encrypts the right plaintext.
Putting everything together, we have that:
Lpk-cpa-LL hyb- 1L pk-ots-LLhyb- 1L pk-ots-R
L hyb- 2L pk-ots-LLhyb- 2L pk-ots-R
:::
263Draft: January 3, 2021 CHAPTER 15. PUBLIC-KEY ENCRYPTION
L hyb-qL pk-ots-LLhyb-qL pk-ots-R
L pk-cpa-R ;
and soLpk-cpa-LLpk-cpa-R . 
The reason this proof goes through for public-key encryption but not symmetric-key
encryption is that anyone can encrypt in a public-key scheme. In a symmetric-key scheme,
it is not possible to generate encryptions without the key. But in a public-key scheme, the
encryption key is public.
In more detail, the Lhyb-hlibrary can indeed obtain pkfromLpk-ots- ?. It therefore has
enough information to perform the encryptions for all calls to /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc . Indeed, you
can think ofLhyb- 0as doing everything that Lpk-cpa-L does, even though it doesn’t know
the secret key. We let Lhyb-hdesignate the hthcall to /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc as a special one to be
handled byLpk-ots- ?. This allows us to change the hthencryption from using mLtomR.
15.3 ElGamal Encryption
ElGamal encryption is a public-key encryption scheme that is based on DHKA.
Construction 15.6
(ElGamal)The public parameters are a choice of cyclic group Gwith nelements and generator /afii10069.ital.
M=G
C=G2KeyGen :
sk:=a Zn
pk:=A:=/afii10069.itala
return¹pk;skºEnc¹A;M2Gº:
b Zn
B:=/afii10069.italb
return¹B;MAbºDec¹a;¹B;Xºº:
return X¹Baº 1
The scheme satis/f_ies correctness, since for all M:
Dec¹sk;Enc¹pk;Mºº=Dec¹sk;¹/afii10069.italb;MAbºº
=¹MAbº¹¹/afii10069.italbºaº 1
=M¹/afii10069.italabº¹/afii10069.italabº 1=M:
Security
Imagine an adversary who is interested in attacking an ElGamal scheme. This adversary
sees the public key A=/afii10069.italaand a ciphertext¹/afii10069.italb;M/afii10069.italabºgo by. Intuitively, the Decisional
Diﬃe-Hellman assumption says that the value /afii10069.italablooks random, even to someone who
has seen/afii10069.italaand/afii10069.italb. Thus, the message Mis masked with a pseudorandom group element
— as we’ve seen before, this is a lot like masking the message with a random pad as in
one-time pad. The only change here is that instead of the /x.sc/o.sc/r.scoperation, we are using the
group operation in G.
More formally, we can prove the security of ElGamal under the DDH assumption:
Claim 15.7 If the DDH assumption in group Gis true, then ElGamal in group Gis CPA$-secure.
264Draft: January 3, 2021 CHAPTER 15. PUBLIC-KEY ENCRYPTION
Proof It suﬃces to show that ElGamal has pseudorandom ciphertexts when the calling program
sees only a single ciphertext. In other words, we will show that Lpk-ots$-realLpk-ots$-rand ,
where these libraries are the Lpk-cpa$- ?libraries from De/f_inition 15.2 but with the single-
ciphertext restriction used in De/f_inition 15.4. It is left as an exercise to show that
Lpk-ots$-realLpk-ots$-rand implies CPA$ security (which in turn implies CPA security);
the proof is very similar to that of Claim 15.5.
The sequence of hybrid libraries is given below:
Lpk-ots$-real
a Zn
A:=/afii10069.itala
count =0
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return A
/q.sc_u.sc/e.sc/r.sc/y.sc¹M2Gº:
count :count +1
ifcount >1: return null
b Zn
B:=/afii10069.italb
X:=MAb
return¹B;XºThe starting point is the
Lpk-ots$-real library, shown here
with the details of ElGamal /f_illed
in.
a Zn;b Zn
A:=/afii10069.itala;B:=/afii10069.italb;C:=Ab
count =0
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return A
/q.sc_u.sc/e.sc/r.sc/y.sc¹M2Gº:
count :count +1
ifcount >1: return null
X:=MC
return¹B;XºThe main body of /q.sc_u.sc/e.sc/r.sc/y.sc com-
putes some intermediate values
BandAb. But since those lines
are only reachable one time, it
does not change anything to pre-
compute them at initialization
time.
265Draft: January 3, 2021 CHAPTER 15. PUBLIC-KEY ENCRYPTION
¹A;B;Cº /d.sc/h.sc/q.sc_u.sc/e.sc/r.sc/y.sc¹º
count =0
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return A
/q.sc_u.sc/e.sc/r.sc/y.sc¹M2Gº:
count :count +1
ifcount >1: return null
X:=MC
return¹B;XºLdh-real
/d.sc/h.sc/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
a;b Zn
return¹/afii10069.itala;/afii10069.italb;/afii10069.italabºWe can factor out the genera-
tion of A;B;Cin terms of the
Ldh-real library from the De-
cisional Diﬃe-Hellman security
de/f_inition (De/f_inition 14.5).
¹A;B;Cº /d.sc/h.sc/q.sc_u.sc/e.sc/r.sc/y.sc¹º
count =0
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return A
/q.sc_u.sc/e.sc/r.sc/y.sc¹M2Gº:
count :count +1
ifcount >1: return null
X:=MC
return¹B;XºLdh-rand
/d.sc/h.sc/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
a;b;c Zn
return¹/afii10069.itala;/afii10069.italb;/afii10069.italcºApplying the security of DDH,
we can replaceLdh-real with
Ldh-rand .
a;b;c Zn
A:=/afii10069.itala;B:=/afii10069.italb;C:=/afii10069.italc
count =0
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return A
/q.sc_u.sc/e.sc/r.sc/y.sc¹M2Gº:
count :count +1
ifcount >1: return null
X:=MC
return¹B;XºThe call to /d.sc/h.sc/q.sc_u.sc/e.sc/r.sc/y.sc has been in-
lined.
266Draft: January 3, 2021 CHAPTER 15. PUBLIC-KEY ENCRYPTION
a Zn
A:=/afii10069.itala
count =0
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return A
/q.sc_u.sc/e.sc/r.sc/y.sc¹M2Gº:
count :count +1
ifcount >1: return null
b;c Zn
B:=/afii10069.italb;C:=/afii10069.italc
X:=MC
return¹B;XºAs before, since the main body of
/q.sc_u.sc/e.sc/r.sc/y.sc is only reachable once, we
can move the choice of BandC
into that subroutine instead of at
initialization time.
Lpk-ots$-rand
a Zn
A:=/afii10069.itala
count =0
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return A
/q.sc_u.sc/e.sc/r.sc/y.sc¹M2Gº:
count :count +1
ifcount >1: return null
b;x Zn
B:=/afii10069.italb;X:=/afii10069.italx
return¹B;XºWhen bis sampled uniformly
fromZn, the expression B=/afii10069.italb
is a uniformly distributed ele-
ment of G. Also recall that when
Cis a uniformly distributed el-
ement of G, then MCis uni-
formly distributed — this is anal-
ogous to the one-time pad prop-
erty (see Exercise 2.5). Applying
this change gives the library to
the left.
In the /f_inal hybrid, the response to /q.sc_u.sc/e.sc/r.sc/y.sc is a pair of uniformly distributed group
elements¹B;Xº. Hence that library is exactly Lpk-ots$-rand , as desired. 
15.4 Hybrid Encryption
As a rule, public-key encryption schemes are much more computationally expensive than
symmetric-key schemes. Taking ElGamal as a representative example, computing /afii10069.italbin a
cryptographically secure cyclic group is considerably more expensive than one evaluation
of AES. As the plaintext data increases in length, the diﬀerence in cost between public-key
and symmetric-key techniques only gets worse.
A clever way to minimize the cost of public-key cryptography is to use a method
called hybrid encryption. The idea is to use the expensive public-key scheme to encrypt
atemporary key for a symmetric-key scheme. Then use the temporary key to (cheaply)
encrypt the large plaintext data.
267Draft: January 3, 2021 CHAPTER 15. PUBLIC-KEY ENCRYPTION
To decrypt, one can use the decryption key of the public-key scheme to obtain the
temporary key. Then the temporary key can be used to decrypt the main payload.
Construction 15.8
(Hybrid Enc)LetΣpubbe a public-key encryption scheme, and let Σsymbe a symmetric-key encryption
scheme, where Σsym:KΣpub:M— that is, the public-key scheme is capable of encrypting
keys of the symmetric-key scheme.
Then we de/f_ine Σhybto be the following construction:
M=Σsym:M
C=Σpub:CΣsym:C
KeyGen :
¹pk;skº Σpub:KeyGen
return¹pk;skºEnc¹pk;mº:
tk Σsym:KeyGen
cpub Σpub:Enc¹pk;tkº
csym Σsym:Enc¹tk;mº
return¹cpub;csymº
Dec¹sk;¹cpub;csymºº:
tk:=Σpub:Dec¹sk;cpubº
return Σsym:Dec¹tk;csymº
Importantly, the message space of the hybrid encryption scheme is the message space of
the symmetric-key scheme (think of this as involving very long plaintexts), but encryption
and decryption involves expensive public-key operations only on a small temporary key
(think of this as a very short string).
The correctness of the scheme can be veri/f_ied via:
Dec¹sk;Enc¹pk;mºº=Dec
sk; Σpub:Enc¹pk;tkº;Σsym:Enc¹tk;mº
=Σsym:Dec
Σpub:Dec sk;Σpub:Enc¹pk;tkº;Σsym:Enc¹tk;mº
=Σsym:Dec
tk;Σsym:Enc¹tk;mº
=m:
To show that hybrid encryption is a valid way to encrypt data, we prove that it provides
CPA security, when its two components have appropriate security properties:
Claim 15.9 IfΣsymis a one-time-secret symmetric-key encryption scheme and Σpubis a CPA-secure public-
key encryption scheme, then the hybrid scheme Σhyb(Construction 15.8) is also a CPA-secure
public-key encryption scheme.
Note that Σsymdoes not even need to be CPA-secure. Intuitively, one-time secrecy
suﬃces because each temporary key tkis used only once to encrypt just a single plaintext.
Proof As usual, our goal is to show that LΣhyb
pk-cpa-LLΣhyb
pk-cpa-R, which we do in a standard sequence
of hybrids:
268Draft: January 3, 2021 CHAPTER 15. PUBLIC-KEY ENCRYPTION
LΣhyb
pk-cpa-L
¹pk;skº Σpub:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mRº:
tk Σsym:KeyGen
cpub Σpub:Enc¹pk;tkº
csym Σsym:Enc¹tk;mLº
return¹cpub;csymºThe starting point is Lpk-cpa-L , shown here with the details
ofΣhyb/f_illed in.
Our only goal is to somehow replace mLwith mR. Since mL
is only used as a plaintext for Σsym, it is tempting to simply
apply the one-time-secrecy property of Σsymto argue that
mLcan be replaced with mR. Unfortunately, this cannot
work because the keyused for that ciphertext is tk, which
is used elsewhere. In particular, it is used as an argument
toΣpub:Enc.
However, using tkas the plaintext argument to Σpub:Encshould hidetkto the calling
program, if Σpubis CPA-secure. That is, the Σpub-encryption of tkshould look like a Σpub-
encryption of some unrelated dummy value. More formally, we can factor out the call to
Σpub:Encin terms of theLpk-cpa-L library, as follows:
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mRº:
tk Σsym:KeyGen
tk0 Σsym:KeyGen
cpub /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc0¹tk;tk0º
csym Σsym:Enc¹tk;mLº
return¹cpub;csymºLΣpub
pk-cpa-L
¹pk;skº Σpub:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc0¹tkL;tkRº:
return Σpub:Enc¹pk;tkLº
Here we have changed the variable names of the arguments of /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc0to avoid un-
necessary confusion. Note also that /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc now chooses twotemporary keys — one
which is actually used to encrypt mLand one which is not used anywhere. This is because
syntactically we must have two arguments to pass into /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc0.
Now imagine replacing Lpk-cpa-L withLpk-cpa-R and then inlining subroutine calls. The
result is:
¹pk;skº Σpub:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mRº:
tk Σsym:KeyGen
tk0 Σsym:KeyGen
cpub Σpub:Enc¹pk;tk0º
csym Σsym:Enc¹tk;mLº
return¹cpub;csymº
At this point, it does now work to factor out the call to Σsym:Encin terms of theLots-L
library. This is because the key tkis not used anywhere else in the library. The result of
269Draft: January 3, 2021 CHAPTER 15. PUBLIC-KEY ENCRYPTION
factoring out in this way is:
¹pk;skº Σpub:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mRº:
tk0 Σsym:KeyGen
cpub Σpub:Enc¹pk;tk0º
csym /c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc0¹mL;mRº
return¹cpub;csymºLΣsym
ots-L
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc0¹mL;mRº:
tk Σsym:KeyGen
return Σsym:Enc¹tk;mLº
At this point, we can replace Lots-L withLots-R. After this change the Σsym-ciphertext
encrypts mRinstead of mL. This is the “half-way point” of the proof, and the rest of the
steps are a mirror image of what has come before. In summary: we inline Lots-R, then
we apply CPA security to replace the Σpub-encryption of tk0with tk. The result is exactly
Lpk-cpa-R , as desired. 
Exercises
15.1. Prove Claim 15.3.
15.2. Show that a 2-message key-agreement protocol exists if and only if CPA-secure public-key
encryption exists.
In other words, show how to construct a CPA-secure encryption scheme from any 2-
message KA protocol, and vice-versa. Prove the security of your constructions.
15.3. (a) Suppose you are given an ElGamal encryption of an unknown plaintext M2G. Show
how to construct a diﬀerent ciphertext that also decrypts to the same M.
(b) Suppose you are given two ElGamal encryptions, of unknown plaintexts M1;M22G.
Show how to construct a ciphertext that decrypts to their product M1M2.
15.4. Suppose you obtain two ElGamal ciphertexts ¹B1;C1º,¹B2;C2ºthat encrypt unknown plain-
texts M1andM2. Suppose you also know the public key Aand cyclic group generator /afii10069.ital.
(a) What information can you infer about M1andM2if you observe that B1=B2?
(b) What information can you infer about M1andM2if you observe that B1=/afii10069.italB2?
?(c) What information can you infer about M1andM2if you observe that B1=¹B2º2?
270>Index of Security Definitions
One-time uniform ciphertexts for symmetric-key encryption (De/f_inition 2.5):
LΣ
ots$-real
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
k Σ:KeyGen
c Σ:Enc¹k;mº
return cLΣ
ots$-rand
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
c Σ:C
return c
One-time secrecy for symmetric-key encryption (De/f_inition 2.6):
LΣ
ots-L
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
k Σ:KeyGen
c Σ:Enc¹k;mLº
return cLΣ
ots-R
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
k Σ:KeyGen
c Σ:Enc¹k;mRº
return c
t-out-of- nsecret sharing (De/f_inition 3.3):
LΣ
tsss-L
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR2Σ:M;Uº:
ifjUj>Σ:t: return err
s Σ:Share¹mLº
returnfsiji2UgLΣ
tsss-R
/s.sc/h.sc/a.sc/r.sc/e.sc¹mL;mR2Σ:M;Uº:
ifjUj>Σ:t: return err
s Σ:Share¹mRº
returnfsiji2Ug
Pseudorandom generator (De/f_inition 5.1):
LG
prg-real
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
s f0;1gλ
return G¹sºLG
prg-rand
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
r f0;1gλ+`
return r
Pseudorandom function (De/f_inition 6.1):
LF
prf-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1ginº:
return F¹k;xºLF
prf-rand
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1ginº:
ifT»x¼unde/f_ined:
T»x¼ f 0;1gout
return T»x¼
©Copyright Mike Rosulek. Creative Commons BY-NC-SA 4.0. Latest version at joyofcryptography.com.Draft: January 3, 2021 INDEX OF SECURITY DEFINITIONS
Pseudorandom permutation (De/f_inition 6.6):
LF
prp-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1gblenº:
return F¹k;xºLF
prp-rand
T:=empty assoc. array
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1gblenº:
ifT»x¼unde/f_ined:
T»x¼ f 0;1gblennT:values
return T»x¼
Strong pseudorandom permutation (De/f_inition 6.13):
LF
sprp-real
k f0;1gλ
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1gblenº:
return F¹k;xº
/i.sc/n.sc/v.sc/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹/y.alt2f0;1gblenº:
return F 1¹k;/y.altºLF
sprp-rand
T;Tinv:=empty assoc. arrays
/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹x2f0;1gblenº:
ifT»x¼unde/f_ined:
/y.alt f0;1gblennT:values
T»x¼:=/y.alt;Tinv»/y.alt¼:=x
return T»x¼
/i.sc/n.sc/v.sc/l.sc/o.sc/o.sc/k.sc/u.sc/p.sc¹/y.alt2f0;1gblenº:
ifTinv»/y.alt¼unde/f_ined:
x f0;1gblennTinv:values
Tinv»/y.alt¼:=x;T»x¼:=/y.alt
return Tinv»/y.alt¼
CPA security for symmetric-key encryption (De/f_inition 7.1, Section 8.2):
LΣ
cpa-L
k Σ:KeyGen
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
ifjmLj,jmRjreturn err
c:=Σ:Enc¹k;mLº
return cLΣ
cpa-R
k Σ:KeyGen
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
ifjmLj,jmRjreturn err
c:=Σ:Enc¹k;mRº
return c
CPA$ security for symmetric-key encryption (De/f_inition 7.2, Section 8.2):
LΣ
cpa$-real
k Σ:KeyGen
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m2Σ:Mº:
c:=Σ:Enc¹k;mº
return cLΣ
cpa$-rand
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m2Σ:Mº:
c Σ:C¹jmjº
return c
272Draft: January 3, 2021 INDEX OF SECURITY DEFINITIONS
CCA security for symmetric-key encryption (De/f_inition 9.1):
LΣ
cca-L
k Σ:KeyGen
S:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
ifjmLj,jmRjreturn err
c:=Σ:Enc¹k;mLº
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
return Σ:Dec¹k;cºLΣ
cca-R
k Σ:KeyGen
S:=;
/e.sc/a.sc/v.sc/e.sc/s.sc/d.sc/r.sc/o.sc/p.sc¹mL;mR2Σ:Mº:
ifjmLj,jmRjreturn err
c:=Σ:Enc¹k;mRº
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
return Σ:Dec¹k;cº
CCA$ security for symmetric-key encryption (De/f_inition 9.2):
LΣ
cca$-real
k Σ:KeyGen
S:=;
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
c:=Σ:Enc¹k;mº
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
return Σ:Dec¹k;cºLΣ
cca$-rand
k Σ:KeyGen
S:=;
/c.sc/t.sc/x.sc/t.sc¹m2Σ:Mº:
c Σ:C¹jmjº
S:=S[f cg
return c
/d.sc/e.sc/c.sc/r.sc/y.sc/p.sc/t.sc¹c2Σ:Cº:
ifc2Sreturn err
return Σ:Dec¹k;cº
MAC (De/f_inition 10.2):
LΣ
mac-real
k Σ:KeyGen
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹m2Σ:Mº:
return Σ:MAC¹k;mº
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m2Σ:M;tº:
return t?=Σ:MAC¹k;mºLΣ
mac-fake
k Σ:KeyGen
T:=;
/g.sc/e.sc/t.sc/t.sc/a.sc/g.sc¹m2Σ:Mº:
t:=Σ:MAC¹k;mº
T:=T[f¹ m;tºg
return t
/c.sc/h.sc/e.sc/c.sc/k.sc/t.sc/a.sc/g.sc¹m2Σ:M;tº:
return¹m;tº?2T
273Draft: January 3, 2021 INDEX OF SECURITY DEFINITIONS
Collision resistance (De/f_inition 11.1):
LH
cr-real
s f0;1gλ
/g.sc/e.sc/t.sc/s.sc/a.sc/l.sc/t.sc¹º:
return s
/t.sc/e.sc/s.sc/t.sc¹x;x02f0;1gº:
ifx,x0andH¹s;xº=H¹s;x0º: return true
return falseLH
cr-fake
s f0;1gλ
/g.sc/e.sc/t.sc/s.sc/a.sc/l.sc/t.sc¹º:
return s
/t.sc/e.sc/s.sc/t.sc¹x;x02f0;1gº:
return false
Digital signatures (De/f_inition 13.6):
LΣ
sig-real
¹/v.altk;skº Σ:KeyGen
/g.sc/e.sc/t.sc/v.sc/k.sc¹º:
return/v.altk
/g.sc/e.sc/t.sc/s.sc/i.sc/g.sc¹mº:
return Σ:Sign¹sk;mº
/v.sc/e.sc/r.sc/s.sc/i.sc/g.sc¹m;σº:
return Σ:Ver¹/v.altk;m;σºLΣ
sig-fake
¹/v.altk;skº Σ:KeyGen
S:=;
/g.sc/e.sc/t.sc/v.sc/k.sc¹º:
return/v.altk
/g.sc/e.sc/t.sc/s.sc/i.sc/g.sc¹mº:
σ:=Σ:Sign¹sk;mº
S:=S[f¹ m;σºg
returnσ
/v.sc/e.sc/r.sc/s.sc/i.sc/g.sc¹m;σº:
return¹m;σº?2S
Key agreement (De/f_inition 14.4):
LΣ
ka-real
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
¹t;Kº /e.sc/x.sc/e.sc/c.sc/p.sc/r.sc/o.sc/t.sc¹Σº
return¹t;KºLΣ
ka-rand
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
¹t;Kº /e.sc/x.sc/e.sc/c.sc/p.sc/r.sc/o.sc/t.sc¹Σº
K0 Σ:K
return¹t;K0º
Decisional Diﬃe-Hellman assumption (De/f_inition 14.5):
LG
dh-real
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
a;b Zn
return¹/afii10069.itala;/afii10069.italb;/afii10069.italabºLG
dh-rand
/q.sc_u.sc/e.sc/r.sc/y.sc¹º:
a;b;c Zn
return¹/afii10069.itala;/afii10069.italb;/afii10069.italcº
274Draft: January 3, 2021 INDEX OF SECURITY DEFINITIONS
CPA security for public-key encryption (De/f_inition 15.1):
LΣ
pk-cpa-L
¹pk;skº Σ:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mR2Σ:Mº:
return Σ:Enc¹pk;mLºLΣ
pk-cpa-R
¹pk;skº Σ:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mR2Σ:Mº:
return Σ:Enc¹pk;mRº
CPA$ security for public-key encryption (De/f_inition 15.2):
LΣ
pk-cpa$-real
¹pk;skº Σ:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m2Σ:Mº:
return Σ:Enc¹pk;mºLΣ
pk-cpa$-rand
¹pk;skº Σ:KeyGen
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹m2Σ:Mº:
c Σ:C
return c
One-time secrecy for public-key encryption (De/f_inition 15.4):
LΣ
pk-ots-L
¹pk;skº Σ:KeyGen
count :=0
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mR2Σ:Mº:
count :=count +1
ifcount >1: return null
return Σ:Enc¹pk;mLºLΣ
pk-ots-R
¹pk;skº Σ:KeyGen
count :=0
/g.sc/e.sc/t.sc/p.sc/k.sc¹º:
return pk
/c.sc/h.sc/a.sc/l.sc/l.sc/e.sc/n.sc/g.sc/e.sc¹mL;mR2Σ:Mº:
count :=count +1
ifcount >1: return null
return Σ:Enc¹pk;mRº
275